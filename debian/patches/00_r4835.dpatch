#! /bin/sh /usr/share/dpatch/dpatch-run
## 00_r4835.dpatch by Kenshi Muto <kmuto@debian.org>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

@DPATCH@
diff -urNad cupsys-1.1.99.b1.r4748~/CHANGES.txt cupsys-1.1.99.b1.r4748/CHANGES.txt
--- cupsys-1.1.99.b1.r4748~/CHANGES.txt	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/CHANGES.txt	2005-10-24 23:19:16.580228000 +0900
@@ -1,8 +1,19 @@
-CHANGES.txt - 10/03/2005
+CHANGES.txt - 10/24/2005
 ------------------------
 
 CHANGES IN CUPS V1.2.0b1
 
+	- The scheduler now only updates the permissions of SSL
+	  keys and certificates when they are under the
+	  ServerRoot directory (STR #1324)
+	- The rastertodymo driver has been renamed to
+	  rastertolabel (a symlink is installed so that existing
+	  queues continue to work) and now also supports Zebra's
+	  CPCL language.
+	- The lpstat command could show the wrong active job for
+	  a printer (STR #1301)
+	- Fixed a potential crash problem in the scheduler when
+	  aborting a CGI program (STR #1290)
 	- Added a "cancel all jobs" button to the class and
 	  printer web interfaces (STR #1140)
 	- The add-printer web page now shows the
diff -urNad cupsys-1.1.99.b1.r4748~/Makedefs.in cupsys-1.1.99.b1.r4748/Makedefs.in
--- cupsys-1.1.99.b1.r4748~/Makedefs.in	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/Makedefs.in	2005-11-13 06:46:52.687523000 +0900
@@ -1,5 +1,5 @@
 #
-# "$Id: Makedefs.in 4730 2005-09-30 21:45:34Z mike $"
+# "$Id: Makedefs.in 4833 2005-11-12 21:46:52Z mike $"
 #
 #   Common makefile definitions for the Common UNIX Printing System (CUPS).
 #
@@ -36,7 +36,6 @@
 LIBTOOL		=	@LIBTOOL@
 LN		=	@LN@ -sf
 MV		=	@MV@
-NROFF		=	@NROFF@
 RANLIB		=	@RANLIB@
 RM		=	@RM@ -f
 SED		=	@SED@
@@ -87,7 +86,7 @@
 BACKLIBS	=	@BACKLIBS@
 CFLAGS		=	-I.. $(RC_CFLAGS) $(SSLFLAGS) @CPPFLAGS@ @CFLAGS@ \
 			@LARGEFILE@ $(OPTIONS)
-COMMONLIBS	=	@COMMONLIBS@
+COMMONLIBS	=	@LIBS@
 CXXFLAGS	=	-I.. $(RC_CFLAGS) $(SSLFLAGS) @CPPFLAGS@ @CXXFLAGS@ \
 			@LARGEFILE@ $(OPTIONS)
 CXXLIBS		=	@CXXLIBS@
@@ -95,10 +94,9 @@
 DSOLIBS		=	@DSOLIBS@ $(COMMONLIBS)
 IMGLIBS		=	@IMGLIBS@ -lm
 LDFLAGS		=	-L../cups -L../filter $(RC_CFLAGS) @LDFLAGS@ $(OPTIM)
-LINKCUPS	=	@LINKCUPS@
+LINKCUPS	=	@LINKCUPS@ $(SSLLIBS)
 LINKCUPSIMAGE	=	@LINKCUPSIMAGE@
-LIBS		=	$(LINKCUPS) $(NETLIBS) @LIBS@ $(COMMONLIBS)
-NETLIBS		=	@NETLIBS@
+LIBS		=	$(LINKCUPS) $(COMMONLIBS)
 OPTIM		=	@OPTIM@
 OPTIONS		=
 PAMLIBS		=	@PAMLIBS@
@@ -155,10 +153,8 @@
 SERVERROOT	= 	$(BUILDROOT)@CUPS_SERVERROOT@
 STATEDIR	=	$(BUILDROOT)@CUPS_STATEDIR@
 
-CAT1EXT		=	@CAT1EXT@
-CAT3EXT		=	@CAT3EXT@
-CAT5EXT		=	@CAT5EXT@
-CAT8EXT		=	@CAT8EXT@
+MAN1EXT		=	@MAN1EXT@
+MAN5EXT		=	@MAN5EXT@
 MAN8EXT		=	@MAN8EXT@
 MAN8DIR		=	@MAN8DIR@
 
@@ -171,25 +167,27 @@
 #
 
 .SILENT:
-.SUFFIXES:	.a .c .cxx .h .man .o .0 .1 .1m .3 .5 .8 .z
+.SUFFIXES:	.1 .1.gz .1m .1m.gz .5 .5.gz .8 .8.gz .a .c .cxx .h .man .o .gz
+
 .c.o:
 	echo Compiling $<...
 	$(CC) $(OPTIM) $(CFLAGS) -c $<
+
 .cxx.o:
 	echo Compiling $<...
 	$(CXX) $(OPTIM) $(CXXFLAGS) -c $<
-.man.0 .man.1 .man.1m .man.3 .man.5 .man.8:
-	echo Formatting $<...
+
+.man.1 .man.1m .man.5 .man.8:
+	echo Linking $<...
 	$(RM) $@
-	-$(NROFF) -man $< >$@
-.man.z:
-	echo Formatting $<...
-	$(RM) $@ $@.tmp $@.tmp.z
-	-$(NROFF) -man $< >$@.tmp
-	pack -f $@.tmp
-	$(MV) $@.tmp.z $@
+	$(LN) $< $@
+
+.man.1.gz .man.1m.gz .man.5.gz .man.8.gz .man.gz:
+	echo Compressing $<...
+	$(RM) $@
+	gzip -v9 <$< >$@
 
 
 #
-# End of "$Id: Makedefs.in 4730 2005-09-30 21:45:34Z mike $"
+# End of "$Id: Makedefs.in 4833 2005-11-12 21:46:52Z mike $"
 #
diff -urNad cupsys-1.1.99.b1.r4748~/Makefile cupsys-1.1.99.b1.r4748/Makefile
--- cupsys-1.1.99.b1.r4748~/Makefile	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/Makefile	2005-11-13 07:00:16.644476000 +0900
@@ -1,5 +1,5 @@
 #
-# "$Id: Makefile 4493 2005-02-18 02:09:53Z mike $"
+# "$Id: Makefile 4835 2005-11-12 22:00:16Z mike $"
 #
 #   Top-level Makefile for the Common UNIX Printing System (CUPS).
 #
@@ -29,7 +29,7 @@
 #
 
 DIRS	=	cups backend berkeley cgi-bin filter man pdftops \
-		scheduler systemv
+		notifier scheduler systemv
 
 #
 # Make all targets...
@@ -143,29 +143,29 @@
 EPMFLAGS	=	-v
 
 aix:
-	epm $(EPMFLAGS) -f aix cups
+	epm $(EPMFLAGS) -f aix cups packaging/cups.list
 
 bsd:
-	epm $(EPMFLAGS) -f bsd cups
+	epm $(EPMFLAGS) -f bsd cups packaging/cups.list
 
 epm:
-	epm $(EPMFLAGS) cups
+	epm $(EPMFLAGS) cups packaging/cups.list
 
 rpm:
-	epm $(EPMFLAGS) -f rpm cups
+	epm $(EPMFLAGS) -f rpm cups packaging/cups.list
 
 deb:
-	epm $(EPMFLAGS) -f deb cups
+	epm $(EPMFLAGS) -f deb cups packaging/cups.list
 
 depot:
-	epm $(EPMFLAGS) -f depot cups
+	epm $(EPMFLAGS) -f depot cups packaging/cups.list
 
 pkg:
-	epm $(EPMFLAGS) -f pkg cups
+	epm $(EPMFLAGS) -f pkg cups packaging/cups.list
 
 tardist:
-	epm $(EPMFLAGS) -f tardist cups
+	epm $(EPMFLAGS) -f tardist cups packaging/cups.list
 
 #
-# End of "$Id: Makefile 4493 2005-02-18 02:09:53Z mike $".
+# End of "$Id: Makefile 4835 2005-11-12 22:00:16Z mike $".
 #
diff -urNad cupsys-1.1.99.b1.r4748~/backend/Dependencies cupsys-1.1.99.b1.r4748/backend/Dependencies
--- cupsys-1.1.99.b1.r4748~/backend/Dependencies	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/backend/Dependencies	2005-10-19 06:09:12.681329000 +0900
@@ -1,12 +1,12 @@
 # DO NOT DELETE
 
 betest.o: ../cups/string.h ../config.h
-ipp.o: ../cups/backend.h ../cups/http-private.h ../config.h ../cups/http.h
-ipp.o: ../cups/md5.h ../cups/cups.h ../cups/ipp.h ../cups/ppd.h
+ipp.o: ../cups/http-private.h ../config.h ../cups/http.h ../cups/md5.h
+ipp.o: ../cups/backend.h ../cups/cups.h ../cups/ipp.h ../cups/ppd.h
 ipp.o: ../cups/file.h ../cups/language.h ../cups/string.h
-lpd.o: ../cups/backend.h ../cups/cups.h ../cups/ipp.h ../cups/http.h
-lpd.o: ../cups/md5.h ../cups/ppd.h ../cups/file.h ../cups/http-private.h
-lpd.o: ../config.h ../cups/string.h
+lpd.o: ../cups/backend.h ../cups/http-private.h ../config.h ../cups/http.h
+lpd.o: ../cups/md5.h ../cups/cups.h ../cups/ipp.h ../cups/ppd.h
+lpd.o: ../cups/file.h ../cups/string.h
 parallel.o: ../cups/backend.h ../cups/cups.h ../cups/ipp.h ../cups/http.h
 parallel.o: ../cups/md5.h ../cups/ppd.h ../cups/file.h ../cups/string.h
 parallel.o: ../config.h
@@ -16,9 +16,9 @@
 serial.o: ../cups/backend.h ../cups/cups.h ../cups/ipp.h ../cups/http.h
 serial.o: ../cups/md5.h ../cups/ppd.h ../cups/file.h ../cups/string.h
 serial.o: ../config.h
-socket.o: ../cups/backend.h ../cups/cups.h ../cups/ipp.h ../cups/http.h
-socket.o: ../cups/md5.h ../cups/ppd.h ../cups/file.h ../cups/http-private.h
-socket.o: ../config.h ../cups/string.h
+socket.o: ../cups/backend.h ../cups/http-private.h ../config.h ../cups/http.h
+socket.o: ../cups/md5.h ../cups/cups.h ../cups/ipp.h ../cups/ppd.h
+socket.o: ../cups/file.h ../cups/string.h
 usb.o: ../cups/backend.h ../cups/cups.h ../cups/ipp.h ../cups/http.h
 usb.o: ../cups/md5.h ../cups/ppd.h ../cups/file.h ../cups/string.h
 usb.o: ../config.h
diff -urNad cupsys-1.1.99.b1.r4748~/backend/ipp.c cupsys-1.1.99.b1.r4748/backend/ipp.c
--- cupsys-1.1.99.b1.r4748~/backend/ipp.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/backend/ipp.c	2005-10-19 03:06:20.449904000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: ipp.c 4704 2005-09-26 20:59:15Z mike $"
+ * "$Id: ipp.c 4800 2005-10-18 18:06:20Z mike $"
  *
  *   IPP backend for the Common UNIX Printing System (CUPS).
  *
@@ -39,13 +39,13 @@
  * Include necessary headers.
  */
 
+#include <cups/http-private.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <cups/backend.h>
-#include <cups/http-private.h>
 #include <cups/cups.h>
 #include <cups/language.h>
 #include <cups/string.h>
@@ -1460,5 +1460,5 @@
 
 
 /*
- * End of "$Id: ipp.c 4704 2005-09-26 20:59:15Z mike $".
+ * End of "$Id: ipp.c 4800 2005-10-18 18:06:20Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/backend/lpd.c cupsys-1.1.99.b1.r4748/backend/lpd.c
--- cupsys-1.1.99.b1.r4748~/backend/lpd.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/backend/lpd.c	2005-11-13 06:46:52.687523000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: lpd.c 4730 2005-09-30 21:45:34Z mike $"
+ * "$Id: lpd.c 4833 2005-11-12 21:46:52Z mike $"
  *
  *   Line Printer Daemon backend for the Common UNIX Printing System (CUPS).
  *
@@ -39,12 +39,12 @@
  */
 
 #include <cups/backend.h>
+#include <cups/http-private.h>
 #include <cups/cups.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdarg.h>
 #include <ctype.h>
-#include <cups/http-private.h>
 #include <cups/string.h>
 #include <errno.h>
 #include <sys/types.h>
@@ -99,7 +99,7 @@
 static void	lpd_timeout(int sig);
 static int	lpd_write(int lpd_fd, char *buffer, int length);
 #ifndef HAVE_RRESVPORT_AF
-extern int	rresvport_af(int *port, int family);
+static int	rresvport_af(int *port, int family);
 #endif /* !HAVE_RRESVPORT_AF */
 static void	sigterm_handler(int sig);
 
@@ -536,7 +536,6 @@
 	  int        manual_copies,	/* I - Do copies by hand... */
 	  int        timeout)		/* I - Timeout... */
 {
-  int			i;		/* Looping var */
   FILE			*fp;		/* Job file */
   char			localhost[255];	/* Local host name */
   int			error;		/* Error number */
@@ -546,8 +545,9 @@
   char			control[10240],	/* LPD control 'file' */
 			*cptr;		/* Pointer into control file string */
   char			status;		/* Status byte from command */
-  http_addr_t		addr;		/* Socket address */
-  struct hostent	*hostaddr;	/* Host address */
+  char			portname[255];	/* Port name */
+  http_addrlist_t	*addrlist,	/* Address list */
+			*addr;		/* Socket address */
   int			copy;		/* Copies written */
   size_t		nbytes;		/* Number of bytes written */
   off_t			tbytes;		/* Total bytes written */
@@ -574,6 +574,19 @@
 #endif /* HAVE_SIGSET */
 
  /*
+  * Find the printer...
+  */
+
+  sprintf(portname, "%d", port);
+
+  if ((addrlist = httpAddrGetList(hostname, AF_UNSPEC, portname)) == NULL)
+  {
+    fprintf(stderr, "ERROR: Unable to locate printer \'%s\'!\n",
+            hostname);
+    return (CUPS_BACKEND_STOP);
+  }
+
+ /*
   * Loop forever trying to print the file...
   */
 
@@ -583,29 +596,30 @@
     * First try to reserve a port for this connection...
     */
 
-    if ((hostaddr = httpGetHostByName(hostname)) == NULL)
-    {
-      fprintf(stderr, "ERROR: Unable to locate printer \'%s\' - %s\n",
-              hostname, hstrerror(h_errno));
-      return (CUPS_BACKEND_STOP);
-    }
-
     fprintf(stderr, "INFO: Attempting to connect to host %s for printer %s\n",
             hostname, printer);
 
-    for (lport = reserve == RESERVE_RFC1179 ? 732 : 1024;;)
+    for (lport = reserve == RESERVE_RFC1179 ? 732 : 1024, addr = addrlist;;
+         addr = addr->next)
     {
      /*
       * Stop if this job has been cancelled...
       */
 
       if (abort_job)
+      {
+        httpAddrFreeList(addrlist);
+
         return (CUPS_BACKEND_FAILED);
+      }
 
      /*
       * Choose the next priviledged port...
       */
 
+      if (!addr)
+        addr = addrlist;
+
       lport --;
 
       if (lport < 721 && reserve == RESERVE_RFC1179)
@@ -623,10 +637,12 @@
 	* Just create a regular socket...
 	*/
 
-	if ((fd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
+	if ((fd = socket(addr->addr.addr.sa_family, SOCK_STREAM, 0)) < 0)
 	{
           perror("ERROR: Unable to create socket");
-          return (CUPS_BACKEND_FAILED);
+	  sleep(1);
+
+          continue;
 	}
 
         lport = 0;
@@ -638,7 +654,7 @@
 	* priviledged lport between 721 and 731...
 	*/
 
-	if ((fd = rresvport_af(&lport, hostaddr->h_addrtype)) < 0)
+	if ((fd = rresvport_af(&lport, addr->addr.addr.sa_family)) < 0)
 	{
 	  perror("ERROR: Unable to reserve port");
 	  sleep(1);
@@ -651,70 +667,68 @@
       * Connect to the printer or server...
       */
 
-      for (i = 0; hostaddr->h_addr_list[i]; i ++)
+      if (abort_job)
       {
-        if (abort_job)
-	{
-	  close(fd);
-	  return (CUPS_BACKEND_FAILED);
-	}
+        httpAddrFreeList(addrlist);
 
-        httpAddrLoad(hostaddr, port, i, &addr);
+	close(fd);
 
-	if (!connect(fd, (struct sockaddr *)&addr, sizeof(addr)))
-	  break;
+	return (CUPS_BACKEND_FAILED);
       }
 
-      if (!hostaddr->h_addr_list[i])
+      if (!connect(fd, &(addr->addr.addr), httpAddrLength(&(addr->addr))))
+	break;
+
+      error = errno;
+      close(fd);
+      fd = -1;
+
+      if (addr->next)
+        continue;
+
+      if (getenv("CLASS") != NULL)
       {
-	error = errno;
-	close(fd);
-	fd = -1;
+       /*
+        * If the CLASS environment variable is set, the job was submitted
+	* to a class and not to a specific queue.  In this case, we want
+	* to abort immediately so that the job can be requeued on the next
+	* available printer in the class.
+	*/
 
-	if (getenv("CLASS") != NULL)
-	{
-	 /*
-          * If the CLASS environment variable is set, the job was submitted
-	  * to a class and not to a specific queue.  In this case, we want
-	  * to abort immediately so that the job can be requeued on the next
-	  * available printer in the class.
-	  */
+        fprintf(stderr, "INFO: Unable to connect to %s, queuing on next printer in class...\n",
+		hostname);
 
-          fprintf(stderr, "INFO: Unable to connect to %s, queuing on next printer in class...\n",
-		  hostname);
+        httpAddrFreeList(addrlist);
 
-	 /*
-          * Sleep 5 seconds to keep the job from requeuing too rapidly...
-	  */
+       /*
+        * Sleep 5 seconds to keep the job from requeuing too rapidly...
+	*/
 
-	  sleep(5);
+	sleep(5);
 
-          return (CUPS_BACKEND_FAILED);
-	}
+        return (CUPS_BACKEND_FAILED);
+      }
 
-	if (error == ECONNREFUSED || error == EHOSTDOWN ||
-            error == EHOSTUNREACH)
-	{
-	  fprintf(stderr, "WARNING: Network host \'%s\' is busy, down, or unreachable; will retry in 30 seconds...\n",
-                  hostname);
-	  sleep(30);
-	}
-	else if (error == EADDRINUSE)
-	{
-	 /*
-	  * Try on another port...
-	  */
+      if (error == ECONNREFUSED || error == EHOSTDOWN ||
+          error == EHOSTUNREACH)
+      {
+	fprintf(stderr, "WARNING: Network host \'%s\' is busy, down, or unreachable; will retry in 30 seconds...\n",
+                hostname);
+	sleep(30);
+      }
+      else if (error == EADDRINUSE)
+      {
+       /*
+	* Try on another port...
+	*/
 
-	  sleep(1);
-	}
-	else
-	{
-	  perror("ERROR: Unable to connect to printer; will retry in 30 seconds...");
-          sleep(30);
-	}
+	sleep(1);
       }
       else
-	break;
+      {
+	perror("ERROR: Unable to connect to printer; will retry in 30 seconds...");
+        sleep(30);
+      }
     }
 
     fprintf(stderr, "INFO: Connected to %s...\n", hostname);
@@ -727,6 +741,9 @@
 
     if (stat(filename, &filestats))
     {
+      httpAddrFreeList(addrlist);
+      close(fd);
+
       perror("ERROR: unable to stat print file");
       return (CUPS_BACKEND_FAILED);
     }
@@ -735,6 +752,9 @@
 
     if ((fp = fopen(filename, "rb")) == NULL)
     {
+      httpAddrFreeList(addrlist);
+      close(fd);
+
       perror("ERROR: unable to open print file for reading");
       return (CUPS_BACKEND_FAILED);
     }
@@ -746,41 +766,54 @@
 
     if (lpd_command(fd, timeout, "\002%s\n",
                     printer))		/* Receive print job(s) */
+    {
+      httpAddrFreeList(addrlist);
+      close(fd);
       return (CUPS_BACKEND_FAILED);
+    }
 
-    gethostname(localhost, sizeof(localhost));
-    localhost[31] = '\0'; /* RFC 1179, Section 7.2 - host name < 32 chars */
+    httpGetHostname(localhost, sizeof(localhost));
 
-    snprintf(control, sizeof(control), "H%s\nP%s\nJ%s\n", localhost, user,
-             title);
+    snprintf(control, sizeof(control),
+             "H.31%s\n"		/* RFC 1179, Section 7.2 - host name <= 31 chars */
+	     "P.31%s\n"		/* RFC 1179, Section 7.2 - user name <= 31 chars */
+	     "J.99%s\n",	/* RFC 1179, Section 7.2 - job name <= 99 chars */
+	     localhost, user, title);
     cptr = control + strlen(control);
 
     if (banner)
     {
-      snprintf(cptr, sizeof(control) - (cptr - control), "C%s\nL%s\n",
+      snprintf(cptr, sizeof(control) - (cptr - control),
+               "C.31%s\n"	/* RFC 1179, Section 7.2 - class name <= 31 chars */
+	       "L%s\n",
                localhost, user);
       cptr   += strlen(cptr);
     }
 
     while (copies > 0)
     {
-      snprintf(cptr, sizeof(control) - (cptr - control), "%cdfA%03d%.15s\n", format,
-               getpid() % 1000, localhost);
+      snprintf(cptr, sizeof(control) - (cptr - control), "%cdfA%03d%.15s\n",
+               format, (int)getpid() % 1000, localhost);
       cptr   += strlen(cptr);
       copies --;
     }
 
     snprintf(cptr, sizeof(control) - (cptr - control),
              "UdfA%03d%.15s\nN%s\n",
-             getpid() % 1000, localhost, title);
+             (int)getpid() % 1000, localhost, title);
 
     fprintf(stderr, "DEBUG: Control file is:\n%s", control);
 
     if (order == ORDER_CONTROL_DATA)
     {
       if (lpd_command(fd, timeout, "\002%d cfA%03.3d%.15s\n", strlen(control),
-                      getpid() % 1000, localhost))
+                      (int)getpid() % 1000, localhost))
+      {
+        httpAddrFreeList(addrlist);
+	close(fd);
+
         return (CUPS_BACKEND_FAILED);
+      }
 
       fprintf(stderr, "INFO: Sending control file (%u bytes)\n",
               (unsigned)strlen(control));
@@ -820,9 +853,14 @@
       */
 
       if (lpd_command(fd, timeout, "\003" CUPS_LLFMT " dfA%03.3d%.15s\n",
-                      CUPS_LLCAST filestats.st_size, getpid() % 1000,
+                      CUPS_LLCAST filestats.st_size, (int)getpid() % 1000,
 		      localhost))
+      {
+        httpAddrFreeList(addrlist);
+	close(fd);
+
         return (CUPS_BACKEND_FAILED);
+      }
 
       fprintf(stderr, "INFO: Sending data file (" CUPS_LLFMT " bytes)\n",
               CUPS_LLCAST filestats.st_size);
@@ -885,8 +923,13 @@
     if (status == 0 && order == ORDER_DATA_CONTROL)
     {
       if (lpd_command(fd, timeout, "\002%d cfA%03.3d%.15s\n", strlen(control),
-                      getpid() % 1000, localhost))
+                      (int)getpid() % 1000, localhost))
+      {
+        httpAddrFreeList(addrlist);
+	close(fd);
+
         return (CUPS_BACKEND_FAILED);
+      }
 
       fprintf(stderr, "INFO: Sending control file (%lu bytes)\n",
               (unsigned long)strlen(control));
@@ -925,7 +968,11 @@
     fclose(fp);
 
     if (status == 0)
+    {
+      httpAddrFreeList(addrlist);
+
       return (CUPS_BACKEND_OK);
+    }
 
    /*
     * Waiting for a retry...
@@ -934,6 +981,8 @@
     sleep(30);
   }
 
+  httpAddrFreeList(addrlist);
+
  /*
   * If we get here, then the job has been cancelled...
   */
@@ -995,7 +1044,7 @@
  * 'rresvport_af()' - A simple implementation of rresvport_af().
  */
 
-int					/* O  - Socket or -1 on error */
+static int				/* O  - Socket or -1 on error */
 rresvport_af(int *port,			/* IO - Port number to bind to */
              int family)		/* I  - Address family */
 {
@@ -1028,7 +1077,7 @@
     */
 
 #  ifdef AF_INET6
-    if (family == AF_INET6
+    if (family == AF_INET6)
       addr.ipv6.sin6_port = htons(*port);
     else
 #  endif /* AF_INET6 */
@@ -1093,5 +1142,5 @@
 
 
 /*
- * End of "$Id: lpd.c 4730 2005-09-30 21:45:34Z mike $".
+ * End of "$Id: lpd.c 4833 2005-11-12 21:46:52Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/backend/socket.c cupsys-1.1.99.b1.r4748/backend/socket.c
--- cupsys-1.1.99.b1.r4748~/backend/socket.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/backend/socket.c	2005-10-17 23:52:10.949534000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: socket.c 4703 2005-09-26 19:33:58Z mike $"
+ * "$Id: socket.c 4799 2005-10-17 14:52:10Z mike $"
  *
  *   AppSocket backend for the Common UNIX Printing System (CUPS).
  *
@@ -33,11 +33,11 @@
  */
 
 #include <cups/backend.h>
+#include <cups/http-private.h>
 #include <cups/cups.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdarg.h>
-#include <cups/http-private.h>
 #include <cups/string.h>
 #include <errno.h>
 #include <sys/types.h>
@@ -68,7 +68,6 @@
 main(int  argc,				/* I - Number of command-line arguments (6 or 7) */
      char *argv[])			/* I - Command-line arguments */
 {
-  int		i;			/* Looping var */
   char		method[255],		/* Method in URI */
 		hostname[1024],		/* Hostname */
 		username[255],		/* Username info (not used) */
@@ -76,11 +75,11 @@
   int		fp;			/* Print file */
   int		copies;			/* Number of copies to print */
   int		port;			/* Port number */
+  char		portname[255];		/* Port name */
   int		delay;			/* Delay for retries... */
   int		fd;			/* AppSocket */
   int		error;			/* Error code (if any) */
-  http_addr_t	addr;			/* Socket address */
-  struct hostent *hostaddr;		/* Host address */
+  http_addrlist_t *addrlist;		/* Address list */
   int		rbytes;			/* Number of bytes read */
   int		wbytes;			/* Number of bytes written */
   int		nbytes;			/* Number of bytes read */
@@ -169,10 +168,11 @@
   * Then try to connect to the remote host...
   */
 
-  if ((hostaddr = httpGetHostByName(hostname)) == NULL)
+  sprintf(portname, "%d", port);
+
+  if ((addrlist = httpAddrGetList(hostname, AF_UNSPEC, portname)) == NULL)
   {
-    fprintf(stderr, "ERROR: Unable to locate printer \'%s\' - %s\n",
-            hostname, hstrerror(h_errno));
+    fprintf(stderr, "ERROR: Unable to locate printer \'%s\'!\n", hostname);
     return (CUPS_BACKEND_STOP);
   }
 
@@ -185,25 +185,10 @@
   {
     for (delay = 5;;)
     {
-      if ((fd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
-      {
-	perror("ERROR: Unable to create socket");
-	return (CUPS_BACKEND_FAILED);
-      }
-
-      for (i = 0; hostaddr->h_addr_list[i]; i ++)
-      {
-        httpAddrLoad(hostaddr, port, i, &addr);
-
-        if (!connect(fd, (struct sockaddr *)&addr, sizeof(addr)))
-	  break;
-      }
-
-      if (!hostaddr->h_addr_list[i])
+      if (!httpAddrConnect(addrlist, &fd))
       {
 	error = errno;
-	close(fd);
-	fd = -1;
+	fd    = -1;
 
 	if (getenv("CLASS") != NULL)
 	{
@@ -410,6 +395,8 @@
     close(fd);
   }
 
+  httpAddrFreeList(addrlist);
+
  /*
   * Close the input file and return...
   */
@@ -425,5 +412,5 @@
 
 
 /*
- * End of "$Id: socket.c 4703 2005-09-26 19:33:58Z mike $".
+ * End of "$Id: socket.c 4799 2005-10-17 14:52:10Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/backend/usb-unix.c cupsys-1.1.99.b1.r4748/backend/usb-unix.c
--- cupsys-1.1.99.b1.r4748~/backend/usb-unix.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/backend/usb-unix.c	2005-10-11 04:23:23.958633000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: usb-unix.c 4703 2005-09-26 19:33:58Z mike $"
+ * "$Id: usb-unix.c 4767 2005-10-10 19:23:23Z mike $"
  *
  *   USB port backend for the Common UNIX Printing System (CUPS).
  *
@@ -212,7 +212,8 @@
   * Finally, send the print file...
   */
 
-  wbytes = 0;
+  wbytes   = 0;
+  paperout = 0;
 
   while (copies > 0)
   {
@@ -889,5 +890,5 @@
 
 
 /*
- * End of "$Id: usb-unix.c 4703 2005-09-26 19:33:58Z mike $".
+ * End of "$Id: usb-unix.c 4767 2005-10-10 19:23:23Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/berkeley/lpq.c cupsys-1.1.99.b1.r4748/berkeley/lpq.c
--- cupsys-1.1.99.b1.r4748~/berkeley/lpq.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/berkeley/lpq.c	2005-10-22 03:49:24.065412000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: lpq.c 4730 2005-09-30 21:45:34Z mike $"
+ * "$Id: lpq.c 4806 2005-10-21 18:49:24Z mike $"
  *
  *   "lpq" command for the Common UNIX Printing System (CUPS).
  *
@@ -327,7 +327,8 @@
   }
   else
   {
-    snprintf(resource, sizeof(resource), "ipp://localhost/printers/%s", dest);
+    httpAssembleURIf(resource, sizeof(resource), "ipp", NULL, "localhost", 0,
+	             "/printers/%s", dest);
 
     ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri",
                  NULL, resource);
@@ -554,7 +555,8 @@
   ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
                "attributes-natural-language", NULL, language->language);
 
-  snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", dest);
+  httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+	           "/printers/%s", dest);
   ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI,
                "printer-uri", NULL, uri);
 
@@ -611,5 +613,5 @@
 
 
 /*
- * End of "$Id: lpq.c 4730 2005-09-30 21:45:34Z mike $".
+ * End of "$Id: lpq.c 4806 2005-10-21 18:49:24Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/berkeley/lprm.c cupsys-1.1.99.b1.r4748/berkeley/lprm.c
--- cupsys-1.1.99.b1.r4748~/berkeley/lprm.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/berkeley/lprm.c	2005-10-22 03:49:24.065412000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: lprm.c 4494 2005-02-18 02:18:11Z mike $"
+ * "$Id: lprm.c 4806 2005-10-21 18:49:24Z mike $"
  *
  *   "lprm" command for the Common UNIX Printing System (CUPS).
  *
@@ -187,7 +187,8 @@
 
       if (dest)
       {
-        snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", dest);
+        httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+	                 "/printers/%s", dest);
 	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI,
 	             "printer-uri", NULL, uri);
 	ippAddInteger(request, IPP_TAG_OPERATION, IPP_TAG_INTEGER, "job-id",
@@ -272,5 +273,5 @@
 
 
 /*
- * End of "$Id: lprm.c 4494 2005-02-18 02:18:11Z mike $".
+ * End of "$Id: lprm.c 4806 2005-10-21 18:49:24Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cgi-bin/admin.c cupsys-1.1.99.b1.r4748/cgi-bin/admin.c
--- cupsys-1.1.99.b1.r4748~/cgi-bin/admin.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cgi-bin/admin.c	2005-11-05 00:57:50.182805000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: admin.c 4747 2005-10-03 20:43:07Z mike $"
+ * "$Id: admin.c 4816 2005-11-04 15:57:50Z mike $"
  *
  *   Administration CGI for the Common UNIX Printing System (CUPS).
  *
@@ -264,8 +264,8 @@
       ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
         	   "attributes-natural-language", NULL, language->language);
 
-      snprintf(uri, sizeof(uri), "ipp://localhost/classes/%s",
-               cgiGetVariable("PRINTER_NAME"));
+      httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                       "/classes/%s", cgiGetVariable("PRINTER_NAME"));
       ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri",
                    NULL, uri);
 
@@ -397,8 +397,8 @@
     ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
         	 "attributes-natural-language", NULL, language->language);
 
-    snprintf(uri, sizeof(uri), "ipp://localhost/classes/%s",
-             cgiGetVariable("PRINTER_NAME"));
+    httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                     "/classes/%s", cgiGetVariable("PRINTER_NAME"));
     ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri",
                  NULL, uri);
 
@@ -464,8 +464,8 @@
     ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
         	 "attributes-natural-language", NULL, language->language);
 
-    snprintf(uri, sizeof(uri), "ipp://localhost/classes/%s",
-             cgiGetVariable("PRINTER_NAME"));
+    httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                     "/classes/%s", cgiGetVariable("PRINTER_NAME"));
     ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri",
                  NULL, uri);
 
@@ -515,7 +515,7 @@
       char	refresh[1024];		/* Refresh URL */
 
       cgiFormEncode(uri, name, sizeof(uri));
-      snprintf(refresh, sizeof(refresh), "2;/admin?OP=redirect&URL=/classes/%s",
+      snprintf(refresh, sizeof(refresh), "5;/admin?OP=redirect&URL=/classes/%s",
                uri);
       cgiSetVariable("refresh_page", refresh);
 
@@ -596,8 +596,8 @@
     ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
         	 "attributes-natural-language", NULL, language->language);
 
-    snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s",
-             cgiGetVariable("PRINTER_NAME"));
+    httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                     "/printers/%s", cgiGetVariable("PRINTER_NAME"));
     ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri",
                  NULL, uri);
 
@@ -998,8 +998,8 @@
     ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
         	 "attributes-natural-language", NULL, language->language);
 
-    snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s",
-             cgiGetVariable("PRINTER_NAME"));
+    httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                     "/printers/%s", cgiGetVariable("PRINTER_NAME"));
     ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri",
                  NULL, uri);
 
@@ -1067,10 +1067,10 @@
 
       if (modify)
 	snprintf(refresh, sizeof(refresh),
-	         "2;/admin?OP=redirect&URL=/printers/%s", uri);
+	         "5;/admin?OP=redirect&URL=/printers/%s", uri);
       else
 	snprintf(refresh, sizeof(refresh),
-	         "2;/admin?OP=config-printer&PRINTER_NAME=%s", uri);
+	         "5;/admin?OP=config-printer&PRINTER_NAME=%s", uri);
 
       cgiSetVariable("refresh_page", refresh);
 
@@ -1125,7 +1125,8 @@
   */
 
   if ((printer = cgiGetVariable("PRINTER_NAME")) != NULL)
-    snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", printer);
+    httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                     "/printers/%s", printer);
   else
   {
     cgiSetVariable("ERROR", ippErrorString(IPP_NOT_FOUND));
@@ -1237,7 +1238,7 @@
 	 i > 0;
 	 i --, group ++)
     {
-      if (strcmp(group->text, "InstallableOptions") == 0)
+      if (!strcmp(group->name, "InstallableOptions"))
 	cgiSetVariable("GROUP",
 	               cupsLangString(language, CUPS_MSG_OPTIONS_INSTALLED));
       else
@@ -1322,7 +1323,8 @@
     ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
         	 "attributes-natural-language", NULL, language->language);
 
-    snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", printer);
+    httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                     "/printers/%s", printer);
     ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri",
                  NULL, uri);
 
@@ -1372,6 +1374,80 @@
                             getenv("LANG"));
       }
 
+      if (ippFindAttribute(response, "printer-error-policy-supported",
+                           IPP_TAG_ZERO) ||
+          ippFindAttribute(response, "printer-op-policy-supported",
+	                   IPP_TAG_ZERO))
+      {
+       /*
+	* Add the error and operation policy options...
+	*/
+
+	cgiSetVariable("GROUP", "Policies");
+	cgiCopyTemplateLang(stdout, TEMPLATES, "option-header.tmpl",
+                            getenv("LANG"));
+
+       /*
+        * Error policy...
+	*/
+
+        attr = ippFindAttribute(response, "printer-error-policy-supported",
+	                        IPP_TAG_ZERO);
+
+        if (attr)
+	{
+	  cgiSetSize("CHOICES", attr->num_values);
+	  cgiSetSize("TEXT", attr->num_values);
+	  for (k = 0; k < attr->num_values; k ++)
+	  {
+	    cgiSetArray("CHOICES", k, attr->values[k].string.text);
+	    cgiSetArray("TEXT", k, attr->values[k].string.text);
+	  }
+
+          attr = ippFindAttribute(response, "printer-error-policy",
+	                          IPP_TAG_ZERO);
+
+          cgiSetVariable("KEYWORD", "printer_error_policy");
+          cgiSetVariable("KEYTEXT", "Error Policy");
+          cgiSetVariable("DEFCHOICE", attr == NULL ?
+	                              "" : attr->values[0].string.text);
+        }
+
+	cgiCopyTemplateLang(stdout, TEMPLATES, "option-pickone.tmpl",
+	                    getenv("LANG"));
+
+       /*
+        * Operation policy...
+	*/
+
+        attr = ippFindAttribute(response, "printer-op-policy-supported",
+	                        IPP_TAG_ZERO);
+
+        if (attr)
+	{
+	  cgiSetSize("CHOICES", attr->num_values);
+	  cgiSetSize("TEXT", attr->num_values);
+	  for (k = 0; k < attr->num_values; k ++)
+	  {
+	    cgiSetArray("CHOICES", k, attr->values[k].string.text);
+	    cgiSetArray("TEXT", k, attr->values[k].string.text);
+	  }
+
+          attr = ippFindAttribute(response, "printer-op-policy", IPP_TAG_ZERO);
+
+          cgiSetVariable("KEYWORD", "printer_op_policy");
+          cgiSetVariable("KEYTEXT", "Operation Policy");
+          cgiSetVariable("DEFCHOICE", attr == NULL ?
+	                              "" : attr->values[0].string.text);
+
+	  cgiCopyTemplateLang(stdout, TEMPLATES, "option-pickone.tmpl",
+	                      getenv("LANG"));
+        }
+
+	cgiCopyTemplateLang(stdout, TEMPLATES, "option-trailer.tmpl",
+                            getenv("LANG"));
+      }
+
       ippDelete(response);
     }
 
@@ -1507,8 +1583,8 @@
     ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
         	 "attributes-natural-language", NULL, language->language);
 
-    snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s",
-             cgiGetVariable("PRINTER_NAME"));
+    httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                     "/printers/%s", cgiGetVariable("PRINTER_NAME"));
     ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri",
                  NULL, uri);
 
@@ -1517,6 +1593,14 @@
     attr->values[0].string.text = strdup(cgiGetVariable("job_sheets_start"));
     attr->values[1].string.text = strdup(cgiGetVariable("job_sheets_end"));
 
+    if ((var = cgiGetVariable("printer_error_policy")) != NULL)
+      attr = ippAddString(request, IPP_TAG_PRINTER, IPP_TAG_NAME,
+                          "printer-error-policy", NULL, var);
+
+    if ((var = cgiGetVariable("printer_op_policy")) != NULL)
+      attr = ippAddString(request, IPP_TAG_PRINTER, IPP_TAG_NAME,
+                          "printer-op-policy", NULL, var);
+
    /*
     * Do the request and get back a response...
     */
@@ -1544,7 +1628,7 @@
       char	refresh[1024];		/* Refresh URL */
 
       cgiFormEncode(uri, printer, sizeof(uri));
-      snprintf(refresh, sizeof(refresh), "2;/admin?OP=redirect&URL=/printers/%s",
+      snprintf(refresh, sizeof(refresh), "5;/admin?OP=redirect&URL=/printers/%s",
                uri);
       cgiSetVariable("refresh_page", refresh);
 
@@ -1710,6 +1794,10 @@
 	    cupsFilePuts(temp, "# Only listen for connections from the local machine.\n");
 	    cupsFilePrintf(temp, "Listen localhost:%d\n", ippPort());
 	  }
+
+#ifdef CUPS_DEFAULT_DOMAINSOCKET
+          cupsFilePuts(temp, "Listen " CUPS_DEFAULT_DOMAINSOCKET "\n");
+#endif /* CUPS_DEFAULT_DOMAINSOCKET */
 	}
       }
       else if (!strcasecmp(line, "Browsing") ||
@@ -1865,8 +1953,6 @@
       }
       else if (!strcasecmp(line, "<Limit") && in_policy)
       {
-	indent += 2;
-
        /*
 	* See if the policy limit is for the Cancel-Job operation...
 	*/
@@ -1874,6 +1960,8 @@
 	char	*valptr;		/* Pointer into value */
 
 
+	indent += 2;
+
         if (!strcasecmp(value, "cancel-job"))
 	{
 	 /*
@@ -2014,6 +2102,10 @@
 	cupsFilePuts(temp, "# Only listen for connections from the local machine.\n");
 	cupsFilePrintf(temp, "Listen localhost:%d\n", ippPort());
       }
+
+#ifdef CUPS_DEFAULT_DOMAINSOCKET
+      cupsFilePuts(temp, "Listen " CUPS_DEFAULT_DOMAINSOCKET "\n");
+#endif /* CUPS_DEFAULT_DOMAINSOCKET */
     }
 
     if (!wrote_root_location)
@@ -2046,8 +2138,6 @@
         cupsFilePuts(temp, "# Restrict access to the admin pages...\n");
 
       cupsFilePuts(temp, "<Location /admin>\n"
-                         "  AuthType Basic\n"
-                         "  Require user @SYSTEM\n"
                          "  Order allow,deny\n");
 
       if (remote_admin)
@@ -2137,7 +2227,7 @@
     }
     else
     {
-      cgiSetVariable("refresh_page", "10;/admin?OP=redirect");
+      cgiSetVariable("refresh_page", "5;/admin?OP=redirect");
 
       cgiStartHTML("Change Settings");
       cgiCopyTemplateLang(stdout, TEMPLATES, "restart.tmpl", getenv("LANG"));
@@ -2227,7 +2317,7 @@
     }
     else
     {
-      cgiSetVariable("refresh_page", "10;/admin?OP=redirect");
+      cgiSetVariable("refresh_page", "5;/admin?OP=redirect");
 
       cgiStartHTML("Edit Configuration File");
       cgiCopyTemplateLang(stdout, TEMPLATES, "restart.tmpl", getenv("LANG"));
@@ -2352,7 +2442,8 @@
   }
 
   if ((pclass = cgiGetVariable("PRINTER_NAME")) != NULL)
-    snprintf(uri, sizeof(uri), "ipp://localhost/classes/%s", pclass);
+    httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                     "/classes/%s", pclass);
   else
   {
     cgiSetVariable("ERROR", ippErrorString(IPP_NOT_FOUND));
@@ -2436,7 +2527,8 @@
   }
 
   if ((printer = cgiGetVariable("PRINTER_NAME")) != NULL)
-    snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", printer);
+    httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                     "/printers/%s", printer);
   else
   {
     cgiSetVariable("ERROR", ippErrorString(IPP_NOT_FOUND));
@@ -2552,6 +2644,7 @@
     int		remote_access = 0,	/* Remote access allowed? */
 		remote_admin = 0,	/* Remote administration allowed? */
 		browsing = 1,		/* Browsing enabled? */
+		browse_allow = 1,	/* Browse address set? */
 		browse_address = 0,	/* Browse address set? */
 		cancel_policy = 1,	/* Cancel-job policy set? */
 		debug_logging = 0;	/* LogLevel debug set? */
@@ -2587,6 +2680,14 @@
       {
         browse_address = 1;
       }
+      else if (!strcasecmp(line, "BrowseAllow"))
+      {
+        browse_allow = 1;
+      }
+      else if (!strcasecmp(line, "BrowseOrder"))
+      {
+        browse_allow = !strncasecmp(value, "deny,", 5);
+      }
       else if (!strcasecmp(line, "LogLevel"))
       {
         debug_logging = !strncasecmp(value, "debug", 5);
@@ -2649,7 +2750,7 @@
 
     cupsFileClose(cupsd);
 
-    if (browsing)
+    if (browsing && browse_allow)
       cgiSetVariable("REMOTE_PRINTERS", "CHECKED");
 
     if (remote_access && browsing && browse_address)
@@ -2663,9 +2764,6 @@
 
     if (debug_logging)
       cgiSetVariable("DEBUG_LOGGING", "CHECKED");
-
-    printf("<!-- browsing=%d, browse_address=%d, cancel_policy=%d, debug_logging=%d, remote_access=%d, remote_admin=%d -->\n",
-           browsing, browse_address, cancel_policy, debug_logging, remote_access, remote_admin);
   }
 
  /*
@@ -2734,6 +2832,8 @@
         qsort(printer_devices, num_printer_devices, sizeof(char *),
 	      compare_printer_devices);
     }
+    else
+      printer_devices = NULL;
 
    /*
     * Free the printer list and get the device list...
@@ -2928,7 +3028,8 @@
 
 
   if ((printer = cgiGetVariable("PRINTER_NAME")) != NULL)
-    snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", printer);
+    httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                     "/printers/%s", printer);
   else
   {
     cgiSetVariable("ERROR", ippErrorString(IPP_NOT_FOUND));
@@ -2989,7 +3090,7 @@
     char	refresh[1024];		/* Refresh URL */
 
     cgiFormEncode(uri, printer, sizeof(uri));
-    snprintf(refresh, sizeof(refresh), "2;/admin?OP=redirect&URL=/printers/%s",
+    snprintf(refresh, sizeof(refresh), "5;/admin?OP=redirect&URL=/printers/%s",
              uri);
     cgiSetVariable("refresh_page", refresh);
 
@@ -3043,7 +3144,8 @@
 
 
   if ((printer = cgiGetVariable("PRINTER_NAME")) != NULL)
-    snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", printer);
+    httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                     "/printers/%s", printer);
   else
   {
     cgiSetVariable("ERROR", ippErrorString(IPP_NOT_FOUND));
@@ -3275,7 +3377,7 @@
       char	refresh[1024];		/* Refresh URL */
 
       cgiFormEncode(uri, printer, sizeof(uri));
-      snprintf(refresh, sizeof(refresh), "2;/admin?OP=redirect&URL=/printers/%s",
+      snprintf(refresh, sizeof(refresh), "5;/admin?OP=redirect&URL=/printers/%s",
                uri);
       cgiSetVariable("refresh_page", refresh);
 
@@ -3306,7 +3408,8 @@
 
 
   if ((printer = cgiGetVariable("PRINTER_NAME")) != NULL)
-    snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", printer);
+    httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                     "/printers/%s", printer);
   else
   {
     cgiSetVariable("ERROR", ippErrorString(IPP_NOT_FOUND));
@@ -3381,7 +3484,7 @@
     char	refresh[1024];		/* Refresh URL */
 
     cgiFormEncode(uri, printer, sizeof(uri));
-    snprintf(refresh, sizeof(refresh), "2;/admin?OP=redirect&URL=/printers/%s",
+    snprintf(refresh, sizeof(refresh), "5;/admin?OP=redirect&URL=/printers/%s",
              uri);
     cgiSetVariable("refresh_page", refresh);
 
@@ -3444,5 +3547,5 @@
 
     
 /*
- * End of "$Id: admin.c 4747 2005-10-03 20:43:07Z mike $".
+ * End of "$Id: admin.c 4816 2005-11-04 15:57:50Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cgi-bin/classes.c cupsys-1.1.99.b1.r4748/cgi-bin/classes.c
--- cupsys-1.1.99.b1.r4748~/cgi-bin/classes.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cgi-bin/classes.c	2005-10-22 03:49:24.065412000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: classes.c 4746 2005-10-03 15:10:52Z mike $"
+ * "$Id: classes.c 4806 2005-10-21 18:49:24Z mike $"
  *
  *   Class status CGI for the Common UNIX Printing System (CUPS).
  *
@@ -192,8 +192,8 @@
       request->request.op.operation_id = IPP_GET_PRINTER_ATTRIBUTES;
       request->request.op.request_id   = 1;
 
-      snprintf(uri, sizeof(uri), "ipp://%s/classes/%s", getenv("SERVER_NAME"),
-               pclass);
+      httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                       "/classes/%s", pclass);
       ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri", NULL,
                    uri);
     }
@@ -242,8 +242,8 @@
       request->request.op.operation_id = IPP_GET_JOBS;
       request->request.op.request_id   = 1;
 
-      snprintf(uri, sizeof(uri), "ipp://%s/classes/%s", getenv("SERVER_NAME"),
-               pclass);
+      httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                       "/classes/%s", pclass);
       ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri", NULL,
                    uri);
 
@@ -297,7 +297,8 @@
       datadir = CUPS_DATADIR;
 
     snprintf(filename, sizeof(filename), "%s/data/testprint.ps", datadir);
-    snprintf(uri, sizeof(uri), "ipp://localhost/classes/%s", pclass);
+    httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                     "/classes/%s", pclass);
 
    /*
     * Build an IPP_PRINT_JOB request, which requires the following
@@ -391,5 +392,5 @@
 
 
 /*
- * End of "$Id: classes.c 4746 2005-10-03 15:10:52Z mike $".
+ * End of "$Id: classes.c 4806 2005-10-21 18:49:24Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cgi-bin/help-index.c cupsys-1.1.99.b1.r4748/cgi-bin/help-index.c
--- cupsys-1.1.99.b1.r4748~/cgi-bin/help-index.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cgi-bin/help-index.c	2005-10-11 04:23:23.958633000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: help-index.c 4608 2005-08-27 03:40:05Z mike $"
+ * "$Id: help-index.c 4767 2005-10-10 19:23:23Z mike $"
  *
  *   On-line help index routines for the Common UNIX Printing System (CUPS).
  *
@@ -179,45 +179,56 @@
 
   if ((fp = cupsFileOpen(hifile, "r")) != NULL)
   {
+   /*
+    * Lock the file and then read the first line...
+    */
+
     cupsFileLock(fp, 1);
 
-    while (cupsFileGets(fp, line, sizeof(line)))
+    if (cupsFileGets(fp, line, sizeof(line)) && !strcmp(line, "HELPV0"))
     {
      /*
-      * Each line looks like one of the following:
-      *
-      *     filename mtime offset length text
-      *     filename#anchor offset length text
+      * Got a valid header line, now read the data lines...
       */
 
-      filename = line;
+      while (cupsFileGets(fp, line, sizeof(line)))
+      {
+       /*
+	* Each line looks like one of the following:
+	*
+	*     filename mtime offset length text
+	*     filename#anchor offset length text
+	*/
 
-      if ((ptr = strchr(line, ' ')) == NULL)
-        break;
+	filename = line;
 
-      while (isspace(*ptr & 255))
-        *ptr++ = '\0';
+	if ((ptr = strchr(line, ' ')) == NULL)
+          break;
 
-      if ((anchor = strrchr(filename, '#')) != NULL)
-        *anchor++ = '\0';
+	while (isspace(*ptr & 255))
+          *ptr++ = '\0';
 
-      mtime  = strtol(ptr, &ptr, 10);
-     /* TODO: Use strtoll for 64-bit file support */
-      offset = strtol(ptr, &ptr, 10);
-      length = strtol(ptr, &ptr, 10);
+	if ((anchor = strrchr(filename, '#')) != NULL)
+          *anchor++ = '\0';
 
-      while (isspace(*ptr & 255))
-        ptr ++;
+	mtime  = strtol(ptr, &ptr, 10);
+       /* TODO: Use strtoll for 64-bit file support */
+	offset = strtol(ptr, &ptr, 10);
+	length = strtol(ptr, &ptr, 10);
 
-      text = ptr;
+	while (isspace(*ptr & 255))
+          ptr ++;
 
-      if ((node = help_new_node(filename, anchor, text,
-				mtime, offset, length)) == NULL)
-        break;
+	text = ptr;
 
-      help_insert_node(hi, node);
+	if ((node = help_new_node(filename, anchor, text,
+				  mtime, offset, length)) == NULL)
+          break;
 
-      node->score = -1;
+	help_insert_node(hi, node);
+
+	node->score = -1;
+      }
     }
 
     cupsFileClose(fp);
@@ -309,6 +320,8 @@
 
   cupsFileLock(fp, 1);
 
+  cupsFilePuts(fp, "HELPV0\n");
+
   for (i = 0; i < hi->num_nodes; i ++)
   {
    /*
@@ -317,17 +330,20 @@
 
     node = hi->nodes[i];
 
-   /* TODO: %lld for 64-bit file support */
     if (node->anchor)
     {
-      if (cupsFilePrintf(fp, "%s#%s %ld %ld %s\n", node->filename, node->anchor,
-                         node->offset, node->length, node->text) < 0)
+      if (cupsFilePrintf(fp, "%s#%s " CUPS_LLFMT " " CUPS_LLFMT " %s\n",
+                         node->filename, node->anchor,
+                         CUPS_LLCAST node->offset, CUPS_LLCAST node->length,
+			 node->text) < 0)
         break;
     }
     else
     {
-      if (cupsFilePrintf(fp, "%s %ld %ld %ld %s\n", node->filename, node->mtime,
-                         node->offset, node->length, node->text) < 0)
+      if (cupsFilePrintf(fp, "%s %d " CUPS_LLFMT " " CUPS_LLFMT " %s\n",
+                         node->filename, node->mtime,
+                         CUPS_LLCAST node->offset, CUPS_LLCAST node->length,
+			 node->text) < 0)
         break;
     }
   }
@@ -919,6 +935,8 @@
   if ((dir = opendir(directory)) == NULL)
     return (0);
 
+  update = 0;
+
   while ((dent = readdir(dir)) != NULL)
   {
    /*
@@ -1288,5 +1306,5 @@
 
 
 /*
- * End of "$Id: help-index.c 4608 2005-08-27 03:40:05Z mike $".
+ * End of "$Id: help-index.c 4767 2005-10-10 19:23:23Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cgi-bin/ipp-var.c cupsys-1.1.99.b1.r4748/cgi-bin/ipp-var.c
--- cupsys-1.1.99.b1.r4748~/cgi-bin/ipp-var.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cgi-bin/ipp-var.c	2005-11-13 06:46:52.687523000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: ipp-var.c 4735 2005-10-01 01:45:18Z mike $"
+ * "$Id: ipp-var.c 4833 2005-11-12 21:46:52Z mike $"
  *
  *   IPP variable routines for the Common UNIX Printing System (CUPS).
  *
@@ -230,7 +230,8 @@
     * these to see if the printer URL is local...
     */
 
-    server = getenv("SERVER_NAME");
+    if ((server = getenv("SERVER_NAME")) == NULL)
+      server = "";
 
     httpGetHostname(servername, sizeof(servername));
 
@@ -247,8 +248,9 @@
 
   httpSeparate(uri, method, userpass, hostname, &port, rawresource);
 
-  if (strcmp(method, "ipp") == 0 ||
-      strcmp(method, "http") == 0)
+  if (!strcmp(method, "ipp") ||
+      !strcmp(method, "http") ||
+      !strcmp(method, "https"))
   {
     if (newresource)
     {
@@ -287,8 +289,9 @@
     * Map local access to a local URI...
     */
 
-    if (strcasecmp(hostname, server) == 0 ||
-	strcasecmp(hostname, servername) == 0)
+    if (!strcasecmp(hostname, "localhost") ||
+	!strcasecmp(hostname, server) ||
+	!strcasecmp(hostname, servername))
     {
      /*
       * Make URI relative to the current server...
@@ -586,5 +589,5 @@
 
 
 /*
- * End of "$Id: ipp-var.c 4735 2005-10-01 01:45:18Z mike $".
+ * End of "$Id: ipp-var.c 4833 2005-11-12 21:46:52Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cgi-bin/printers.c cupsys-1.1.99.b1.r4748/cgi-bin/printers.c
--- cupsys-1.1.99.b1.r4748~/cgi-bin/printers.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cgi-bin/printers.c	2005-10-22 03:49:24.065412000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: printers.c 4746 2005-10-03 15:10:52Z mike $"
+ * "$Id: printers.c 4806 2005-10-21 18:49:24Z mike $"
  *
  *   Printer status CGI for the Common UNIX Printing System (CUPS).
  *
@@ -192,8 +192,8 @@
       request->request.op.operation_id = IPP_GET_PRINTER_ATTRIBUTES;
       request->request.op.request_id   = 1;
 
-      snprintf(uri, sizeof(uri), "ipp://%s/printers/%s", getenv("SERVER_NAME"),
-               printer);
+      httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                       "/printers/%s", printer);
       ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri", NULL,
                    uri);
     }
@@ -278,8 +278,8 @@
       request->request.op.operation_id = IPP_GET_JOBS;
       request->request.op.request_id   = 1;
 
-      snprintf(uri, sizeof(uri), "ipp://%s/printers/%s", getenv("SERVER_NAME"),
-               printer);
+      httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                       "/printers/%s", printer);
       ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri", NULL,
                    uri);
 
@@ -335,7 +335,8 @@
       datadir = CUPS_DATADIR;
 
     snprintf(filename, sizeof(filename), "%s/data/testprint.ps", datadir);
-    snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", printer);
+    httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                     "/printers/%s", printer);
 
    /*
     * Build an IPP_PRINT_JOB request, which requires the following
@@ -429,5 +430,5 @@
 
 
 /*
- * End of "$Id: printers.c 4746 2005-10-03 15:10:52Z mike $".
+ * End of "$Id: printers.c 4806 2005-10-21 18:49:24Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/conf/cupsd.conf.in cupsys-1.1.99.b1.r4748/conf/cupsd.conf.in
--- cupsys-1.1.99.b1.r4748~/conf/cupsd.conf.in	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/conf/cupsd.conf.in	2005-11-05 01:21:01.604469000 +0900
@@ -1,5 +1,5 @@
 #
-# "$Id: cupsd.conf.in 4704 2005-09-26 20:59:15Z mike $"
+# "$Id: cupsd.conf.in 4817 2005-11-04 16:21:01Z mike $"
 #
 #   Sample configuration file for the Common UNIX Printing System (CUPS)
 #   scheduler.  See "man cupsd.conf" for a complete description of this
@@ -14,7 +14,7 @@
 SystemGroup @CUPS_GROUP@
 
 # Only listen for connections from the local machine.
-Listen 127.0.0.1:@DEFAULT_IPP_PORT@
+Listen localhost:@DEFAULT_IPP_PORT@
 @CUPS_LISTEN_DOMAINSOCKET@
 
 # Show shared printers on the local network.
@@ -45,9 +45,6 @@
   Allow localhost
 </Location>
 
-# Authenticate against system accounts by default...
-DefaultAuthType Basic
-
 # Set the default printer/job policies...
 <Policy default>
   # Job-related operations must be done by the owner or an adminstrator...
@@ -75,5 +72,5 @@
 </Policy>
 
 #
-# End of "$Id: cupsd.conf.in 4704 2005-09-26 20:59:15Z mike $".
+# End of "$Id: cupsd.conf.in 4817 2005-11-04 16:21:01Z mike $".
 #
diff -urNad cupsys-1.1.99.b1.r4748~/conf/pam.std cupsys-1.1.99.b1.r4748/conf/pam.std
--- cupsys-1.1.99.b1.r4748~/conf/pam.std	2005-11-13 13:02:24.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/conf/pam.std	1970-01-01 09:00:00.000000000 +0900
@@ -1,2 +0,0 @@
-auth	required	pam_unix.so nullok shadow
-account	required	pam_unix.so
diff -urNad cupsys-1.1.99.b1.r4748~/config-scripts/cups-common.m4 cupsys-1.1.99.b1.r4748/config-scripts/cups-common.m4
--- cupsys-1.1.99.b1.r4748~/config-scripts/cups-common.m4	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/config-scripts/cups-common.m4	2005-11-13 06:46:52.687523000 +0900
@@ -1,5 +1,5 @@
 dnl
-dnl "$Id: cups-common.m4 4680 2005-09-21 09:28:39Z mike $"
+dnl "$Id: cups-common.m4 4833 2005-11-12 21:46:52Z mike $"
 dnl
 dnl   Common configuration stuff for the Common UNIX Printing System (CUPS).
 dnl
@@ -55,15 +55,6 @@
 AC_PATH_PROG(HTMLDOC,htmldoc)
 AC_PATH_PROG(LN,ln)
 AC_PATH_PROG(MV,mv)
-AC_PATH_PROG(NROFF,nroff)
-if test "x$NROFF" = x; then
-	AC_PATH_PROG(GROFF,groff)
-	if test "x$GROFF" = x; then
-        	NROFF="echo"
-	else
-        	NROFF="$GROFF -T ascii"
-	fi
-fi
 AC_PATH_PROG(RM,rm)
 AC_PATH_PROG(SED,sed)
 AC_PATH_PROG(STRIP,strip)
@@ -184,16 +175,14 @@
 case $uname in
         Darwin*)
                 BACKLIBS="-framework IOKit"
-                COMMONLIBS="-framework CoreFoundation"
+                LIBS="-framework CoreFoundation $LIBS"
                 ;;
         *)
                 BACKLIBS=""
-		COMMONLIBS=""
                 ;;
 esac
 
 AC_SUBST(BACKLIBS)
-AC_SUBST(COMMONLIBS)
 
 dnl New default port definition for IPP...
 AC_ARG_WITH(ipp-port, [  --with-ipp-port         set default port number for IPP ],
@@ -204,5 +193,5 @@
 AC_DEFINE_UNQUOTED(CUPS_DEFAULT_IPP_PORT,$DEFAULT_IPP_PORT)
 
 dnl
-dnl End of "$Id: cups-common.m4 4680 2005-09-21 09:28:39Z mike $".
+dnl End of "$Id: cups-common.m4 4833 2005-11-12 21:46:52Z mike $".
 dnl
diff -urNad cupsys-1.1.99.b1.r4748~/config-scripts/cups-compiler.m4 cupsys-1.1.99.b1.r4748/config-scripts/cups-compiler.m4
--- cupsys-1.1.99.b1.r4748~/config-scripts/cups-compiler.m4	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/config-scripts/cups-compiler.m4	2005-10-11 04:23:23.958633000 +0900
@@ -1,5 +1,5 @@
 dnl
-dnl "$Id: cups-compiler.m4 4730 2005-09-30 21:45:34Z mike $"
+dnl "$Id: cups-compiler.m4 4767 2005-10-10 19:23:23Z mike $"
 dnl
 dnl   Compiler stuff for the Common UNIX Printing System (CUPS).
 dnl
@@ -41,12 +41,8 @@
 if test -n "$GCC"; then
 	if test -z "$OPTIM"; then
 		if test "x$with_optim" = x; then
-			if test $uname = HP-UX; then
-				# GCC under HP-UX has bugs with -O2
-				OPTIM="-O1"
-			else
-		       		OPTIM="-O2"
-			fi
+			# Default to optimize-for-size and debug
+       			OPTIM="-Os -g"
 		else
 			OPTIM="$with_optim $OPTIM"
 		fi
@@ -190,5 +186,5 @@
 fi
 
 dnl
-dnl End of "$Id: cups-compiler.m4 4730 2005-09-30 21:45:34Z mike $".
+dnl End of "$Id: cups-compiler.m4 4767 2005-10-10 19:23:23Z mike $".
 dnl
diff -urNad cupsys-1.1.99.b1.r4748~/config-scripts/cups-directories.m4 cupsys-1.1.99.b1.r4748/config-scripts/cups-directories.m4
--- cupsys-1.1.99.b1.r4748~/config-scripts/cups-directories.m4	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/config-scripts/cups-directories.m4	2005-10-14 22:16:12.594462000 +0900
@@ -1,5 +1,5 @@
 dnl
-dnl "$Id: cups-directories.m4 4615 2005-08-30 20:13:19Z mike $"
+dnl "$Id: cups-directories.m4 4793 2005-10-14 13:16:12Z mike $"
 dnl
 dnl   Directory stuff for the Common UNIX Printing System (CUPS).
 dnl
@@ -60,7 +60,11 @@
 dnl Fix "localstatedir" variable if it hasn't been specified...
 if test "$localstatedir" = "\${prefix}/var"; then
 	if test "$prefix" = "/"; then
-		localstatedir="/var"
+		if test "$uname" = Darwin; then
+			localstatedir="/private/var"
+		else
+			localstatedir="/var"
+		fi
 	else
 		localstatedir="$prefix/var"
 	fi
@@ -69,7 +73,11 @@
 dnl Fix "sysconfdir" variable if it hasn't been specified...
 if test "$sysconfdir" = "\${prefix}/etc"; then
 	if test "$prefix" = "/"; then
-		sysconfdir="/etc"
+		if test "$uname" = Darwin; then
+			sysconfdir="/private/etc"
+		else
+			sysconfdir="/etc"
+		fi
 	else
 		sysconfdir="$prefix/etc"
 	fi
@@ -257,5 +265,5 @@
 AC_SUBST(CUPS_STATEDIR)
 
 dnl
-dnl End of "$Id: cups-directories.m4 4615 2005-08-30 20:13:19Z mike $".
+dnl End of "$Id: cups-directories.m4 4793 2005-10-14 13:16:12Z mike $".
 dnl
diff -urNad cupsys-1.1.99.b1.r4748~/config-scripts/cups-manpages.m4 cupsys-1.1.99.b1.r4748/config-scripts/cups-manpages.m4
--- cupsys-1.1.99.b1.r4748~/config-scripts/cups-manpages.m4	2005-02-18 11:18:11.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/config-scripts/cups-manpages.m4	2005-11-13 06:46:52.687523000 +0900
@@ -1,5 +1,5 @@
 dnl
-dnl "$Id: cups-manpages.m4 4494 2005-02-18 02:18:11Z mike $"
+dnl "$Id: cups-manpages.m4 4833 2005-11-12 21:46:52Z mike $"
 dnl
 dnl   Manpage stuff for the Common UNIX Printing System (CUPS).
 dnl
@@ -56,49 +56,46 @@
 case "$uname" in
 	*BSD* | Darwin*)
 		# *BSD
-		CAT1EXT=0
-		CAT3EXT=0
-		CAT5EXT=0
-		CAT8EXT=0
+		MAN1EXT=1
+		MAN5EXT=5
 		MAN8EXT=8
 		MAN8DIR=8
 		;;
 	IRIX*)
 		# SGI IRIX
-		CAT1EXT=z
-		CAT3EXT=z
-		CAT5EXT=z
-		CAT8EXT=z
+		MAN1EXT=1
+		MAN5EXT=5
 		MAN8EXT=1m
 		MAN8DIR=1
 		;;
 	SunOS* | HP-UX*)
 		# Solaris and HP-UX
-		CAT1EXT=1
-		CAT3EXT=3
-		CAT5EXT=5
-		CAT8EXT=1m
+		MAN1EXT=1
+		MAN5EXT=5
 		MAN8EXT=1m
 		MAN8DIR=1m
 		;;
+	Linux* | GNU*)
+		# Linux and GNU Hurd
+		MAN1EXT=1.gz
+		MAN5EXT=5.gz
+		MAN8EXT=8.gz
+		MAN8DIR=8
+		;;
 	*)
 		# All others
-		CAT1EXT=1
-		CAT3EXT=3
-		CAT5EXT=5
-		CAT8EXT=8
+		MAN1EXT=1
+		MAN5EXT=5
 		MAN8EXT=8
 		MAN8DIR=8
 		;;
 esac
 
-AC_SUBST(CAT1EXT)
-AC_SUBST(CAT3EXT)
-AC_SUBST(CAT5EXT)
-AC_SUBST(CAT8EXT)
+AC_SUBST(MAN1EXT)
+AC_SUBST(MAN5EXT)
 AC_SUBST(MAN8EXT)
 AC_SUBST(MAN8DIR)
 
 dnl
-dnl End of "$Id: cups-manpages.m4 4494 2005-02-18 02:18:11Z mike $".
+dnl End of "$Id: cups-manpages.m4 4833 2005-11-12 21:46:52Z mike $".
 dnl
diff -urNad cupsys-1.1.99.b1.r4748~/config-scripts/cups-network.m4 cupsys-1.1.99.b1.r4748/config-scripts/cups-network.m4
--- cupsys-1.1.99.b1.r4748~/config-scripts/cups-network.m4	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/config-scripts/cups-network.m4	2005-10-19 06:09:12.681329000 +0900
@@ -1,5 +1,5 @@
 dnl
-dnl "$Id: cups-network.m4 4653 2005-09-16 20:13:58Z mike $"
+dnl "$Id: cups-network.m4 4801 2005-10-18 21:09:12Z mike $"
 dnl
 dnl   Networking stuff for the Common UNIX Printing System (CUPS).
 dnl
@@ -22,19 +22,16 @@
 dnl         WWW: http://www.cups.org
 dnl
 
-NETLIBS=""
-
-if test "$uname" != "IRIX"; then
-	AC_CHECK_LIB(socket,socket,NETLIBS="-lsocket")
-	AC_CHECK_LIB(nsl,gethostbyaddr,NETLIBS="$NETLIBS -lnsl")
-fi
-
-AC_CHECK_FUNCS(getaddrinfo getifaddrs hstrerror rresvport_af)
-
-AC_CHECK_MEMBER(struct sockaddr.sa_len,,,[#include <sys/socket.h>])
-AC_CHECK_HEADER(sys/sockio.h,AC_DEFINE(HAVE_SYS_SOCKIO_H))
+AC_SEARCH_LIBS(socket, socket)
+AC_SEARCH_LIBS(gethostbyaddr, nsl)
+AC_SEARCH_LIBS(getaddrinfo, nsl, AC_DEFINE(HAVE_GETADDRINFO))
+AC_SEARCH_LIBS(getifaddrs, nsl, AC_DEFINE(HAVE_GETIFADDRS))
+AC_SEARCH_LIBS(getnameinfo, nsl, AC_DEFINE(HAVE_GETNAMEINFO))
+AC_SEARCH_LIBS(hstrerror, nsl socket resolv, AC_DEFINE(HAVE_HSTRERROR))
+AC_SEARCH_LIBS(rresvport_af, nsl, AC_DEFINE(HAVE_RRESVPORT_AF))
 
-AC_SUBST(NETLIBS)
+AC_CHECK_MEMBER(struct sockaddr.sa_len,,, [#include <sys/socket.h>])
+AC_CHECK_HEADER(sys/sockio.h, AC_DEFINE(HAVE_SYS_SOCKIO_H))
 
 if test "$uname" = "SunOS"; then
 	case "$uversion" in
@@ -57,27 +54,35 @@
 CUPS_DEFAULT_DOMAINSOCKET=""
 
 dnl Domain socket support...
-AC_ARG_ENABLE(domainsocket, [  --enable-domainsocket   turn on domain socket support, default=yes])
 AC_ARG_WITH(domainsocket, [  --with-domainsocket     set unix domain socket name],
 	default_domainsocket="$withval",
 	default_domainsocket="")
 
-if test x$enable_domainsocket != xno; then
+if test x$enable_domainsocket != xno -a x$default_domainsocket != xno; then
 	if test "x$default_domainsocket" = x; then
-		CUPS_DEFAULT_DOMAINSOCKET="$CUPS_STATEDIR/cups.sock"
+		case "$uname" in
+			Darwin*)
+				# Darwin and MaxOS X do their own thing...
+				CUPS_DEFAULT_DOMAINSOCKET="$localstatedir/run/cupsd"
+				;;
+			*)
+				# All others use FHS standard...
+				CUPS_DEFAULT_DOMAINSOCKET="$CUPS_STATEDIR/cups.sock"
+				;;
+		esac
 	else
 		CUPS_DEFAULT_DOMAINSOCKET="$default_domainsocket"
 	fi
 
 	CUPS_LISTEN_DOMAINSOCKET="Listen $CUPS_DEFAULT_DOMAINSOCKET"
+
+	AC_DEFINE_UNQUOTED(CUPS_DEFAULT_DOMAINSOCKET, "$CUPS_DEFAULT_DOMAINSOCKET")
 else
-	CUPS_DEFAULT_DOMAINSOCKET=""
 	CUPS_LISTEN_DOMAINSOCKET=""
 fi
 
-AC_DEFINE_UNQUOTED(CUPS_DEFAULT_DOMAINSOCKET, "$CUPS_DEFAULT_DOMAINSOCKET")
 AC_SUBST(CUPS_LISTEN_DOMAINSOCKET)
 
 dnl
-dnl End of "$Id: cups-network.m4 4653 2005-09-16 20:13:58Z mike $".
+dnl End of "$Id: cups-network.m4 4801 2005-10-18 21:09:12Z mike $".
 dnl
diff -urNad cupsys-1.1.99.b1.r4748~/config-scripts/cups-opsys.m4 cupsys-1.1.99.b1.r4748/config-scripts/cups-opsys.m4
--- cupsys-1.1.99.b1.r4748~/config-scripts/cups-opsys.m4	2005-02-18 11:18:11.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/config-scripts/cups-opsys.m4	2005-11-13 06:46:52.687523000 +0900
@@ -1,5 +1,5 @@
 dnl
-dnl "$Id: cups-opsys.m4 4494 2005-02-18 02:18:11Z mike $"
+dnl "$Id: cups-opsys.m4 4833 2005-11-12 21:46:52Z mike $"
 dnl
 dnl   Operating system stuff for the Common UNIX Printing System (CUPS).
 dnl
@@ -67,7 +67,7 @@
 		if test x$uname = xDarwin; then
 			GROUP_LIST="lp admin"
 		else
-			GROUP_LIST="sys system root"
+			GROUP_LIST="lpadmin sys system root"
 		fi
 
 		CUPS_GROUP=""
@@ -95,5 +95,5 @@
 AC_DEFINE_UNQUOTED(CUPS_DEFAULT_GROUP, "$CUPS_GROUP")
 
 dnl
-dnl "$Id: cups-opsys.m4 4494 2005-02-18 02:18:11Z mike $"
+dnl "$Id: cups-opsys.m4 4833 2005-11-12 21:46:52Z mike $"
 dnl
diff -urNad cupsys-1.1.99.b1.r4748~/config-scripts/cups-sharedlibs.m4 cupsys-1.1.99.b1.r4748/config-scripts/cups-sharedlibs.m4
--- cupsys-1.1.99.b1.r4748~/config-scripts/cups-sharedlibs.m4	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/config-scripts/cups-sharedlibs.m4	2005-10-19 03:06:20.449904000 +0900
@@ -1,5 +1,5 @@
 dnl
-dnl "$Id: cups-sharedlibs.m4 4494 2005-02-18 02:18:11Z mike $"
+dnl "$Id: cups-sharedlibs.m4 4800 2005-10-18 18:06:20Z mike $"
 dnl
 dnl   Shared library support for the Common UNIX Printing System (CUPS).
 dnl
@@ -87,7 +87,7 @@
 AC_SUBST(LIBCUPSIMAGE)
 
 if test x$enable_shared = xno; then
-	LINKCUPS="../cups/libcups.a \$(SSLLIBS)"
+	LINKCUPS="../cups/libcups.a"
 	LINKCUPSIMAGE="../filter/libcupsimage.a"
 else
 	if test $uname = AIX; then
@@ -152,5 +152,5 @@
 AC_SUBST(EXPORT_LDFLAGS)
 
 dnl
-dnl End of "$Id: cups-sharedlibs.m4 4494 2005-02-18 02:18:11Z mike $".
+dnl End of "$Id: cups-sharedlibs.m4 4800 2005-10-18 18:06:20Z mike $".
 dnl
diff -urNad cupsys-1.1.99.b1.r4748~/config-scripts/cups-ssl.m4 cupsys-1.1.99.b1.r4748/config-scripts/cups-ssl.m4
--- cupsys-1.1.99.b1.r4748~/config-scripts/cups-ssl.m4	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/config-scripts/cups-ssl.m4	2005-10-19 03:06:20.449904000 +0900
@@ -1,5 +1,5 @@
 dnl
-dnl "$Id: cups-ssl.m4 4615 2005-08-30 20:13:19Z mike $"
+dnl "$Id: cups-ssl.m4 4800 2005-10-18 18:06:20Z mike $"
 dnl
 dnl   OpenSSL/GNUTLS stuff for the Common UNIX Printing System (CUPS).
 dnl
@@ -55,12 +55,10 @@
 	    dnl included...
 	    SAVELIBS="$LIBS"
 
-	    TEST_GNUTLS_LIBS=`libgnutls-config --libs`
 	    AC_CHECK_LIB(gnutls, gnutls_init,
-		[SSLLIBS=$TEST_GNUTLS_LIBS
+		[SSLLIBS="-lgnutls"
 		 AC_DEFINE(HAVE_SSL)
-		 AC_DEFINE(HAVE_GNUTLS)],,
-		$TEST_GNUTLS_LIBS)
+		 AC_DEFINE(HAVE_GNUTLS)])
 
 	    LIBS="$SAVELIBS")
     fi
@@ -107,5 +105,5 @@
 
 
 dnl
-dnl End of "$Id: cups-ssl.m4 4615 2005-08-30 20:13:19Z mike $".
+dnl End of "$Id: cups-ssl.m4 4800 2005-10-18 18:06:20Z mike $".
 dnl
diff -urNad cupsys-1.1.99.b1.r4748~/config-scripts/cups-threads.m4 cupsys-1.1.99.b1.r4748/config-scripts/cups-threads.m4
--- cupsys-1.1.99.b1.r4748~/config-scripts/cups-threads.m4	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/config-scripts/cups-threads.m4	2005-10-19 22:48:06.018726000 +0900
@@ -28,8 +28,7 @@
 
 if test "x$enable_threads" != xno; then
 	AC_CHECK_HEADER(pthread.h, AC_DEFINE(HAVE_PTHREAD_H))
-	AC_CHECK_LIB(pthread, pthread_create,
-		COMMONLIBS="-lpthread $COMMONLIBS")
+	AC_CHECK_LIB(pthread, pthread_create)
 
 	if test "x$ac_cv_lib_pthread_pthread_create" = xyes -a x$ac_cv_header_pthread_h = xyes; then
         	have_pthread=yes
@@ -40,9 +39,8 @@
 		LIBS="-pthread $LIBS"
         	AC_TRY_LINK([#include <pthread.h>],
 			[pthread_create(0, 0, 0, 0);],
-        		COMMONLIBS="-pthread $COMMONLIBS"
-        		have_pthread=yes)
-		LIBS="$SAVELIBS"
+        		have_pthread=yes,
+			LIBS="$SAVELIBS")
         	AC_MSG_RESULT([$have_pthread])
 	fi
 fi
diff -urNad cupsys-1.1.99.b1.r4748~/config.h.in cupsys-1.1.99.b1.r4748/config.h.in
--- cupsys-1.1.99.b1.r4748~/config.h.in	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/config.h.in	2005-10-09 05:11:08.260376000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: config.h.in 4730 2005-09-30 21:45:34Z mike $"
+ * "$Id: config.h.in 4760 2005-10-08 20:11:08Z mike $"
  *
  *   Configuration file for the Common UNIX Printing System (CUPS).
  *
@@ -61,7 +61,7 @@
  * Do we have domain socket support?
  */
 
-#define CUPS_DEFAULT_DOMAINSOCKET ""
+#undef CUPS_DEFAULT_DOMAINSOCKET
 
 
 /*
@@ -275,6 +275,13 @@
 
 
 /*
+ * Do we have getnameinfo()?
+ */
+
+#undef HAVE_GETNAMEINFO
+
+
+/*
  * Do we have getifaddrs()?
  */
 
@@ -332,5 +339,5 @@
 #endif /* !_CUPS_CONFIG_H_ */
 
 /*
- * End of "$Id: config.h.in 4730 2005-09-30 21:45:34Z mike $".
+ * End of "$Id: config.h.in 4760 2005-10-08 20:11:08Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/configure cupsys-1.1.99.b1.r4748/configure
--- cupsys-1.1.99.b1.r4748~/configure	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/configure	2005-11-13 14:15:02.853277607 +0900
@@ -310,7 +310,7 @@
 #endif"
 
 ac_default_prefix=/
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS CUPS_USER CUPS_GROUP CUPS_VERSION AWK CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT CXX CXXFLAGS ac_ct_CXX CPP INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA RANLIB ac_ct_RANLIB AR HTMLDOC LN MV NROFF GROFF RM SED STRIP LIBMALLOC LIBPAPER EGREP ARFLAGS BACKLIBS COMMONLIBS DEFAULT_IPP_PORT INITDIR INITDDIR CUPS_CACHEDIR CUPS_DATADIR CUPS_DOCROOT CUPS_FONTPATH CUPS_LOCALEDIR CUPS_LOGDIR CUPS_REQUESTS CUPS_SERVERBIN INSTALL_SYSV CUPS_SERVERROOT CUPS_STATEDIR AMANDIR PMANDIR CAT1EXT CAT3EXT CAT5EXT CAT8EXT MAN8EXT MAN8DIR DSO DSOFLAGS LIBCUPS LIBCUPSIMAGE LINKCUPS LINKCUPSIMAGE DSOLIBS IMGLIBS EXPORT_LDFLAGS LIBTOOL OPTIM CXXLIBS LIBJPEG LIBPNG LIBTIFF LIBZ EXPORT_LIBJPEG EXPORT_LIBPNG EXPORT_LIBTIFF EXPORT_LIBZ NETLIBS CUPS_LISTEN_DOMAINSOCKET LIBSLP SSLFLAGS SSLLIBS EXPORT_SSLLIBS PAMDIR PAMFILE PAMLIBS PAMMOD LARGEFILE MAKEDEFS JAVA PERL PHP PYTHON LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS CUPS_USER CUPS_GROUP CUPS_VERSION AWK CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT CXX CXXFLAGS ac_ct_CXX CPP INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA RANLIB ac_ct_RANLIB AR HTMLDOC LN MV RM SED STRIP LIBMALLOC LIBPAPER EGREP ARFLAGS BACKLIBS DEFAULT_IPP_PORT INITDIR INITDDIR CUPS_CACHEDIR CUPS_DATADIR CUPS_DOCROOT CUPS_FONTPATH CUPS_LOCALEDIR CUPS_LOGDIR CUPS_REQUESTS CUPS_SERVERBIN INSTALL_SYSV CUPS_SERVERROOT CUPS_STATEDIR AMANDIR PMANDIR MAN1EXT MAN5EXT MAN8EXT MAN8DIR DSO DSOFLAGS LIBCUPS LIBCUPSIMAGE LINKCUPS LINKCUPSIMAGE DSOLIBS IMGLIBS EXPORT_LDFLAGS LIBTOOL OPTIM CXXLIBS LIBJPEG LIBPNG LIBTIFF LIBZ EXPORT_LIBJPEG EXPORT_LIBPNG EXPORT_LIBTIFF EXPORT_LIBZ CUPS_LISTEN_DOMAINSOCKET LIBSLP SSLFLAGS SSLLIBS EXPORT_SSLLIBS PAMDIR PAMFILE PAMLIBS PAMMOD LARGEFILE MAKEDEFS JAVA PERL PHP PYTHON LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 
 # Initialize some variables set by options.
@@ -858,7 +858,6 @@
   --enable-jpeg           turn on JPEG support, default=yes
   --enable-png            turn on PNG support, default=yes
   --enable-tiff           turn on TIFF support, default=yes
-  --enable-domainsocket   turn on domain socket support, default=yes
   --enable-slp            turn on SLP support, default=yes
   --enable-ssl            turn on SSL/TLS support, default=yes
   --enable-cdsassl        use CDSA for SSL/TLS support, default=first
@@ -1399,7 +1398,7 @@
 		if test x$uname = xDarwin; then
 			GROUP_LIST="lp admin"
 		else
-			GROUP_LIST="sys system root"
+			GROUP_LIST="lpadmin sys system root"
 		fi
 
 		CUPS_GROUP=""
@@ -3352,91 +3351,6 @@
 echo "${ECHO_T}no" >&6
 fi
 
-# Extract the first word of "nroff", so it can be a program name with args.
-set dummy nroff; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_path_NROFF+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  case $NROFF in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_NROFF="$NROFF" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_path_NROFF="$as_dir/$ac_word$ac_exec_ext"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-  ;;
-esac
-fi
-NROFF=$ac_cv_path_NROFF
-
-if test -n "$NROFF"; then
-  echo "$as_me:$LINENO: result: $NROFF" >&5
-echo "${ECHO_T}$NROFF" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-if test "x$NROFF" = x; then
-	# Extract the first word of "groff", so it can be a program name with args.
-set dummy groff; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_path_GROFF+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  case $GROFF in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_GROFF="$GROFF" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
-    ac_cv_path_GROFF="$as_dir/$ac_word$ac_exec_ext"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-
-  ;;
-esac
-fi
-GROFF=$ac_cv_path_GROFF
-
-if test -n "$GROFF"; then
-  echo "$as_me:$LINENO: result: $GROFF" >&5
-echo "${ECHO_T}$GROFF" >&6
-else
-  echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-
-	if test "x$GROFF" = x; then
-        	NROFF="echo"
-	else
-        	NROFF="$GROFF -T ascii"
-	fi
-fi
 # Extract the first word of "rm", so it can be a program name with args.
 set dummy rm; ac_word=$2
 echo "$as_me:$LINENO: checking for $ac_word" >&5
@@ -6845,18 +6759,16 @@
 case $uname in
         Darwin*)
                 BACKLIBS="-framework IOKit"
-                COMMONLIBS="-framework CoreFoundation"
+                LIBS="-framework CoreFoundation $LIBS"
                 ;;
         *)
                 BACKLIBS=""
-		COMMONLIBS=""
                 ;;
 esac
 
 
 
 
-
 # Check whether --with-ipp-port or --without-ipp-port was given.
 if test "${with_ipp_port+set}" = set; then
   withval="$with_ipp_port"
@@ -6905,7 +6817,11 @@
 
 if test "$localstatedir" = "\${prefix}/var"; then
 	if test "$prefix" = "/"; then
-		localstatedir="/var"
+		if test "$uname" = Darwin; then
+			localstatedir="/private/var"
+		else
+			localstatedir="/var"
+		fi
 	else
 		localstatedir="$prefix/var"
 	fi
@@ -6913,7 +6829,11 @@
 
 if test "$sysconfdir" = "\${prefix}/etc"; then
 	if test "$prefix" = "/"; then
-		sysconfdir="/etc"
+		if test "$uname" = Darwin; then
+			sysconfdir="/private/etc"
+		else
+			sysconfdir="/etc"
+		fi
 	else
 		sysconfdir="$prefix/etc"
 	fi
@@ -7199,37 +7119,36 @@
 case "$uname" in
 	*BSD* | Darwin*)
 		# *BSD
-		CAT1EXT=0
-		CAT3EXT=0
-		CAT5EXT=0
-		CAT8EXT=0
+		MAN1EXT=1
+		MAN5EXT=5
 		MAN8EXT=8
 		MAN8DIR=8
 		;;
 	IRIX*)
 		# SGI IRIX
-		CAT1EXT=z
-		CAT3EXT=z
-		CAT5EXT=z
-		CAT8EXT=z
+		MAN1EXT=1
+		MAN5EXT=5
 		MAN8EXT=1m
 		MAN8DIR=1
 		;;
 	SunOS* | HP-UX*)
 		# Solaris and HP-UX
-		CAT1EXT=1
-		CAT3EXT=3
-		CAT5EXT=5
-		CAT8EXT=1m
+		MAN1EXT=1
+		MAN5EXT=5
 		MAN8EXT=1m
 		MAN8DIR=1m
 		;;
+	Linux* | GNU*)
+		# Linux and GNU Hurd
+		MAN1EXT=1.gz
+		MAN5EXT=5.gz
+		MAN8EXT=8.gz
+		MAN8DIR=8
+		;;
 	*)
 		# All others
-		CAT1EXT=1
-		CAT3EXT=3
-		CAT5EXT=5
-		CAT8EXT=8
+		MAN1EXT=1
+		MAN5EXT=5
 		MAN8EXT=8
 		MAN8DIR=8
 		;;
@@ -7243,8 +7162,6 @@
 
 
 
-
-
 PICFLAG=1
 DSOFLAGS="${DSOFLAGS:=}"
 
@@ -7314,7 +7231,7 @@
 
 
 if test x$enable_shared = xno; then
-	LINKCUPS="../cups/libcups.a \$(SSLLIBS)"
+	LINKCUPS="../cups/libcups.a"
 	LINKCUPSIMAGE="../filter/libcupsimage.a"
 else
 	if test $uname = AIX; then
@@ -7429,12 +7346,8 @@
 if test -n "$GCC"; then
 	if test -z "$OPTIM"; then
 		if test "x$with_optim" = x; then
-			if test $uname = HP-UX; then
-				# GCC under HP-UX has bugs with -O2
-				OPTIM="-O1"
-			else
-		       		OPTIM="-O2"
-			fi
+			# Default to optimize-for-size and debug
+       			OPTIM="-Os -g"
 		else
 			OPTIM="$with_optim $OPTIM"
 		fi
@@ -8750,16 +8663,13 @@
 
 
 
-NETLIBS=""
-
-if test "$uname" != "IRIX"; then
-	echo "$as_me:$LINENO: checking for socket in -lsocket" >&5
-echo $ECHO_N "checking for socket in -lsocket... $ECHO_C" >&6
-if test "${ac_cv_lib_socket_socket+set}" = set; then
+echo "$as_me:$LINENO: checking for library containing socket" >&5
+echo $ECHO_N "checking for library containing socket... $ECHO_C" >&6
+if test "${ac_cv_search_socket+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lsocket  $LIBS"
+  ac_func_search_save_LIBS=$LIBS
+ac_cv_search_socket=no
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -8803,30 +8713,87 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_lib_socket_socket=yes
+  ac_cv_search_socket="none required"
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-ac_cv_lib_socket_socket=no
 fi
 rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
+if test "$ac_cv_search_socket" = no; then
+  for ac_lib in socket; do
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char socket ();
+int
+main ()
+{
+socket ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_socket="-l$ac_lib"
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 fi
-echo "$as_me:$LINENO: result: $ac_cv_lib_socket_socket" >&5
-echo "${ECHO_T}$ac_cv_lib_socket_socket" >&6
-if test $ac_cv_lib_socket_socket = yes; then
-  NETLIBS="-lsocket"
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+  done
+fi
+LIBS=$ac_func_search_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_search_socket" >&5
+echo "${ECHO_T}$ac_cv_search_socket" >&6
+if test "$ac_cv_search_socket" != no; then
+  test "$ac_cv_search_socket" = "none required" || LIBS="$ac_cv_search_socket $LIBS"
+
 fi
 
-	echo "$as_me:$LINENO: checking for gethostbyaddr in -lnsl" >&5
-echo $ECHO_N "checking for gethostbyaddr in -lnsl... $ECHO_C" >&6
-if test "${ac_cv_lib_nsl_gethostbyaddr+set}" = set; then
+echo "$as_me:$LINENO: checking for library containing gethostbyaddr" >&5
+echo $ECHO_N "checking for library containing gethostbyaddr... $ECHO_C" >&6
+if test "${ac_cv_search_gethostbyaddr+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lnsl  $LIBS"
+  ac_func_search_save_LIBS=$LIBS
+ac_cv_search_gethostbyaddr=no
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -8870,84 +8837,667 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_lib_nsl_gethostbyaddr=yes
+  ac_cv_search_gethostbyaddr="none required"
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-ac_cv_lib_nsl_gethostbyaddr=no
 fi
 rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
+if test "$ac_cv_search_gethostbyaddr" = no; then
+  for ac_lib in nsl; do
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char gethostbyaddr ();
+int
+main ()
+{
+gethostbyaddr ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_gethostbyaddr="-l$ac_lib"
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 fi
-echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyaddr" >&5
-echo "${ECHO_T}$ac_cv_lib_nsl_gethostbyaddr" >&6
-if test $ac_cv_lib_nsl_gethostbyaddr = yes; then
-  NETLIBS="$NETLIBS -lnsl"
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+  done
 fi
+LIBS=$ac_func_search_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_search_gethostbyaddr" >&5
+echo "${ECHO_T}$ac_cv_search_gethostbyaddr" >&6
+if test "$ac_cv_search_gethostbyaddr" != no; then
+  test "$ac_cv_search_gethostbyaddr" = "none required" || LIBS="$ac_cv_search_gethostbyaddr $LIBS"
 
 fi
 
+echo "$as_me:$LINENO: checking for library containing getaddrinfo" >&5
+echo $ECHO_N "checking for library containing getaddrinfo... $ECHO_C" >&6
+if test "${ac_cv_search_getaddrinfo+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+ac_cv_search_getaddrinfo=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char getaddrinfo ();
+int
+main ()
+{
+getaddrinfo ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_getaddrinfo="none required"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+if test "$ac_cv_search_getaddrinfo" = no; then
+  for ac_lib in nsl; do
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char getaddrinfo ();
+int
+main ()
+{
+getaddrinfo ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_getaddrinfo="-l$ac_lib"
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
-for ac_func in getaddrinfo getifaddrs hstrerror rresvport_af
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-echo "$as_me:$LINENO: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
-if eval "test \"\${$as_ac_var+set}\" = set"; then
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+  done
+fi
+LIBS=$ac_func_search_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_search_getaddrinfo" >&5
+echo "${ECHO_T}$ac_cv_search_getaddrinfo" >&6
+if test "$ac_cv_search_getaddrinfo" != no; then
+  test "$ac_cv_search_getaddrinfo" = "none required" || LIBS="$ac_cv_search_getaddrinfo $LIBS"
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETADDRINFO 1
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for library containing getifaddrs" >&5
+echo $ECHO_N "checking for library containing getifaddrs... $ECHO_C" >&6
+if test "${ac_cv_search_getifaddrs+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
+  ac_func_search_save_LIBS=$LIBS
+ac_cv_search_getifaddrs=no
+cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
 
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char getifaddrs ();
+int
+main ()
+{
+getifaddrs ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_getifaddrs="none required"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+if test "$ac_cv_search_getifaddrs" = no; then
+  for ac_lib in nsl; do
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
 #endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char getifaddrs ();
+int
+main ()
+{
+getifaddrs ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_getifaddrs="-l$ac_lib"
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
-#undef $ac_func
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+  done
+fi
+LIBS=$ac_func_search_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_search_getifaddrs" >&5
+echo "${ECHO_T}$ac_cv_search_getifaddrs" >&6
+if test "$ac_cv_search_getifaddrs" != no; then
+  test "$ac_cv_search_getifaddrs" = "none required" || LIBS="$ac_cv_search_getifaddrs $LIBS"
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETIFADDRS 1
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for library containing getnameinfo" >&5
+echo $ECHO_N "checking for library containing getnameinfo... $ECHO_C" >&6
+if test "${ac_cv_search_getnameinfo+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+ac_cv_search_getnameinfo=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char getnameinfo ();
+int
+main ()
 {
+getnameinfo ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_getnameinfo="none required"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+if test "$ac_cv_search_getnameinfo" = no; then
+  for ac_lib in nsl; do
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
-choke me
-#else
-char (*f) () = $ac_func;
+char getnameinfo ();
+int
+main ()
+{
+getnameinfo ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_getnameinfo="-l$ac_lib"
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+  done
+fi
+LIBS=$ac_func_search_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_search_getnameinfo" >&5
+echo "${ECHO_T}$ac_cv_search_getnameinfo" >&6
+if test "$ac_cv_search_getnameinfo" != no; then
+  test "$ac_cv_search_getnameinfo" = "none required" || LIBS="$ac_cv_search_getnameinfo $LIBS"
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETNAMEINFO 1
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for library containing hstrerror" >&5
+echo $ECHO_N "checking for library containing hstrerror... $ECHO_C" >&6
+if test "${ac_cv_search_hstrerror+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+ac_cv_search_hstrerror=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
 #endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char hstrerror ();
+int
+main ()
+{
+hstrerror ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_hstrerror="none required"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+if test "$ac_cv_search_hstrerror" = no; then
+  for ac_lib in nsl socket resolv; do
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char hstrerror ();
+int
+main ()
+{
+hstrerror ();
+  ;
+  return 0;
 }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_hstrerror="-l$ac_lib"
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+  done
+fi
+LIBS=$ac_func_search_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_search_hstrerror" >&5
+echo "${ECHO_T}$ac_cv_search_hstrerror" >&6
+if test "$ac_cv_search_hstrerror" != no; then
+  test "$ac_cv_search_hstrerror" = "none required" || LIBS="$ac_cv_search_hstrerror $LIBS"
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_HSTRERROR 1
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for library containing rresvport_af" >&5
+echo $ECHO_N "checking for library containing rresvport_af... $ECHO_C" >&6
+if test "${ac_cv_search_rresvport_af+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+ac_cv_search_rresvport_af=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
 #endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char rresvport_af ();
+int
+main ()
+{
+rresvport_af ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_rresvport_af="none required"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+if test "$ac_cv_search_rresvport_af" = no; then
+  for ac_lib in nsl; do
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char rresvport_af ();
 int
 main ()
 {
-return f != $ac_func;
+rresvport_af ();
   ;
   return 0;
 }
@@ -8973,25 +9523,28 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  eval "$as_ac_var=yes"
+  ac_cv_search_rresvport_af="-l$ac_lib"
+break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-eval "$as_ac_var=no"
 fi
 rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
+  done
 fi
-echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
-if test `eval echo '${'$as_ac_var'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+LIBS=$ac_func_search_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_search_rresvport_af" >&5
+echo "${ECHO_T}$ac_cv_search_rresvport_af" >&6
+if test "$ac_cv_search_rresvport_af" != no; then
+  test "$ac_cv_search_rresvport_af" = "none required" || LIBS="$ac_cv_search_rresvport_af $LIBS"
+  cat >>confdefs.h <<\_ACEOF
+#define HAVE_RRESVPORT_AF 1
 _ACEOF
 
 fi
-done
 
 
 echo "$as_me:$LINENO: checking for struct sockaddr.sa_len" >&5
@@ -9241,8 +9794,6 @@
 
 
 
-
-
 if test "$uname" = "SunOS"; then
 	case "$uversion" in
 		55* | 56*)
@@ -9270,11 +9821,6 @@
 
 CUPS_DEFAULT_DOMAINSOCKET=""
 
-# Check whether --enable-domainsocket or --disable-domainsocket was given.
-if test "${enable_domainsocket+set}" = set; then
-  enableval="$enable_domainsocket"
-
-fi;
 
 # Check whether --with-domainsocket or --without-domainsocket was given.
 if test "${with_domainsocket+set}" = set; then
@@ -9284,23 +9830,32 @@
   default_domainsocket=""
 fi;
 
-if test x$enable_domainsocket != xno; then
+if test x$enable_domainsocket != xno -a x$default_domainsocket != xno; then
 	if test "x$default_domainsocket" = x; then
-		CUPS_DEFAULT_DOMAINSOCKET="$CUPS_STATEDIR/cups.sock"
+		case "$uname" in
+			Darwin*)
+				# Darwin and MaxOS X do their own thing...
+				CUPS_DEFAULT_DOMAINSOCKET="$localstatedir/run/cupsd"
+				;;
+			*)
+				# All others use FHS standard...
+				CUPS_DEFAULT_DOMAINSOCKET="$CUPS_STATEDIR/cups.sock"
+				;;
+		esac
 	else
 		CUPS_DEFAULT_DOMAINSOCKET="$default_domainsocket"
 	fi
 
 	CUPS_LISTEN_DOMAINSOCKET="Listen $CUPS_DEFAULT_DOMAINSOCKET"
-else
-	CUPS_DEFAULT_DOMAINSOCKET=""
-	CUPS_LISTEN_DOMAINSOCKET=""
-fi
 
-cat >>confdefs.h <<_ACEOF
+	cat >>confdefs.h <<_ACEOF
 #define CUPS_DEFAULT_DOMAINSOCKET "$CUPS_DEFAULT_DOMAINSOCKET"
 _ACEOF
 
+else
+	CUPS_LISTEN_DOMAINSOCKET=""
+fi
+
 
 
 
@@ -9881,14 +10436,13 @@
 if test $ac_cv_header_gnutls_gnutls_h = yes; then
   	    	    SAVELIBS="$LIBS"
 
-	    TEST_GNUTLS_LIBS=`libgnutls-config --libs`
 	    echo "$as_me:$LINENO: checking for gnutls_init in -lgnutls" >&5
 echo $ECHO_N "checking for gnutls_init in -lgnutls... $ECHO_C" >&6
 if test "${ac_cv_lib_gnutls_gnutls_init+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lgnutls $TEST_GNUTLS_LIBS $LIBS"
+LIBS="-lgnutls  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -9946,7 +10500,7 @@
 echo "$as_me:$LINENO: result: $ac_cv_lib_gnutls_gnutls_init" >&5
 echo "${ECHO_T}$ac_cv_lib_gnutls_gnutls_init" >&6
 if test $ac_cv_lib_gnutls_gnutls_init = yes; then
-  SSLLIBS=$TEST_GNUTLS_LIBS
+  SSLLIBS="-lgnutls"
 		 cat >>confdefs.h <<\_ACEOF
 #define HAVE_SSL 1
 _ACEOF
@@ -10720,7 +11274,8 @@
 fi
 
 
-	echo "$as_me:$LINENO: checking for pthread_create in -lpthread" >&5
+
+echo "$as_me:$LINENO: checking for pthread_create in -lpthread" >&5
 echo $ECHO_N "checking for pthread_create in -lpthread... $ECHO_C" >&6
 if test "${ac_cv_lib_pthread_pthread_create+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
@@ -10784,7 +11339,12 @@
 echo "$as_me:$LINENO: result: $ac_cv_lib_pthread_pthread_create" >&5
 echo "${ECHO_T}$ac_cv_lib_pthread_pthread_create" >&6
 if test $ac_cv_lib_pthread_pthread_create = yes; then
-  COMMONLIBS="-lpthread $COMMONLIBS"
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBPTHREAD 1
+_ACEOF
+
+  LIBS="-lpthread $LIBS"
+
 fi
 
 
@@ -10831,16 +11391,15 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  COMMONLIBS="-pthread $COMMONLIBS"
-        		have_pthread=yes
+  have_pthread=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
+LIBS="$SAVELIBS"
 fi
 rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
-		LIBS="$SAVELIBS"
         	echo "$as_me:$LINENO: result: $have_pthread" >&5
 echo "${ECHO_T}$have_pthread" >&6
 	fi
@@ -11647,7 +12206,7 @@
 
 
 
-                                                                                          ac_config_files="$ac_config_files Makedefs cups.list cups.sh cups.spec cups-config conf/cupsd.conf conf/pam.std doc/index.html templates/edit-config.tmpl"
+                                                                                ac_config_files="$ac_config_files Makedefs packaging/cups.list cups.sh cups-config conf/cupsd.conf conf/pam.std doc/index.html templates/edit-config.tmpl"
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
 # tests run on this system so they can be shared between configure
@@ -12174,9 +12733,8 @@
   case "$ac_config_target" in
   # Handling of arguments.
   "Makedefs" ) CONFIG_FILES="$CONFIG_FILES Makedefs" ;;
-  "cups.list" ) CONFIG_FILES="$CONFIG_FILES cups.list" ;;
+  "packaging/cups.list" ) CONFIG_FILES="$CONFIG_FILES packaging/cups.list" ;;
   "cups.sh" ) CONFIG_FILES="$CONFIG_FILES cups.sh" ;;
-  "cups.spec" ) CONFIG_FILES="$CONFIG_FILES cups.spec" ;;
   "cups-config" ) CONFIG_FILES="$CONFIG_FILES cups-config" ;;
   "conf/cupsd.conf" ) CONFIG_FILES="$CONFIG_FILES conf/cupsd.conf" ;;
   "conf/pam.std" ) CONFIG_FILES="$CONFIG_FILES conf/pam.std" ;;
@@ -12291,8 +12849,6 @@
 s,@HTMLDOC@,$HTMLDOC,;t t
 s,@LN@,$LN,;t t
 s,@MV@,$MV,;t t
-s,@NROFF@,$NROFF,;t t
-s,@GROFF@,$GROFF,;t t
 s,@RM@,$RM,;t t
 s,@SED@,$SED,;t t
 s,@STRIP@,$STRIP,;t t
@@ -12301,7 +12857,6 @@
 s,@EGREP@,$EGREP,;t t
 s,@ARFLAGS@,$ARFLAGS,;t t
 s,@BACKLIBS@,$BACKLIBS,;t t
-s,@COMMONLIBS@,$COMMONLIBS,;t t
 s,@DEFAULT_IPP_PORT@,$DEFAULT_IPP_PORT,;t t
 s,@INITDIR@,$INITDIR,;t t
 s,@INITDDIR@,$INITDDIR,;t t
@@ -12318,10 +12873,8 @@
 s,@CUPS_STATEDIR@,$CUPS_STATEDIR,;t t
 s,@AMANDIR@,$AMANDIR,;t t
 s,@PMANDIR@,$PMANDIR,;t t
-s,@CAT1EXT@,$CAT1EXT,;t t
-s,@CAT3EXT@,$CAT3EXT,;t t
-s,@CAT5EXT@,$CAT5EXT,;t t
-s,@CAT8EXT@,$CAT8EXT,;t t
+s,@MAN1EXT@,$MAN1EXT,;t t
+s,@MAN5EXT@,$MAN5EXT,;t t
 s,@MAN8EXT@,$MAN8EXT,;t t
 s,@MAN8DIR@,$MAN8DIR,;t t
 s,@DSO@,$DSO,;t t
@@ -12344,7 +12897,6 @@
 s,@EXPORT_LIBPNG@,$EXPORT_LIBPNG,;t t
 s,@EXPORT_LIBTIFF@,$EXPORT_LIBTIFF,;t t
 s,@EXPORT_LIBZ@,$EXPORT_LIBZ,;t t
-s,@NETLIBS@,$NETLIBS,;t t
 s,@CUPS_LISTEN_DOMAINSOCKET@,$CUPS_LISTEN_DOMAINSOCKET,;t t
 s,@LIBSLP@,$LIBSLP,;t t
 s,@SSLFLAGS@,$SSLFLAGS,;t t
diff -urNad cupsys-1.1.99.b1.r4748~/configure.in cupsys-1.1.99.b1.r4748/configure.in
--- cupsys-1.1.99.b1.r4748~/configure.in	2005-10-01 06:45:34.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/configure.in	2005-11-13 07:00:16.644476000 +0900
@@ -1,5 +1,5 @@
 dnl
-dnl "$Id: configure.in 4730 2005-09-30 21:45:34Z mike $"
+dnl "$Id: configure.in 4835 2005-11-12 22:00:16Z mike $"
 dnl
 dnl   Configuration script for the Common UNIX Printing System (CUPS).
 dnl
@@ -46,11 +46,12 @@
 
 sinclude(config-scripts/cups-scripting.m4)
 
-AC_OUTPUT(Makedefs cups.list cups.sh cups.spec cups-config conf/cupsd.conf 
-          conf/pam.std doc/index.html templates/edit-config.tmpl)
+AC_OUTPUT(Makedefs packaging/cups.list cups.sh cups-config
+          conf/cupsd.conf conf/pam.std doc/index.html
+	  templates/edit-config.tmpl)
 
 chmod +x cups-config
 
 dnl
-dnl End of "$Id: configure.in 4730 2005-09-30 21:45:34Z mike $".
+dnl End of "$Id: configure.in 4835 2005-11-12 22:00:16Z mike $".
 dnl
diff -urNad cupsys-1.1.99.b1.r4748~/cups/Dependencies cupsys-1.1.99.b1.r4748/cups/Dependencies
--- cupsys-1.1.99.b1.r4748~/cups/Dependencies	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/Dependencies	2005-10-19 06:09:12.681329000 +0900
@@ -1,6 +1,6 @@
 # DO NOT DELETE
 
-array.o: array.h string.h ../config.h
+array.o: array.h string.h ../config.h debug.h
 attr.o: ppd.h file.h debug.h string.h ../config.h
 auth.o: cups.h ipp.h http.h string.h ../config.h md5.h ppd.h file.h
 auth.o: language.h debug.h
@@ -10,19 +10,23 @@
 dir.o: dir.h string.h ../config.h debug.h
 emit.o: ppd.h file.h string.h ../config.h
 encode.o: cups.h ipp.h http.h string.h ../config.h md5.h ppd.h file.h debug.h
-file.o: string.h ../config.h ../cups/debug.h file.h http-private.h http.h
-file.o: md5.h
+file.o: http-private.h ../config.h http.h string.h md5.h ../cups/debug.h
+file.o: file.h
 getputfile.o: cups.h ipp.h http.h string.h ../config.h md5.h ppd.h file.h
 getputfile.o: language.h debug.h
-globals.o: globals.h string.h ../config.h cups.h ipp.h http.h md5.h ppd.h
-globals.o: file.h language.h normalize.h transcode.h http-private.h
+globals.o: http-private.h ../config.h http.h string.h md5.h globals.h cups.h
+globals.o: ipp.h ppd.h file.h language.h normalize.h transcode.h
 http.o: http-private.h ../config.h http.h string.h md5.h globals.h cups.h
 http.o: ipp.h ppd.h file.h language.h normalize.h transcode.h debug.h
 http-addr.o: globals.h string.h ../config.h cups.h ipp.h http.h md5.h ppd.h
 http-addr.o: file.h language.h normalize.h transcode.h debug.h
-http-support.o: string.h ../config.h http.h md5.h ipp.h
-ipp.o: globals.h string.h ../config.h cups.h ipp.h http.h md5.h ppd.h file.h
-ipp.o: language.h normalize.h transcode.h debug.h
+http-addrlist.o: http-private.h ../config.h http.h string.h md5.h globals.h
+http-addrlist.o: cups.h ipp.h ppd.h file.h language.h normalize.h transcode.h
+http-addrlist.o: debug.h
+http-support.o: debug.h globals.h string.h ../config.h cups.h ipp.h http.h
+http-support.o: md5.h ppd.h file.h language.h normalize.h transcode.h
+ipp.o: http-private.h ../config.h http.h string.h md5.h globals.h cups.h
+ipp.o: ipp.h ppd.h file.h language.h normalize.h transcode.h debug.h
 ipp-support.o: globals.h string.h ../config.h cups.h ipp.h http.h md5.h ppd.h
 ipp-support.o: file.h language.h normalize.h transcode.h debug.h
 langprintf.o: string.h ../config.h language.h transcode.h
@@ -48,7 +52,8 @@
 usersys.o: ipp.h ppd.h file.h language.h normalize.h transcode.h
 util.o: globals.h string.h ../config.h cups.h ipp.h http.h md5.h ppd.h file.h
 util.o: language.h normalize.h transcode.h debug.h
-testarray.o: ../cups/string.h ../config.h string.h ipp.h http.h md5.h
+testarray.o: ../cups/string.h ../config.h string.h array.h dir.h debug.h
+testfile.o: string.h ../config.h file.h debug.h
 testhttp.o: http.h string.h ../config.h md5.h
 testi18n.o: language.h string.h ../config.h transcode.h normalize.h
 testipp.o: ../cups/string.h ../config.h string.h ipp.h http.h md5.h
diff -urNad cupsys-1.1.99.b1.r4748~/cups/Makefile cupsys-1.1.99.b1.r4748/cups/Makefile
--- cupsys-1.1.99.b1.r4748~/cups/Makefile	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/Makefile	2005-10-19 06:09:12.681329000 +0900
@@ -1,5 +1,5 @@
 #
-# "$Id: Makefile 4725 2005-09-29 21:09:46Z mike $"
+# "$Id: Makefile 4801 2005-10-18 21:09:12Z mike $"
 #
 #   API library Makefile for the Common UNIX Printing System (CUPS).
 #
@@ -44,6 +44,7 @@
 		globals.o \
 		http.o \
 		http-addr.o \
+		http-addrlist.o \
 		http-support.o \
 		ipp.o \
 		ipp-support.o \
@@ -65,6 +66,7 @@
 OBJS	=	\
 		$(LIBOBJS) \
 		testarray.o \
+		testfile.o \
 		testhttp.o \
 		testi18n.o \
 		testipp.o \
@@ -98,6 +100,7 @@
 		$(LIBCUPS) \
 		libcups.a \
 		testarray \
+		testfile \
 		testhttp \
 		testi18n \
 		testipp \
@@ -191,7 +194,8 @@
 	(echo _ipp_add_attr; echo _ipp_free_attr; \
 	 echo _cups_hstrerror; echo _cups_md5_init; \
 	 echo _cups_md5_append; echo _cups_md5_finish; \
-	 echo _cups_strlcat; echo _cups_strlcpy) >libcups_s.exp
+	 echo _cups_strlcat; echo _cups_strlcpy; \
+	 echo _httpReadCDSA; echo _httpWriteCDSA) >libcups_s.exp
 	$(DSO) $(DSOFLAGS) -Wl,-bexport:libcups_s.exp -o libcups_s.o $(LIBOBJS) $(SSLLIBS) $(COMMONLIBS) $(LIBZ) -lm
 	$(RM) $@
 	$(AR) $(ARFLAGS) $@ libcups_s.o
@@ -256,7 +260,17 @@
 testarray:	testarray.o libcups.a
 	echo Linking $@...
 	$(CC) $(LDFLAGS) -o $@ testarray.o libcups.a \
-		$(NETLIBS) $(SSLLIBS) $(COMMONLIBS) $(LIBZ)
+		$(SSLLIBS) $(COMMONLIBS) $(LIBZ)
+
+
+#
+# testfile (dependency on static CUPS library is intentional)
+#
+
+testfile:	testfile.o libcups.a
+	echo Linking $@...
+	$(CC) $(LDFLAGS) -o $@ testfile.o libcups.a \
+		$(SSLLIBS) $(COMMONLIBS) $(LIBZ)
 
 
 #
@@ -266,7 +280,7 @@
 testhttp:	testhttp.o libcups.a
 	echo Linking $@...
 	$(CC) $(LDFLAGS) -o $@ testhttp.o libcups.a \
-		$(NETLIBS) $(SSLLIBS) $(COMMONLIBS) $(LIBZ)
+		$(SSLLIBS) $(COMMONLIBS) $(LIBZ)
 
 
 #
@@ -276,7 +290,7 @@
 testipp:	testipp.o libcups.a
 	echo Linking $@...
 	$(CC) $(LDFLAGS) -o $@ testipp.o libcups.a \
-		$(NETLIBS) $(SSLLIBS) $(COMMONLIBS) $(LIBZ)
+		$(SSLLIBS) $(COMMONLIBS) $(LIBZ)
 
 
 #
@@ -286,7 +300,7 @@
 testi18n:	testi18n.o libcups.a
 	echo Linking $@...
 	$(CC) $(LDFLAGS) -o $@ testi18n.o libcups.a \
-		$(NETLIBS) $(SSLLIBS) $(COMMONLIBS) $(LIBZ)
+		$(SSLLIBS) $(COMMONLIBS) $(LIBZ)
 
 
 #
@@ -296,7 +310,7 @@
 testlang:	testlang.o libcups.a
 	echo Linking $@...
 	$(CC) $(LDFLAGS) -o $@ testlang.o libcups.a \
-		$(NETLIBS) $(SSLLIBS) $(COMMONLIBS) $(LIBZ)
+		$(SSLLIBS) $(COMMONLIBS) $(LIBZ)
 
 
 #
@@ -323,5 +337,5 @@
 
 
 #
-# End of "$Id: Makefile 4725 2005-09-29 21:09:46Z mike $".
+# End of "$Id: Makefile 4801 2005-10-18 21:09:12Z mike $".
 #
diff -urNad cupsys-1.1.99.b1.r4748~/cups/array.c cupsys-1.1.99.b1.r4748/cups/array.c
--- cupsys-1.1.99.b1.r4748~/cups/array.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/array.c	2005-11-01 05:40:17.608247000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: array.c 4744 2005-10-03 01:32:35Z mike $"
+ * "$Id: array.c 4815 2005-10-31 20:40:17Z mike $"
  *
  *   Sorted array routines for the Common UNIX Printing System (CUPS).
  *
@@ -38,6 +38,9 @@
  *   cupsArrayNext()    - Get the next element in the array.
  *   cupsArrayPrev()    - Get the previous element in the array.
  *   cupsArrayRemove()  - Remove an element from the array.
+ *   cupsArrayRestore() - Reset the current element to the last cupsArraySave.
+ *   cupsArraySave()    - Mark the current element for a later cupsArrayRestore.
+ *   cups_find()        - Find an element in the array...
  */
 
 /*
@@ -610,6 +613,34 @@
 
 
 /*
+ * 'cupsArrayRestore()' - Reset the current element to the last cupsArraySave.
+ */
+
+void *					/* O - New current element */
+cupsArrayRestore(cups_array_t *a)	/* I - Array */
+{
+  a->current = a->saved;
+  a->saved   = -1;
+
+  if (a->current >= 0 && a->current < a->num_elements)
+    return (a->elements[a->current]);
+  else
+    return (NULL);
+}
+
+
+/*
+ * 'cupsArraySave()' - Mark the current element for a later cupsArrayRestore.
+ */
+
+void
+cupsArraySave(cups_array_t *a)		/* I - Array */
+{
+  a->saved = a->current;
+}
+
+
+/*
  * 'cups_find()' - Find an element in the array...
  */
 
@@ -745,33 +776,5 @@
 
 
 /*
- * 'cupsArrayRestore()' - Reset the current element to the last cupsArraySave.
- */
-
-void *					/* O - New current element */
-cupsArrayRestore(cups_array_t *a)	/* I - Array */
-{
-  a->current = a->saved;
-  a->saved   = -1;
-
-  if (a->current >= 0 && a->current < a->num_elements)
-    return (a->elements[a->current]);
-  else
-    return (NULL);
-}
-
-
-/*
- * 'cupsArraySave()' - Mark the current element for a later cupsArrayRestore.
- */
-
-void
-cupsArraySave(cups_array_t *a)		/* I - Array */
-{
-  a->saved = a->current;
-}
-
-
-/*
- * End of "$Id: array.c 4744 2005-10-03 01:32:35Z mike $".
+ * End of "$Id: array.c 4815 2005-10-31 20:40:17Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/attr.c cupsys-1.1.99.b1.r4748/cups/attr.c
--- cupsys-1.1.99.b1.r4748~/cups/attr.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/attr.c	2005-10-14 04:39:05.160337000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: attr.c 4494 2005-02-18 02:18:11Z mike $"
+ * "$Id: attr.c 4785 2005-10-13 19:39:05Z mike $"
  *
  *   PPD model-specific attribute routines for the Common UNIX Printing System
  *   (CUPS).
@@ -47,6 +47,8 @@
 
 /*
  * 'ppdFindAttr()' - Find the first matching attribute...
+ *
+ * @since CUPS 1.1.19@
  */
 
 ppd_attr_t *			/* O - Attribute or NULL if not found */
@@ -117,6 +119,8 @@
 
 /*
  * 'ppdFindNextAttr()' - Find the next matching attribute...
+ *
+ * @since CUPS 1.1.19@
  */
 
 ppd_attr_t *				/* O - Attribute or NULL if not found */
@@ -176,5 +180,5 @@
 
 
 /*
- * End of "$Id: attr.c 4494 2005-02-18 02:18:11Z mike $".
+ * End of "$Id: attr.c 4785 2005-10-13 19:39:05Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/auth.c cupsys-1.1.99.b1.r4748/cups/auth.c
--- cupsys-1.1.99.b1.r4748~/cups/auth.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/auth.c	2005-10-15 06:35:46.754310000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: auth.c 4549 2005-06-27 02:59:29Z mike $"
+ * "$Id: auth.c 4796 2005-10-14 21:35:46Z mike $"
  *
  *   Authentication functions for the Common UNIX Printing System (CUPS).
  *
@@ -60,6 +60,8 @@
 
 /*
  * 'cupsDoAuthentication()' - Authenticate a request...
+ *
+ * @since CUPS 1.1.20@
  */
 
 int					/* O - 0 on success, -1 on error */
@@ -110,7 +112,7 @@
              http->hostname);
 
     http->digest_tries  = strncasecmp(http->fields[HTTP_FIELD_WWW_AUTHENTICATE],
-                                      "Basic", 5) == 0;
+                                      "Digest", 5) != 0;
     http->userpass[0]   = '\0';
 
     if ((password = cupsGetPassword(prompt)) == NULL)
@@ -129,7 +131,7 @@
   * Got a password; encode it for the server...
   */
 
-  if (strncmp(http->fields[HTTP_FIELD_WWW_AUTHENTICATE], "Basic", 5) == 0)
+  if (strncmp(http->fields[HTTP_FIELD_WWW_AUTHENTICATE], "Digest", 6))
   {
    /*
     * Basic authentication...
@@ -183,14 +185,14 @@
   const char	*state;			/* Server state directory */
 
 
-  DEBUG_printf(("cups_local_auth(http=%p) hostaddr=%08x, hostname=\"%s\"\n",
-                http, ntohl(http->hostaddr.sin_addr.s_addr), http->hostname));
+  DEBUG_printf(("cups_local_auth(http=%p) hostaddr=%s, hostname=\"%s\"\n",
+                http, httpAddrString(http->hostaddr, filename, sizeof(filename)), http->hostname));
 
  /*
   * See if we are accessing localhost...
   */
 
-  if (!httpAddrLocalhost(&http->hostaddr) &&
+  if (!httpAddrLocalhost(http->hostaddr) &&
       strcasecmp(http->hostname, "localhost") != 0)
   {
     DEBUG_puts("cups_local_auth: Not a local connection!");
@@ -245,5 +247,5 @@
 
 
 /*
- * End of "$Id: auth.c 4549 2005-06-27 02:59:29Z mike $".
+ * End of "$Id: auth.c 4796 2005-10-14 21:35:46Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/backchannel.c cupsys-1.1.99.b1.r4748/cups/backchannel.c
--- cupsys-1.1.99.b1.r4748~/cups/backchannel.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/backchannel.c	2005-11-11 21:53:38.810647000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: backchannel.c 4658 2005-09-17 03:48:43Z mike $"
+ * "$Id: backchannel.c 4828 2005-11-11 12:53:38Z mike $"
  *
  *   Backchannel functions for the Common UNIX Printing System (CUPS).
  *
@@ -25,6 +25,9 @@
  *
  * Contents:
  *
+ *   cupsBackChannelRead()  - Read data from the backchannel.
+ *   cupsBackChannelWrite() - Write data to the backchannel.
+ *   cups_setup()           - Setup select() 
  */
 
 /*
@@ -33,9 +36,12 @@
 
 #include "cups.h"
 #include <errno.h>
-#ifndef WIN32
+#ifdef WIN32
+#  include <io.h>
+#  include <fcntl.h>
+#else
 #  include <sys/time.h>
-#endif /* !WIN32 */
+#endif /* WIN32 */
 
 
 /*
@@ -53,6 +59,8 @@
  * parameter controls how many seconds to wait for the data - use
  * 0.0 to return immediately if there is no data, -1.0 to wait
  * for data indefinitely.
+ *
+ * @since CUPS 1.2@
  */
 
 int					/* O - Bytes read or -1 on error */
@@ -98,6 +106,8 @@
  * controls how many seconds to wait for the data to be written - use
  * 0.0 to return immediately if the data cannot be written, -1.0 to wait
  * indefinitely.
+ *
+ * @since CUPS 1.2@
  */
 
 int					/* O - Bytes written or -1 on error */
@@ -187,5 +197,5 @@
 
 
 /*
- * End of "$Id: backchannel.c 4658 2005-09-17 03:48:43Z mike $".
+ * End of "$Id: backchannel.c 4828 2005-11-11 12:53:38Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/cups.dsp cupsys-1.1.99.b1.r4748/cups/cups.dsp
--- cupsys-1.1.99.b1.r4748~/cups/cups.dsp	2003-11-06 04:11:54.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/cups.dsp	1970-01-01 09:00:00.000000000 +0900
@@ -1,220 +0,0 @@
-# Microsoft Developer Studio Project File - Name="cups" - Package Owner=<4>
-# Microsoft Developer Studio Generated Build File, Format Version 6.00
-# ** DO NOT EDIT **
-
-# TARGTYPE "Win32 (x86) Static Library" 0x0104
-
-CFG=cups - Win32 Debug
-!MESSAGE This is not a valid makefile. To build this project using NMAKE,
-!MESSAGE use the Export Makefile command and run
-!MESSAGE 
-!MESSAGE NMAKE /f "cups.mak".
-!MESSAGE 
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f "cups.mak" CFG="cups - Win32 Debug"
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE "cups - Win32 Release" (based on "Win32 (x86) Static Library")
-!MESSAGE "cups - Win32 Debug" (based on "Win32 (x86) Static Library")
-!MESSAGE 
-
-# Begin Project
-# PROP AllowPerConfigDependencies 0
-# PROP Scc_ProjName ""
-# PROP Scc_LocalPath ""
-CPP=cl.exe
-RSC=rc.exe
-
-!IF  "$(CFG)" == "cups - Win32 Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "Release"
-# PROP BASE Intermediate_Dir "Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Release"
-# PROP Intermediate_Dir "Release"
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
-# ADD CPP /nologo /MD /W3 /GX /O2 /I "../visualc" /I ".." /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
-# ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LIB32=link.exe -lib
-# ADD BASE LIB32 /nologo
-# ADD LIB32 /nologo /out:"cups.lib"
-
-!ELSEIF  "$(CFG)" == "cups - Win32 Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "Debug"
-# PROP BASE Intermediate_Dir "Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Debug"
-# PROP Intermediate_Dir "Debug"
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
-# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I "../visualc" /I ".." /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
-# ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LIB32=link.exe -lib
-# ADD BASE LIB32 /nologo
-# ADD LIB32 /nologo /out:"cupsd.lib"
-
-!ENDIF 
-
-# Begin Target
-
-# Name "cups - Win32 Release"
-# Name "cups - Win32 Debug"
-# Begin Group "Source Files"
-
-# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-# Begin Source File
-
-SOURCE=.\auth.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\dest.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\emit.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\encode.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\getputfile.c
-# End Source File
-# Begin Source File
-
-SOURCE=".\http-addr.c"
-# End Source File
-# Begin Source File
-
-SOURCE=".\http-support.c"
-# End Source File
-# Begin Source File
-
-SOURCE=.\http.c
-# End Source File
-# Begin Source File
-
-SOURCE=".\ipp-support.c"
-# End Source File
-# Begin Source File
-
-SOURCE=.\ipp.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\language.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\mark.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\md5.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\md5passwd.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\options.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\page.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\ppd.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\snprintf.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\string.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\tempfile.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\usersys.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\util.c
-# End Source File
-# End Group
-# Begin Group "Header Files"
-
-# PROP Default_Filter "h;hpp;hxx;hm;inl"
-# Begin Source File
-
-SOURCE=.\cups.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\cups_C.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\debug.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\http.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\ipp.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\language.h
-# End Source File
-# Begin Source File
-
-SOURCE=..\oemlicense\license.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\md5.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\ppd.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\string.h
-# End Source File
-# End Group
-# End Target
-# End Project
diff -urNad cupsys-1.1.99.b1.r4748~/cups/cups.h cupsys-1.1.99.b1.r4748/cups/cups.h
--- cupsys-1.1.99.b1.r4748~/cups/cups.h	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/cups.h	2005-10-14 04:39:05.160337000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: cups.h 4703 2005-09-26 19:33:58Z mike $"
+ * "$Id: cups.h 4785 2005-10-13 19:39:05Z mike $"
  *
  *   API definitions for the Common UNIX Printing System (CUPS).
  *
@@ -83,9 +83,9 @@
   CUPS_PRINTER_DEFAULT = 0x20000,	/* Default printer on network */
   CUPS_PRINTER_FAX = 0x40000,		/* Fax queue */
   CUPS_PRINTER_REJECTING = 0x80000,	/* Printer is rejecting jobs */
-  CUPS_PRINTER_DELETE = 0x100000,	/* Delete printer */
-  CUPS_PRINTER_NOT_SHARED = 0x200000,	/* Printer is not shared */
-  CUPS_PRINTER_AUTHENTICATED = 0x400000,/* Printer requires authentication */
+  CUPS_PRINTER_DELETE = 0x100000,	/* Delete printer @since CUPS 1.2@ */
+  CUPS_PRINTER_NOT_SHARED = 0x200000,	/* Printer is not shared @since CUPS 1.2@ */
+  CUPS_PRINTER_AUTHENTICATED = 0x400000,/* Printer requires authentication @since CUPS 1.2@ */
   CUPS_PRINTER_OPTIONS = 0x66fffc	/* ~(CLASS | REMOTE | IMPLICIT) */
 };
 
@@ -219,5 +219,5 @@
 #endif /* !_CUPS_CUPS_H_ */
 
 /*
- * End of "$Id: cups.h 4703 2005-09-26 19:33:58Z mike $".
+ * End of "$Id: cups.h 4785 2005-10-13 19:39:05Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/dest.c cupsys-1.1.99.b1.r4748/cups/dest.c
--- cupsys-1.1.99.b1.r4748~/cups/dest.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/dest.c	2005-10-14 04:39:05.160337000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: dest.c 4494 2005-02-18 02:18:11Z mike $"
+ * "$Id: dest.c 4785 2005-10-13 19:39:05Z mike $"
  *
  *   User-defined destination (and option) support for the Common UNIX
  *   Printing System (CUPS).
@@ -32,6 +32,7 @@
  *   cupsGetDests()    - Get the list of destinations.
  *   cupsGetDests2()   - Get the list of destinations using a HTTP connection.
  *   cupsSetDests()    - Set the list of destinations.
+ *   cupsSetDests2()   - Set the list of destinations.
  *   cups_get_dests()  - Get destinations from a file.
  *   cups_get_sdests() - Get destinations from a server.
  */
@@ -231,6 +232,8 @@
 
 /*
  * 'cupsGetDests2()' - Get the list of destinations.
+ *
+ * @since CUPS 1.1.21@
  */
 
 int					/* O - Number of destinations */
@@ -415,7 +418,9 @@
 
 
 /*
- * 'cupsSetDests()' - Set the list of destinations.
+ * 'cupsSetDests2()' - Set the list of destinations.
+ *
+ * @since CUPS 1.1.21@
  */
 
 int					/* O - 0 on success, -1 on error */
@@ -852,5 +857,5 @@
 
 
 /*
- * End of "$Id: dest.c 4494 2005-02-18 02:18:11Z mike $".
+ * End of "$Id: dest.c 4785 2005-10-13 19:39:05Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/dir.c cupsys-1.1.99.b1.r4748/cups/dir.c
--- cupsys-1.1.99.b1.r4748~/cups/dir.c	2005-11-13 13:59:11.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/dir.c	2005-11-11 21:53:38.810647000 +0900
@@ -82,8 +82,8 @@
   * between them...
   */
 
-  val = ft.dwLowDateTime + ft.dwHighDateTime << 32;
-  return (val / 10000000 - 11644732800);
+  val = ft.dwLowDateTime + (ft.dwHighDateTime << 32);
+  return ((time_t)(val / 10000000 - 11644732800));
 }
 
 
@@ -98,7 +98,7 @@
   * Range check input...
   */
 
-  if (!directory)
+  if (!dp)
     return;
 
  /*
@@ -198,14 +198,14 @@
   strlcpy(dp->entry.filename, entry.cFileName, sizeof(dp->entry.filename));
 
   if (entry.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
-    dp->entry.st_mode = 0755 | S_IFDIR;
+    dp->entry.fileinfo.st_mode = 0755 | S_IFDIR;
   else
-    dp->entry.st_mode = 0644;
+    dp->entry.fileinfo.st_mode = 0644;
 
-  dp->entry.st_atime = _cups_dir_time(entry.ftLastAccessTime);
-  dp->entry.st_ctime = _cups_dir_time(entry.ftCreationTime);
-  dp->entry.st_mtime = _cups_dir_time(entry.ftLastWriteTime);
-  dp->entry.st_size  = entry.nFileSizeLow + entry.nFileSizeHigh << 32;
+  dp->entry.fileinfo.st_atime = _cups_dir_time(entry.ftLastAccessTime);
+  dp->entry.fileinfo.st_ctime = _cups_dir_time(entry.ftCreationTime);
+  dp->entry.fileinfo.st_mtime = _cups_dir_time(entry.ftLastWriteTime);
+  dp->entry.fileinfo.st_size  = entry.nFileSizeLow + (entry.nFileSizeHigh << 32);
 
  /*
   * Return the entry...
diff -urNad cupsys-1.1.99.b1.r4748~/cups/emit.c cupsys-1.1.99.b1.r4748/cups/emit.c
--- cupsys-1.1.99.b1.r4748~/cups/emit.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/emit.c	2005-10-14 04:39:05.160337000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: emit.c 4680 2005-09-21 09:28:39Z mike $"
+ * "$Id: emit.c 4785 2005-10-13 19:39:05Z mike $"
  *
  *   PPD code emission routines for the Common UNIX Printing System (CUPS).
  *
@@ -657,6 +657,8 @@
 
 /*
  * 'ppdEmitJCLEnd()' - Emit JCLEnd code to a file.
+ *
+ * @since CUPS 1.2@
  */
 
 int					/* O - 0 on success, -1 on failure */
@@ -810,5 +812,5 @@
 
 
 /*
- * End of "$Id: emit.c 4680 2005-09-21 09:28:39Z mike $".
+ * End of "$Id: emit.c 4785 2005-10-13 19:39:05Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/encode.c cupsys-1.1.99.b1.r4748/cups/encode.c
--- cupsys-1.1.99.b1.r4748~/cups/encode.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/encode.c	2005-10-14 04:39:05.160337000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: encode.c 4683 2005-09-21 22:17:44Z mike $"
+ * "$Id: encode.c 4785 2005-10-13 19:39:05Z mike $"
  *
  *   Option encoding routines for the Common UNIX Printing System (CUPS).
  *
@@ -123,6 +123,8 @@
 
 /*
  * 'cupsEncodeOptions2()' - Encode printer options into IPP attributes for a group.
+ *
+ * @since CUPS 1.2@
  */
 
 void
@@ -457,5 +459,5 @@
 
 
 /*
- * End of "$Id: encode.c 4683 2005-09-21 22:17:44Z mike $".
+ * End of "$Id: encode.c 4785 2005-10-13 19:39:05Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/file.c cupsys-1.1.99.b1.r4748/cups/file.c
--- cupsys-1.1.99.b1.r4748~/cups/file.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/file.c	2005-11-13 06:46:52.687523000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: file.c 4683 2005-09-21 22:17:44Z mike $"
+ * "$Id: file.c 4833 2005-11-12 21:46:52Z mike $"
  *
  *   File functions for the Common UNIX Printing System (CUPS).
  *
@@ -49,6 +49,7 @@
  *   cupsFileTell()        - Return the current file position.
  *   cupsFileUnlock()      - Unlock access to a file.
  *   cupsFileWrite()       - Write to a file.
+ *   cups_compress()       - Compress a buffer of data...
  *   cups_fill()           - Fill the input buffer...
  *   cups_read()           - Read from a file descriptor.
  *   cups_write()          - Write to a file descriptor.
@@ -61,31 +62,36 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdarg.h>
+#include "http-private.h"
 #include "string.h"
 #include <errno.h>
 #include <cups/debug.h>
 #include <sys/types.h>
-
-#ifdef WIN32
-#  include <io.h>
-#  include <winsock2.h>
-#else
-#  include <unistd.h>
-#  include <fcntl.h>
-#  include <sys/socket.h>
-#  define closesocket(f) close(f)
-#endif /* WIN32 */
+#include <fcntl.h>
 
 #include "file.h"
 #ifdef HAVE_LIBZ
 #  include <zlib.h>
 #endif /* HAVE_LIBZ */
-#include "http-private.h"
+#ifdef WIN32
+#  include <io.h>
+#  include <sys/locking.h>
+#endif /* WIN32 */
+
+
+/*
+ * Some operating systems support large files via open flag O_LARGEFILE...
+ */
+
+#ifndef O_LARGEFILE
+#  define O_LARGEFILE
+#endif /* !O_LARGEFILE */
 
 
 /*
  * Types and structures...
  */
+
 struct _cups_file_s			/**** CUPS file structure... ****/
 
 {
@@ -98,10 +104,11 @@
 		*end;			/* End of buffer data */
   off_t		pos;			/* File position for start of buffer */
 
-#  ifdef HAVE_LIBZ
-  z_stream	stream;			/* Decompression stream */
-  unsigned char	cbuf[1024];		/* Decompression buffer */
-#  endif /* HAVE_LIBZ */
+#ifdef HAVE_LIBZ
+  z_stream	stream;			/* (De)compression stream */
+  Bytef		cbuf[1024];		/* (De)compression buffer */
+  uLong		crc;			/* (De)compression CRC */
+#endif /* HAVE_LIBZ */
 };
 
 
@@ -109,6 +116,9 @@
  * Local functions...
  */
 
+#ifdef HAVE_LIBZ
+static ssize_t	cups_compress(cups_file_t *fp, const char *buf, size_t bytes);
+#endif /* HAVE_LIBZ */
 static ssize_t	cups_fill(cups_file_t *fp);
 static ssize_t	cups_read(cups_file_t *fp, char *buf, size_t bytes);
 static ssize_t	cups_write(cups_file_t *fp, const char *buf, size_t bytes);
@@ -123,6 +133,7 @@
 {
   int	fd;				/* File descriptor */
   char	mode;				/* Open mode */
+  int	status;				/* Return status */
 
 
   DEBUG_printf(("cupsFileClose(fp=%p)\n", fp));
@@ -134,17 +145,81 @@
   if (!fp)
     return (-1);
 
-#ifdef HAVE_LIBZ
  /*
-  * Free decompression data as needed...
+  * Flush pending write data...
   */
 
-  if (fp->compressed && fp->mode == 'r')
-    inflateEnd(&fp->stream);
-#endif /* HAVE_LIBZ */
-
   if (fp->mode == 'w')
-    cupsFileFlush(fp);
+    status = cupsFileFlush(fp);
+  else
+    status = 0;
+
+#ifdef HAVE_LIBZ
+  if (fp->compressed && status >= 0)
+  {
+    if (fp->mode == 'r')
+    {
+     /*
+      * Free decompression data...
+      */
+
+      inflateEnd(&fp->stream);
+    }
+    else
+    {
+     /*
+      * Flush any remaining compressed data...
+      */
+
+      unsigned char	trailer[8];	/* Trailer CRC and length */
+      int		done;		/* Done writing... */
+
+
+      fp->stream.avail_in = 0;
+
+      for (done = 0;;)
+      {
+        if (fp->stream.next_out > fp->cbuf)
+	{
+	  if (cups_write(fp, (char *)fp->cbuf,
+	                 fp->stream.next_out - fp->cbuf) < 0)
+	    status = -1;
+
+	  fp->stream.next_out  = fp->cbuf;
+	  fp->stream.avail_out = sizeof(fp->cbuf);
+	}
+
+        if (done || status < 0)
+	  break;
+
+        done = deflate(&fp->stream, Z_FINISH) == Z_STREAM_END &&
+	       fp->stream.next_out == fp->cbuf;
+      }
+
+     /*
+      * Write the CRC and length...
+      */
+
+      trailer[0] = fp->crc;
+      trailer[1] = fp->crc >> 8;
+      trailer[2] = fp->crc >> 16;
+      trailer[3] = fp->crc >> 24;
+      trailer[4] = fp->pos;
+      trailer[5] = fp->pos >> 8;
+      trailer[6] = fp->pos >> 16;
+      trailer[7] = fp->pos >> 24;
+
+      if (cups_write(fp, (char *)trailer, 8) < 0)
+        status = -1;
+
+     /*
+      * Free all memory used by the compression stream...
+      */
+
+      deflateEnd(&(fp->stream));
+    }
+  }
+#endif /* HAVE_LIBZ */
 
  /*
   * Save the file descriptor we used and free memory...
@@ -160,9 +235,17 @@
   */
 
   if (mode == 's')
-    return (closesocket(fd));
+  {
+    if (closesocket(fd) < 0)
+      status = -1;
+  }
   else
-    return (close(fd));
+  {
+    if (close(fd) < 0)
+      status = -1;
+  }
+
+  return (status);
 }
 
 
@@ -214,7 +297,14 @@
 
   if (bytes > 0)
   {
-    if (cups_write(fp, fp->buf, bytes) < bytes)
+#ifdef HAVE_LIBZ
+    if (fp->compressed)
+      bytes = cups_compress(fp, fp->buf, bytes);
+    else
+#endif /* HAVE_LIBZ */
+      bytes = cups_write(fp, fp->buf, bytes);
+
+    if (bytes < 0)
       return (-1);
 
     fp->ptr = fp->buf;
@@ -467,7 +557,11 @@
   * Try the lock...
   */
 
+#ifdef WIN32
+  return (locking(fp->fd, block ? _LK_LOCK : _LK_NBLCK, 0));
+#else
   return (lockf(fp->fd, block ? F_LOCK : F_TLOCK, 0));
+#endif /* WIN32 */
 }
 
 
@@ -493,13 +587,8 @@
   cups_file_t	*fp;			/* New CUPS file */
   int		fd;			/* File descriptor */
   char		hostname[1024],		/* Hostname */
-		portname[64];		/* Port "name" (number or service) */
-  int		port;			/* Port number */
-  struct servent *service;		/* Service */
-  int		i;			/* Looping var */
-  int		val;			/* Socket value */
-  struct hostent *hostaddr;		/* Host address data */
-  http_addr_t	sockaddr;		/* Socket address */
+		*portname;		/* Port "name" (number or service) */
+  http_addrlist_t *addrlist;		/* Host address list */
 
 
  /*
@@ -517,87 +606,42 @@
   switch (*mode)
   {
     case 'a' : /* Append file */
-        fd = open(filename, O_RDWR | O_CREAT | O_APPEND, 0666);
+        fd = open(filename, O_RDWR | O_CREAT | O_APPEND | O_LARGEFILE, 0666);
         break;
 
     case 'r' : /* Read file */
-	fd = open(filename, O_RDONLY, 0);
+	fd = open(filename, O_RDONLY | O_LARGEFILE, 0);
 	break;
 
     case 'w' : /* Write file */
-        fd = open(filename, O_WRONLY | O_TRUNC | O_CREAT, 0666);
+        fd = open(filename, O_WRONLY | O_TRUNC | O_CREAT | O_LARGEFILE, 0666);
         break;
 
     case 's' : /* Read/write socket */
-        if (sscanf(filename, "%1023[^:]:%63s", hostname, portname) != 2)
-	  return (NULL);
-
-        if ((hostaddr = httpGetHostByName(hostname)) == NULL)
-          return (NULL);
-
-        if (isdigit(portname[0] & 255))
-	  port = atoi(portname);
-	else if ((service = getservbyname(portname, NULL)) != NULL)
-	  port = ntohs(service->s_port);
+        strlcpy(hostname, filename, sizeof(hostname));
+	if ((portname = strrchr(hostname, ':')) != NULL)
+	  *portname++ = '\0';
 	else
 	  return (NULL);
 
-	for (i = 0, fd = -1; hostaddr->h_addr_list[i]; i ++)
-	{
-	 /*
-	  * Load the address...
-	  */
-
-	  httpAddrLoad(hostaddr, port, i, &sockaddr);
-
-	 /*
-	  * Create a socket...
-	  */
-
-	  if ((fd = socket(sockaddr.addr.sa_family, SOCK_STREAM, 0)) < 0)
-	    continue;
-
-	  val = 1;
-	  setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val));
-
-#ifdef SO_REUSEPORT
-	  val = 1;
-	  setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &val, sizeof(val));
-#endif /* SO_REUSEPORT */
-
-	 /*
-	  * Using TCP_NODELAY improves responsiveness, especially on systems
-	  * with a slow loopback interface...  Since we write large buffers
-	  * when sending print files and requests, there shouldn't be any
-	  * performance penalty for this...
-	  */
+       /*
+        * Lookup the hostname and service...
+	*/
 
-	  val = 1;
-	  setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &val, sizeof(val)); 
+        if ((addrlist = httpAddrGetList(hostname, AF_UNSPEC, portname)) == NULL)
+	  return (NULL);
 
-	 /*
-	  * Connect to the server...
-	  */
+       /*
+	* Connect to the server...
+	*/
 
-#ifdef AF_INET6
-	  if (sockaddr.addr.sa_family == AF_INET6)
-	  {
-	    if (connect(fd, (struct sockaddr *)&sockaddr,
-			sizeof(sockaddr.ipv6)) < 0)
-	    {
-	      fd = -1;
-	      continue;
-	    }
-	  }
-	  else
-#endif /* AF_INET6 */
-	  if (connect(fd, (struct sockaddr *)&sockaddr,
-		      sizeof(sockaddr.ipv4)) < 0)
-	  {
-	    fd = -1;
-	    continue;
-	  }
+        if (!httpAddrConnect(addrlist, &fd))
+	{
+	  httpAddrFreeList(addrlist);
+	  return (NULL);
 	}
+
+	httpAddrFreeList(addrlist);
 	break;
 
     default : /* Remove bogus compiler warning... */
@@ -656,11 +700,55 @@
   * Open the file...
   */
 
+  fp->fd = fd;
+
   switch (*mode)
   {
     case 'w' :
     case 'a' :
 	fp->mode = 'w';
+	fp->ptr  = fp->buf;
+	fp->end  = fp->buf + sizeof(fp->buf);
+
+#ifdef HAVE_LIBZ
+	if (mode[1] >= '1' && mode[1] <= '9')
+	{
+	 /*
+	  * Open a compressed stream, so write the standard gzip file
+	  * header...
+	  */
+
+          unsigned char header[10];	/* gzip file header */
+	  time_t	curtime;	/* Current time */
+
+
+          curtime   = time(NULL);
+	  header[0] = 0x1f;
+	  header[1] = 0x8b;
+	  header[2] = Z_DEFLATED;
+	  header[3] = 0;
+	  header[4] = curtime;
+	  header[5] = curtime >> 8;
+	  header[6] = curtime >> 16;
+	  header[7] = curtime >> 24;
+	  header[8] = 0;
+	  header[9] = 0x03;
+
+	  cups_write(fp, (char *)header, 10);
+
+         /*
+	  * Initialize the compressor...
+	  */
+
+          deflateInit2(&(fp->stream), mode[1] - '0', Z_DEFLATED, -15, 8,
+	               Z_DEFAULT_STRATEGY);
+
+	  fp->stream.next_out  = fp->cbuf;
+	  fp->stream.avail_out = sizeof(fp->cbuf);
+	  fp->compressed       = 1;
+	  fp->crc              = crc32(0L, Z_NULL, 0);
+	}
+#endif /* HAVE_LIBZ */
         break;
 
     case 'r' :
@@ -675,24 +763,13 @@
         return (NULL);
   }
 
-  fp->fd = fd;
-
  /*
   * Don't pass this file to child processes...
   */
 
+#ifndef WIN32
   fcntl(fp->fd, F_SETFD, fcntl(fp->fd, F_GETFD) | FD_CLOEXEC);
-
-  if (*mode == 'a')
-    fp->pos = lseek(fp->fd, 0, SEEK_END);
-  else
-    fp->pos = 0;
-
-  if (*mode != 'r' && *mode != 's')
-  {
-    fp->ptr = fp->buf;
-    fp->end = fp->buf + sizeof(fp->buf);
-  }
+#endif /* !WIN32 */
 
   return (fp);
 }
@@ -759,7 +836,14 @@
   fp->pos += bytes;
 
   if (bytes > sizeof(fp->buf))
-    return (cups_write(fp, buf, bytes));
+  {
+#ifdef HAVE_LIBZ
+    if (fp->compressed)
+      return (cups_compress(fp, buf, bytes));
+    else
+#endif /* HAVE_LIBZ */
+      return (cups_write(fp, buf, bytes));
+  }
   else
   {
     memcpy(fp->ptr, buf, bytes);
@@ -858,7 +942,14 @@
   fp->pos += bytes;
 
   if (bytes > sizeof(fp->buf))
-    return (cups_write(fp, s, bytes));
+  {
+#ifdef HAVE_LIBZ
+    if (fp->compressed)
+      return (cups_compress(fp, s, bytes));
+    else
+#endif /* HAVE_LIBZ */
+      return (cups_write(fp, s, bytes));
+  }
   else
   {
     memcpy(fp->ptr, s, bytes);
@@ -1079,7 +1170,11 @@
   * Unlock...
   */
 
+#ifdef WIN32
+  return (locking(fp->fd, _LK_UNLCK, 0));
+#else
   return (lockf(fp->fd, F_ULOCK, 0));
+#endif /* WIN32 */
 }
 
 
@@ -1123,7 +1218,14 @@
   fp->pos += bytes;
 
   if (bytes > sizeof(fp->buf))
-    return (cups_write(fp, buf, bytes));
+  {
+#ifdef HAVE_LIBZ
+    if (fp->compressed)
+      return (cups_compress(fp, buf, bytes));
+    else
+#endif /* HAVE_LIBZ */
+      return (cups_write(fp, buf, bytes));
+  }
   else
   {
     memcpy(fp->ptr, buf, bytes);
@@ -1133,6 +1235,49 @@
 }
 
 
+#ifdef HAVE_LIBZ
+/*
+ * 'cups_compress()' - Compress a buffer of data...
+ */
+
+static ssize_t				/* O - Number of bytes written or -1 */
+cups_compress(cups_file_t *fp,		/* I - CUPS file */
+              const char  *buf,		/* I - Buffer */
+	      size_t      bytes)	/* I - Number bytes */
+{
+ /*
+  * Update the CRC...
+  */
+
+  fp->crc = crc32(fp->crc, (const Bytef *)buf, bytes);
+
+ /*
+  * Deflate the bytes...
+  */
+
+  fp->stream.next_in  = (Bytef *)buf;
+  fp->stream.avail_in = bytes;
+
+  while (fp->stream.avail_in > 0)
+  {
+   /*
+    * Flush the current buffer...
+    */
+
+    if (fp->stream.avail_out < (int)(sizeof(fp->cbuf) / 8))
+    {
+      if (cups_write(fp, (char *)fp->cbuf, fp->stream.next_out - fp->cbuf) < 0)
+        return (-1);
+    }
+
+    deflate(&(fp->stream), Z_NO_FLUSH);
+  }
+
+  return (bytes);
+}
+#endif /* HAVE_LIBZ */
+
+
 /*
  * 'cups_fill()' - Fill the input buffer...
  */
@@ -1159,211 +1304,247 @@
     fp->pos += fp->end - fp->buf;
 
 #ifdef HAVE_LIBZ
- /*
-  * Check to see if we have read any data yet; if not, see if we have a
-  * compressed file...
-  */
-
-  if (!fp->ptr)
+  while (!fp->ptr || fp->compressed)
   {
    /*
-    * Reset the file position in case we are seeking...
-    */
-
-    fp->compressed = 0;
-    fp->pos        = 0;
-
-   /*
-    * Read the first bytes in the file to determine if we have a gzip'd
-    * file...
+    * Check to see if we have read any data yet; if not, see if we have a
+    * compressed file...
     */
 
-    if ((bytes = cups_read(fp, (char *)fp->cbuf, sizeof(fp->cbuf))) < 0)
+    if (!fp->ptr)
     {
      /*
-      * Can't read from file!
+      * Reset the file position in case we are seeking...
       */
 
-      return (-1);
-    }
+      fp->compressed = 0;
+      fp->pos        = 0;
 
-    if (bytes < 10 || fp->cbuf[0] != 0x1f || fp->cbuf[1] != 0x8b ||
-        fp->cbuf[2] != 8 || (fp->cbuf[3] & 0xe0) != 0)
-    {
      /*
-      * Not a gzip'd file!
+      * Read the first bytes in the file to determine if we have a gzip'd
+      * file...
       */
 
-      memcpy(fp->buf, fp->cbuf, bytes);
+      if ((bytes = cups_read(fp, (char *)fp->cbuf, sizeof(fp->cbuf))) < 0)
+      {
+       /*
+	* Can't read from file!
+	*/
 
-      fp->ptr = fp->buf;
-      fp->end = fp->buf + bytes;
+	return (-1);
+      }
 
-      return (bytes);
-    }
+      if (bytes < 10 || fp->cbuf[0] != 0x1f || fp->cbuf[1] != 0x8b ||
+          fp->cbuf[2] != 8 || (fp->cbuf[3] & 0xe0) != 0)
+      {
+       /*
+	* Not a gzip'd file!
+	*/
 
-   /*
-    * Parse header junk: extra data, original name, and comment...
-    */
+	memcpy(fp->buf, fp->cbuf, bytes);
 
-    ptr = fp->cbuf + 10;
-    end = fp->cbuf + bytes;
+	fp->ptr = fp->buf;
+	fp->end = fp->buf + bytes;
+
+	return (bytes);
+      }
 
-    if (fp->cbuf[3] & 0x04)
-    {
      /*
-      * Skip extra data...
+      * Parse header junk: extra data, original name, and comment...
       */
 
-      if ((ptr + 2) > end)
+      ptr = (unsigned char *)fp->cbuf + 10;
+      end = (unsigned char *)fp->cbuf + bytes;
+
+      if (fp->cbuf[3] & 0x04)
       {
        /*
-	* Can't read from file!
+	* Skip extra data...
 	*/
 
-	return (-1);
-      }
+	if ((ptr + 2) > end)
+	{
+	 /*
+	  * Can't read from file!
+	  */
 
-      bytes = ((unsigned char)ptr[1] << 8) | (unsigned char)ptr[0];
-      ptr   += 2 + bytes;
+	  return (-1);
+	}
 
-      if (ptr > end)
+	bytes = ((unsigned char)ptr[1] << 8) | (unsigned char)ptr[0];
+	ptr   += 2 + bytes;
+
+	if (ptr > end)
+	{
+	 /*
+	  * Can't read from file!
+	  */
+
+	  return (-1);
+	}
+      }
+
+      if (fp->cbuf[3] & 0x08)
       {
        /*
-	* Can't read from file!
+	* Skip original name data...
 	*/
 
-	return (-1);
+	while (ptr < end && *ptr)
+          ptr ++;
+
+	if (ptr < end)
+          ptr ++;
+	else
+	{
+	 /*
+	  * Can't read from file!
+	  */
+
+	  return (-1);
+	}
       }
-    }
 
-    if (fp->cbuf[3] & 0x08)
-    {
-     /*
-      * Skip original name data...
-      */
+      if (fp->cbuf[3] & 0x10)
+      {
+       /*
+	* Skip comment data...
+	*/
 
-      while (ptr < end && *ptr)
-        ptr ++;
+	while (ptr < end && *ptr)
+          ptr ++;
 
-      if (ptr < end)
-        ptr ++;
-      else
+	if (ptr < end)
+          ptr ++;
+	else
+	{
+	 /*
+	  * Can't read from file!
+	  */
+
+	  return (-1);
+	}
+      }
+
+      if (fp->cbuf[3] & 0x02)
       {
        /*
-	* Can't read from file!
+	* Skip header CRC data...
 	*/
 
-	return (-1);
+	ptr += 2;
+
+	if (ptr > end)
+	{
+	 /*
+	  * Can't read from file!
+	  */
+
+	  return (-1);
+	}
       }
+
+     /*
+      * Setup the decompressor data...
+      */
+
+      fp->stream.zalloc    = (alloc_func)0;
+      fp->stream.zfree     = (free_func)0;
+      fp->stream.opaque    = (voidpf)0;
+      fp->stream.next_in   = (Bytef *)ptr;
+      fp->stream.next_out  = NULL;
+      fp->stream.avail_in  = end - ptr;
+      fp->stream.avail_out = 0;
+      fp->crc              = crc32(0L, Z_NULL, 0);
+
+      if (inflateInit2(&(fp->stream), -15) != Z_OK)
+	return (-1);
+
+      fp->compressed = 1;
     }
 
-    if (fp->cbuf[3] & 0x10)
+    if (fp->compressed)
     {
      /*
-      * Skip comment data...
+      * If we have reached end-of-file, return immediately...
       */
 
-      while (ptr < end && *ptr)
-        ptr ++;
+      if (fp->eof)
+	return (-1);
 
-      if (ptr < end)
-        ptr ++;
-      else
+     /*
+      * Fill the decompression buffer as needed...
+      */
+
+      if (fp->stream.avail_in == 0)
       {
-       /*
-	* Can't read from file!
-	*/
+	if ((bytes = cups_read(fp, (char *)fp->cbuf, sizeof(fp->cbuf))) <= 0)
+          return (-1);
 
-	return (-1);
+	fp->stream.next_in  = fp->cbuf;
+	fp->stream.avail_in = bytes;
       }
-    }
 
-    if (fp->cbuf[3] & 0x02)
-    {
      /*
-      * Skip header CRC data...
+      * Decompress data from the buffer...
       */
 
-      ptr += 2;
+      fp->stream.next_out  = (Bytef *)fp->buf;
+      fp->stream.avail_out = sizeof(fp->buf);
 
-      if (ptr > end)
+      if (inflate(&(fp->stream), Z_NO_FLUSH) == Z_STREAM_END)
       {
        /*
-	* Can't read from file!
+	* Read the CRC and length...
 	*/
 
-	return (-1);
-      }
-    }
-
-   /*
-    * Setup the decompressor data...
-    */
-
-    fp->stream.zalloc    = (alloc_func)0;
-    fp->stream.zfree     = (free_func)0;
-    fp->stream.opaque    = (voidpf)0;
-    fp->stream.next_in   = (Bytef *)ptr;
-    fp->stream.next_out  = NULL;
-    fp->stream.avail_in  = end - ptr;
-    fp->stream.avail_out = 0;
+	unsigned char	trailer[8];	/* Trailer bytes */
+	uLong		tcrc;		/* Trailer CRC */
 
-    if (inflateInit2(&(fp->stream), -15) != Z_OK)
-      return (-1);
 
-    fp->compressed = 1;
-  }
+	if (read(fp->fd, trailer, sizeof(trailer)) < sizeof(trailer))
+	{
+	 /*
+          * Can't get it, so mark end-of-file...
+	  */
 
-  if (fp->compressed)
-  {
-   /*
-    * If we have reached end-of-file, return immediately...
-    */
+          fp->eof = 1;
+	  return (-1);
+	}
 
-    if (fp->eof)
-      return (-1);
+	tcrc = (((((trailer[3] << 8) | trailer[2]) << 8) | trailer[1]) << 8) |
+               trailer[0];
 
-   /*
-    * Fill the decompression buffer as needed...
-    */
+	if (tcrc != fp->crc)
+	{
+	 /*
+          * Bad CRC, mark end-of-file...
+	  */
+	  fp->eof = 1;
 
-    if (fp->stream.avail_in == 0)
-    {
-      if ((bytes = cups_read(fp, (char *)fp->cbuf, sizeof(fp->cbuf))) <= 0)
-        return (-1);
+	  return (-1);
+	}
 
-      fp->stream.next_in  = fp->cbuf;
-      fp->stream.avail_in = bytes;
-    }
+       /*
+	* Otherwise, reset the current pointer so that we re-read the
+	* file header...
+	*/
 
-   /*
-    * Decompress data from the buffer...
-    */
+	fp->ptr = NULL;
+	continue;
+      }
 
-    fp->stream.next_out  = (Bytef *)fp->buf;
-    fp->stream.avail_out = sizeof(fp->buf);
+      bytes = sizeof(fp->buf) - fp->stream.avail_out;
 
-    if (inflate(&(fp->stream), Z_NO_FLUSH) == Z_STREAM_END)
-    {
      /*
-      * Mark end-of-file; note: we do not support concatenated gzip files
-      * like gunzip does...
+      * Return the decompressed data...
       */
 
-      fp->eof = 1;
-    }
-
-    bytes = sizeof(fp->buf) - fp->stream.avail_out;
-
-   /*
-    * Return the decompressed data...
-    */
-
-    fp->ptr = fp->buf;
-    fp->end = fp->buf + bytes;
+      fp->ptr = fp->buf;
+      fp->end = fp->buf + bytes;
 
-    return (bytes);
+      return (bytes);
+    }
   }
 #endif /* HAVE_LIBZ */
 
@@ -1495,5 +1676,5 @@
 
 
 /*
- * End of "$Id: file.c 4683 2005-09-21 22:17:44Z mike $".
+ * End of "$Id: file.c 4833 2005-11-12 21:46:52Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/file.h cupsys-1.1.99.b1.r4748/cups/file.h
--- cupsys-1.1.99.b1.r4748~/cups/file.h	2005-09-22 07:17:44.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/file.h	2005-11-11 21:53:38.810647000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: file.h 4683 2005-09-21 22:17:44Z mike $"
+ * "$Id: file.h 4828 2005-11-11 12:53:38Z mike $"
  *
  *   Public file definitions for the Common UNIX Printing System (CUPS).
  *
@@ -37,6 +37,11 @@
 
 #  include <sys/types.h>
 
+#  ifdef WIN32
+/* Windows does not support the ssize_t type, so map it to off_t... */
+typedef off_t ssize_t;
+#  endif /* WIN32 */
+
 
 /*
  * C++ magic...
@@ -96,5 +101,5 @@
 #endif /* !_CUPS_FILE_H_ */
 
 /*
- * End of "$Id: file.h 4683 2005-09-21 22:17:44Z mike $".
+ * End of "$Id: file.h 4828 2005-11-11 12:53:38Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/getputfile.c cupsys-1.1.99.b1.r4748/cups/getputfile.c
--- cupsys-1.1.99.b1.r4748~/cups/getputfile.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/getputfile.c	2005-10-14 04:39:05.160337000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: getputfile.c 4494 2005-02-18 02:18:11Z mike $"
+ * "$Id: getputfile.c 4785 2005-10-13 19:39:05Z mike $"
  *
  *   Get/put file functions for the Common UNIX Printing System (CUPS).
  *
@@ -54,6 +54,8 @@
 
 /*
  * 'cupsGetFd()' - Get a file from the server.
+ *
+ * @since CUPS 1.1.20@
  */
 
 http_status_t				/* O - Status */
@@ -170,6 +172,8 @@
 
 /*
  * 'cupsGetFile()' - Get a file from the server.
+ *
+ * @since CUPS 1.1.20@
  */
 
 http_status_t				/* O - Status */
@@ -233,6 +237,8 @@
 
 /*
  * 'cupsPutFd()' - Put a file on the server.
+ *
+ * @since CUPS 1.1.20@
  */
 
 http_status_t				/* O - Status */
@@ -364,6 +370,8 @@
 
 /*
  * 'cupsPutFile()' - Put a file on the server.
+ *
+ * @since CUPS 1.1.20@
  */
 
 http_status_t				/* O - Status */
@@ -415,5 +423,5 @@
 
 
 /*
- * End of "$Id: getputfile.c 4494 2005-02-18 02:18:11Z mike $".
+ * End of "$Id: getputfile.c 4785 2005-10-13 19:39:05Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/globals.c cupsys-1.1.99.b1.r4748/cups/globals.c
--- cupsys-1.1.99.b1.r4748~/cups/globals.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/globals.c	2005-10-19 03:06:20.449904000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: globals.c 4686 2005-09-22 15:27:03Z mike $"
+ * "$Id: globals.c 4800 2005-10-18 18:06:20Z mike $"
  *
  *   Global variable access routines for the Common UNIX Printing System (CUPS).
  *
@@ -34,8 +34,8 @@
  * Include necessary headers...
  */
 
-#include "globals.h"
 #include "http-private.h"
+#include "globals.h"
 #include <stdlib.h>
 
 
@@ -169,5 +169,5 @@
 
 
 /*
- * End of "$Id: globals.c 4686 2005-09-22 15:27:03Z mike $".
+ * End of "$Id: globals.c 4800 2005-10-18 18:06:20Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/globals.h cupsys-1.1.99.b1.r4748/cups/globals.h
--- cupsys-1.1.99.b1.r4748~/cups/globals.h	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/globals.h	2005-10-09 05:11:08.260376000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: globals.h 4683 2005-09-21 22:17:44Z mike $"
+ * "$Id: globals.h 4760 2005-10-08 20:11:08Z mike $"
  *
  *   Global variable definitions for the Common UNIX Printing System (CUPS).
  *
@@ -52,13 +52,6 @@
 
 
 /*
- * Constants/limits...
- */
-
-#  define CUPS_MAX_ADDRS	100	/* Limit on number of addresses... */
-
-
-/*
  * To make libcups thread safe, define thread safe globals (aka thread-
  * specific data) for the static variables used in the library.
  */
@@ -69,10 +62,8 @@
   char			http_date[256];	/* Date+time buffer */
 
   /* http-addr.c */
-  unsigned		ip_addrs[CUPS_MAX_ADDRS][4];
-					/* Packed IPv4/6 addresses */
-  char			*ip_ptrs[CUPS_MAX_ADDRS + 1];
-					/* Pointer to packed address */
+  unsigned		ip_addr;	/* Packed IPv4 address */
+  char			*ip_ptrs[2];	/* Pointer to packed address */
   struct hostent	hostent;	/* Host entry for IP address */
 #  ifdef HAVE_GETADDRINFO
   char			hostname[1024];	/* Hostname */
@@ -118,7 +109,8 @@
   /* usersys.c */
   http_encryption_t	encryption;	/* Encryption setting */
   char			user[65],	/* User name */
-			server[256];	/* Server address */
+			server[256],	/* Server address */
+			servername[256];/* Server hostname */
   const char		*(*password_cb)(const char *);
 					/* Password callback */
 
@@ -150,5 +142,5 @@
 #endif /* !_CUPS_GLOBALS_H_ */
 
 /*
- * End of "$Id: globals.h 4683 2005-09-21 22:17:44Z mike $".
+ * End of "$Id: globals.h 4760 2005-10-08 20:11:08Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/http-addr.c cupsys-1.1.99.b1.r4748/cups/http-addr.c
--- cupsys-1.1.99.b1.r4748~/cups/http-addr.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/http-addr.c	2005-10-22 03:49:24.065412000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: http-addr.c 4697 2005-09-23 20:29:27Z mike $"
+ * "$Id: http-addr.c 4806 2005-10-21 18:49:24Z mike $"
  *
  *   HTTP address routines for the Common UNIX Printing System (CUPS).
  *
@@ -25,12 +25,12 @@
  *
  *   httpAddrAny()       - Check for the "any" address.
  *   httpAddrEqual()     - Compare two addresses.
- *   httpAddrLoad()      - Load a host entry address into an HTTP address.
  *   httpAddrLocalhost() - Check for the local loopback address.
  *   httpAddrLookup()    - Lookup the hostname associated with the address.
  *   httpAddrString()    - Convert an IP address to a dotted string.
  *   httpGetHostByName() - Lookup a hostname or IP address, and return
  *                         address records for the specified name.
+ *   httpGetHostname()   - Get the FQDN for the local system.
  */
 
 /*
@@ -40,10 +40,13 @@
 #include "globals.h"
 #include "debug.h"
 #include <stdlib.h>
+#include <stddef.h>
 
 
 /*
  * 'httpAddrAny()' - Check for the "any" address.
+ *
+ * @since CUPS 1.2@
  */
 
 int					/* O - 1 if "any", 0 otherwise */
@@ -65,6 +68,8 @@
 
 /*
  * 'httpAddrEqual()' - Compare two addresses.
+ *
+ * @since CUPS 1.2@
  */
 
 int						/* O - 1 if equal, 0 if != */
@@ -81,7 +86,7 @@
 
 #ifdef AF_INET6
   if (addr1->addr.sa_family == AF_INET6)
-    return (memcmp(&(addr1->ipv6.sin6_addr), &(addr2->ipv6.sin6_addr), 16) == 0);
+    return (!memcmp(&(addr1->ipv6.sin6_addr), &(addr2->ipv6.sin6_addr), 16));
 #endif /* AF_INET6 */
 
   return (addr1->ipv4.sin_addr.s_addr == addr2->ipv4.sin_addr.s_addr);
@@ -90,6 +95,8 @@
 
 /*
  * 'httpAddrLength()' - Return the length of the address in bytes.
+ *
+ * @since CUPS 1.2@
  */
 
 int					/* O - Length in bytes */
@@ -102,7 +109,8 @@
 #endif /* AF_INET6 */
 #ifdef AF_LOCAL
   if (addr->addr.sa_family == AF_LOCAL)
-    return (sizeof(addr->un.sun_family) + strlen(addr->un.sun_path));
+    return (offsetof(struct sockaddr_un, sun_path) +
+            strlen(addr->un.sun_path) + 1);
   else
 #endif /* AF_LOCAL */
   if (addr->addr.sa_family == AF_INET)
@@ -114,60 +122,14 @@
 
 
 /*
- * 'httpAddrLoad()' - Load a host entry address into an HTTP address.
- */
-
-void
-httpAddrLoad(const struct hostent *host,	/* I - Host entry */
-             int                  port,		/* I - Port number */
-             int                  n,		/* I - Index into host entry */
-	     http_addr_t          *addr)	/* O - Address to load */
-{
-#ifdef AF_INET6
-  if (host->h_addrtype == AF_INET6)
-  {
-#  ifdef WIN32
-    addr->ipv6.sin6_port = htons((u_short)port);
-#  else
-    addr->ipv6.sin6_port = htons(port);
-#  endif /* WIN32 */
-
-    memcpy((char *)&(addr->ipv6.sin6_addr), host->h_addr_list[n],
-           host->h_length);
-    addr->ipv6.sin6_family = AF_INET6;
-  }
-  else
-#endif /* AF_INET6 */
-#ifdef AF_LOCAL
-  if (host->h_addrtype == AF_LOCAL)
-  {
-    addr->un.sun_family = AF_LOCAL;
-    strlcpy(addr->un.sun_path, host->h_addr_list[n], sizeof(addr->un.sun_path));
-  }
-  else
-#endif /* AF_LOCAL */
-  if (host->h_addrtype == AF_INET)
-  {
-#  ifdef WIN32
-    addr->ipv4.sin_port = htons((u_short)port);
-#  else
-    addr->ipv4.sin_port = htons(port);
-#  endif /* WIN32 */
-
-    memcpy((char *)&(addr->ipv4.sin_addr), host->h_addr_list[n],
-           host->h_length);
-    addr->ipv4.sin_family = AF_INET;
-  }
-}
-
-
-/*
  * 'httpAddrLocalhost()' - Check for the local loopback address.
+ *
+ * @since CUPS 1.2@
  */
 
 int					/* O - 1 if local host, 0 otherwise */
-httpAddrLocalhost(const http_addr_t *addr)
-					/* I - Address to check */
+httpAddrLocalhost(
+    const http_addr_t *addr)		/* I - Address to check */
 {
 #ifdef AF_INET6
   if (addr->addr.sa_family == AF_INET6 &&
@@ -198,6 +160,8 @@
 
 /*
  * 'httpAddrLookup()' - Lookup the hostname associated with the address.
+ *
+ * @since CUPS 1.2@
  */
 
 char *						/* O - Host name */
@@ -205,39 +169,71 @@
                char              *name,		/* I - Host name buffer */
 	       int               namelen)	/* I - Size of name buffer */
 {
-  struct hostent	*host;			/* Host from name service */
-
-
   DEBUG_printf(("httpAddrLookup(addr=%p, name=%p, namelen=%d)\n",
                 addr, name, namelen));
 
-#ifdef AF_INET6
-  if (addr->addr.sa_family == AF_INET6)
-    host = gethostbyaddr(ADDR_CAST &(addr->ipv6.sin6_addr),
-                         sizeof(struct in6_addr), AF_INET6);
-  else
-#endif /* AF_INET6 */
+ /*
+  * Range check input...
+  */
+
+  if (!addr || !name || namelen <= 2)
+  {
+    if (name && namelen >= 1)
+      *name = '\0';
+
+    return (NULL);
+  }
+
 #ifdef AF_LOCAL
   if (addr->addr.sa_family == AF_LOCAL)
-  {
     strlcpy(name, addr->un.sun_path, namelen);
-    return (name);
-  }
   else
 #endif /* AF_LOCAL */
-  if (addr->addr.sa_family == AF_INET)
-    host = gethostbyaddr(ADDR_CAST &(addr->ipv4.sin_addr),
-                         sizeof(struct in_addr), AF_INET);
-  else
-    host = NULL;
-
-  if (host == NULL)
+#ifdef HAVE_GETNAMEINFO
   {
-    httpAddrString(addr, name, namelen);
-    return (NULL);
+    char	servname[1024];			/* Service name (not used) */
+
+
+    if (getnameinfo(&addr->addr, httpAddrLength(addr), name, namelen,
+                    servname, sizeof(servname), 0))
+    {
+     /*
+      * If we get an error back, then the address type is not supported
+      * and we should zero out the buffer...
+      */
+
+      name[0] = '\0';
+
+      return (NULL);
+    }
   }
+#else
+  {
+    struct hostent	*host;			/* Host from name service */
 
-  strlcpy(name, host->h_name, namelen);
+
+#  ifdef AF_INET6
+    if (addr->addr.sa_family == AF_INET6)
+      host = gethostbyaddr(ADDR_CAST &(addr->ipv6.sin6_addr),
+                	   sizeof(struct in_addr), AF_INET6);
+    else
+#  endif /* AF_INET6 */
+    host = gethostbyaddr(ADDR_CAST &(addr->ipv4.sin_addr),
+                	 sizeof(struct in_addr), AF_INET);
+
+    if (host == NULL)
+    {
+     /*
+      * No hostname, so return the raw address...
+      */
+
+      httpAddrString(addr, name, namelen);
+      return (NULL);
+    }
+
+    strlcpy(name, host->h_name, namelen);
+  }
+#endif /* HAVE_GETNAMEINFO */
 
   return (name);
 }
@@ -245,6 +241,8 @@
 
 /*
  * 'httpAddrString()' - Convert an IP address to a dotted string.
+ *
+ * @since CUPS 1.2@
  */
 
 char *						/* O - IP string */
@@ -255,32 +253,138 @@
   DEBUG_printf(("httpAddrString(addr=%p, s=%p, slen=%d)\n",
                 addr, s, slen));
 
-#ifdef AF_INET6
-  if (addr->addr.sa_family == AF_INET6)
-    snprintf(s, slen, "[%x:%x:%x:%x]",
-             ntohl(addr->ipv6.sin6_addr.s6_addr32[0]),
-             ntohl(addr->ipv6.sin6_addr.s6_addr32[1]),
-             ntohl(addr->ipv6.sin6_addr.s6_addr32[2]),
-             ntohl(addr->ipv6.sin6_addr.s6_addr32[3]));
-  else
-#endif /* AF_INET6 */
+ /*
+  * Range check input...
+  */
+
+  if (!addr || !s || slen <= 2)
+  {
+    if (s && slen >= 1)
+      *s = '\0';
+
+    return (NULL);
+  }
+
 #ifdef AF_LOCAL
   if (addr->addr.sa_family == AF_LOCAL)
     strlcpy(s, addr->un.sun_path, slen);
   else
 #endif /* AF_LOCAL */
-  if (addr->addr.sa_family == AF_INET)
+#ifdef HAVE_GETNAMEINFO
   {
-    unsigned temp;				/* Temporary address */
+    char	servname[1024];		/* Service name (not used) */
 
 
-    temp = ntohl(addr->ipv4.sin_addr.s_addr);
+    if (getnameinfo(&addr->addr, httpAddrLength(addr), s, slen,
+                    servname, sizeof(servname), NI_NUMERICHOST))
+    {
+     /*
+      * If we get an error back, then the address type is not supported
+      * and we should zero out the buffer...
+      */
 
-    snprintf(s, slen, "%d.%d.%d.%d", (temp >> 24) & 255,
-             (temp >> 16) & 255, (temp >> 8) & 255, temp & 255);
+      s[0] = '\0';
+
+      return (NULL);
+    }
   }
-  else
-    strlcpy(s, "UNKNOWN", slen);
+#else
+  {
+#ifdef AF_INET6
+    if (addr->addr.sa_family == AF_INET6)
+    {
+      char		*sptr;		/* Pointer into string */
+      int		i;		/* Looping var */
+      unsigned		temp;		/* Current value */
+      const char	*prefix;	/* Prefix for address */
+
+
+      prefix = "";
+      for (sptr = s, i = 0; i < 4 && addr->ipv6.sin6_addr.s6_addr32[i]; i ++)
+      {
+        temp = ntohl(addr->ipv6.sin6_addr.s6_addr32[i]);
+
+        snprintf(sptr, slen, "%s%x", prefix, (temp >> 16) & 0xffff);
+	prefix = ":";
+	slen -= strlen(sptr);
+	sptr += strlen(sptr);
+
+        temp &= 0xffff;
+
+	if (temp || i == 3 || addr->ipv6.sin6_addr.s6_addr32[i + 1])
+	{
+          snprintf(sptr, slen, "%s%x", prefix, temp);
+	  slen -= strlen(sptr);
+	  sptr += strlen(sptr);
+	}
+      }
+
+      if (i < 4)
+      {
+	while (i < 4 && !addr->ipv6.sin6_addr.s6_addr32[i])
+	  i ++;
+
+        if (i < 4)
+	{
+          snprintf(sptr, slen, "%s:", prefix);
+	  prefix = ":";
+	  slen -= strlen(sptr);
+	  sptr += strlen(sptr);
+
+	  for (; i < 4; i ++)
+	  {
+            temp = ntohl(addr->ipv6.sin6_addr.s6_addr32[i]);
+
+            if ((temp & 0xffff0000) || addr->ipv6.sin6_addr.s6_addr32[i - 1])
+	    {
+              snprintf(sptr, slen, "%s%x", prefix, (temp >> 16) & 0xffff);
+	      slen -= strlen(sptr);
+	      sptr += strlen(sptr);
+            }
+
+            snprintf(sptr, slen, "%s%x", prefix, temp & 0xffff);
+	    slen -= strlen(sptr);
+	    sptr += strlen(sptr);
+	  }
+	}
+	else if (sptr == s)
+	{
+	 /*
+          * Empty address...
+	  */
+
+          strlcpy(s, "::", slen);
+	  sptr = s + 2;
+	  slen -= 2;
+	}
+	else
+	{
+	 /*
+	  * Empty at end...
+	  */
+
+          strlcpy(sptr, "::", slen);
+	  sptr += 2;
+	  slen -= 2;
+	}
+      }
+    }
+    else
+#endif /* AF_INET6 */
+    if (addr->addr.sa_family == AF_INET)
+    {
+      unsigned temp;				/* Temporary address */
+
+
+      temp = ntohl(addr->ipv4.sin_addr.s_addr);
+
+      snprintf(s, slen, "%d.%d.%d.%d", (temp >> 24) & 255,
+               (temp >> 16) & 255, (temp >> 8) & 255, temp & 255);
+    }
+    else
+      strlcpy(s, "UNKNOWN", slen);
+  }
+#endif /* HAVE_GETNAMEINFO */
 
   DEBUG_printf(("httpAddrString: returning \"%s\"...\n", s));
 
@@ -289,14 +393,15 @@
 
 
 /*
- * 'httpGetHostByName()' - Lookup a hostname or IP address, and return
+ * 'httpGetHostByName()' - Lookup a hostname or IPv4 address, and return
  *                         address records for the specified name.
+ *
+ * @deprecated@
  */
 
 struct hostent *			/* O - Host entry */
 httpGetHostByName(const char *name)	/* I - Hostname or IP address */
 {
-  int			i;		/* Looping var */
   const char		*nameptr;	/* Pointer into name */
   unsigned		ip[4];		/* IP address components */
   _cups_globals_t	*cg = _cupsGlobals();
@@ -346,48 +451,6 @@
     return (&cg->hostent);
   }
 #endif /* AF_LOCAL */
-#ifdef AF_INET6
-  if (name[0] == '[')
-  {
-   /*
-    * A raw 128-bit IPv6 address of the form "[xxxx:xxxx:xxxx:xxxx]"
-    */
-
-    cg->hostent.h_name      = (char *)name;
-    cg->hostent.h_aliases   = NULL;
-    cg->hostent.h_addrtype  = AF_INET6;
-    cg->hostent.h_length    = 16;
-    cg->hostent.h_addr_list = cg->ip_ptrs;
-    cg->ip_ptrs[0]       = (char *)(cg->ip_addrs[0]);
-    cg->ip_ptrs[1]       = NULL;
-
-    for (i = 0, nameptr = name + 1; *nameptr && i < 4; i ++)
-    {
-      if (*nameptr == ']')
-        break;
-      else if (*nameptr == ':')
-        cg->ip_addrs[0][i] = 0;
-      else
-        cg->ip_addrs[0][i] = htonl(strtoul(nameptr, (char **)&nameptr, 16));
-
-      if (*nameptr == ':' || *nameptr == ']')
-        nameptr ++;
-    }
-
-    while (i < 4)
-    {
-      cg->ip_addrs[0][i] = 0;
-      i ++;
-    }
-
-    if (*nameptr)
-      return (NULL);
-
-    DEBUG_puts("httpGetHostByName: returning IPv6 address...");
-
-    return (&cg->hostent);
-  }
-#endif /* AF_INET6 */
 
   for (nameptr = name; isdigit(*nameptr & 255) || *nameptr == '.'; nameptr ++);
 
@@ -404,8 +467,8 @@
     if (ip[0] > 255 || ip[1] > 255 || ip[2] > 255 || ip[3] > 255)
       return (NULL);			/* Invalid byte ranges! */
 
-    cg->ip_addrs[0][0] = htonl(((((((ip[0] << 8) | ip[1]) << 8) | ip[2]) << 8) |
-                             ip[3]));
+    cg->ip_addr = htonl(((((((ip[0] << 8) | ip[1]) << 8) | ip[2]) << 8) |
+                         ip[3]));
 
    /*
     * Fill in the host entry and return it...
@@ -416,117 +479,17 @@
     cg->hostent.h_addrtype  = AF_INET;
     cg->hostent.h_length    = 4;
     cg->hostent.h_addr_list = cg->ip_ptrs;
-    cg->ip_ptrs[0]       = (char *)cg->ip_addrs[0];
-    cg->ip_ptrs[1]       = NULL;
+    cg->ip_ptrs[0]          = (char *)&(cg->ip_addr);
+    cg->ip_ptrs[1]          = NULL;
 
     DEBUG_puts("httpGetHostByName: returning IPv4 address...");
 
     return (&cg->hostent);
   }
   else
-#ifdef HAVE_GETADDRINFO
-  {
-   /*
-    * Use the getaddrinfo() function to get the IP address for the
-    * name...
-    */
-
-    struct addrinfo	hints,		/* Address lookup hints */
-			*results,	/* Address lookup results */
-			*current;	/* Current result */
-    http_addr_t		*address;	/* Current address */
-
-
-    memset(&hints, 0, sizeof(hints));
-    hints.ai_family   = PF_UNSPEC;
-    hints.ai_socktype = SOCK_STREAM;
-    hints.ai_flags    = AI_CANONNAME;
-
-    if (getaddrinfo(name, NULL, &hints, &results))
-    {
-     /*
-      * If getaddrinfo() fails, try gethostbyname()...
-      */
-
-      return (gethostbyname(name));
-    }
-
-   /*
-    * Initialize hostent structure, preferring the IPv6 address...
-    */
-
-    for (current = results; current; current = current->ai_next)
-      if (current->ai_family == AF_INET6)
-        break;
-
-    if (!current)
-    {
-      for (current = results; current; current = current->ai_next)
-	if (current->ai_family == AF_INET)
-          break;
-
-      if (!current)
-      {
-       /*
-	* No IPv4 or IPv6 addresses, try gethostbyname()...
-	*/
-
-        freeaddrinfo(results);
-
-	return (gethostbyname(name));
-      }
-    }
-
-    strlcpy(cg->hostname, current->ai_canonname, sizeof(cg->hostname));
-
-    cg->hostent.h_name      = cg->hostname;
-    cg->hostent.h_aliases   = NULL;
-    cg->hostent.h_addrtype  = current->ai_family;
-    cg->hostent.h_addr_list = cg->ip_ptrs;
-
-    if (current->ai_family == AF_INET6)
-      cg->hostent.h_length = 16;
-    else
-      cg->hostent.h_length = 4;
-
-   /*
-    * Convert the address info to a hostent structure...
-    */
-
-    for (i = 0, current = results;
-         i < CUPS_MAX_ADDRS && current;
-	 current = current->ai_next)
-      if (current->ai_family == cg->hostent.h_addrtype)
-      {
-       /*
-        * Copy this address...
-	*/
-
-        address = (http_addr_t *)(current->ai_addr);
-
-        if (current->ai_family == AF_INET)
-	  memcpy((char *)cg->ip_addrs[i], (char *)&(address->ipv4.sin_addr), 4);
-	else
-	  memcpy((char *)cg->ip_addrs[i], (char *)&(address->ipv6.sin6_addr), 16);
-
-	cg->ip_ptrs[i] = (char *)cg->ip_addrs[i];
-	i ++;
-      }
-
-    cg->ip_ptrs[i] = NULL;
-
-   /*
-    * Free the getaddrinfo() results and return the hostent structure...
-    */
-
-    freeaddrinfo(results);
-
-    return (&cg->hostent);
-  }
-#else
   {
    /*
-    * Use the gethostbyname() function to get the IP address for
+    * Use the gethostbyname() function to get the IPv4 address for
     * the name...
     */
 
@@ -534,7 +497,6 @@
 
     return (gethostbyname(name));
   }
-#endif /* HAVE_GETADDRINFO */
 }
 
 
@@ -543,6 +505,8 @@
  *
  * This function uses both gethostname() and gethostbyname() to
  * get the local hostname with domain.
+ *
+ * @since CUPS 1.2@
  */
 
 const char *				/* O - FQDN for this system */
@@ -577,5 +541,5 @@
 
 
 /*
- * End of "$Id: http-addr.c 4697 2005-09-23 20:29:27Z mike $".
+ * End of "$Id: http-addr.c 4806 2005-10-21 18:49:24Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/http-addrlist.c cupsys-1.1.99.b1.r4748/cups/http-addrlist.c
--- cupsys-1.1.99.b1.r4748~/cups/http-addrlist.c	1970-01-01 09:00:00.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/http-addrlist.c	2005-11-01 05:40:17.608247000 +0900
@@ -0,0 +1,588 @@
+/*
+ * "$Id: http-addrlist.c 4815 2005-10-31 20:40:17Z mike $"
+ *
+ *   HTTP address list routines for the Common UNIX Printing System (CUPS).
+ *
+ *   Copyright 1997-2005 by Easy Software Products, all rights reserved.
+ *
+ *   These coded instructions, statements, and computer programs are the
+ *   property of Easy Software Products and are protected by Federal
+ *   copyright law.  Distribution and use rights are outlined in the file
+ *   "LICENSE.txt" which should have been included with this file.  If this
+ *   file is missing or damaged please contact Easy Software Products
+ *   at:
+ *
+ *       Attn: CUPS Licensing Information
+ *       Easy Software Products
+ *       44141 Airport View Drive, Suite 204
+ *       Hollywood, Maryland 20636 USA
+ *
+ *       Voice: (301) 373-9600
+ *       EMail: cups-info@cups.org
+ *         WWW: http://www.cups.org
+ *
+ * Contents:
+ *
+ *   httpAddrConnect()  - Connect to any of the addresses in the list.
+ *   httpAddrFreeList() - Free an address list.
+ *   httpAddrGetList()  - Get a list of addresses for a hostname.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "http-private.h"
+#include "globals.h"
+#include "debug.h"
+#include <stdlib.h>
+
+
+/*
+ * 'httpAddrConnect()' - Connect to any of the addresses in the list.
+ *
+ * @since CUPS 1.2@
+ */
+
+http_addrlist_t *			/* O - Connected address or NULL on failure */
+httpAddrConnect(
+    http_addrlist_t *addrlist,		/* I - List of potential addresses */
+    int             *sock)		/* O - Socket */
+{
+  int	val;				/* Socket option value */
+
+
+ /*
+  * Loop through each address until we connect or run out of addresses...
+  */
+
+  while (addrlist)
+  {
+   /*
+    * Create the socket...
+    */
+
+    if ((*sock = socket(addrlist->addr.addr.sa_family, SOCK_STREAM, 0)) < 0)
+    {
+     /*
+      * Don't abort yet, as this could just be an issue with the local
+      * system not being configured with IPv4/IPv6/domain socket enabled...
+      */
+
+      addrlist = addrlist->next;
+      continue;
+    }
+
+   /*
+    * Set options...
+    */
+
+    val = 1;
+#ifdef WIN32
+    setsockopt(*sock, SOL_SOCKET, SO_REUSEADDR, (const char *)&val,
+               sizeof(val));
+#else
+    setsockopt(*sock, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val));
+#endif /* WIN32 */
+
+#ifdef SO_REUSEPORT
+    val = 1;
+    setsockopt(*sock, SOL_SOCKET, SO_REUSEPORT, &val, sizeof(val));
+#endif /* SO_REUSEPORT */
+
+   /*
+    * Using TCP_NODELAY improves responsiveness, especially on systems
+    * with a slow loopback interface...
+    */
+
+    val = 1;
+#ifdef WIN32
+    setsockopt(*sock, IPPROTO_TCP, TCP_NODELAY, (const char *)&val,
+               sizeof(val)); 
+#else
+    setsockopt(*sock, IPPROTO_TCP, TCP_NODELAY, &val, sizeof(val)); 
+#endif /* WIN32 */
+
+#ifdef FD_CLOEXEC
+   /*
+    * Close this socket when starting another process...
+    */
+
+    fcntl(*sock, F_SETFD, FD_CLOEXEC);
+#endif /* FD_CLOEXEC */
+
+   /*
+    * Then connect...
+    */
+
+    if (!connect(*sock, &(addrlist->addr.addr),
+                 httpAddrLength(&(addrlist->addr))))
+      break;
+
+   /*
+    * Close this socket and move to the next address...
+    */
+
+    closesocket(*sock);
+
+    addrlist = addrlist->next;
+  }
+
+  return (addrlist);
+}
+
+
+/*
+ * 'httpAddrFreeList()' - Free an address list.
+ *
+ * @since CUPS 1.2@
+ */
+
+void
+httpAddrFreeList(
+    http_addrlist_t *addrlist)		/* I - Address list to free */
+{
+  http_addrlist_t	*next;		/* Next address in list */
+
+
+ /*
+  * Free each address in the list...
+  */
+
+  while (addrlist)
+  {
+    next = addrlist->next;
+
+    free(addrlist);
+
+    addrlist = next;
+  }
+}
+
+
+/*
+ * 'httpAddrGetList()' - Get a list of addresses for a hostname.
+ *
+ * @since CUPS 1.2@
+ */
+
+http_addrlist_t	*			/* O - List of addresses or NULL */
+httpAddrGetList(const char *hostname,	/* I - Hostname, IP address, or NULL for passive listen address */
+                int        family,	/* I - Address family or AF_UNSPEC */
+		const char *service)	/* I - Service name or port number */
+{
+  http_addrlist_t	*first,		/* First address in list */
+			*addr,		/* Current address in list */
+			*temp;		/* New address */
+
+
+#ifdef DEBUG
+  printf("httpAddrGetList(hostname=\"%s\", family=AF_%s, service=\"%s\")\n",
+         hostname ? hostname : "(nil)",
+	 family == AF_UNSPEC ? "UNSPEC" :
+#  ifdef AF_LOCAL
+	     family == AF_LOCAL ? "LOCAL" :
+#  endif /* AF_LOCAL */
+#  ifdef AF_INET6
+	     family == AF_INET6 ? "INET6" :
+#  endif /* AF_INET6 */
+	     family == AF_INET ? "INET" : "???", service);
+#endif /* DEBUG */
+
+ /*
+  * Lookup the address the best way we can...
+  */
+
+  first = addr = NULL;
+
+#ifdef AF_LOCAL
+  if (hostname && hostname[0] == '/')
+  {
+   /*
+    * Domain socket address...
+    */
+
+    first = (http_addrlist_t *)calloc(1, sizeof(http_addrlist_t));
+    first->addr.un.sun_family = AF_LOCAL;
+    strlcpy(first->addr.un.sun_path, hostname, sizeof(first->addr.un.sun_path));
+  }
+  else
+#endif /* AF_LOCAL */
+  {
+#ifdef HAVE_GETADDRINFO
+    struct addrinfo	hints,		/* Address lookup hints */
+			*results,	/* Address lookup results */
+			*current;	/* Current result */
+    char		ipv6[1024],	/* IPv6 address */
+			*ipv6zone;	/* Pointer to zone separator */
+    int			ipv6len;	/* Length of IPv6 address */
+
+   /*
+    * Lookup the address as needed...
+    */
+
+    memset(&hints, 0, sizeof(hints));
+    hints.ai_family   = family;
+    hints.ai_flags    = hostname ? 0 : AI_PASSIVE;
+    hints.ai_socktype = SOCK_STREAM;
+
+    if (hostname && *hostname == '[')
+    {
+     /*
+      * Remove brackets from numeric IPv6 address...
+      */
+
+      if (!strncmp(hostname, "[v1.", 4))
+      {
+       /*
+        * Copy the newer address format which supports link-local addresses...
+	*/
+
+	strlcpy(ipv6, hostname + 4, sizeof(ipv6));
+	if ((ipv6len = strlen(ipv6) - 1) >= 0 && ipv6[ipv6len] == ']')
+	{
+          ipv6[ipv6len] = '\0';
+	  hostname      = ipv6;
+
+         /*
+	  * Convert "+zone" in address to "%zone"...
+	  */
+
+          if ((ipv6zone = strrchr(ipv6, '+')) != NULL)
+	    *ipv6zone = '%';
+	}
+      }
+      else
+      {
+       /*
+        * Copy the regular non-link-local IPv6 address...
+	*/
+
+	strlcpy(ipv6, hostname + 1, sizeof(ipv6));
+	if ((ipv6len = strlen(ipv6) - 1) >= 0 && ipv6[ipv6len] == ']')
+	{
+          ipv6[ipv6len] = '\0';
+	  hostname      = ipv6;
+	}
+      }
+    }
+
+    if (!getaddrinfo(hostname, service, &hints, &results))
+    {
+     /*
+      * Copy the results to our own address list structure...
+      */
+
+      for (current = results; current; current = current->ai_next)
+        if (current->ai_family == AF_INET || current->ai_family == AF_INET6)
+	{
+	 /*
+          * Copy the address over...
+	  */
+
+	  temp = (http_addrlist_t *)calloc(1, sizeof(http_addrlist_t));
+	  if (!temp)
+	  {
+	    httpAddrFreeList(first);
+	    return (NULL);
+	  }
+
+          if (current->ai_family == AF_INET6)
+	    memcpy(&(temp->addr.ipv6), current->ai_addr,
+	           sizeof(temp->addr.ipv6));
+	  else
+	    memcpy(&(temp->addr.ipv4), current->ai_addr,
+	           sizeof(temp->addr.ipv4));
+
+         /*
+	  * Append the address to the list...
+	  */
+
+	  if (!first)
+	    first = temp;
+
+	  if (addr)
+	    addr->next = temp;
+
+	  addr = temp;
+	}
+
+     /*
+      * Free the results from getaddrinfo()...
+      */
+
+      freeaddrinfo(results);
+    }
+#else
+    if (hostname)
+    {
+      int		i;		/* Looping vars */
+      unsigned		ip[4];		/* IPv4 address components */
+      const char	*ptr;		/* Pointer into hostname */
+      struct hostent	*host;		/* Result of lookup */
+      struct servent	*port;		/* Port number for service */
+      int		portnum;	/* Port number */
+
+
+     /*
+      * Lookup the service...
+      */
+
+      if (!service)
+	portnum = 0;
+      else if (isdigit(*service & 255))
+	portnum = atoi(service);
+      else if ((port = getservbyname(service, NULL)) != NULL)
+	portnum = ntohs(port->s_port);
+      else if (!strcmp(service, "http"))
+        portnum = 80;
+      else if (!strcmp(service, "https"))
+        portnum = 443;
+      else if (!strcmp(service, "ipp"))
+        portnum = 631;
+      else if (!strcmp(service, "lpd"))
+        portnum = 515;
+      else if (!strcmp(service, "socket"))
+        portnum = 9100;
+      else
+	return (NULL);
+
+     /*
+      * This code is needed because some operating systems have a
+      * buggy implementation of gethostbyname() that does not support
+      * IPv4 addresses.  If the hostname string is an IPv4 address, then
+      * sscanf() is used to extract the IPv4 components.  We then pack
+      * the components into an IPv4 address manually, since the
+      * inet_aton() function is deprecated.  We use the htonl() macro
+      * to get the right byte order for the address.
+      */
+
+      for (ptr = hostname; isdigit(*ptr & 255) || *ptr == '.'; ptr ++);
+
+      if (!*ptr)
+      {
+       /*
+	* We have an IPv4 address; break it up and create an IPv4 address...
+	*/
+
+	if (sscanf(hostname, "%u.%u.%u.%u", ip, ip + 1, ip + 2, ip + 3) == 4 &&
+            ip[0] <= 255 && ip[1] <= 255 && ip[2] <= 255 && ip[3] <= 255)
+	{
+	  first = (http_addrlist_t *)calloc(1, sizeof(http_addrlist_t));
+	  if (!first)
+	    return (NULL);
+
+          first->addr.ipv4.sin_family = AF_INET;
+          first->addr.ipv4.sin_addr.s_addr = htonl(((((((ip[0] << 8) |
+	                                               ip[1]) << 8) |
+						     ip[2]) << 8) | ip[3]));
+          first->addr.ipv4.sin_port = htons(portnum);
+	}
+      }
+      else if ((host = gethostbyname(hostname)) != NULL &&
+#  ifdef AF_INET6
+               (host->h_addrtype == AF_INET || host->h_addrtype == AF_INET6))
+#  else
+               host->h_addrtype == AF_INET)
+#  endif /* AF_INET6 */
+      {
+	for (i = 0; host->h_addr_list[i]; i ++)
+	{
+	 /*
+          * Copy the address over...
+	  */
+
+	  temp = (http_addrlist_t *)calloc(1, sizeof(http_addrlist_t));
+	  if (!temp)
+	  {
+	    httpAddrFreeList(first);
+	    return (NULL);
+	  }
+
+#  ifdef AF_INET6
+          if (host->h_addrtype == AF_INET6)
+	  {
+            first->addr.ipv6.sin6_family = AF_INET6;
+	    memcpy(&(temp->addr.ipv6), host->h_addr_list[i],
+	           sizeof(temp->addr.ipv6));
+            temp->addr.ipv6.sin6_port = htons(portnum);
+	  }
+	  else
+#  endif /* AF_INET6 */
+	  {
+            first->addr.ipv4.sin_family = AF_INET;
+	    memcpy(&(temp->addr.ipv4), host->h_addr_list[i],
+	           sizeof(temp->addr.ipv4));
+            temp->addr.ipv4.sin_port = htons(portnum);
+          }
+
+	 /*
+	  * Append the address to the list...
+	  */
+
+	  if (!first)
+	    first = temp;
+
+	  if (addr)
+	    addr->next = temp;
+
+	  addr = temp;
+	}
+      }
+    }
+#endif /* HAVE_GETADDRINFO */
+  }
+
+ /*
+  * Detect some common errors and handle them sanely...
+  */
+
+  if (!addr && (!hostname || !strcmp(hostname, "localhost")))
+  {
+    struct servent	*port;		/* Port number for service */
+    int			portnum;	/* Port number */
+
+
+   /*
+    * Lookup the service...
+    */
+
+    if (!service)
+      portnum = 0;
+    else if (isdigit(*service & 255))
+      portnum = atoi(service);
+    else if ((port = getservbyname(service, NULL)) != NULL)
+      portnum = ntohs(port->s_port);
+    else if (!strcmp(service, "http"))
+      portnum = 80;
+    else if (!strcmp(service, "https"))
+      portnum = 443;
+    else if (!strcmp(service, "ipp"))
+      portnum = 631;
+    else if (!strcmp(service, "lpd"))
+      portnum = 515;
+    else if (!strcmp(service, "socket"))
+      portnum = 9100;
+    else
+      return (NULL);
+
+    if (hostname && !strcmp(hostname, "localhost"))
+    {
+     /*
+      * Unfortunately, some users ignore all of the warnings in the
+      * /etc/hosts file and delete "localhost" from it. If we get here
+      * then we were unable to resolve the name, so use the IPv6 and/or
+      * IPv4 loopback interface addresses...
+      */
+
+#ifdef AF_INET6
+      if (family != AF_INET)
+      {
+       /*
+        * Add [::1] to the address list...
+	*/
+
+	temp = (http_addrlist_t *)calloc(1, sizeof(http_addrlist_t));
+	if (!temp)
+	{
+	  httpAddrFreeList(first);
+	  return (NULL);
+	}
+
+        temp->addr.ipv6.sin6_family            = AF_INET6;
+	temp->addr.ipv6.sin6_port              = htons(portnum);
+#  ifdef WIN32
+	temp->addr.ipv6.sin6_addr.u.Byte[15]   = 1;
+#  else
+	temp->addr.ipv6.sin6_addr.s6_addr32[3] = htonl(1);
+#  endif /* WIN32 */
+
+        addr = temp;
+      }
+
+      if (family != AF_INET6)
+#endif /* AF_INET6 */
+      {
+       /*
+        * Add 127.0.0.1 to the address list...
+	*/
+
+	temp = (http_addrlist_t *)calloc(1, sizeof(http_addrlist_t));
+	if (!temp)
+	{
+	  httpAddrFreeList(first);
+	  return (NULL);
+	}
+
+        temp->addr.ipv4.sin_family      = AF_INET;
+	temp->addr.ipv4.sin_port        = htons(portnum);
+	temp->addr.ipv4.sin_addr.s_addr = htonl(0x7f000001);
+
+        if (addr)
+	  addr->next = temp;
+	else
+          addr = temp;
+      }
+    }
+    else if (!hostname)
+    {
+     /*
+      * Provide one or more passive listening addresses...
+      */
+
+#ifdef AF_INET6
+      if (family != AF_INET)
+      {
+       /*
+        * Add [::] to the address list...
+	*/
+
+	temp = (http_addrlist_t *)calloc(1, sizeof(http_addrlist_t));
+	if (!temp)
+	{
+	  httpAddrFreeList(first);
+	  return (NULL);
+	}
+
+        temp->addr.ipv6.sin6_family = AF_INET6;
+	temp->addr.ipv6.sin6_port   = htons(portnum);
+
+        addr = temp;
+      }
+
+      if (family != AF_INET6)
+#endif /* AF_INET6 */
+      {
+       /*
+        * Add 0.0.0.0 to the address list...
+	*/
+
+	temp = (http_addrlist_t *)calloc(1, sizeof(http_addrlist_t));
+	if (!temp)
+	{
+	  httpAddrFreeList(first);
+	  return (NULL);
+	}
+
+        temp->addr.ipv4.sin_family = AF_INET;
+	temp->addr.ipv4.sin_port   = htons(portnum);
+
+        if (addr)
+	  addr->next = temp;
+	else
+          addr = temp;
+      }
+    }
+  }
+
+ /*
+  * Return the address list...
+  */
+
+  return (first);
+}
+
+
+/*
+ * End of "$Id: http-addrlist.c 4815 2005-10-31 20:40:17Z mike $".
+ */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/http-private.h cupsys-1.1.99.b1.r4748/cups/http-private.h
--- cupsys-1.1.99.b1.r4748~/cups/http-private.h	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/http-private.h	2005-10-19 03:06:20.449904000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: http-private.h 4683 2005-09-21 22:17:44Z mike $"
+ * "$Id: http-private.h 4800 2005-10-18 18:06:20Z mike $"
  *
  *   Private HTTP definitions for the Common UNIX Printing System (CUPS).
  *
@@ -43,6 +43,26 @@
 #    include <sys/select.h>
 #  endif /* __sun */
 
+#  include <limits.h>
+#  ifdef WIN32
+#    include <io.h>
+#    include <winsock2.h>
+#  else
+#    include <unistd.h>
+#    include <fcntl.h>
+#    include <sys/socket.h>
+#    define closesocket(f) close(f)
+#  endif /* WIN32 */
+
+#  ifdef __sgi
+/*
+ * IRIX does not define socklen_t, and in fact uses an int instead of
+ * unsigned type for length values...
+ */
+
+typedef int socklen_t;
+#  endif /* __sgi */
+
 #  include "http.h"
 
 #  if defined HAVE_LIBSSL
@@ -79,6 +99,10 @@
 
 typedef SSLConnectionRef http_tls_t;
 
+extern OSStatus	_httpReadCDSA(SSLConnectionRef connection, void *data,
+		              size_t *dataLength);
+extern OSStatus	_httpWriteCDSA(SSLConnectionRef connection, const void *data,
+		               size_t *dataLength);
 #  endif /* HAVE_LIBSSL */
 
 /*
@@ -98,5 +122,5 @@
 #endif /* !_CUPS_HTTP_PRIVATE_H_ */
 
 /*
- * End of "$Id: http-private.h 4683 2005-09-21 22:17:44Z mike $".
+ * End of "$Id: http-private.h 4800 2005-10-18 18:06:20Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/http-support.c cupsys-1.1.99.b1.r4748/cups/http-support.c
--- cupsys-1.1.99.b1.r4748~/cups/http-support.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/http-support.c	2005-10-22 04:45:49.306753000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: http-support.c 4683 2005-09-21 22:17:44Z mike $"
+ * "$Id: http-support.c 4810 2005-10-21 19:45:49Z mike $"
  *
  *   HTTP support routines for the Common UNIX Printing System (CUPS) scheduler.
  *
@@ -25,27 +25,67 @@
  *
  * Contents:
  *
- *   httpSeparate()     - Separate a Universal Resource Identifier into its
- *                        components.
- *   httpSeparate2()    - Separate a Universal Resource Identifier into its
- *                        components.
- *   httpStatus()       - Return a short string describing a HTTP status code.
- *   _cups_hstrerror()  - hstrerror() emulation function for Solaris and others...
- *   http_copy_decode() - Copy and decode a URI.
+ *   httpAssembleURI()    - Assemble a uniform resource identifier from its
+ *                          components.
+ *   httpAssembleURIf()   - Assemble a uniform resource identifier from its
+ *                          components with a formatted resource.
+ *   httpDecode64()       - Base64-decode a string.
+ *   httpDecode64_2()     - Base64-decode a string.
+ *   httpEncode64()       - Base64-encode a string.
+ *   httpEncode64_2()     - Base64-encode a string.
+ *   httpGetDateString()  - Get a formatted date/time string from a time value.
+ *   httpGetDateString2() - Get a formatted date/time string from a time value.
+ *   httpGetDateTime()    - Get a time value from a formatted date/time string.
+ *   httpSeparate()       - Separate a Universal Resource Identifier into its
+ *                          components.
+ *   httpSeparate2()      - Separate a Universal Resource Identifier into its
+ *                          components.
+ *   httpSeparateURI()    - Separate a Universal Resource Identifier into its
+ *                          components.
+ *   httpStatus()         - Return a short string describing a HTTP status code.
+ *   _cups_hstrerror()    - hstrerror() emulation function for Solaris and
+ *                          others...
+ *   http_copy_decode()   - Copy and decode a URI.
+ *   http_copy_encode()   - Copy and encode a URI.
  */
 
 /*
  * Include necessary headers...
  */
 
-#include <stdio.h>
+#include "debug.h"
+#include "globals.h"
 #include <stdlib.h>
-#include <stdarg.h>
-#include <ctype.h>
-#include "string.h"
 
-#include "http.h"
-#include "ipp.h"
+
+/*
+ * Local globals...
+ */
+
+static const char * const http_days[7] =
+			{
+			  "Sun",			  "Mon",
+			  "Tue",
+			  "Wed",
+			  "Thu",
+			  "Fri",
+			  "Sat"
+			};
+static const char * const http_months[12] =
+			{
+			  "Jan",
+			  "Feb",
+			  "Mar",
+			  "Apr",
+			  "May",
+			  "Jun",
+		          "Jul",
+			  "Aug",
+			  "Sep",
+			  "Oct",
+			  "Nov",
+			  "Dec"
+			};
 
 
 /*
@@ -54,234 +94,919 @@
 
 static const char	*http_copy_decode(char *dst, const char *src,
 			                  int dstsize, const char *term);
+static char		*http_copy_encode(char *dst, const char *src,
+			                  char *dstend, const char *reserved);
 
 
 /*
- * 'httpSeparate()' - Separate a Universal Resource Identifier into its
- *                    components.
+ * 'httpAssembleURI()' - Assemble a uniform resource identifier from its
+ *                       components.
+ *
+ * This function properly escapes all reserved characters in a URI.  You
+ * should use this function in place of traditional string functions
+ * whenever you need to create a URI string.
+ *
+ * @since CUPS 1.2@
  */
 
-void
-httpSeparate(const char *uri,		/* I - Universal Resource Identifier */
-             char       *scheme,	/* O - Scheme [32] (http, https, etc.) */
-	     char       *username,	/* O - Username [1024] */
-	     char       *host,		/* O - Hostname [1024] */
-	     int        *port,		/* O - Port number to use */
-             char       *resource)	/* O - Resource/filename [1024] */
+http_uri_status_t			/* O - URI status */
+httpAssembleURI(char       *uri,	/* I - URI buffer */
+                int        urilen,	/* I - Size of URI buffer */
+		const char *scheme,	/* I - Scheme name */
+		const char *username,	/* I - Username */
+		const char *host,	/* I - Hostname or address */
+		int        port,	/* I - Port number */
+		const char *resource)	/* I - Resource */
 {
-  httpSeparate2(uri, scheme, 32, username, HTTP_MAX_URI, host, HTTP_MAX_URI,
-                port, resource, HTTP_MAX_URI);
+  return (httpAssembleURIf(uri, urilen, scheme, username, host, port, "%s",
+                           resource));
 }
 
 
 /*
- * 'httpSeparate2()' - Separate a Universal Resource Identifier into its
- *                     components.
+ * 'httpAssembleURIf()' - Assemble a uniform resource identifier from its
+ *                        components with a formatted resource.
+ *
+ * This function creates a formatted version of the resource string
+ * argument "resourcef" and properly escapes all reserved characters
+ * in a URI.  You should use this function in place of traditional
+ * string functions whenever you need to create a URI string.
+ *
+ * @since CUPS 1.2@
  */
 
-void
-httpSeparate2(const char *uri,		/* I - Universal Resource Identifier */
-              char       *scheme,	/* O - Scheme (http, https, etc.) */
-	      int        schemelen,	/* I - Size of scheme buffer */
-	      char       *username,	/* O - Username */
-	      int        usernamelen,	/* I - Size of username buffer */
-	      char       *host,		/* O - Hostname */
-	      int        hostlen,	/* I - Size of hostname buffer */
-	      int        *port,		/* O - Port number to use */
-              char       *resource,	/* O - Resource/filename */
-	      int        resourcelen)	/* I - Size of resource buffer */
+http_uri_status_t			/* O - URI status */
+httpAssembleURIf(char       *uri,	/* I - URI buffer */
+                 int        urilen,	/* I - Size of URI buffer */
+		 const char *scheme,	/* I - Scheme name */
+	 	 const char *username,	/* I - Username */
+		 const char *host,	/* I - Hostname or address */
+		 int        port,	/* I - Port number */
+		 const char *resourcef,	/* I - Printf-style resource */
+		 ...)			/* I - Additional arguments as needed */
 {
-  char		*ptr;			/* Pointer into string... */
-  const char	*atsign,		/* @ sign */
-		*slash;			/* Separator */
+  char		*ptr,			/* Pointer into URI buffer */
+		*end;			/* End of URI buffer */
+  va_list	ap;			/* Pointer to additional arguments */
+  char		resource[1024];		/* Formatted resource string */
+  int		bytes;			/* Bytes in formatted string */
 
 
  /*
   * Range check input...
   */
 
-  if (uri == NULL || scheme == NULL || username == NULL || host == NULL ||
-      port == NULL || resource == NULL)
-    return;
+  if (!uri || urilen < 1 || !scheme || port < 0)
+  {
+    if (uri)
+      *uri = '\0';
+
+    return (HTTP_URI_BAD_ARGUMENTS);
+  }
 
  /*
-  * Grab the scheme portion of the URI...
+  * Assemble the URI starting with the scheme...
   */
 
-  if (!strncmp(uri, "//", 2))
+  end = uri + urilen - 1;
+  ptr = http_copy_encode(uri, scheme, end, NULL);
+
+  if (!ptr)
+    goto assemble_overflow;
+
+  if (!strcmp(scheme, "mailto:"))
   {
    /*
-    * Workaround for HP IPP client bug...
+    * mailto: only has :, no //...
     */
 
-    strlcpy(scheme, "ipp", schemelen);
+    if (ptr < end)
+      *ptr++ = ':';
+    else
+      goto assemble_overflow;
   }
   else
   {
    /*
-    * Standard URI with scheme...
+    * Schemes other than mailto: all have //...
     */
 
-    uri = http_copy_decode(host, uri, hostlen, ":");
+    if ((ptr + 2) < end)
+    {
+      *ptr++ = ':';
+      *ptr++ = '/';
+      *ptr++ = '/';
+    }
+    else
+      goto assemble_overflow;
+  }
 
-    if (*uri == ':')
-      uri ++;
+ /*
+  * Next the username and hostname, if any...
+  */
+
+  if (host)
+  {
+    if (username && *username)
+    {
+     /*
+      * Add username@ first...
+      */
+
+      ptr = http_copy_encode(ptr, username, end, "/?@");
+
+      if (!ptr)
+        goto assemble_overflow;
+
+      if (ptr < end)
+	*ptr++ = '@';
+      else
+        goto assemble_overflow;
+    }
 
    /*
-    * If the scheme contains a period or slash, then it's probably
-    * hostname/filename...
+    * Then add the hostname.  Since IPv6 is a particular pain to deal
+    * with, we have several special cases to deal with...  If we get
+    * an IPv6 address with brackets around it, assume it is already in
+    * URI format...
     */
 
-    if (strchr(host, '.') || strchr(host, '/') || !*uri)
+    if (host[0] != '[' && strchr(host, ':'))
     {
-      if ((ptr = strchr(host, '/')) != NULL)
+     /*
+      * We have an IPv6 address...
+      */
+
+      if (strchr(host, '%'))
       {
-	strlcpy(resource, ptr, resourcelen);
-	*ptr = '\0';
+       /*
+        * We have a link-local address, add "[v1." prefix...
+	*/
+
+	if ((ptr + 4) < end)
+	{
+	  *ptr++ = '[';
+	  *ptr++ = 'v';
+	  *ptr++ = '1';
+	  *ptr++ = '.';
+	}
+	else
+          goto assemble_overflow;
       }
       else
-	resource[0] = '\0';
-
-      if (isdigit(*uri & 255))
       {
        /*
-	* OK, we have "hostname:port[/resource]"...
+        * We have a normal address, add "[" prefix...
 	*/
 
-	*port = strtol(uri, (char **)&uri, 10);
+	if (ptr < end)
+	  *ptr++ = '[';
+	else
+          goto assemble_overflow;
+      }
 
-	if (*uri == '/')
-	  http_copy_decode(resource, uri, resourcelen, "");
+     /*
+      * Copy the rest of the IPv6 address, and terminate with "]".
+      */
+
+      while (ptr < end && *host)
+      {
+        if (*host == '%')
+	{
+          *ptr++ = '+';			/* Convert zone separator */
+	  host ++;
+	}
+	else
+	  *ptr++ = *host++;
       }
-      else
-	*port = 631;
 
-      strlcpy(scheme, "http", schemelen);
-      username[0] = '\0';
-      return;
+      if (*host)
+        goto assemble_overflow;
+
+      if (ptr < end)
+	*ptr++ = ']';
+      else
+        goto assemble_overflow;
     }
     else
     {
      /*
-      * Copy scheme over...
+      * Otherwise, just copy the host string...
       */
 
-      strlcpy(scheme, host, schemelen);
+      ptr = http_copy_encode(ptr, host, end, NULL);
+
+      if (!ptr)
+        goto assemble_overflow;
+    }
+
+   /*
+    * Finish things off with the port number...
+    */
+
+    if (port > 0)
+    {
+      snprintf(ptr, end - ptr + 1, ":%d", port);
+      ptr += strlen(ptr);
+
+      if (ptr >= end)
+	goto assemble_overflow;
     }
   }
 
  /*
-  * If the scheme starts with less than 2 slashes then it is a local resource...
+  * Last but not least, add the resource string...
   */
 
-  if (strncmp(uri, "//", 2))
+  if (resourcef)
   {
-   /*
-    * File-based URI...
-    */
+    va_start(ap, resourcef);
+    bytes = vsnprintf(resource, sizeof(resource), resourcef, ap);
+    va_end(ap);
 
-    http_copy_decode(resource, uri, resourcelen, "");
+    if (bytes >= sizeof(resource))
+      goto assemble_overflow;
 
-    username[0] = '\0';
-    host[0]     = '\0';
-    *port       = 0;
-    return;
+    ptr = http_copy_encode(ptr, resource, end, NULL);
+    if (!ptr)
+      goto assemble_overflow;
   }
+  else if (ptr < end)
+    *ptr++ = '/';
+  else
+    goto assemble_overflow;
 
  /*
-  * Grab the username, if any...
+  * Nul-terminate the URI buffer and return with no errors...
   */
 
-  uri += 2;
+  *ptr = '\0';
 
-  if ((slash = strchr(uri, '/')) == NULL)
-    slash = uri + strlen(uri);
+  return (HTTP_URI_OK);
 
-  if ((atsign = strchr(uri, '@')) != NULL && atsign < slash)
+ /*
+  * Clear the URI string and return an overflow error; I don't usually
+  * like goto's, but in this case it makes sense...
+  */
+
+  assemble_overflow:
+
+  *uri = '\0';
+  return (HTTP_URI_OVERFLOW);
+}
+
+
+/*
+ * 'httpDecode64()' - Base64-decode a string.
+ */
+
+char *					/* O - Decoded string */
+httpDecode64(char       *out,		/* I - String to write to */
+             const char *in)		/* I - String to read from */
+{
+  int	outlen;				/* Output buffer length */
+
+
+ /*
+  * Use the old maximum buffer size for binary compatibility...
+  */
+
+  outlen = 512;
+
+  return (httpDecode64_2(out, &outlen, in));
+}
+
+
+/*
+ * 'httpDecode64_2()' - Base64-decode a string.
+ *
+ * @since CUPS 1.1.21@
+ */
+
+char *					/* O  - Decoded string */
+httpDecode64_2(char       *out,		/* I  - String to write to */
+	       int        *outlen,	/* IO - Size of output string */
+               const char *in)		/* I  - String to read from */
+{
+  int	pos,				/* Bit position */
+	base64;				/* Value of this character */
+  char	*outptr,			/* Output pointer */
+	*outend;			/* End of output buffer */
+
+
+ /*
+  * Range check input...
+  */
+
+  if (!out || !outlen || *outlen < 1 || !in || !*in)
+    return (NULL);
+
+ /*
+  * Convert from base-64 to bytes...
+  */
+
+  for (outptr = out, outend = out + *outlen - 1, pos = 0; *in != '\0'; in ++)
   {
    /*
-    * Get a username:password combo...
+    * Decode this character into a number from 0 to 63...
     */
 
-    uri = http_copy_decode(username, uri, usernamelen, "@") + 1;
-  }
-  else
-  {
+    if (*in >= 'A' && *in <= 'Z')
+      base64 = *in - 'A';
+    else if (*in >= 'a' && *in <= 'z')
+      base64 = *in - 'a' + 26;
+    else if (*in >= '0' && *in <= '9')
+      base64 = *in - '0' + 52;
+    else if (*in == '+')
+      base64 = 62;
+    else if (*in == '/')
+      base64 = 63;
+    else if (*in == '=')
+      break;
+    else
+      continue;
+
    /*
-    * No username:password combo...
+    * Store the result in the appropriate chars...
     */
 
-    username[0] = '\0';
+    switch (pos)
+    {
+      case 0 :
+          if (outptr < outend)
+            *outptr = base64 << 2;
+	  pos ++;
+	  break;
+      case 1 :
+          if (outptr < outend)
+            *outptr++ |= (base64 >> 4) & 3;
+          if (outptr < outend)
+	    *outptr = (base64 << 4) & 255;
+	  pos ++;
+	  break;
+      case 2 :
+          if (outptr < outend)
+            *outptr++ |= (base64 >> 2) & 15;
+          if (outptr < outend)
+	    *outptr = (base64 << 6) & 255;
+	  pos ++;
+	  break;
+      case 3 :
+          if (outptr < outend)
+            *outptr++ |= base64;
+	  pos = 0;
+	  break;
+    }
   }
 
+  *outptr = '\0';
+
  /*
-  * Grab the hostname...
+  * Return the decoded string and size...
   */
 
-  if (uri[0] == '[')
+  *outlen = (int)(outptr - out);
+
+  return (out);
+}
+
+
+/*
+ * 'httpEncode64()' - Base64-encode a string.
+ */
+
+char *					/* O - Encoded string */
+httpEncode64(char       *out,		/* I - String to write to */
+             const char *in)		/* I - String to read from */
+{
+  return (httpEncode64_2(out, 512, in, strlen(in)));
+}
+
+
+/*
+ * 'httpEncode64_2()' - Base64-encode a string.
+ *
+ * @since CUPS 1.1.21@
+ */
+
+char *					/* O - Encoded string */
+httpEncode64_2(char       *out,		/* I - String to write to */
+	       int        outlen,	/* I - Size of output string */
+               const char *in,		/* I - String to read from */
+	       int        inlen)	/* I - Size of input string */
+{
+  char		*outptr,		/* Output pointer */
+		*outend;		/* End of output buffer */
+  static const char base64[] =		/* Base64 characters... */
+  		{
+		  "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+		  "abcdefghijklmnopqrstuvwxyz"
+		  "0123456789"
+		  "+/"
+  		};
+
+
+ /*
+  * Range check input...
+  */
+
+  if (!out || outlen < 1 || !in || inlen < 1)
+    return (NULL);
+
+ /*
+  * Convert bytes to base-64...
+  */
+
+  for (outptr = out, outend = out + outlen - 1; inlen > 0; in ++, inlen --)
   {
    /*
-    * Get IPv6 address...
+    * Encode the up to 3 characters as 4 Base64 numbers...
     */
 
-    uri = http_copy_decode(host, uri, hostlen, "]");
+    if (outptr < outend)
+      *outptr ++ = base64[(in[0] & 255) >> 2];
+    if (outptr < outend)
+      *outptr ++ = base64[(((in[0] & 255) << 4) | ((in[1] & 255) >> 4)) & 63];
 
-    if (*uri == ']')
-      uri ++;
+    in ++;
+    inlen --;
+    if (inlen <= 0)
+    {
+      if (outptr < outend)
+        *outptr ++ = '=';
+      if (outptr < outend)
+        *outptr ++ = '=';
+      break;
+    }
+
+    if (outptr < outend)
+      *outptr ++ = base64[(((in[0] & 255) << 2) | ((in[1] & 255) >> 6)) & 63];
+
+    in ++;
+    inlen --;
+    if (inlen <= 0)
+    {
+      if (outptr < outend)
+        *outptr ++ = '=';
+      break;
+    }
+
+    if (outptr < outend)
+      *outptr ++ = base64[in[0] & 63];
   }
+
+  *outptr = '\0';
+
+ /*
+  * Return the encoded string...
+  */
+
+  return (out);
+}
+
+
+/*
+ * 'httpGetDateString()' - Get a formatted date/time string from a time value.
+ *
+ * @deprecated@
+ */
+
+const char *				/* O - Date/time string */
+httpGetDateString(time_t t)		/* I - UNIX time */
+{
+  _cups_globals_t *cg = _cupsGlobals();	/* Pointer to library globals */
+
+
+  return (httpGetDateString2(t, cg->http_date, sizeof(cg->http_date)));
+}
+
+
+/*
+ * 'httpGetDateString2()' - Get a formatted date/time string from a time value.
+ *
+ * @since CUPS 1.2@
+ */
+
+const char *				/* O - Date/time string */
+httpGetDateString2(time_t t,		/* I - UNIX time */
+                   char   *s,		/* I - String buffer */
+		   int    slen)		/* I - Size of string buffer */
+{
+  struct tm	*tdate;			/* UNIX date/time data */
+
+
+  tdate = gmtime(&t);
+  snprintf(s, slen, "%s, %02d %s %d %02d:%02d:%02d GMT",
+           http_days[tdate->tm_wday], tdate->tm_mday,
+	   http_months[tdate->tm_mon], tdate->tm_year + 1900,
+	   tdate->tm_hour, tdate->tm_min, tdate->tm_sec);
+
+  return (s);
+}
+
+
+/*
+ * 'httpGetDateTime()' - Get a time value from a formatted date/time string.
+ */
+
+time_t					/* O - UNIX time */
+httpGetDateTime(const char *s)		/* I - Date/time string */
+{
+  int		i;			/* Looping var */
+  char		mon[16];		/* Abbreviated month name */
+  int		day, year;		/* Day of month and year */
+  int		hour, min, sec;		/* Time */
+  int		days;			/* Number of days since 1970 */
+  static const int normal_days[] =	/* Days to a month, normal years */
+		{ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 };
+  static const int leap_days[] =	/* Days to a month, leap years */
+		{ 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 };
+
+
+  DEBUG_printf(("httpGetDateTime(s=\"%s\")\n", s));
+
+ /*
+  * Extract the date and time from the formatted string...
+  */
+
+  if (sscanf(s, "%*s%d%15s%d%d:%d:%d", &day, mon, &year, &hour, &min, &sec) < 6)
+    return (0);
+
+  DEBUG_printf(("    day=%d, mon=\"%s\", year=%d, hour=%d, min=%d, sec=%d\n",
+                day, mon, year, hour, min, sec));
+
+ /*
+  * Convert the month name to a number from 0 to 11.
+  */
+
+  for (i = 0; i < 12; i ++)
+    if (!strcasecmp(mon, http_months[i]))
+      break;
+
+  if (i >= 12)
+    return (0);
+
+  DEBUG_printf(("    i=%d\n", i));
+
+ /*
+  * Now convert the date and time to a UNIX time value in seconds since
+  * 1970.  We can't use mktime() since the timezone may not be UTC but
+  * the date/time string *is* UTC.
+  */
+
+  if ((year & 3) == 0 && ((year % 100) != 0 || (year % 400) == 0))
+    days = leap_days[i] + day - 1;
   else
+    days = normal_days[i] + day - 1;
+
+  DEBUG_printf(("    days=%d\n", days));
+
+  days += (year - 1970) * 365 +		/* 365 days per year (normally) */
+          ((year - 1) / 4 - 492) -	/* + leap days */
+	  ((year - 1) / 100 - 19) +	/* - 100 year days */
+          ((year - 1) / 400 - 4);	/* + 400 year days */
+
+  DEBUG_printf(("    days=%d\n", days));
+
+  return (days * 86400 + hour * 3600 + min * 60 + sec);
+}
+
+
+/*
+ * 'httpSeparate()' - Separate a Universal Resource Identifier into its
+ *                    components.
+ */
+
+void
+httpSeparate(const char *uri,		/* I - Universal Resource Identifier */
+             char       *scheme,	/* O - Scheme [32] (http, https, etc.) */
+	     char       *username,	/* O - Username [1024] */
+	     char       *host,		/* O - Hostname [1024] */
+	     int        *port,		/* O - Port number to use */
+             char       *resource)	/* O - Resource/filename [1024] */
+{
+  httpSeparateURI(uri, scheme, 32, username, HTTP_MAX_URI, host, HTTP_MAX_URI,
+                  port, resource, HTTP_MAX_URI);
+}
+
+
+/*
+ * 'httpSeparate2()' - Separate a Universal Resource Identifier into its
+ *                     components.
+ *
+ * @since CUPS 1.1.21@
+ */
+
+void
+httpSeparate2(const char *uri,		/* I - Universal Resource Identifier */
+              char       *scheme,	/* O - Scheme (http, https, etc.) */
+	      int        schemelen,	/* I - Size of scheme buffer */
+	      char       *username,	/* O - Username */
+	      int        usernamelen,	/* I - Size of username buffer */
+	      char       *host,		/* O - Hostname */
+	      int        hostlen,	/* I - Size of hostname buffer */
+	      int        *port,		/* O - Port number to use */
+              char       *resource,	/* O - Resource/filename */
+	      int        resourcelen)	/* I - Size of resource buffer */
+{
+  httpSeparateURI(uri, scheme, schemelen, username, usernamelen, host, hostlen,
+                  port, resource, resourcelen);
+}
+
+
+/*
+ * 'httpSeparateURI()' - Separate a Universal Resource Identifier into its
+ *                       components.
+ *
+ * @since CUPS 1.2@
+ */
+
+http_uri_status_t			/* O - Result of separation */
+httpSeparateURI(const char *uri,	/* I - Universal Resource Identifier */
+                char       *scheme,	/* O - Scheme (http, https, etc.) */
+	        int        schemelen,	/* I - Size of scheme buffer */
+	        char       *username,	/* O - Username */
+		int        usernamelen,	/* I - Size of username buffer */
+		char       *host,	/* O - Hostname */
+		int        hostlen,	/* I - Size of hostname buffer */
+		int        *port,	/* O - Port number to use */
+        	char       *resource,	/* O - Resource/filename */
+		int        resourcelen)	/* I - Size of resource buffer */
+{
+  char			*ptr,		/* Pointer into string... */
+			*end;		/* End of string */
+  const char		*sep;		/* Separator character */
+  http_uri_status_t	status;		/* Result of separation */
+
+
+ /*
+  * Initialize everything to blank...
+  */
+
+  if (scheme && schemelen > 0)
+    *scheme = '\0';
+
+  if (username && usernamelen > 0)
+    *username = '\0';
+
+  if (host && hostlen > 0)
+    *host = '\0';
+
+  if (port)
+    *port = 0;
+
+  if (resource && resourcelen > 0)
+    *resource = '\0';
+
+ /*
+  * Range check input...
+  */
+
+  if (!uri || !port || !scheme || schemelen <= 0 || !username ||
+      usernamelen <= 0 || !host || hostlen <= 0 || !resource ||
+      resourcelen <= 0)
+    return (HTTP_URI_BAD_ARGUMENTS);
+
+  if (!*uri)
+    return (HTTP_URI_BAD_URI);
+
+ /*
+  * Grab the scheme portion of the URI...
+  */
+
+  status = HTTP_URI_OK;
+
+  if (!strncmp(uri, "//", 2))
   {
    /*
-    * Get IPv4 address or hostname...
+    * Workaround for HP IPP client bug...
     */
 
-    uri = http_copy_decode(host, uri, hostlen, ":/");
+    strlcpy(scheme, "ipp", schemelen);
+    status = HTTP_URI_MISSING_SCHEME;
   }
-
-  if (*uri != ':')
+  else if (*uri == '/')
   {
    /*
-    * Use a standard port number for the given scheme.
+    * Filename...
     */
 
-    if (!strcmp(scheme, "http"))
-      *port = 80;
-    else if (!strcmp(scheme, "https"))
-      *port = 443;
-    else if (!strcmp(scheme, "ipp"))
-      *port = 631;
-    else if (!strcasecmp(scheme, "lpd"))
-      *port = 515;
-    else if (!strcmp(scheme, "socket"))	/* Not yet registered... */
-      *port = 9100;
-    else
-      *port = 0;
+    strlcpy(scheme, "file", schemelen);
+    status = HTTP_URI_MISSING_SCHEME;
   }
   else
   {
    /*
-    * Parse port number...
+    * Standard URI with scheme...
     */
 
-    *port = strtol(uri + 1, (char **)&uri, 10);
+    for (ptr = scheme, end = scheme + schemelen - 1;
+         *uri && *uri != ':' && ptr < end;)
+      if (isalnum(*uri & 255) || *uri == '-' || *uri == '+' || *uri == '.')
+        *ptr++ = *uri++;
+      else
+        break;
+
+    *ptr = '\0';
+
+    if (*uri != ':')
+    {
+      *scheme = '\0';
+      return (HTTP_URI_BAD_SCHEME);
+    }
+
+    uri ++;
   }
 
-  if (!*uri)
+ /*
+  * Set the default port number...
+  */
+
+  if (!strcmp(scheme, "http"))
+    *port = 80;
+  else if (!strcmp(scheme, "https"))
+    *port = 443;
+  else if (!strcmp(scheme, "ipp"))
+    *port = 631;
+  else if (!strcasecmp(scheme, "lpd"))
+    *port = 515;
+  else if (!strcmp(scheme, "socket"))	/* Not yet registered with IANA... */
+    *port = 9100;
+  else if (strcmp(scheme, "file") && strcmp(scheme, "mailto"))
+    status = HTTP_URI_UNKNOWN_SCHEME;
+
+ /*
+  * Now see if we have a hostname...
+  */
+
+  if (!strncmp(uri, "//", 2))
   {
    /*
-    * No resource path...
+    * Yes, extract it...
     */
 
-    resource[0] = '/';
-    resource[1] = '\0';
-    return;
+    uri += 2;
+
+   /*
+    * Grab the username, if any...
+    */
+
+    if ((sep = strpbrk(uri, "@/")) != NULL && *sep == '@')
+    {
+     /*
+      * Get a username:password combo...
+      */
+
+      uri = http_copy_decode(username, uri, usernamelen, "@");
+
+      if (!uri)
+      {
+        *username = '\0';
+        return (HTTP_URI_BAD_USERNAME);
+      }
+
+      uri ++;
+    }
+
+   /*
+    * Then the hostname/IP address...
+    */
+
+    if (*uri == '[')
+    {
+     /*
+      * Grab IPv6 address...
+      */
+
+      uri ++;
+      if (!strncmp(uri, "v1.", 3))
+        uri += 3;			/* Skip IPvN leader... */
+
+      uri = http_copy_decode(host, uri, hostlen, "]");
+
+      if (!uri)
+      {
+        *host = '\0';
+        return (HTTP_URI_BAD_HOSTNAME);
+      }
+
+     /*
+      * Validate value...
+      */
+
+      if (*uri != ']')
+      {
+        *host = '\0';
+        return (HTTP_URI_BAD_HOSTNAME);
+      }
+
+      uri ++;
+
+      for (ptr = host; *ptr; ptr ++)
+        if (*ptr == '+')
+	{
+	 /*
+	  * Convert zone separator to % and stop here...
+	  */
+
+	  *ptr = '%';
+	  break;
+	}
+	else if (*ptr != ':' && *ptr != '.' && !isxdigit(*ptr & 255))
+	{
+	  *host = '\0';
+	  return (HTTP_URI_BAD_HOSTNAME);
+	}
+    }
+    else
+    {
+     /*
+      * Grab hostname or IPv4 address...
+      */
+
+      uri = http_copy_decode(host, uri, hostlen, ":?/");
+
+      if (!uri)
+      {
+        *host = '\0';
+        return (HTTP_URI_BAD_HOSTNAME);
+      }
+
+     /*
+      * Validate value...
+      */
+
+      for (ptr = host; *ptr; ptr ++)
+        if (!strchr("abcdefghijklmnopqrstuvwxyz"
+		    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+		    "0123456789"
+	            "-._~"
+		    "!$&'()*+,;=", *ptr))
+	{
+	  *host = '\0';
+	  return (HTTP_URI_BAD_HOSTNAME);
+	}
+    }
+
+   /*
+    * Validate hostname for file scheme - only empty and localhost are
+    * acceptable.
+    */
+
+    if (!strcmp(scheme, "file") && strcmp(host, "localhost") && host[0])
+    {
+      *host = '\0';
+      return (HTTP_URI_BAD_HOSTNAME);
+    }
+
+   /*
+    * See if we have a port number...
+    */
+
+    if (*uri == ':')
+    {
+     /*
+      * Yes, collect the port number...
+      */
+
+      *port = strtol(uri + 1, (char **)&uri, 10);
+
+      if (*uri != '/')
+      {
+        *port = 0;
+        return (HTTP_URI_BAD_PORT);
+      }
+    }
   }
 
  /*
   * The remaining portion is the resource string...
   */
 
-  http_copy_decode(resource, uri, resourcelen, "");
+  if (*uri == '?' || !*uri)
+  {
+   /*
+    * Hostname but no path...
+    */
+
+    status    = HTTP_URI_MISSING_RESOURCE;
+    *resource = '/';
+    uri       = http_copy_decode(resource + 1, uri, resourcelen - 1, "");
+  }
+  else
+    uri = http_copy_decode(resource, uri, resourcelen, "");
+
+  if (!uri)
+  {
+    *resource = '\0';
+    return (HTTP_URI_BAD_RESOURCE);
+  }
+
+ /*
+  * Return the URI separation status...
+  */
+
+  return (status);
 }
 
 
@@ -362,7 +1087,7 @@
  * 'http_copy_decode()' - Copy and decode a URI.
  */
 
-static const char *			/* O - New source pointer */
+static const char *			/* O - New source pointer or NULL on error */
 http_copy_decode(char       *dst,	/* O - Destination buffer */ 
                  const char *src,	/* I - Source pointer */
 		 int        dstsize,	/* I - Destination size */
@@ -381,25 +1106,37 @@
   for (ptr = dst, end = dst + dstsize - 1; *src && !strchr(term, *src); src ++)
     if (ptr < end)
     {
-      if (*src == '%' && isxdigit(src[1] & 255) && isxdigit(src[2] & 255))
+      if (*src == '%')
       {
-       /*
-	* Grab a hex-encoded character...
-	*/
+        if (isxdigit(src[1] & 255) && isxdigit(src[2] & 255))
+	{
+	 /*
+	  * Grab a hex-encoded character...
+	  */
 
-        src ++;
-	if (isalpha(*src))
-	  quoted = (tolower(*src) - 'a' + 10) << 4;
-	else
-	  quoted = (*src - '0') << 4;
+          src ++;
+	  if (isalpha(*src))
+	    quoted = (tolower(*src) - 'a' + 10) << 4;
+	  else
+	    quoted = (*src - '0') << 4;
 
-        src ++;
-	if (isalpha(*src))
-	  quoted |= tolower(*src) - 'a' + 10;
+          src ++;
+	  if (isalpha(*src))
+	    quoted |= tolower(*src) - 'a' + 10;
+	  else
+	    quoted |= *src - '0';
+
+          *ptr++ = quoted;
+	}
 	else
-	  quoted |= *src - '0';
+	{
+	 /*
+	  * Bad hex-encoded character...
+	  */
 
-        *ptr++ = quoted;
+	  *ptr = '\0';
+	  return (NULL);
+	}
       }
       else
 	*ptr++ = *src;
@@ -412,5 +1149,47 @@
 
 
 /*
- * End of "$Id: http-support.c 4683 2005-09-21 22:17:44Z mike $".
+ * 'http_copy_encode()' - Copy and encode a URI.
+ */
+
+static char *				/* O - End of current URI */
+http_copy_encode(char       *dst,	/* O - Destination buffer */ 
+                 const char *src,	/* I - Source pointer */
+		 char       *dstend,	/* I - End of destination buffer */
+                 const char *reserved)	/* I - Extra reserved characters */
+{
+  static const char *hex = "0123456789ABCDEF";
+
+
+  while (*src && dst < dstend)
+  {
+    if (*src == '%' || *src <= ' ' || *src & 128 ||
+        (reserved && strchr(reserved, *src)))
+    {
+     /*
+      * Hex encode reserved characters...
+      */
+
+      if ((dst + 2) >= dstend)
+        break;
+
+      *dst++ = '%';
+      *dst++ = hex[(*src >> 4) & 15];
+      *dst++ = hex[*src & 15];
+
+      src ++;
+    }
+    else
+      *dst++ = *src++;
+  }
+
+  if (*src)
+    return (NULL);
+  else
+    return (dst);
+}
+
+
+/*
+ * End of "$Id: http-support.c 4810 2005-10-21 19:45:49Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/http.c cupsys-1.1.99.b1.r4748/cups/http.c
--- cupsys-1.1.99.b1.r4748~/cups/http.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/http.c	2005-11-11 21:53:38.810647000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: http.c 4734 2005-10-01 01:03:34Z mike $"
+ * "$Id: http.c 4828 2005-11-11 12:53:38Z mike $"
  *
  *   HTTP routines for the Common UNIX Printing System (CUPS).
  *
@@ -31,18 +31,11 @@
  *   httpClose()          - Close an HTTP connection...
  *   httpConnect()        - Connect to a HTTP server.
  *   httpConnectEncrypt() - Connect to a HTTP server using encryption.
- *   httpDecode64()       - Base64-decode a string.
- *   httpDecode64_2()     - Base64-decode a string.
  *   httpDelete()         - Send a DELETE request to the server.
- *   httpEncode64()       - Base64-encode a string.
- *   httpEncode64_2()     - Base64-encode a string.
  *   httpEncryption()     - Set the required encryption on the link.
  *   httpFlush()          - Flush data from a HTTP connection.
  *   httpFlushWrite()     - Flush data in write buffer.
  *   httpGet()            - Send a GET request to the server.
- *   httpGetDateString()  - Get a formatted date/time string from a time value.
- *   httpGetDateString2() - Get a formatted date/time string from a time value.
- *   httpGetDateTime()    - Get a time value from a formatted date/time string.
  *   httpGetLength()      - Get the amount of data remaining from the
  *                          content-length or transfer-encoding fields.
  *   httpGetLength2()     - Get the amount of data remaining from the
@@ -57,6 +50,7 @@
  *   httpPrintf()         - Print a formatted string to a HTTP connection.
  *   httpPut()            - Send a PUT request to the server.
  *   httpRead()           - Read data from a HTTP connection.
+ *   _httpReadCDSA()      - Read function for CDSA decryption code.
  *   httpReconnect()      - Reconnect to a HTTP server...
  *   httpSetCookie()      - Set the cookie value(s)...
  *   httpSetField()       - Set the value of an HTTP header.
@@ -65,6 +59,7 @@
  *   httpUpdate()         - Update the current HTTP state for incoming data.
  *   httpWait()           - Wait for data available on a connection.
  *   httpWrite()          - Write data to a HTTP connection.
+ *   _httpWriteCDSA()     - Write function for CDSA encryption code.
  *   http_field()         - Return the field index for a field name.
  *   http_read_ssl()      - Read from a SSL/TLS connection.
  *   http_send()          - Send a request with all fields and the trailing
@@ -75,8 +70,6 @@
  *   http_wait()          - Wait for data available on a connection.
  *   http_write()         - Write data to a connection.
  *   http_write_ssl()     - Write to a SSL/TLS connection.
- *   http_read_cdsa()       - Read function for CDSA decryption code.
- *   http_write_cdsa()      - Write function for CDSA encryption code.
  */
 
 /*
@@ -119,16 +112,10 @@
 static int		http_write_chunk(http_t *http, const char *buffer,
 			                 int length);
 #ifdef HAVE_SSL
-#  ifdef HAVE_CDSASSL
-static OSStatus		http_read_cdsa(SSLConnectionRef connection, void *data, size_t *dataLength);
-#  endif /* HAVE_CDSASSL */
 static int		http_read_ssl(http_t *http, char *buf, int len);
 static int		http_setup_ssl(http_t *http);
 static void		http_shutdown_ssl(http_t *http);
 static int		http_upgrade(http_t *http);
-#  ifdef HAVE_CDSASSL
-static OSStatus		http_write_cdsa(SSLConnectionRef connection, const void *data, size_t *dataLength);
-#  endif /* HAVE_CDSASSL */
 static int		http_write_ssl(http_t *http, const char *buf, int len);
 #endif /* HAVE_SSL */
 
@@ -167,31 +154,6 @@
 			  "User-Agent",
 			  "WWW-Authenticate"
 			};
-static const char * const http_days[7] =
-			{
-			  "Sun",
-			  "Mon",
-			  "Tue",
-			  "Wed",
-			  "Thu",
-			  "Fri",
-			  "Sat"
-			};
-static const char * const http_months[12] =
-			{
-			  "Jan",
-			  "Feb",
-			  "Mar",
-			  "Apr",
-			  "May",
-			  "Jun",
-		          "Jul",
-			  "Aug",
-			  "Sep",
-			  "Oct",
-			  "Nov",
-			  "Dec"
-			};
 
 
 /*
@@ -207,6 +169,8 @@
 
 /*
  * 'httpClearCookie()' - Clear the cookie value(s).
+ *
+ * @since CUPS 1.1.19@
  */
 
 void
@@ -235,6 +199,8 @@
   if (!http)
     return;
 
+  httpAddrFreeList(http->addrlist);
+
   if (http->input_set)
     free(http->input_set);
 
@@ -290,9 +256,9 @@
     int               port,		/* I - Port number */
     http_encryption_t encryption)	/* I - Type of encryption to use */
 {
-  int			i;		/* Looping var */
   http_t		*http;		/* New HTTP connection */
-  struct hostent	*hostaddr;	/* Host address data */
+  http_addrlist_t	*addrlist;	/* Host address data */
+  char			service[255];	/* Service name */
 
 
   DEBUG_printf(("httpConnectEncrypt(host=\"%s\", port=%d, encryption=%d)\n",
@@ -307,31 +273,9 @@
   * Lookup the host...
   */
 
-  if ((hostaddr = httpGetHostByName(host)) == NULL)
-  {
-   /*
-    * This hack to make users that don't have a localhost entry in
-    * their hosts file or DNS happy...
-    */
-
-    if (strcasecmp(host, "localhost") != 0)
-      return (NULL);
-    else if ((hostaddr = httpGetHostByName("127.0.0.1")) == NULL)
-      return (NULL);
-  }
-
- /*
-  * Verify that it is an IPv4, IPv6, or domain address...
-  */
+  sprintf(service, "%d", port);
 
-  if ((hostaddr->h_addrtype != AF_INET || hostaddr->h_length != 4)
-#ifdef AF_INET6
-      && (hostaddr->h_addrtype != AF_INET6 || hostaddr->h_length != 16)
-#endif /* AF_INET6 */
-#ifdef AF_LOCAL
-      && (hostaddr->h_addrtype != AF_LOCAL)
-#endif /* AF_LOCAL */
-      )
+  if ((addrlist = httpAddrGetList(host, AF_UNSPEC, service)) == NULL)
     return (NULL);
 
  /*
@@ -362,141 +306,24 @@
 
   strlcpy(http->hostname, host, sizeof(http->hostname));
 
-  for (i = 0; hostaddr->h_addr_list[i]; i ++)
-  {
-   /*
-    * Load the address...
-    */
-
-    httpAddrLoad(hostaddr, port, i, &(http->hostaddr));
-
-   /*
-    * Connect to the remote system...
-    */
-
-    if (!httpReconnect(http))
-      return (http);
-  }
-
  /*
-  * Could not connect to any known address - bail out!
-  */
-
-  free(http);
-  return (NULL);
-}
-
-
-/*
- * 'httpDecode64()' - Base64-decode a string.
- */
-
-char *					/* O - Decoded string */
-httpDecode64(char       *out,		/* I - String to write to */
-             const char *in)		/* I - String to read from */
-{
-  int	outlen;				/* Output buffer length */
-
-
- /*
-  * Use the old maximum buffer size for binary compatibility...
+  * Connect to the remote system...
   */
 
-  outlen = 512;
-
-  return (httpDecode64_2(out, &outlen, in));
-}
-
-
-/*
- * 'httpDecode64_2()' - Base64-decode a string.
- */
-
-char *					/* O  - Decoded string */
-httpDecode64_2(char       *out,		/* I  - String to write to */
-	       int        *outlen,	/* IO - Size of output string */
-               const char *in)		/* I  - String to read from */
-{
-  int	pos,				/* Bit position */
-	base64;				/* Value of this character */
-  char	*outptr,			/* Output pointer */
-	*outend;			/* End of output buffer */
-
-
- /*
-  * Range check input...
-  */
+  http->addrlist = addrlist;
 
-  if (!out || !outlen || *outlen < 1 || !in || !*in)
-    return (NULL);
+  if (!httpReconnect(http))
+    return (http);
 
  /*
-  * Convert from base-64 to bytes...
+  * Could not connect to any known address - bail out!
   */
 
-  for (outptr = out, outend = out + *outlen - 1, pos = 0; *in != '\0'; in ++)
-  {
-   /*
-    * Decode this character into a number from 0 to 63...
-    */
-
-    if (*in >= 'A' && *in <= 'Z')
-      base64 = *in - 'A';
-    else if (*in >= 'a' && *in <= 'z')
-      base64 = *in - 'a' + 26;
-    else if (*in >= '0' && *in <= '9')
-      base64 = *in - '0' + 52;
-    else if (*in == '+')
-      base64 = 62;
-    else if (*in == '/')
-      base64 = 63;
-    else if (*in == '=')
-      break;
-    else
-      continue;
-
-   /*
-    * Store the result in the appropriate chars...
-    */
-
-    switch (pos)
-    {
-      case 0 :
-          if (outptr < outend)
-            *outptr = base64 << 2;
-	  pos ++;
-	  break;
-      case 1 :
-          if (outptr < outend)
-            *outptr++ |= (base64 >> 4) & 3;
-          if (outptr < outend)
-	    *outptr = (base64 << 4) & 255;
-	  pos ++;
-	  break;
-      case 2 :
-          if (outptr < outend)
-            *outptr++ |= (base64 >> 2) & 15;
-          if (outptr < outend)
-	    *outptr = (base64 << 6) & 255;
-	  pos ++;
-	  break;
-      case 3 :
-          if (outptr < outend)
-            *outptr++ |= base64;
-	  pos = 0;
-	  break;
-    }
-  }
-
-  *outptr = '\0';
-
- /*
-  * Return the decoded string and size...
-  */
+  httpAddrFreeList(addrlist);
 
-  *outlen = (int)(outptr - out);
+  free(http);
 
-  return (out);
+  return (NULL);
 }
 
 
@@ -513,98 +340,6 @@
 
 
 /*
- * 'httpEncode64()' - Base64-encode a string.
- */
-
-char *					/* O - Encoded string */
-httpEncode64(char       *out,		/* I - String to write to */
-             const char *in)		/* I - String to read from */
-{
-  return (httpEncode64_2(out, 512, in, strlen(in)));
-}
-
-
-/*
- * 'httpEncode64_2()' - Base64-encode a string.
- */
-
-char *					/* O - Encoded string */
-httpEncode64_2(char       *out,		/* I - String to write to */
-	       int        outlen,	/* I - Size of output string */
-               const char *in,		/* I - String to read from */
-	       int        inlen)	/* I - Size of input string */
-{
-  char		*outptr,		/* Output pointer */
-		*outend;		/* End of output buffer */
-  static const char base64[] =		/* Base64 characters... */
-  		{
-		  "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
-		  "abcdefghijklmnopqrstuvwxyz"
-		  "0123456789"
-		  "+/"
-  		};
-
-
- /*
-  * Range check input...
-  */
-
-  if (!out || outlen < 1 || !in || inlen < 1)
-    return (NULL);
-
- /*
-  * Convert bytes to base-64...
-  */
-
-  for (outptr = out, outend = out + outlen - 1; inlen > 0; in ++, inlen --)
-  {
-   /*
-    * Encode the up to 3 characters as 4 Base64 numbers...
-    */
-
-    if (outptr < outend)
-      *outptr ++ = base64[(in[0] & 255) >> 2];
-    if (outptr < outend)
-      *outptr ++ = base64[(((in[0] & 255) << 4) | ((in[1] & 255) >> 4)) & 63];
-
-    in ++;
-    inlen --;
-    if (inlen <= 0)
-    {
-      if (outptr < outend)
-        *outptr ++ = '=';
-      if (outptr < outend)
-        *outptr ++ = '=';
-      break;
-    }
-
-    if (outptr < outend)
-      *outptr ++ = base64[(((in[0] & 255) << 2) | ((in[1] & 255) >> 6)) & 63];
-
-    in ++;
-    inlen --;
-    if (inlen <= 0)
-    {
-      if (outptr < outend)
-        *outptr ++ = '=';
-      break;
-    }
-
-    if (outptr < outend)
-      *outptr ++ = base64[in[0] & 63];
-  }
-
-  *outptr = '\0';
-
- /*
-  * Return the encoded string...
-  */
-
-  return (out);
-}
-
-
-/*
  * 'httpEncryption()' - Set the required encryption on the link.
  */
 
@@ -654,6 +389,8 @@
 
 /*
  * 'httpFlushWrite()' - Flush data in write buffer.
+ *
+ * @since CUPS 1.2@
  */
 
 int					/* O - Bytes written or -1 on error */
@@ -691,134 +428,49 @@
 
 
 /*
- * 'httpGetDateString()' - Get a formatted date/time string from a time value.
+ * 'httpGetSubField()' - Get a sub-field value.
  *
- * @deprecated
- */
-
-const char *				/* O - Date/time string */
-httpGetDateString(time_t t)		/* I - UNIX time */
-{
-  _cups_globals_t *cg = _cupsGlobals();	/* Pointer to library globals */
-
-
-  return (httpGetDateString2(t, cg->http_date, sizeof(cg->http_date)));
-}
-
-
-/*
- * 'httpGetDateString2()' - Get a formatted date/time string from a time value.
- */
-
-const char *				/* O - Date/time string */
-httpGetDateString2(time_t t,		/* I - UNIX time */
-                   char   *s,		/* I - String buffer */
-		   int    slen)		/* I - Size of string buffer */
-{
-  struct tm	*tdate;			/* UNIX date/time data */
-
-
-  tdate = gmtime(&t);
-  snprintf(s, slen, "%s, %02d %s %d %02d:%02d:%02d GMT",
-           http_days[tdate->tm_wday], tdate->tm_mday,
-	   http_months[tdate->tm_mon], tdate->tm_year + 1900,
-	   tdate->tm_hour, tdate->tm_min, tdate->tm_sec);
-
-  return (s);
-}
-
-
-/*
- * 'httpGetDateTime()' - Get a time value from a formatted date/time string.
+ * @deprecated@
  */
 
-time_t					/* O - UNIX time */
-httpGetDateTime(const char *s)		/* I - Date/time string */
+char *					/* O - Value or NULL */
+httpGetSubField(http_t       *http,	/* I - HTTP data */
+                http_field_t field,	/* I - Field index */
+                const char   *name,	/* I - Name of sub-field */
+		char         *value)	/* O - Value string */
 {
-  int		i;			/* Looping var */
-  char		mon[16];		/* Abbreviated month name */
-  int		day, year;		/* Day of month and year */
-  int		hour, min, sec;		/* Time */
-  int		days;			/* Number of days since 1970 */
-  static const int normal_days[] =	/* Days to a month, normal years */
-		{ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 };
-  static const int leap_days[] =	/* Days to a month, leap years */
-		{ 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 };
-
-
-  DEBUG_printf(("httpGetDateTime(s=\"%s\")\n", s));
-
- /*
-  * Extract the date and time from the formatted string...
-  */
-
-  if (sscanf(s, "%*s%d%15s%d%d:%d:%d", &day, mon, &year, &hour, &min, &sec) < 6)
-    return (0);
-
-  DEBUG_printf(("    day=%d, mon=\"%s\", year=%d, hour=%d, min=%d, sec=%d\n",
-                day, mon, year, hour, min, sec));
-
- /*
-  * Convert the month name to a number from 0 to 11.
-  */
-
-  for (i = 0; i < 12; i ++)
-    if (!strcasecmp(mon, http_months[i]))
-      break;
-
-  if (i >= 12)
-    return (0);
-
-  DEBUG_printf(("    i=%d\n", i));
-
- /*
-  * Now convert the date and time to a UNIX time value in seconds since
-  * 1970.  We can't use mktime() since the timezone may not be UTC but
-  * the date/time string *is* UTC.
-  */
-
-  if ((year & 3) == 0 && ((year % 100) != 0 || (year % 400) == 0))
-    days = leap_days[i] + day - 1;
-  else
-    days = normal_days[i] + day - 1;
-
-  DEBUG_printf(("    days=%d\n", days));
-
-  days += (year - 1970) * 365 +		/* 365 days per year (normally) */
-          ((year - 1) / 4 - 492) -	/* + leap days */
-	  ((year - 1) / 100 - 19) +	/* - 100 year days */
-          ((year - 1) / 400 - 4);	/* + 400 year days */
-
-  DEBUG_printf(("    days=%d\n", days));
-
-  return (days * 86400 + hour * 3600 + min * 60 + sec);
+  return (httpGetSubField2(http, field, name, value, HTTP_MAX_VALUE));
 }
 
 
 /*
- * 'httpGetSubField()' - Get a sub-field value.
+ * 'httpGetSubField2()' - Get a sub-field value.
+ *
+ * @since CUPS 1.2@
  */
 
 char *					/* O - Value or NULL */
-httpGetSubField(http_t       *http,	/* I - HTTP data */
-                http_field_t field,	/* I - Field index */
-                const char   *name,	/* I - Name of sub-field */
-		char         *value)	/* O - Value string */
+httpGetSubField2(http_t       *http,	/* I - HTTP data */
+                 http_field_t field,	/* I - Field index */
+                 const char   *name,	/* I - Name of sub-field */
+		 char         *value,	/* O - Value string */
+		 int          valuelen)	/* I - Size of value buffer */
 {
   const char	*fptr;			/* Pointer into field */
   char		temp[HTTP_MAX_VALUE],	/* Temporary buffer for name */
-		*ptr;			/* Pointer into string buffer */
-
+		*ptr,			/* Pointer into string buffer */
+		*end;			/* End of value buffer */
 
-  DEBUG_printf(("httpGetSubField(http=%p, field=%d, name=\"%s\", value=%p)\n",
-                http, field, name, value));
+  DEBUG_printf(("httpGetSubField2(http=%p, field=%d, name=\"%s\", value=%p, valuelen=%d)\n",
+                http, field, name, value, valuelen));
 
-  if (http == NULL ||
+  if (!http || !name || !value || valuelen < 2 ||
       field < HTTP_FIELD_ACCEPT_LANGUAGE ||
-      field > HTTP_FIELD_WWW_AUTHENTICATE ||
-      name == NULL || value == NULL)
+      field > HTTP_FIELD_WWW_AUTHENTICATE)
     return (NULL);
 
+  end = value + valuelen - 1;
+
   for (fptr = http->fields[field]; *fptr;)
   {
    /*
@@ -839,7 +491,8 @@
     */
 
     for (ptr = temp;
-         *fptr && *fptr != '=' && !isspace(*fptr & 255) && ptr < (temp + sizeof(temp) - 1);
+         *fptr && *fptr != '=' && !isspace(*fptr & 255) &&
+	     ptr < (temp + sizeof(temp) - 1);
          *ptr++ = *fptr++);
 
     *ptr = '\0';
@@ -875,7 +528,7 @@
       */
 
       for (ptr = value, fptr ++;
-           *fptr && *fptr != '\"' && ptr < (value + HTTP_MAX_VALUE - 1);
+           *fptr && *fptr != '\"' && ptr < end;
 	   *ptr++ = *fptr++);
 
       *ptr = '\0';
@@ -893,7 +546,7 @@
       */
 
       for (ptr = value;
-           *fptr && !isspace(*fptr & 255) && *fptr != ',' && ptr < (value + HTTP_MAX_VALUE - 1);
+           *fptr && !isspace(*fptr & 255) && *fptr != ',' && ptr < end;
 	   *ptr++ = *fptr++);
 
       *ptr = '\0';
@@ -908,7 +561,7 @@
     * See if this is the one...
     */
 
-    if (strcmp(name, temp) == 0)
+    if (!strcmp(name, temp))
       return (value);
   }
 
@@ -924,6 +577,8 @@
  *
  * This function is deprecated and will not return lengths larger than
  * 2^31 - 1; use httpGetLength2() instead.
+ *
+ * @since CUPS 1.2@
  */
 
 int					/* O - Content length */
@@ -977,7 +632,7 @@
       http->data_remaining = strtoll(http->fields[HTTP_FIELD_CONTENT_LENGTH],
                                      NULL, 10);
 
-    DEBUG_printf(("httpGetLength2: content_length=" CUPS_LLFORMAT "\n",
+    DEBUG_printf(("httpGetLength2: content_length=" CUPS_LLFMT "\n",
                   CUPS_LLCAST http->data_remaining));
   }
 
@@ -1331,7 +986,8 @@
     }
   }
 
-  DEBUG_printf(("httpRead: data_remaining=%d\n", http->data_remaining));
+  DEBUG_printf(("httpRead: data_remaining=" CUPS_LLFMT "\n",
+                CUPS_LLCAST http->data_remaining));
 
   if (http->data_remaining <= 0)
   {
@@ -1524,6 +1180,32 @@
 }
 
 
+#if defined(HAVE_SSL) && defined(HAVE_CDSASSL)
+/*
+ * '_httpReadCDSA()' - Read function for CDSA decryption code.
+ */
+
+OSStatus				/* O  - -1 on error, 0 on success */
+_httpReadCDSA(
+    SSLConnectionRef connection,	/* I  - SSL/TLS connection */
+    void             *data,		/* I  - Data buffer */
+    size_t           *dataLength)	/* IO - Number of bytes */
+{
+  ssize_t	bytes;			/* Number of bytes read */
+
+
+  bytes = recv((int)connection, data, *dataLength, 0);
+  if (bytes >= 0)
+  {
+    *dataLength = bytes;
+    return (0);
+  }
+  else
+    return (-1);
+}
+#endif /* HAVE_SSL && HAVE_CDSASSL */
+
+
 /*
  * 'httpReconnect()' - Reconnect to a HTTP server...
  */
@@ -1531,8 +1213,7 @@
 int					/* O - 0 on success, non-zero on failure */
 httpReconnect(http_t *http)		/* I - HTTP data */
 {
-  int		val;			/* Socket option value */
-  int		status;			/* Connect status */
+  http_addrlist_t	*addr;		/* Connected address */
 
 
   DEBUG_printf(("httpReconnect(http=%p)\n", http));
@@ -1557,68 +1238,15 @@
 #endif /* WIN32 */
 
  /*
-  * Create the socket and set options to allow reuse.
-  */
-
-  if ((http->fd = socket(http->hostaddr.addr.sa_family, SOCK_STREAM, 0)) < 0)
-  {
-#ifdef WIN32
-    http->error  = WSAGetLastError();
-#else
-    http->error  = errno;
-#endif /* WIN32 */
-    http->status = HTTP_ERROR;
-    return (-1);
-  }
-
-#ifdef FD_CLOEXEC
-  fcntl(http->fd, F_SETFD, FD_CLOEXEC);	/* Close this socket when starting *
-					 * other processes...              */
-#endif /* FD_CLOEXEC */
-
-  val = 1;
-  setsockopt(http->fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));
-
-#ifdef SO_REUSEPORT
-  val = 1;
-  setsockopt(http->fd, SOL_SOCKET, SO_REUSEPORT, &val, sizeof(val));
-#endif /* SO_REUSEPORT */
-
- /*
-  * Using TCP_NODELAY improves responsiveness, especially on systems
-  * with a slow loopback interface...  Since we write large buffers
-  * when sending print files and requests, there shouldn't be any
-  * performance penalty for this...
-  */
-
-  val = 1;
-#ifdef WIN32
-  setsockopt(http->fd, IPPROTO_TCP, TCP_NODELAY, (char *)&val, sizeof(val)); 
-#else
-  setsockopt(http->fd, IPPROTO_TCP, TCP_NODELAY, &val, sizeof(val)); 
-#endif /* WIN32 */
-
- /*
   * Connect to the server...
   */
 
-#ifdef AF_INET6
-  if (http->hostaddr.addr.sa_family == AF_INET6)
-    status = connect(http->fd, (struct sockaddr *)&(http->hostaddr),
-                     sizeof(http->hostaddr.ipv6));
-  else
-#endif /* AF_INET6 */
-#ifdef AF_LOCAL
-  if (http->hostaddr.addr.sa_family == AF_LOCAL)
-    status = connect(http->fd, (struct sockaddr *)&(http->hostaddr),
-                     SUN_LEN(&(http->hostaddr.un)));
-  else
-#endif /* AF_LOCAL */
-  status = connect(http->fd, (struct sockaddr *)&(http->hostaddr),
-                   sizeof(http->hostaddr.ipv4));
-
-  if (status < 0)
+  if ((addr = httpAddrConnect(http->addrlist, &(http->fd))) == NULL)
   {
+   /*
+    * Unable to connect...
+    */
+
 #ifdef WIN32
     http->error  = WSAGetLastError();
 #else
@@ -1626,19 +1254,12 @@
 #endif /* WIN32 */
     http->status = HTTP_ERROR;
 
-#ifdef WIN32
-    closesocket(http->fd);
-#else
-    close(http->fd);
-#endif
-
-    http->fd = -1;
-
     return (-1);
   }
 
-  http->error  = 0;
-  http->status = HTTP_CONTINUE;
+  http->hostaddr = &(addr->addr);
+  http->error    = 0;
+  http->status   = HTTP_CONTINUE;
 
 #ifdef HAVE_SSL
   if (http->encryption == HTTP_ENCRYPT_ALWAYS)
@@ -1668,6 +1289,8 @@
 
 /*
  * 'httpSetCookie()' - Set the cookie value(s)...
+ *
+ * @since CUPS 1.1.19@
  */
 
 void
@@ -1708,13 +1331,15 @@
 
 /*
  * 'httpSetLength()' - Set the content-length and content-encoding.
+ *
+ * @since CUPS 1.2@
  */
 
 void
 httpSetLength(http_t *http,		/* I - HTTP data */
-              off_t  length)		/* I - Length (0 for chunked) */
+              size_t length)		/* I - Length (0 for chunked) */
 {
-  if (!http || length < 0)
+  if (!http)
     return;
 
   if (!length)
@@ -1922,6 +1547,8 @@
 
 /*
  * 'httpWait()' - Wait for data available on a connection.
+ *
+ * @since CUPS 1.1.19@
  */
 
 int					/* O - 1 if data is available, 0 otherwise */
@@ -2019,6 +1646,8 @@
     if (http->data_encoding == HTTP_ENCODE_LENGTH)
       http->data_remaining -= bytes;
   }
+  else
+    bytes = 0;
 
  /*
   * Handle end-of-request processing...
@@ -2065,39 +1694,21 @@
 }
 
 
-/*
- * 'http_field()' - Return the field index for a field name.
- */
-
-static http_field_t		/* O - Field index */
-http_field(const char *name)	/* I - String name */
-{
-  int	i;			/* Looping var */
-
-
-  for (i = 0; i < HTTP_FIELD_MAX; i ++)
-    if (strcasecmp(name, http_fields[i]) == 0)
-      return ((http_field_t)i);
-
-  return (HTTP_FIELD_UNKNOWN);
-}
-
-
 #if defined(HAVE_SSL) && defined(HAVE_CDSASSL)
 /*
- * 'http_read_cdsa()' - Read function for CDSA decryption code.
+ * '_httpWriteCDSA()' - Write function for CDSA encryption code.
  */
 
-static OSStatus				/* O  - -1 on error, 0 on success */
-http_read_cdsa(
+OSStatus				/* O  - -1 on error, 0 on success */
+_httpWriteCDSA(
     SSLConnectionRef connection,	/* I  - SSL/TLS connection */
-    void             *data,		/* I  - Data buffer */
+    const void       *data,		/* I  - Data buffer */
     size_t           *dataLength)	/* IO - Number of bytes */
 {
-  ssize_t	bytes;			/* Number of bytes read */
+  ssize_t bytes;			/* Number of write written */
 
 
-  bytes = recv((int)connection, data, *dataLength, 0);
+  bytes = write((int)connection, data, *dataLength);
   if (bytes >= 0)
   {
     *dataLength = bytes;
@@ -2109,6 +1720,24 @@
 #endif /* HAVE_SSL && HAVE_CDSASSL */
 
 
+/*
+ * 'http_field()' - Return the field index for a field name.
+ */
+
+static http_field_t		/* O - Field index */
+http_field(const char *name)	/* I - String name */
+{
+  int	i;			/* Looping var */
+
+
+  for (i = 0; i < HTTP_FIELD_MAX; i ++)
+    if (strcasecmp(name, http_fields[i]) == 0)
+      return ((http_field_t)i);
+
+  return (HTTP_FIELD_UNKNOWN);
+}
+
+
 #ifdef HAVE_SSL
 /*
  * 'http_read_ssl()' - Read from a SSL/TLS connection.
@@ -2245,6 +1874,13 @@
       }
     }
 
+  if (http->cookie)
+    if (httpPrintf(http, "Cookie: $Version=0; %s\r\n", http->cookie) < 1)
+    {
+      http->status = HTTP_ERROR;
+      return (-1);
+    }
+
   if (httpPrintf(http, "\r\n") < 1)
   {
     http->status = HTTP_ERROR;
@@ -2355,7 +1991,7 @@
   error = SSLNewContext(false, &conn);
 
   if (!error)
-    error = SSLSetIOFuncs(conn, http_read_cdsa, http_write_cdsa);
+    error = SSLSetIOFuncs(conn, _httpReadCDSA, _httpWriteCDSA);
 
   if (!error)
     error = SSLSetConnection(conn, (SSLConnectionRef)http->fd);
@@ -2535,10 +2171,10 @@
 {
 #ifndef WIN32
   struct rlimit		limit;          /* Runtime limit */
+  int			set_size;	/* Size of select set */
 #endif /* !WIN32 */
   struct timeval	timeout;	/* Timeout */
   int			nfds;		/* Result from select() */
-  int			set_size;	/* Size of select set */
 
 
   DEBUG_printf(("http_wait(http=%p, msec=%d)\n", http, msec));
@@ -2712,32 +2348,6 @@
 }
 
 
-#if defined(HAVE_SSL) && defined(HAVE_CDSASSL)
-/*
- * 'http_write_cdsa()' - Write function for CDSA encryption code.
- */
-
-static OSStatus				/* O  - -1 on error, 0 on success */
-http_write_cdsa(
-    SSLConnectionRef connection,	/* I  - SSL/TLS connection */
-    const void       *data,		/* I  - Data buffer */
-    size_t           *dataLength)	/* IO - Number of bytes */
-{
-  ssize_t bytes;			/* Number of write written */
-
-
-  bytes = write((int)connection, data, *dataLength);
-  if (bytes >= 0)
-  {
-    *dataLength = bytes;
-    return (0);
-  }
-  else
-    return (-1);
-}
-#endif /* HAVE_SSL && HAVE_CDSASSL */
-
-
 /*
  * 'http_write_chunk()' - Write a chunked buffer.
  */
@@ -2815,5 +2425,5 @@
 
 
 /*
- * End of "$Id: http.c 4734 2005-10-01 01:03:34Z mike $".
+ * End of "$Id: http.c 4828 2005-11-11 12:53:38Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/http.h cupsys-1.1.99.b1.r4748/cups/http.h
--- cupsys-1.1.99.b1.r4748~/cups/http.h	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/http.h	2005-11-11 21:53:38.810647000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: http.h 4730 2005-09-30 21:45:34Z mike $"
+ * "$Id: http.h 4828 2005-11-11 12:53:38Z mike $"
  *
  *   Hyper-Text Transport Protocol definitions for the Common UNIX Printing
  *   System (CUPS).
@@ -34,12 +34,13 @@
 
 #  include <string.h>
 #  include <time.h>
+#  include <sys/types.h>
 #  ifdef WIN32
-#    include <winsock.h>
+#    include <winsock2.h>
+#    include <ws2tcpip.h>
 #  else
 #    include <unistd.h>
 #    include <sys/time.h>
-#    include <sys/types.h>
 #    include <sys/socket.h>
 #    include <netdb.h>
 #    include <netinet/in.h>
@@ -74,7 +75,7 @@
  * core structure and union names, so the same defines or code
  * can't be used on all platforms.
  *
- * The following will likely need tweeking on new platforms that
+ * The following will likely need tweaking on new platforms that
  * support IPv6 - the "s6_addr32" define maps to the 32-bit integer
  * array in the in6_addr union, which is named differently on various
  * platforms.
@@ -85,6 +86,12 @@
 #    define s6_addr32	_S6_un._S6_u32
 #  elif defined(__FreeBSD__) || defined(__APPLE__)
 #    define s6_addr32	__u6_addr.__u6_addr32
+#  elif defined(WIN32)
+/*
+ * Windows only defines byte and 16-bit word members of the union and
+ * requires special casing of all raw address code...
+ */
+#    define s6_addr32	error_need_win32_specific_code
 #  endif /* __sun */
 #endif /* AF_INET6 && !s6_addr32 */
 
@@ -100,186 +107,168 @@
 
 
 /*
- * HTTP state values...
- */
-
-typedef enum			/* States are server-oriented */
-{
-  HTTP_WAITING,			/* Waiting for command */
-  HTTP_OPTIONS,			/* OPTIONS command, waiting for blank line */
-  HTTP_GET,			/* GET command, waiting for blank line */
-  HTTP_GET_SEND,		/* GET command, sending data */
-  HTTP_HEAD,			/* HEAD command, waiting for blank line */
-  HTTP_POST,			/* POST command, waiting for blank line */
-  HTTP_POST_RECV,		/* POST command, receiving data */
-  HTTP_POST_SEND,		/* POST command, sending data */
-  HTTP_PUT,			/* PUT command, waiting for blank line */
-  HTTP_PUT_RECV,		/* PUT command, receiving data */
-  HTTP_DELETE,			/* DELETE command, waiting for blank line */
-  HTTP_TRACE,			/* TRACE command, waiting for blank line */
-  HTTP_CLOSE,			/* CLOSE command, waiting for blank line */
-  HTTP_STATUS			/* Command complete, sending status */
-} http_state_t;
-
-
-/*
- * HTTP version numbers...
- */
-
-typedef enum
-{
-  HTTP_0_9 = 9,			/* HTTP/0.9 */
-  HTTP_1_0 = 100,		/* HTTP/1.0 */
-  HTTP_1_1 = 101		/* HTTP/1.1 */
-} http_version_t;
-
-
-/*
- * HTTP keep-alive values...
+ * Types and structures...
  */
 
-typedef enum
+typedef enum http_auth_e		/**** HTTP authentication types ****/
 {
-  HTTP_KEEPALIVE_OFF = 0,
-  HTTP_KEEPALIVE_ON
-} http_keepalive_t;
-
-
-/*
- * HTTP transfer encoding values...
- */
+  HTTP_AUTH_NONE,			/* No authentication in use */
+  HTTP_AUTH_BASIC,			/* Basic authentication in use */
+  HTTP_AUTH_MD5,			/* Digest authentication in use */
+  HTTP_AUTH_MD5_SESS,			/* MD5-session authentication in use */
+  HTTP_AUTH_MD5_INT,			/* Digest authentication in use for body */
+  HTTP_AUTH_MD5_SESS_INT		/* MD5-session authentication in use for body */
+} http_auth_t;
 
-typedef enum
+typedef enum http_encoding_e		/**** HTTP transfer encoding values ****/
 {
-  HTTP_ENCODE_LENGTH,		/* Data is sent with Content-Length */
-  HTTP_ENCODE_CHUNKED		/* Data is chunked */
+  HTTP_ENCODE_LENGTH,			/* Data is sent with Content-Length */
+  HTTP_ENCODE_CHUNKED			/* Data is chunked */
 } http_encoding_t;
 
-
-/*
- * HTTP encryption values...
- */
-
-typedef enum
+typedef enum http_encryption_e		/**** HTTP encryption values ****/
 {
-  HTTP_ENCRYPT_IF_REQUESTED,	/* Encrypt if requested (TLS upgrade) */
-  HTTP_ENCRYPT_NEVER,		/* Never encrypt */
-  HTTP_ENCRYPT_REQUIRED,	/* Encryption is required (TLS upgrade) */
-  HTTP_ENCRYPT_ALWAYS		/* Always encrypt (SSL) */
+  HTTP_ENCRYPT_IF_REQUESTED,		/* Encrypt if requested (TLS upgrade) */
+  HTTP_ENCRYPT_NEVER,			/* Never encrypt */
+  HTTP_ENCRYPT_REQUIRED,		/* Encryption is required (TLS upgrade) */
+  HTTP_ENCRYPT_ALWAYS			/* Always encrypt (SSL) */
 } http_encryption_t;
 
-
-/*
- * HTTP authentication types...
- */
-
-typedef enum
+typedef enum http_field_e		/**** HTTP field names ****/
 {
-  HTTP_AUTH_NONE,		/* No authentication in use */
-  HTTP_AUTH_BASIC,		/* Basic authentication in use */
-  HTTP_AUTH_MD5,		/* Digest authentication in use */
-  HTTP_AUTH_MD5_SESS,		/* MD5-session authentication in use */
-  HTTP_AUTH_MD5_INT,		/* Digest authentication in use for body */
-  HTTP_AUTH_MD5_SESS_INT	/* MD5-session authentication in use for body */
-} http_auth_t;
+  HTTP_FIELD_UNKNOWN = -1,		/* Unknown field */
+  HTTP_FIELD_ACCEPT_LANGUAGE,		/* Accept-Language field */
+  HTTP_FIELD_ACCEPT_RANGES,		/* Accept-Ranges field */
+  HTTP_FIELD_AUTHORIZATION,		/* Authorization field */
+  HTTP_FIELD_CONNECTION,		/* Connection field */
+  HTTP_FIELD_CONTENT_ENCODING,		/* Content-Encoding field */
+  HTTP_FIELD_CONTENT_LANGUAGE,		/* Content-Language field */
+  HTTP_FIELD_CONTENT_LENGTH,		/* Content-Length field */
+  HTTP_FIELD_CONTENT_LOCATION,		/* Content-Location field */
+  HTTP_FIELD_CONTENT_MD5,		/* Content-MD5 field */
+  HTTP_FIELD_CONTENT_RANGE,		/* Content-Range field */
+  HTTP_FIELD_CONTENT_TYPE,		/* Content-Type field */
+  HTTP_FIELD_CONTENT_VERSION,		/* Content-Version field */
+  HTTP_FIELD_DATE,			/* Date field */
+  HTTP_FIELD_HOST,			/* Host field */
+  HTTP_FIELD_IF_MODIFIED_SINCE,		/* If-Modified-Since field */
+  HTTP_FIELD_IF_UNMODIFIED_SINCE,	/* If-Unmodified-Since field */
+  HTTP_FIELD_KEEP_ALIVE,		/* Keep-Alive field */
+  HTTP_FIELD_LAST_MODIFIED,		/* Last-Modified field */
+  HTTP_FIELD_LINK,			/* Link field */
+  HTTP_FIELD_LOCATION,			/* Location field */
+  HTTP_FIELD_RANGE,			/* Range field */
+  HTTP_FIELD_REFERER,			/* Referer field */
+  HTTP_FIELD_RETRY_AFTER,		/* Retry-After field */
+  HTTP_FIELD_TRANSFER_ENCODING,		/* Transfer-Encoding field */
+  HTTP_FIELD_UPGRADE,			/* Upgrade field */
+  HTTP_FIELD_USER_AGENT,		/* User-Agent field */
+  HTTP_FIELD_WWW_AUTHENTICATE,		/* WWW-Authenticate field */
+  HTTP_FIELD_MAX			/* Maximum field index */
+} http_field_t;
 
+typedef enum http_keepalive_e		/**** HTTP keep-alive values ****/
+{
+  HTTP_KEEPALIVE_OFF = 0,		/* No keep alive support */
+  HTTP_KEEPALIVE_ON			/* Use keep alive */
+} http_keepalive_t;
 
-/*
- * HTTP status codes...
- */
+typedef enum http_state_e		/**** HTTP state values; states
+					 **** are server-oriented...
+					 ****/
+{
+  HTTP_WAITING,				/* Waiting for command */
+  HTTP_OPTIONS,				/* OPTIONS command, waiting for blank line */
+  HTTP_GET,				/* GET command, waiting for blank line */
+  HTTP_GET_SEND,			/* GET command, sending data */
+  HTTP_HEAD,				/* HEAD command, waiting for blank line */
+  HTTP_POST,				/* POST command, waiting for blank line */
+  HTTP_POST_RECV,			/* POST command, receiving data */
+  HTTP_POST_SEND,			/* POST command, sending data */
+  HTTP_PUT,				/* PUT command, waiting for blank line */
+  HTTP_PUT_RECV,			/* PUT command, receiving data */
+  HTTP_DELETE,				/* DELETE command, waiting for blank line */
+  HTTP_TRACE,				/* TRACE command, waiting for blank line */
+  HTTP_CLOSE,				/* CLOSE command, waiting for blank line */
+  HTTP_STATUS				/* Command complete, sending status */
+} http_state_t;
 
-typedef enum
+typedef enum http_status_e		/**** HTTP status codes ****/
 {
-  HTTP_ERROR = -1,		/* An error response from httpXxxx() */
+  HTTP_ERROR = -1,			/* An error response from httpXxxx() */
 
-  HTTP_CONTINUE = 100,		/* Everything OK, keep going... */
-  HTTP_SWITCHING_PROTOCOLS,	/* HTTP upgrade to TLS/SSL */
+  HTTP_CONTINUE = 100,			/* Everything OK, keep going... */
+  HTTP_SWITCHING_PROTOCOLS,		/* HTTP upgrade to TLS/SSL */
 
-  HTTP_OK = 200,		/* OPTIONS/GET/HEAD/POST/TRACE command was successful */
-  HTTP_CREATED,			/* PUT command was successful */
-  HTTP_ACCEPTED,		/* DELETE command was successful */
-  HTTP_NOT_AUTHORITATIVE,	/* Information isn't authoritative */
-  HTTP_NO_CONTENT,		/* Successful command, no new data */
-  HTTP_RESET_CONTENT,		/* Content was reset/recreated */
-  HTTP_PARTIAL_CONTENT,		/* Only a partial file was recieved/sent */
+  HTTP_OK = 200,			/* OPTIONS/GET/HEAD/POST/TRACE command was successful */
+  HTTP_CREATED,				/* PUT command was successful */
+  HTTP_ACCEPTED,			/* DELETE command was successful */
+  HTTP_NOT_AUTHORITATIVE,		/* Information isn't authoritative */
+  HTTP_NO_CONTENT,			/* Successful command, no new data */
+  HTTP_RESET_CONTENT,			/* Content was reset/recreated */
+  HTTP_PARTIAL_CONTENT,			/* Only a partial file was recieved/sent */
 
-  HTTP_MULTIPLE_CHOICES = 300,	/* Multiple files match request */
-  HTTP_MOVED_PERMANENTLY,	/* Document has moved permanently */
-  HTTP_MOVED_TEMPORARILY,	/* Document has moved temporarily */
-  HTTP_SEE_OTHER,		/* See this other link... */
-  HTTP_NOT_MODIFIED,		/* File not modified */
-  HTTP_USE_PROXY,		/* Must use a proxy to access this URI */
+  HTTP_MULTIPLE_CHOICES = 300,		/* Multiple files match request */
+  HTTP_MOVED_PERMANENTLY,		/* Document has moved permanently */
+  HTTP_MOVED_TEMPORARILY,		/* Document has moved temporarily */
+  HTTP_SEE_OTHER,			/* See this other link... */
+  HTTP_NOT_MODIFIED,			/* File not modified */
+  HTTP_USE_PROXY,			/* Must use a proxy to access this URI */
 
-  HTTP_BAD_REQUEST = 400,	/* Bad request */
-  HTTP_UNAUTHORIZED,		/* Unauthorized to access host */
-  HTTP_PAYMENT_REQUIRED,	/* Payment required */
-  HTTP_FORBIDDEN,		/* Forbidden to access this URI */
-  HTTP_NOT_FOUND,		/* URI was not found */
-  HTTP_METHOD_NOT_ALLOWED,	/* Method is not allowed */
-  HTTP_NOT_ACCEPTABLE,		/* Not Acceptable */
-  HTTP_PROXY_AUTHENTICATION,	/* Proxy Authentication is Required */
-  HTTP_REQUEST_TIMEOUT,		/* Request timed out */
-  HTTP_CONFLICT,		/* Request is self-conflicting */
-  HTTP_GONE,			/* Server has gone away */
-  HTTP_LENGTH_REQUIRED,		/* A content length or encoding is required */
-  HTTP_PRECONDITION,		/* Precondition failed */
-  HTTP_REQUEST_TOO_LARGE,	/* Request entity too large */
-  HTTP_URI_TOO_LONG,		/* URI too long */
-  HTTP_UNSUPPORTED_MEDIATYPE,	/* The requested media type is unsupported */
-  HTTP_UPGRADE_REQUIRED = 426,	/* Upgrade to SSL/TLS required */
+  HTTP_BAD_REQUEST = 400,		/* Bad request */
+  HTTP_UNAUTHORIZED,			/* Unauthorized to access host */
+  HTTP_PAYMENT_REQUIRED,		/* Payment required */
+  HTTP_FORBIDDEN,			/* Forbidden to access this URI */
+  HTTP_NOT_FOUND,			/* URI was not found */
+  HTTP_METHOD_NOT_ALLOWED,		/* Method is not allowed */
+  HTTP_NOT_ACCEPTABLE,			/* Not Acceptable */
+  HTTP_PROXY_AUTHENTICATION,		/* Proxy Authentication is Required */
+  HTTP_REQUEST_TIMEOUT,			/* Request timed out */
+  HTTP_CONFLICT,			/* Request is self-conflicting */
+  HTTP_GONE,				/* Server has gone away */
+  HTTP_LENGTH_REQUIRED,			/* A content length or encoding is required */
+  HTTP_PRECONDITION,			/* Precondition failed */
+  HTTP_REQUEST_TOO_LARGE,		/* Request entity too large */
+  HTTP_URI_TOO_LONG,			/* URI too long */
+  HTTP_UNSUPPORTED_MEDIATYPE,		/* The requested media type is unsupported */
+  HTTP_UPGRADE_REQUIRED = 426,		/* Upgrade to SSL/TLS required */
 
-  HTTP_SERVER_ERROR = 500,	/* Internal server error */
-  HTTP_NOT_IMPLEMENTED,		/* Feature not implemented */
-  HTTP_BAD_GATEWAY,		/* Bad gateway */
-  HTTP_SERVICE_UNAVAILABLE,	/* Service is unavailable */
-  HTTP_GATEWAY_TIMEOUT,		/* Gateway connection timed out */
-  HTTP_NOT_SUPPORTED		/* HTTP version not supported */
+  HTTP_SERVER_ERROR = 500,		/* Internal server error */
+  HTTP_NOT_IMPLEMENTED,			/* Feature not implemented */
+  HTTP_BAD_GATEWAY,			/* Bad gateway */
+  HTTP_SERVICE_UNAVAILABLE,		/* Service is unavailable */
+  HTTP_GATEWAY_TIMEOUT,			/* Gateway connection timed out */
+  HTTP_NOT_SUPPORTED			/* HTTP version not supported */
 } http_status_t;
 
-
-/*
- * HTTP field names...
- */
-
-typedef enum
+typedef enum http_uri_status_e		/**** URI separation status @since CUPS1.2@ ****/
 {
-  HTTP_FIELD_UNKNOWN = -1,
-  HTTP_FIELD_ACCEPT_LANGUAGE,
-  HTTP_FIELD_ACCEPT_RANGES,
-  HTTP_FIELD_AUTHORIZATION,
-  HTTP_FIELD_CONNECTION,
-  HTTP_FIELD_CONTENT_ENCODING,
-  HTTP_FIELD_CONTENT_LANGUAGE,
-  HTTP_FIELD_CONTENT_LENGTH,
-  HTTP_FIELD_CONTENT_LOCATION,
-  HTTP_FIELD_CONTENT_MD5,
-  HTTP_FIELD_CONTENT_RANGE,
-  HTTP_FIELD_CONTENT_TYPE,
-  HTTP_FIELD_CONTENT_VERSION,
-  HTTP_FIELD_DATE,
-  HTTP_FIELD_HOST,
-  HTTP_FIELD_IF_MODIFIED_SINCE,
-  HTTP_FIELD_IF_UNMODIFIED_SINCE,
-  HTTP_FIELD_KEEP_ALIVE,
-  HTTP_FIELD_LAST_MODIFIED,
-  HTTP_FIELD_LINK,
-  HTTP_FIELD_LOCATION,
-  HTTP_FIELD_RANGE,
-  HTTP_FIELD_REFERER,
-  HTTP_FIELD_RETRY_AFTER,
-  HTTP_FIELD_TRANSFER_ENCODING,
-  HTTP_FIELD_UPGRADE,
-  HTTP_FIELD_USER_AGENT,
-  HTTP_FIELD_WWW_AUTHENTICATE,
-  HTTP_FIELD_MAX
-} http_field_t;
-
+  HTTP_URI_OVERFLOW = -8,		/* URI buffer for httpAssembleURI is too small */
+  HTTP_URI_BAD_ARGUMENTS = -7,		/* Bad arguments to function (error) */
+  HTTP_URI_BAD_RESOURCE = -6,		/* Bad resource in URI (error) */
+  HTTP_URI_BAD_PORT = -5,		/* Bad port number in URI (error) */
+  HTTP_URI_BAD_HOSTNAME = -4,		/* Bad hostname in URI (error) */
+  HTTP_URI_BAD_USERNAME = -3,		/* Bad username in URI (error) */
+  HTTP_URI_BAD_SCHEME = -2,		/* Bad scheme in URI (error) */
+  HTTP_URI_BAD_URI = -1,		/* Bad/empty URI (error) */
+  HTTP_URI_OK = 0,			/* URI decoded OK */
+  HTTP_URI_MISSING_SCHEME,		/* Missing scheme in URI (warning) */
+  HTTP_URI_UNKNOWN_SCHEME,		/* Unknown scheme in URI (warning) */
+  HTTP_URI_MISSING_RESOURCE		/* Missing resource in URI (warning) */
+} http_uri_status_t;
 
-/*
- * HTTP address structure (makes using IPv6 a little easier and more portable.)
- */  
+typedef enum http_version_e		/**** HTTP version numbers ****/
+{
+  HTTP_0_9 = 9,				/* HTTP/0.9 */
+  HTTP_1_0 = 100,			/* HTTP/1.0 */
+  HTTP_1_1 = 101			/* HTTP/1.1 */
+} http_version_t;
 
-typedef union
+typedef union http_addr_u		/**** Socket address union, which
+					 **** makes using IPv6 and other
+					 **** address types easier and
+					 **** more portable. @since CUPS 1.2@
+					 ****/
 {
   struct sockaddr	addr;		/* Base structure for family value */
   struct sockaddr_in	ipv4;		/* IPv4 address */
@@ -289,14 +278,20 @@
 #ifdef AF_LOCAL
   struct sockaddr_un	un;		/* Domain socket file */
 #endif /* AF_LOCAL */
-  char			pad[128];	/* Pad to ensure binary compatibility */
+  char			pad[256];	/* Padding to ensure binary compatibility */
 } http_addr_t;
 
-/*
- * HTTP connection structure...
- */
+typedef struct http_addrlist_s		/**** Socket address list, which is
+					 **** used to enumerate all of the
+					 **** addresses that are associated
+					 **** with a hostname. @since CUPS 1.2@
+					 ****/
+{
+  struct http_addrlist_s *next;		/* Pointer to next address in list */
+  http_addr_t		addr;		/* Address */
+} http_addrlist_t;
 
-typedef struct
+typedef struct http_s			/**** HTTP connection structure. ****/
 {
   int			fd;		/* File descriptor for this socket */
   int			blocking;	/* To block or not to block */
@@ -306,14 +301,14 @@
   http_status_t		status;		/* Status of last request */
   http_version_t	version;	/* Protocol version */
   http_keepalive_t	keep_alive;	/* Keep-alive supported? */
-  struct sockaddr_in	oldaddr;	/* Address of connected host */
+  struct sockaddr_in	_hostaddr;	/* Address of connected host @deprecated@ */
   char			hostname[HTTP_MAX_HOST],
   					/* Name of connected host */
 			fields[HTTP_FIELD_MAX][HTTP_MAX_VALUE];
 					/* Field values */
   char			*data;		/* Pointer to data buffer */
   http_encoding_t	data_encoding;	/* Chunked or not */
-  int			_data_remaining;/* Number of bytes left (deprecated) */
+  int			_data_remaining;/* Number of bytes left @deprecated@ */
   int			used;		/* Number of bytes used in buffer */
   char			buffer[HTTP_MAX_BUFFER];
 					/* Buffer for incoming data */
@@ -327,23 +322,22 @@
   void			*tls;		/* TLS state information */
   http_encryption_t	encryption;	/* Encryption requirements */
   /**** New in CUPS 1.1.19 ****/
-  fd_set		*input_set;	/* select() set for httpWait() */
-  http_status_t		expect;		/* Expect: header */
-  char			*cookie;	/* Cookie value(s) */
+  fd_set		*input_set;	/* select() set for httpWait() @since CUPS 1.1.19@ */
+  http_status_t		expect;		/* Expect: header @since CUPS 1.1.19@ */
+  char			*cookie;	/* Cookie value(s) @since CUPS 1.1.19@ */
   /**** New in CUPS 1.1.20 ****/
   char			authstring[HTTP_MAX_VALUE],
-					/* Current Authentication value */
+					/* Current Authentication value @since CUPS 1.1.20@ */
 			userpass[HTTP_MAX_VALUE];
-					/* Username:password string */
-  int			digest_tries;	/* Number of tries for digest auth */
+					/* Username:password string @since CUPS 1.1.20@ */
+  int			digest_tries;	/* Number of tries for digest auth @since CUPS 1.1.20@ */
   /**** New in CUPS 1.2 ****/
-  http_addr_t		hostaddr;	/* Host address and port */
-  int			wused;		/* Write buffer bytes used */
-  off_t			data_remaining;	/* Number of bytes left */
+  http_addr_t		*hostaddr;	/* Current host address and port @since CUPS 1.2@ */
+  http_addrlist_t	*addrlist;	/* List of valid addresses @since CUPS 1.2@ */
+  int			wused;		/* Write buffer bytes used @since CUPS 1.2@ */
+  off_t			data_remaining;	/* Number of bytes left @since CUPS 1.2@ */
 } http_t;
 
-/**** New in CUPS 1.1.20+ ****/
-extern int		httpWriteFlush(http_t *http);
 
 /*
  * Prototypes...
@@ -417,21 +411,41 @@
 
 /**** New in CUPS 1.2 ****/
 extern int		httpAddrAny(const http_addr_t *addr);
+extern http_addrlist_t	*httpAddrConnect(http_addrlist_t *addrlist, int *sock);
 extern int		httpAddrEqual(const http_addr_t *addr1,
 			              const http_addr_t *addr2);
+extern void		httpAddrFreeList(http_addrlist_t *addrlist);
+extern http_addrlist_t	*httpAddrGetList(const char *hostname, int family,
+			                 const char *service);
 extern int		httpAddrLength(const http_addr_t *addr);
-extern void		httpAddrLoad(const struct hostent *host, int port,
-			             int n, http_addr_t *addr);
 extern int		httpAddrLocalhost(const http_addr_t *addr);
 extern char		*httpAddrLookup(const http_addr_t *addr,
                                         char *name, int namelen);
 extern char		*httpAddrString(const http_addr_t *addr,
 			                char *s, int slen);
+extern http_uri_status_t httpAssembleURI(char *uri, int urilen,
+			        	 const char *scheme,
+					 const char *username,
+					 const char *host, int port,
+					 const char *resource);
+extern http_uri_status_t httpAssembleURIf(char *uri, int urilen,
+			        	  const char *scheme,
+					  const char *username,
+					  const char *host, int port,
+					  const char *resourcef, ...);
 extern int		httpFlushWrite(http_t *http);
 extern const char	*httpGetDateString2(time_t t, char *s, int slen);
 extern const char	*httpGetHostname(char *s, int slen);
 extern off_t		httpGetLength2(http_t *http);
-extern void		httpSetLength(http_t *http, off_t length);
+extern char		*httpGetSubField2(http_t *http, http_field_t field,
+			                  const char *name, char *value,
+					  int valuelen);
+extern http_uri_status_t httpSeparateURI(const char *uri,
+			        	 char *scheme, int schemelen,
+			        	 char *username, int usernamelen,
+					 char *host, int hostlen, int *port,
+					 char *resource, int resourcelen);
+extern void		httpSetLength(http_t *http, size_t length);
 
 
 /*
@@ -444,5 +458,5 @@
 #endif /* !_CUPS_HTTP_H_ */
 
 /*
- * End of "$Id: http.h 4730 2005-09-30 21:45:34Z mike $".
+ * End of "$Id: http.h 4828 2005-11-11 12:53:38Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/ipp-support.c cupsys-1.1.99.b1.r4748/cups/ipp-support.c
--- cupsys-1.1.99.b1.r4748~/cups/ipp-support.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/ipp-support.c	2005-10-14 04:39:05.160337000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: ipp-support.c 4704 2005-09-26 20:59:15Z mike $"
+ * "$Id: ipp-support.c 4785 2005-10-13 19:39:05Z mike $"
  *
  *   Internet Printing Protocol support functions for the Common UNIX
  *   Printing System (CUPS).
@@ -195,6 +195,8 @@
 
 /*
  * 'ippErrorValue()' - Return a status code for the given name.
+ *
+ * @since CUPS 1.2@
  */
 
 ipp_status_t				/* O - IPP status code */
@@ -224,6 +226,8 @@
 
 /*
  * 'ippOpString()' - Return a name for the given operation id.
+ *
+ * @since CUPS 1.2@
  */
 
 const char *				/* O - Name */
@@ -255,6 +259,8 @@
 
 /*
  * 'ippOpValue()' - Return an operation id for the given name.
+ *
+ * @since CUPS 1.2@
  */
 
 ipp_op_t				/* O - Operation ID */
@@ -285,19 +291,26 @@
 int					/* O - Port number */
 ippPort(void)
 {
-  const char	*server_port;		/* SERVER_PORT environment variable */
+  const char	*ipp_port;		/* IPP_PORT environment variable */
   struct servent *port;			/* Port number info */  
+  int		portnum;		/* Port number */
   _cups_globals_t *cg = _cupsGlobals();	/* Pointer to library globals */
 
 
-  if (cg->ipp_port)
-    return (cg->ipp_port);
-  else if ((server_port = getenv("IPP_PORT")) != NULL)
-    return (cg->ipp_port = atoi(server_port));
-  else if ((port = getservbyname("ipp", NULL)) == NULL)
-    return (cg->ipp_port = CUPS_DEFAULT_IPP_PORT);
-  else
-    return (cg->ipp_port = ntohs(port->s_port));
+  if (!cg->ipp_port)
+  {
+    if ((ipp_port = getenv("IPP_PORT")) != NULL)
+      portnum = atoi(ipp_port);
+    else if ((port = getservbyname("ipp", NULL)) == NULL)
+      portnum = CUPS_DEFAULT_IPP_PORT;
+    else
+      portnum = ntohs(port->s_port);
+
+    if (portnum > 0)
+      cg->ipp_port = portnum;
+  }
+
+  return (cg->ipp_port);
 }
 
 
@@ -308,10 +321,12 @@
 void
 ippSetPort(int p)			/* I - Port number to use */
 {
+  fprintf(stderr, "ippSetPort(p=%d)\n", p);
+
   _cupsGlobals()->ipp_port = p;
 }
 
 
 /*
- * End of "$Id: ipp-support.c 4704 2005-09-26 20:59:15Z mike $".
+ * End of "$Id: ipp-support.c 4785 2005-10-13 19:39:05Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/ipp.c cupsys-1.1.99.b1.r4748/cups/ipp.c
--- cupsys-1.1.99.b1.r4748~/cups/ipp.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/ipp.c	2005-11-11 21:53:38.810647000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: ipp.c 4730 2005-09-30 21:45:34Z mike $"
+ * "$Id: ipp.c 4828 2005-11-11 12:53:38Z mike $"
  *
  *   Internet Printing Protocol support functions for the Common UNIX
  *   Printing System (CUPS).
@@ -68,6 +68,7 @@
  * Include necessary headers...
  */
 
+#include "http-private.h"
 #include "globals.h"
 #include "debug.h"
 #include <stdlib.h>
@@ -158,6 +159,8 @@
 
 /*
  * 'ippAddCollection()' - Add a collection value.
+ *
+ * @since CUPS 1.1.19@
  */
 
 ipp_attribute_t *			/* O - New attribute */
@@ -189,6 +192,8 @@
 
 /*
  * 'ippAddCollections()' - Add an array of collection values.
+ *
+ * @since CUPS 1.1.19@
  */
 
 ipp_attribute_t *			/* O - New attribute */
@@ -696,6 +701,8 @@
 
 /*
  * 'ippDeleteAttribute()' - Delete a single attribute in an IPP request.
+ *
+ * @since CUPS 1.1.19@
  */
 
 void
@@ -882,6 +889,8 @@
 
 /*
  * 'ippReadFile()' - Read data for an IPP request from a file.
+ *
+ * @since CUPS 1.1.19@
  */
 
 ipp_state_t				/* O - Current state */
@@ -896,6 +905,8 @@
 
 /*
  * 'ippReadIO()' - Read data for an IPP request.
+ *
+ * @since CUPS 1.1.19@
  */
 
 ipp_state_t				/* O - Current state */
@@ -1170,9 +1181,13 @@
 	    attr->name       = strdup((char *)buffer);
 	    attr->num_values = 0;
 	  }
+	  else
+	    attr = NULL;
 
           if (tag != IPP_TAG_END_COLLECTION)
             value = attr->values + attr->num_values;
+	  else
+	    value = NULL;
 
 	  if ((*cb)(src, buffer, 2) < 2)
 	  {
@@ -1468,6 +1483,8 @@
 
 /*
  * 'ippWriteFile()' - Write data for an IPP request to a file.
+ *
+ * @since CUPS 1.1.19@
  */
 
 ipp_state_t				/* O - Current state */
@@ -1484,6 +1501,8 @@
 
 /*
  * 'ippWriteIO()' - Write data for an IPP request.
+ *
+ * @since CUPS 1.1.19@
  */
 
 ipp_state_t				/* O - Current state */
@@ -1535,7 +1554,7 @@
 	  *bufptr++ = ipp->request.any.request_id >> 8;
 	  *bufptr++ = ipp->request.any.request_id;
 
-          if ((*cb)(dst, buffer, bufptr - buffer) < 0)
+          if ((*cb)(dst, buffer, (int)(bufptr - buffer)) < 0)
 	  {
 	    DEBUG_puts("ippWrite: Could not write IPP header...");
 	    return (IPP_ERROR);
@@ -1607,7 +1626,7 @@
 	    * overflow the buffer...
 	    */
 
-            if ((n = strlen(attr->name)) > (sizeof(buffer) - 4))
+            if ((n = (int)strlen(attr->name)) > (sizeof(buffer) - 4))
 	      return (IPP_ERROR);
 
            /*
@@ -1630,7 +1649,7 @@
 	    * overflow the buffer...
 	    */
 
-            if ((n = strlen(attr->name)) > (sizeof(buffer) - 7))
+            if ((n = (int)strlen(attr->name)) > (sizeof(buffer) - 7))
 	      return (IPP_ERROR);
 
            /*
@@ -1671,7 +1690,7 @@
 		{
                   if ((sizeof(buffer) - (bufptr - buffer)) < 9)
 		  {
-                    if ((*cb)(dst, buffer, bufptr - buffer) < 0)
+                    if ((*cb)(dst, buffer, (int)(bufptr - buffer)) < 0)
 	            {
 	              DEBUG_puts("ippWrite: Could not write IPP attribute...");
 	              return (IPP_ERROR);
@@ -1715,7 +1734,7 @@
 		{
                   if ((sizeof(buffer) - (bufptr - buffer)) < 6)
 		  {
-                    if ((*cb)(dst, buffer, bufptr - buffer) < 0)
+                    if ((*cb)(dst, buffer, (int)(bufptr - buffer)) < 0)
 	            {
 	              DEBUG_puts("ippWrite: Could not write IPP attribute...");
 	              return (IPP_ERROR);
@@ -1774,7 +1793,7 @@
 
                     if ((sizeof(buffer) - (bufptr - buffer)) < 3)
 		    {
-                      if ((*cb)(dst, buffer, bufptr - buffer) < 0)
+                      if ((*cb)(dst, buffer, (int)(bufptr - buffer)) < 0)
 	              {
 	        	DEBUG_puts("ippWrite: Could not write IPP attribute...");
 	        	return (IPP_ERROR);
@@ -1789,7 +1808,7 @@
 		  }
 
                   if (value->string.text != NULL)
-                    n = strlen(value->string.text);
+                    n = (int)strlen(value->string.text);
 		  else
 		    n = 0;
 
@@ -1801,7 +1820,7 @@
 
                   if ((int)(sizeof(buffer) - (bufptr - buffer)) < (n + 2))
 		  {
-                    if ((*cb)(dst, buffer, bufptr - buffer) < 0)
+                    if ((*cb)(dst, buffer, (int)(bufptr - buffer)) < 0)
 	            {
 	              DEBUG_puts("ippWrite: Could not write IPP attribute...");
 	              return (IPP_ERROR);
@@ -1838,7 +1857,7 @@
 		{
                   if ((sizeof(buffer) - (bufptr - buffer)) < 16)
 		  {
-                    if ((*cb)(dst, buffer, bufptr - buffer) < 0)
+                    if ((*cb)(dst, buffer, (int)(bufptr - buffer)) < 0)
 	            {
 	              DEBUG_puts("ippWrite: Could not write IPP attribute...");
 	              return (IPP_ERROR);
@@ -1881,7 +1900,7 @@
 		{
                   if ((sizeof(buffer) - (bufptr - buffer)) < 14)
 		  {
-                    if ((*cb)(dst, buffer, bufptr - buffer) < 0)
+                    if ((*cb)(dst, buffer, (int)(bufptr - buffer)) < 0)
 	            {
 	              DEBUG_puts("ippWrite: Could not write IPP attribute...");
 	              return (IPP_ERROR);
@@ -1932,7 +1951,7 @@
 		{
                   if ((sizeof(buffer) - (bufptr - buffer)) < 13)
 		  {
-                    if ((*cb)(dst, buffer, bufptr - buffer) < 0)
+                    if ((*cb)(dst, buffer, (int)(bufptr - buffer)) < 0)
 	            {
 	              DEBUG_puts("ippWrite: Could not write IPP attribute...");
 	              return (IPP_ERROR);
@@ -1989,7 +2008,7 @@
 
                     if ((sizeof(buffer) - (bufptr - buffer)) < 3)
 		    {
-                      if ((*cb)(dst, buffer, bufptr - buffer) < 0)
+                      if ((*cb)(dst, buffer, (int)(bufptr - buffer)) < 0)
 	              {
 	        	DEBUG_puts("ippWrite: Could not write IPP attribute...");
 	        	return (IPP_ERROR);
@@ -2026,7 +2045,7 @@
 
                   if ((int)(sizeof(buffer) - (bufptr - buffer)) < (n + 2))
 		  {
-                    if ((*cb)(dst, buffer, bufptr - buffer) < 0)
+                    if ((*cb)(dst, buffer, (int)(bufptr - buffer)) < 0)
 	            {
 	              DEBUG_puts("ippWrite: Could not write IPP attribute...");
 	              return (IPP_ERROR);
@@ -2041,7 +2060,7 @@
 
                  /* Length of charset */
 		  if (value->string.charset != NULL)
-		    n = strlen(value->string.charset);
+		    n = (int)strlen(value->string.charset);
 		  else
 		    n = 0;
 
@@ -2057,7 +2076,7 @@
 
                  /* Length of text */
                   if (value->string.text != NULL)
-		    n = strlen(value->string.text);
+		    n = (int)strlen(value->string.text);
 		  else
 		    n = 0;
 
@@ -2087,7 +2106,7 @@
 
                   if ((sizeof(buffer) - (bufptr - buffer)) < 5)
 		  {
-                    if ((*cb)(dst, buffer, bufptr - buffer) < 0)
+                    if ((*cb)(dst, buffer, (int)(bufptr - buffer)) < 0)
 	            {
 	              DEBUG_puts("ippWrite: Could not write IPP attribute...");
 	              return (IPP_ERROR);
@@ -2115,7 +2134,7 @@
 	          *bufptr++ = 0;
 		  *bufptr++ = 0;
 
-                  if ((*cb)(dst, buffer, bufptr - buffer) < 0)
+                  if ((*cb)(dst, buffer, (int)(bufptr - buffer)) < 0)
 	          {
 	            DEBUG_puts("ippWrite: Could not write IPP attribute...");
 	            return (IPP_ERROR);
@@ -2148,7 +2167,7 @@
 
                     if ((sizeof(buffer) - (bufptr - buffer)) < 3)
 		    {
-                      if ((*cb)(dst, buffer, bufptr - buffer) < 0)
+                      if ((*cb)(dst, buffer, (int)(bufptr - buffer)) < 0)
 	              {
 	        	DEBUG_puts("ippWrite: Could not write IPP attribute...");
 	        	return (IPP_ERROR);
@@ -2176,7 +2195,7 @@
 
                   if ((int)(sizeof(buffer) - (bufptr - buffer)) < (n + 2))
 		  {
-                    if ((*cb)(dst, buffer, bufptr - buffer) < 0)
+                    if ((*cb)(dst, buffer, (int)(bufptr - buffer)) < 0)
 	            {
 	              DEBUG_puts("ippWrite: Could not write IPP attribute...");
 	              return (IPP_ERROR);
@@ -2203,7 +2222,7 @@
 	  * Write the data out...
 	  */
 
-          if ((*cb)(dst, buffer, bufptr - buffer) < 0)
+          if ((*cb)(dst, buffer, (int)(bufptr - buffer)) < 0)
 	  {
 	    DEBUG_puts("ippWrite: Could not write IPP attribute...");
 	    return (IPP_ERROR);
@@ -2635,5 +2654,5 @@
 
 
 /*
- * End of "$Id: ipp.c 4730 2005-09-30 21:45:34Z mike $".
+ * End of "$Id: ipp.c 4828 2005-11-11 12:53:38Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/language.c cupsys-1.1.99.b1.r4748/cups/language.c
--- cupsys-1.1.99.b1.r4748~/cups/language.c	2005-09-24 01:59:47.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/language.c	2005-11-11 21:53:38.810647000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: language.c 4694 2005-09-23 16:59:47Z mike $"
+ * "$Id: language.c 4828 2005-11-11 12:53:38Z mike $"
  *
  *   I18N/language support for the Common UNIX Printing System (CUPS).
  *
@@ -594,7 +594,7 @@
     return (NULL);
   }
 
-  i = strlen(line) - 1;
+  i = (int)strlen(line) - 1;
   if (line[i] == '\n')
     line[i] = '\0';	/* Strip LF */
 
@@ -685,7 +685,7 @@
     * Ignore blank lines...
     */
 
-    i = strlen(line) - 1;
+    i = (int)strlen(line) - 1;
     if (line[i] == '\n')
       line[i] = '\0';	/* Strip LF */
 
@@ -1062,5 +1062,5 @@
 
 
 /*
- * End of "$Id: language.c 4694 2005-09-23 16:59:47Z mike $".
+ * End of "$Id: language.c 4828 2005-11-11 12:53:38Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/md5passwd.c cupsys-1.1.99.b1.r4748/cups/md5passwd.c
--- cupsys-1.1.99.b1.r4748~/cups/md5passwd.c	2005-05-13 04:47:56.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/md5passwd.c	2005-11-11 21:53:38.810647000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: md5passwd.c 4512 2005-05-12 19:47:56Z mike $"
+ * "$Id: md5passwd.c 4828 2005-11-11 12:53:38Z mike $"
  *
  *   MD5 password support for the Common UNIX Printing System (CUPS).
  *
@@ -60,7 +60,7 @@
 
   snprintf(line, sizeof(line), "%s:%s:%s", username, realm, passwd);
   _cups_md5_init(&state);
-  _cups_md5_append(&state, (unsigned char *)line, strlen(line));
+  _cups_md5_append(&state, (unsigned char *)line, (int)strlen(line));
   _cups_md5_finish(&state, sum);
 
  /*
@@ -95,7 +95,7 @@
 
   snprintf(line, sizeof(line), "%s:%s", method, resource);
   _cups_md5_init(&state);
-  _cups_md5_append(&state, (unsigned char *)line, strlen(line));
+  _cups_md5_append(&state, (unsigned char *)line, (int)strlen(line));
   _cups_md5_finish(&state, sum);
   httpMD5String(sum, a2);
 
@@ -108,7 +108,7 @@
   snprintf(line, sizeof(line), "%s:%s:%s", md5, nonce, a2);
 
   _cups_md5_init(&state);
-  _cups_md5_append(&state, (unsigned char *)line, strlen(line));
+  _cups_md5_append(&state, (unsigned char *)line, (int)strlen(line));
   _cups_md5_finish(&state, sum);
 
   return (httpMD5String(sum, md5));
@@ -147,5 +147,5 @@
 
 
 /*
- * End of "$Id: md5passwd.c 4512 2005-05-12 19:47:56Z mike $".
+ * End of "$Id: md5passwd.c 4828 2005-11-11 12:53:38Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/normalize.c cupsys-1.1.99.b1.r4748/cups/normalize.c
--- cupsys-1.1.99.b1.r4748~/cups/normalize.c	2005-09-22 11:15:56.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/normalize.c	2005-11-11 21:53:38.810647000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: normalize.c 4684 2005-09-22 02:15:56Z mike $"
+ * "$Id: normalize.c 4828 2005-11-11 12:53:38Z mike $"
  *
  *   Unicode normalization for the Common UNIX Printing System (CUPS).
  *
@@ -847,7 +847,7 @@
 
   cupsNormalizeMapsFree();
 
-  return (dest - start);
+  return ((int)(dest - start));
 }
 
 
@@ -1680,7 +1680,7 @@
 get_propmap(void)
 {
   int			i, j;		/* Looping variables */
-  int			len;		/* String length */
+  size_t		len;		/* String length */
   cups_utf32_t		unichar;	/* Unicode character value */
   cups_gencat_t		gencat;		/* General Category Value */
   cups_bidi_t	bidicat;	/* Bidi Category Value */
@@ -2193,5 +2193,5 @@
 
 
 /*
- * End of "$Id: normalize.c 4684 2005-09-22 02:15:56Z mike $"
+ * End of "$Id: normalize.c 4828 2005-11-11 12:53:38Z mike $"
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/ppd.c cupsys-1.1.99.b1.r4748/cups/ppd.c
--- cupsys-1.1.99.b1.r4748~/cups/ppd.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/ppd.c	2005-11-11 21:53:38.810647000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: ppd.c 4683 2005-09-21 22:17:44Z mike $"
+ * "$Id: ppd.c 4828 2005-11-11 12:53:38Z mike $"
  *
  *   PPD file routines for the Common UNIX Printing System (CUPS).
  *
@@ -304,6 +304,8 @@
 
 /*
  * 'ppdErrorString()' - Returns the text assocated with a status.
+ *
+ * @since CUPS 1.1.19@
  */
 
 const char *				/* O - Status string */
@@ -343,6 +345,8 @@
 
 /*
  * 'ppdLastError()' - Return the status from the last ppdOpen*().
+ *
+ * @since CUPS 1.1.19@
  */
 
 ppd_status_t				/* O - Status code */
@@ -395,6 +399,8 @@
 
 /*
  * 'ppdOpen2()' - Read a PPD file into memory.
+ *
+ * @since CUPS 1.2@
  */
 
 ppd_file_t *				/* O - PPD file record */
@@ -1030,7 +1036,7 @@
       if (name[0] == '*')
         _cups_strcpy(name, name + 1); /* Eliminate leading asterisk */
 
-      for (i = strlen(name) - 1; i > 0 && isspace(name[i] & 255); i --)
+      for (i = (int)strlen(name) - 1; i > 0 && isspace(name[i] & 255); i --)
         name[i] = '\0'; /* Eliminate trailing spaces */
 
       DEBUG_printf(("OpenUI of %s in group %s...\n", name,
@@ -2039,6 +2045,8 @@
 
 /*
  * 'ppdSetConformance()' - Set the conformance level for PPD files.
+ *
+ * @since CUPS 1.1.20@
  */
 
 void
@@ -2253,7 +2261,7 @@
 
   *outptr = '\0';
 
-  return (outptr - string);
+  return ((int)(outptr - string));
 }
 
 
@@ -3145,5 +3153,5 @@
 
 
 /*
- * End of "$Id: ppd.c 4683 2005-09-21 22:17:44Z mike $".
+ * End of "$Id: ppd.c 4828 2005-11-11 12:53:38Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/ppd.h cupsys-1.1.99.b1.r4748/cups/ppd.h
--- cupsys-1.1.99.b1.r4748~/cups/ppd.h	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/ppd.h	2005-10-14 04:39:05.160337000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: ppd.h 4612 2005-08-30 03:17:47Z mike $"
+ * "$Id: ppd.h 4785 2005-10-13 19:39:05Z mike $"
  *
  *   PostScript Printer Description definitions for the Common UNIX Printing
  *   System (CUPS).
@@ -101,7 +101,7 @@
   PPD_CS_N			/* DeviceN colorspace */
 } ppd_cs_t;
 
-typedef enum ppd_status_e	/**** Status Codes ****/
+typedef enum ppd_status_e	/**** Status Codes @since CUPS 1.1.19@ ****/
 {
   PPD_OK = 0,			/* OK */
   PPD_FILE_OPEN_ERROR,		/* Unable to open PPD file */
@@ -131,7 +131,7 @@
   PPD_CONFORM_STRICT		/* Require strict conformance */
 } ppd_conform_t;
 
-typedef struct ppd_attr_str	/**** PPD Attribute Structure ****/
+typedef struct ppd_attr_str	/**** PPD Attribute Structure @since CUPS 1.1.19@ ****/
 {
   char		name[PPD_MAX_NAME];
   				/* Name of attribute (cupsXYZ) */
@@ -181,7 +181,7 @@
   char		text[PPD_MAX_TEXT - PPD_MAX_NAME];
   				/* Human-readable group name */
   char		name[PPD_MAX_NAME];
-				/* Group name */
+				/* Group name @since CUPS 1.1.18@ */
   int		num_options;	/* Number of options */
   ppd_option_t	*options;	/* Options */
   int		num_subgroups;	/* Number of sub-groups */
@@ -227,7 +227,7 @@
   char		resolution[PPD_MAX_NAME];
   				/* Resolution or "-" */
   char		media_type[PPD_MAX_NAME];
-				/* Media type of "-" */
+				/* Media type or "-" */
   float		density;	/* Ink density to use */
   float		gamma;		/* Gamma correction to use */
   float		matrix[3][3];	/* Transform matrix */
@@ -235,7 +235,7 @@
 
 /**** New in CUPS 1.2 ****/
 #  if 0
-typedef enum ppd_ext_ui_e	/**** Extended UI Types ****/
+typedef enum ppd_ext_ui_e	/**** Extended UI Types @since CUPS 1.2@ ****/
 {
   PPD_UI_CUPS_TEXT,		/* Specify a string */
   PPD_UI_CUPS_INTEGER,		/* Specify an integer number */
@@ -247,7 +247,7 @@
   PPD_UI_CUPS_XY_ARRAY		/* Specify an array of X/Y real numbers */
 } ppd_ext_ui_t;
 
-typedef union ppd_ext_value_u	/**** Extended Values ****/
+typedef union ppd_ext_value_u	/**** Extended Values @since CUPS 1.2@ ****/
 {
   char		*text;		/* Text value */
   int		integer;	/* Integer value */
@@ -276,7 +276,7 @@
   }		xy_array;	/* XY array value */
 } ppd_ext_value_t;
 
-typedef struct ppd_ext_param_str/**** Extended Parameter ****/
+typedef struct ppd_ext_param_str/**** Extended Parameter @since CUPS 1.2@ ****/
 {
   char		keyword[PPD_MAX_NAME];
 				/* Parameter name */
@@ -289,7 +289,7 @@
 } ppd_ext_param_t;
 
 typedef struct ppd_ext_option_str
-				/**** Extended Options ****/
+				/**** Extended Options @since CUPS 1.2@ ****/
 {
   char		keyword[PPD_MAX_NAME];
 				/* Name of option that is being extended... */
@@ -345,19 +345,19 @@
   char		**filters;	/* Filter strings... */
 
   /**** New in CUPS 1.1 ****/
-  int		flip_duplex;	/* 1 = Flip page for back sides */
+  int		flip_duplex;	/* 1 = Flip page for back sides @since CUPS 1.1@ */
 
   /**** New in CUPS 1.1.19 ****/
-  char		*protocols;	/* Protocols (BCP, TBCP) string */
-  char		*pcfilename;	/* PCFileName string */
-  int		num_attrs;	/* Number of attributes */
-  int		cur_attr;	/* Current attribute */
-  ppd_attr_t	**attrs;	/* Attributes */
+  char		*protocols;	/* Protocols (BCP, TBCP) string @since CUPS 1.1.19@ */
+  char		*pcfilename;	/* PCFileName string @since CUPS 1.1.19@ */
+  int		num_attrs;	/* Number of attributes @since CUPS 1.1.19@ */
+  int		cur_attr;	/* Current attribute @since CUPS 1.1.19@ */
+  ppd_attr_t	**attrs;	/* Attributes @since CUPS 1.1.19@ */
 
   /**** New in CUPS 1.2 ****/
 #  if 0
-  int		num_extended;	/* Number of extended options */
-  ppd_ext_option_t **extended;	/* Extended options */
+  int		num_extended;	/* Number of extended options @since CUPS 1.2@ */
+  ppd_ext_option_t **extended;	/* Extended options @since CUPS 1.2@ */
 #  endif /* 0 */
 } ppd_file_t;
 
@@ -417,5 +417,5 @@
 #endif /* !_CUPS_PPD_H_ */
 
 /*
- * End of "$Id: ppd.h 4612 2005-08-30 03:17:47Z mike $".
+ * End of "$Id: ppd.h 4785 2005-10-13 19:39:05Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/tempfile.c cupsys-1.1.99.b1.r4748/cups/tempfile.c
--- cupsys-1.1.99.b1.r4748~/cups/tempfile.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/tempfile.c	2005-10-14 04:39:05.160337000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: tempfile.c 4683 2005-09-21 22:17:44Z mike $"
+ * "$Id: tempfile.c 4785 2005-10-13 19:39:05Z mike $"
  *
  *   Temp file utilities for the Common UNIX Printing System (CUPS).
  *
@@ -200,6 +200,8 @@
 
 /*
  * 'cupsTempFile2()' - Create a temporary CUPS file.
+ *
+ * @since CUPS 1.2@
  */
 
 cups_file_t *				/* O - CUPS file or NULL on error */
@@ -224,5 +226,5 @@
 
 
 /*
- * End of "$Id: tempfile.c 4683 2005-09-21 22:17:44Z mike $".
+ * End of "$Id: tempfile.c 4785 2005-10-13 19:39:05Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/testarray.c cupsys-1.1.99.b1.r4748/cups/testarray.c
--- cupsys-1.1.99.b1.r4748~/cups/testarray.c	2005-09-30 23:52:11.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/testarray.c	2005-11-05 00:57:50.182805000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: testarray.c 4728 2005-09-30 14:52:11Z mike $"
+ * "$Id: testarray.c 4816 2005-11-04 15:57:50Z mike $"
  *
  *   Array test program for the Common UNIX Printing System (CUPS).
  *
@@ -368,6 +368,25 @@
   }
 
  /*
+  * Test deleting with iteration...
+  */
+
+  fputs("Delete While Iterating: ", stdout);
+
+  text = (char *)cupsArrayFirst(array);
+  cupsArrayRemove(array, text);
+  free(text);
+
+  text = (char *)cupsArrayNext(array);
+  if (!text)
+  {
+    puts("FAIL (cupsArrayNext returned NULL!)");
+    status ++;
+  }
+  else
+    puts("PASS");
+    
+ /*
   * Delete the arrays...
   */
 
@@ -452,5 +471,5 @@
 
 
 /*
- * End of "$Id: testarray.c 4728 2005-09-30 14:52:11Z mike $".
+ * End of "$Id: testarray.c 4816 2005-11-04 15:57:50Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/testfile.c cupsys-1.1.99.b1.r4748/cups/testfile.c
--- cupsys-1.1.99.b1.r4748~/cups/testfile.c	1970-01-01 09:00:00.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/testfile.c	2005-10-08 13:01:46.842221000 +0900
@@ -0,0 +1,400 @@
+/*
+ * "$Id: testfile.c 4754 2005-10-08 04:01:46Z mike $"
+ *
+ *   File test program for the Common UNIX Printing System (CUPS).
+ *
+ *   Copyright 1997-2005 by Easy Software Products.
+ *
+ *   These coded instructions, statements, and computer programs are the
+ *   property of Easy Software Products and are protected by Federal
+ *   copyright law.  Distribution and use rights are outlined in the file
+ *   "LICENSE.txt" which should have been included with this file.  If this
+ *   file is missing or damaged please contact Easy Software Products
+ *   at:
+ *
+ *       Attn: CUPS Licensing Information
+ *       Easy Software Products
+ *       44141 Airport View Drive, Suite 204
+ *       Hollywood, Maryland 20636 USA
+ *
+ *       Voice: (301) 373-9600
+ *       EMail: cups-info@cups.org
+ *         WWW: http://www.cups.org
+ *
+ *   This file is subject to the Apple OS-Developed Software exception.
+ *
+ * Contents:
+ *
+ *   main() - Main entry.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <time.h>
+#include "string.h"
+#include "file.h"
+#include "debug.h"
+#include <zlib.h>
+
+
+/*
+ * Local functions...
+ */
+
+static int	read_write_tests(int compression);
+
+
+/*
+ * 'main()' - Main entry.
+ */
+
+int					/* O - Exit status */
+main(int  argc,				/* I - Number of command-line arguments */
+     char *argv[])			/* I - Command-line arguments */
+{
+  int		status;			/* Exit status */
+
+
+ /*
+  * Do uncompressed file tests...
+  */
+
+  status = read_write_tests(0);
+
+#ifdef HAVE_LIBZ
+ /*
+  * Do compressed file tests...
+  */
+
+  putchar('\n');
+
+  status += read_write_tests(1);
+#endif /* HAVE_LIBZ */
+
+ /*
+  * Summarize the results and return...
+  */
+
+  if (!status)
+    puts("\nALL TESTS PASSED!");
+  else
+    printf("\n%d TEST(S) FAILED!\n", status);
+
+  return (status);
+}
+
+
+/*
+ * 'read_write_tests()' - Perform read/write tests.
+ */
+
+static int				/* O - Status */
+read_write_tests(int compression)	/* I - Use compression? */
+{
+  int		i;			/* Looping var */
+  cups_file_t	*fp;			/* First file */
+  int		status;			/* Exit status */
+  char		line[1024],		/* Line from file */
+		*value;			/* Directive value from line */
+  int		linenum;		/* Line number */
+  unsigned char	readbuf[8192],		/* Read buffer */
+		writebuf[8192];		/* Write buffer */
+  int		byte;			/* Byte from file */
+
+
+ /*
+  * No errors so far...
+  */
+
+  status = 0;
+
+ /*
+  * Initialize the write buffer with random data...
+  */
+
+  srand(time(NULL));
+  for (i = 0; i < (int)sizeof(writebuf); i ++)
+    writebuf[i] = rand();
+
+ /*
+  * cupsFileOpen(write)
+  */
+
+  printf("cupsFileOpen(write%s): ", compression ? " compressed" : "");
+
+  fp = cupsFileOpen(compression ? "testfile.dat.gz" : "testfile.dat",
+                    compression ? "w9" : "w");
+  if (fp)
+  {
+    puts("PASS");
+
+   /*
+    * cupsFileCompression()
+    */
+
+    fputs("cupsFileCompression(): ", stdout);
+
+    if (cupsFileCompression(fp) == compression)
+      puts("PASS");
+    else
+    {
+      printf("FAIL (Got %d, expected %d)\n", cupsFileCompression(fp),
+             compression);
+      status ++;
+    }
+
+   /*
+    * cupsFilePuts()
+    */
+
+    fputs("cupsFilePuts(): ", stdout);
+
+    if (cupsFilePuts(fp, "# Hello, World\n") > 0)
+      puts("PASS");
+    else
+    {
+      printf("FAIL (%s)\n", strerror(errno));
+      status ++;
+    }
+
+   /*
+    * cupsFilePrintf()
+    */
+
+    fputs("cupsFilePrintf(): ", stdout);
+
+    for (i = 0; i < 1000; i ++)
+      if (cupsFilePrintf(fp, "TestLine %d\n", i) < 0)
+        break;
+
+    if (i >= 1000)
+      puts("PASS");
+    else
+    {
+      printf("FAIL (%s)\n", strerror(errno));
+      status ++;
+    }
+
+   /*
+    * cupsFilePutChar()
+    */
+
+    fputs("cupsFilePutChar(): ", stdout);
+
+    for (i = 0; i < 256; i ++)
+      if (cupsFilePutChar(fp, i) < 0)
+        break;
+
+    if (i >= 256)
+      puts("PASS");
+    else
+    {
+      printf("FAIL (%s)\n", strerror(errno));
+      status ++;
+    }
+
+   /*
+    * cupsFileWrite()
+    */
+
+    fputs("cupsFileWrite(): ", stdout);
+
+    for (i = 0; i < 100; i ++)
+      if (cupsFileWrite(fp, (char *)writebuf, sizeof(writebuf)) < 0)
+        break;
+
+    if (i >= 100)
+      puts("PASS");
+    else
+    {
+      printf("FAIL (%s)\n", strerror(errno));
+      status ++;
+    }
+
+   /*
+    * cupsFileClose()
+    */
+
+    fputs("cupsFileClose(): ", stdout);
+
+    if (!cupsFileClose(fp))
+      puts("PASS");
+    else
+    {
+      printf("FAIL (%s)\n", strerror(errno));
+      status ++;
+    }
+  }
+  else
+  {
+    printf("FAIL (%s)\n", strerror(errno));
+    status ++;
+  }
+
+ /*
+  * cupsFileOpen(read)
+  */
+
+  fputs("cupsFileOpen(read): ", stdout);
+
+  fp = cupsFileOpen(compression ? "testfile.dat.gz" : "testfile.dat", "r");
+  if (fp)
+  {
+    puts("PASS");
+
+   /*
+    * cupsFileGets()
+    */
+
+    fputs("cupsFileGets(): ", stdout);
+
+    if (cupsFileGets(fp, line, sizeof(line)))
+    {
+      if (line[0] == '#')
+        puts("PASS");
+      else
+      {
+        printf("FAIL (Got line \"%s\", expected comment line)\n", line);
+	status ++;
+      }
+    }
+    else
+    {
+      printf("FAIL (%s)\n", strerror(errno));
+      status ++;
+    }
+
+   /*
+    * cupsFileCompression()
+    */
+
+    fputs("cupsFileCompression(): ", stdout);
+
+    if (cupsFileCompression(fp) == compression)
+      puts("PASS");
+    else
+    {
+      printf("FAIL (Got %d, expected %d)\n", cupsFileCompression(fp),
+             compression);
+      status ++;
+    }
+
+   /*
+    * cupsFileGetConf()
+    */
+
+    linenum = 1;
+
+    fputs("cupsFileGetConf(): ", stdout);
+
+    for (i = 0; i < 1000; i ++)
+      if (!cupsFileGetConf(fp, line, sizeof(line), &value, &linenum))
+        break;
+      else if (strcasecmp(line, "TestLine") || !value || atoi(value) != i ||
+               linenum != (i + 2))
+        break;
+
+    if (i >= 1000)
+      puts("PASS");
+    else if (line[0])
+    {
+      printf("FAIL (Line %d, directive \"%s\", value \"%s\")\n", linenum,
+             line, value ? value : "(null)");
+      status ++;
+    }
+    else
+    {
+      printf("FAIL (%s)\n", strerror(errno));
+      status ++;
+    }
+
+   /*
+    * cupsGetChar()
+    */
+
+    fputs("cupsGetChar(): ", stdout);
+
+    for (i = 0; i < 256; i ++)
+      if ((byte = cupsFileGetChar(fp)) != i)
+        break;
+
+    if (i >= 256)
+      puts("PASS");
+    else if (byte >= 0)
+    {
+      printf("FAIL (Got %d, expected %d)\n", byte, i);
+      status ++;
+    }
+    else
+    {
+      printf("FAIL (%s)\n", strerror(errno));
+      status ++;
+    }
+
+   /*
+    * cupsFileRead()
+    */
+
+    fputs("cupsFileRead(): ", stdout);
+
+    for (i = 0; i < 100; i ++)
+      if ((byte = cupsFileRead(fp, (char *)readbuf, sizeof(readbuf))) < 0)
+        break;
+      else if (memcmp(readbuf, writebuf, sizeof(readbuf)))
+        break;
+
+    if (i >= 100)
+      puts("PASS");
+    else if (byte > 0)
+    {
+      printf("FAIL (Pass %d, ", i);
+
+      for (i = 0; i < (int)sizeof(readbuf); i ++)
+        if (readbuf[i] != writebuf[i])
+	  break;
+
+      printf("match failed at offset %d - got %02X, expected %02X)\n",
+             i, readbuf[i], writebuf[i]);
+    }
+    else
+    {
+      printf("FAIL (%s)\n", strerror(errno));
+      status ++;
+    }
+
+   /*
+    * cupsFileClose()
+    */
+
+    fputs("cupsFileClose(): ", stdout);
+
+    if (!cupsFileClose(fp))
+      puts("PASS");
+    else
+    {
+      printf("FAIL (%s)\n", strerror(errno));
+      status ++;
+    }
+  }
+  else
+  {
+    printf("FAIL (%s)\n", strerror(errno));
+    status ++;
+  }
+
+ /*
+  * Return the test status...
+  */
+
+  return (status);
+}
+
+
+/*
+ * End of "$Id: testfile.c 4754 2005-10-08 04:01:46Z mike $".
+ */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/testhttp.c cupsys-1.1.99.b1.r4748/cups/testhttp.c
--- cupsys-1.1.99.b1.r4748~/cups/testhttp.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/testhttp.c	2005-10-22 04:43:55.562625000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: testhttp.c 4730 2005-09-30 21:45:34Z mike $"
+ * "$Id: testhttp.c 4809 2005-10-21 19:43:55Z mike $"
  *
  *   HTTP test program for the Common UNIX Printing System (CUPS).
  *
@@ -39,6 +39,124 @@
 
 
 /*
+ * Types and structures...
+ */
+
+typedef struct uri_test_s		/**** URI test cases ****/
+{
+  http_uri_status_t	result;		/* Expected return value */
+  const char		*uri,		/* URI */
+			*scheme,	/* Scheme string */
+			*username,	/* Username:password string */
+			*hostname,	/* Hostname string */
+			*resource;	/* Resource string */
+  int			port,		/* Port number */
+			assemble_port;	/* Port number for httpAssembleURI() */
+} uri_test_t;
+
+
+/*
+ * Local globals...
+ */
+
+static uri_test_t	uri_tests[] =	/* URI test data */
+			{
+			  /* Start with valid URIs */
+			  { HTTP_URI_OK, "file:/filename",
+			    "file", "", "", "/filename", 0, 0 },
+			  { HTTP_URI_OK, "file:/filename%20with%20spaces",
+			    "file", "", "", "/filename with spaces", 0, 0 },
+			  { HTTP_URI_OK, "file:///filename",
+			    "file", "", "", "/filename", 0, 0 },
+			  { HTTP_URI_OK, "file:///filename%20with%20spaces",
+			    "file", "", "", "/filename with spaces", 0, 0 },
+			  { HTTP_URI_OK, "file://localhost/filename",
+			    "file", "", "localhost", "/filename", 0, 0 },
+			  { HTTP_URI_OK, "file://localhost/filename%20with%20spaces",
+			    "file", "", "localhost", "/filename with spaces", 0, 0 },
+			  { HTTP_URI_OK, "http://server/",
+			    "http", "", "server", "/", 80, 0 },
+			  { HTTP_URI_OK, "http://username@server/",
+			    "http", "username", "server", "/", 80, 0 },
+			  { HTTP_URI_OK, "http://username:passwor%64@server/",
+			    "http", "username:password", "server", "/", 80, 0 },
+			  { HTTP_URI_OK, "http://username:passwor%64@server:8080/",
+			    "http", "username:password", "server", "/", 8080, 8080 },
+			  { HTTP_URI_OK, "http://username:passwor%64@server:8080/directory/filename",
+			    "http", "username:password", "server", "/directory/filename", 8080, 8080 },
+			  { HTTP_URI_OK, "https://username:passwor%64@server/directory/filename",
+			    "https", "username:password", "server", "/directory/filename", 443, 0 },
+			  { HTTP_URI_OK, "ipp://username:passwor%64@[::1]/ipp",
+			    "ipp", "username:password", "::1", "/ipp", 631, 0 },
+			  { HTTP_URI_OK, "lpd://server/queue?reserve=yes",
+			    "lpd", "", "server", "/queue?reserve=yes", 515, 0 },
+			  { HTTP_URI_OK, "mailto:user@domain.com",
+			    "mailto", "", "", "user@domain.com", 0, 0 },
+			  { HTTP_URI_OK, "socket://server/",
+			    "socket", "", "server", "/", 9100, 0 },
+			  { HTTP_URI_OK, "ipp://username:password@[v1.fe80::200:1234:5678:9abc+eth0]:999/ipp",
+			    "ipp", "username:password", "fe80::200:1234:5678:9abc%eth0", "/ipp", 999, 999 },
+
+			  /* Missing scheme */
+			  { HTTP_URI_MISSING_SCHEME, "/path/to/file/index.html",
+			    "file", "", "", "/path/to/file/index.html", 0, 0 },
+			  { HTTP_URI_MISSING_SCHEME, "//server/ipp",
+			    "ipp", "", "server", "/ipp", 631, 0 },
+
+			  /* Unknown scheme */
+			  { HTTP_URI_UNKNOWN_SCHEME, "vendor://server/resource",
+			    "vendor", "", "server", "/resource", 0, 0 },
+
+			  /* Missing resource */
+			  { HTTP_URI_MISSING_RESOURCE, "socket://[::192.168.2.1]",
+			    "socket", "", "::192.168.2.1", "/", 9100, 0 },
+
+			  /* Bad URI */
+			  { HTTP_URI_BAD_URI, "",
+			    "", "", "", "", 0, 0 },
+
+			  /* Bad scheme */
+			  { HTTP_URI_BAD_SCHEME, "bad_scheme://server/resource",
+			    "", "", "", "", 0, 0 },
+
+			  /* Bad username */
+			  { HTTP_URI_BAD_USERNAME, "http://username:passwor%6@server/resource",
+			    "http", "", "", "", 80, 0 },
+
+			  /* Bad hostname */
+			  { HTTP_URI_BAD_HOSTNAME, "http://[/::1]/index.html",
+			    "http", "", "", "", 80, 0 },
+			  { HTTP_URI_BAD_HOSTNAME, "http://[",
+			    "http", "", "", "", 80, 0 },
+			  { HTTP_URI_BAD_HOSTNAME, "http://serve%7/index.html",
+			    "http", "", "", "", 80, 0 },
+
+			  /* Bad port number */
+			  { HTTP_URI_BAD_PORT, "http://127.0.0.1:9999a/index.html",
+			    "http", "", "127.0.0.1", "", 0, 0 },
+
+			  /* Bad resource */
+			  { HTTP_URI_BAD_RESOURCE, "http://server/index.html%",
+			    "http", "", "server", "", 80, 0 }
+			};
+static const char * const base64_tests[][2] =
+			{
+			  { "A", "QQ==" },
+			  /* 010000 01 */
+			  { "AB", "QUI=" },
+			  /* 010000 010100 0010 */
+			  { "ABC", "QUJD" },
+			  /* 010000 010100 001001 000011 */
+			  { "ABCD", "QUJDRA==" },
+			  /* 010000 010100 001001 000011 010001 00 */
+			  { "ABCDE", "QUJDREU=" },
+			  /* 010000 010100 001001 000011 010001 000100 0101 */
+			  { "ABCDEF", "QUJDREVG" },
+			  /* 010000 010100 001001 000011 010001 000100 010101 000110 */
+			};
+
+
+/*
  * 'main()' - Main entry.
  */
 
@@ -46,149 +164,351 @@
 main(int  argc,				/* I - Number of command-line arguments */
      char *argv[])			/* I - Command-line arguments */
 {
-  int		i, j;			/* Looping vars */
+  int		i, j, k;		/* Looping vars */
   http_t	*http;			/* HTTP connection */
-  struct hostent *hostaddr;		/* Host address */
   http_status_t	status;			/* Status of GET command */
+  int		failures;		/* Number of test failures */
   char		buffer[8192];		/* Input buffer */
   long		bytes;			/* Number of bytes read */
   FILE		*out;			/* Output file */
+  char		encode[256],		/* Base64-encoded string */
+		decode[256];		/* Base64-decoded string */
+  int		decodelen;		/* Length of decoded string */
   char		scheme[HTTP_MAX_URI],	/* Scheme from URI */
-		host[HTTP_MAX_URI],	/* Hostname from URI */
+		hostname[HTTP_MAX_URI],	/* Hostname from URI */
 		username[HTTP_MAX_URI],	/* Username:password from URI */
 		resource[HTTP_MAX_URI];	/* Resource from URI */
   int		port;			/* Port number from URI */
+  http_uri_status_t uri_status;		/* Status of URI separation */
+  http_addrlist_t *addrlist,		/* Address list */
+		*addr;			/* Current address */
   off_t		length, total;		/* Length and total bytes */
   time_t	start, current;		/* Start and end time */
+  static const char * const uri_status_strings[] =
+		{
+		  "HTTP_URI_OVERFLOW",
+		  "HTTP_URI_BAD_ARGUMENTS",
+		  "HTTP_URI_BAD_RESOURCE",
+		  "HTTP_URI_BAD_PORT",
+		  "HTTP_URI_BAD_HOSTNAME",
+		  "HTTP_URI_BAD_USERNAME",
+		  "HTTP_URI_BAD_SCHEME",
+		  "HTTP_URI_BAD_URI",
+		  "HTTP_URI_OK",
+		  "HTTP_URI_MISSING_SCHEME",
+		  "HTTP_URI_UNKNOWN_SCHEME",
+		  "HTTP_URI_MISSING_RESOURCE"
+		};
 
 
+ /*
+  * Do API tests if we don't have a URL on the command-line...
+  */
+
   if (argc == 1)
   {
+    failures = 0;
+
    /*
-    * Do API tests...
+    * httpGetDateString()/httpGetDateTime()
     */
 
+    fputs("httpGetDateString()/httpGetDateTime(): ", stdout);
+
     start = time(NULL);
     strcpy(buffer, httpGetDateString(start));
     current = httpGetDateTime(buffer);
 
-    printf("httpGetDateString(%d) returned \"%s\"\n", (int)start, buffer);
-    printf("httpGetDateTime(\"%s\") returned %d\n", buffer, (int)current);
-    printf("httpGetDateString(%d) returned \"%s\"\n", (int)current,
-           httpGetDateString(current));
-
     i = (int)(current - start);
     if (i < 0)
       i = -i;
 
-    printf("Difference is %d seconds, %02d:%02d:%02d...\n", i, i / 3600,
-           (i / 60) % 60, i % 60);
+    if (!i)
+      puts("PASS");
+    else
+    {
+      failures ++;
+      puts("FAIL");
+      printf("    Difference is %d seconds, %02d:%02d:%02d...\n", i, i / 3600,
+             (i / 60) % 60, i % 60);
+      printf("    httpGetDateString(%d) returned \"%s\"\n", (int)start, buffer);
+      printf("    httpGetDateTime(\"%s\") returned %d\n", buffer, (int)current);
+      printf("    httpGetDateString(%d) returned \"%s\"\n", (int)current,
+             httpGetDateString(current));
+    }
 
    /*
-    * Test address functions...
+    * httpDecode64_2()/httpEncode64_2()
     */
 
-    printf("httpGetHostname() returned \"%s\"...\n",
-           httpGetHostname(buffer, sizeof(buffer)));
+    fputs("httpDecode64_2()/httpEncode64_2(): ", stdout);
 
-    hostaddr = httpGetHostByName("localhost");
-    printf("httpGetHostByName(\"localhost\") returned %p...\n", hostaddr);
-    if (hostaddr)
+    for (i = 0, j = 0; i < (int)(sizeof(base64_tests) / sizeof(base64_tests[0])); i ++)
     {
-      printf("    h_name=\"%s\"\n", hostaddr->h_name);
-      if (hostaddr->h_aliases)
+      httpEncode64_2(encode, sizeof(encode), base64_tests[i][0],
+                     strlen(base64_tests[i][0]));
+      decodelen = (int)sizeof(decode);
+      httpDecode64_2(decode, &decodelen, base64_tests[i][1]);
+
+      if (strcmp(decode, base64_tests[i][0]))
       {
-        for (i = 0; hostaddr->h_aliases[i]; i ++)
-          printf("    h_aliases[%d]=\"%s\"\n", i, hostaddr->h_aliases[i]);
+        failures ++;
+
+        if (j)
+	{
+	  puts("FAIL");
+	  j = 1;
+	}
+
+        printf("    httpDecode64_2() returned \"%s\", expected \"%s\"...\n",
+	       decode, base64_tests[i][0]);
       }
-      printf("    h_addrtype=%s\n",
-             hostaddr->h_addrtype == AF_INET ? "AF_INET" :
-#ifdef AF_INET6
-                 hostaddr->h_addrtype == AF_INET6 ? "AF_INET6" :
-#endif /* AF_INET6 */
-#ifdef AF_LOCAL
-                 hostaddr->h_addrtype == AF_LOCAL ? "AF_LOCAL" :
-#endif /* AF_LOCAL */
-                 "UNKNOWN");
-      printf("    h_length=%d\n", hostaddr->h_length);
-      for (i = 0; hostaddr->h_addr_list[i]; i ++)
+
+      if (strcmp(encode, base64_tests[i][1]))
       {
-        printf("    h_addr_list[%d]=", i);
-	for (j = 0; j < hostaddr->h_length; j ++)
-	  printf("%02X", hostaddr->h_addr_list[i][j] & 255);
-	putchar('\n');
+        failures ++;
+
+        if (j)
+	{
+	  puts("FAIL");
+	  j = 1;
+	}
+
+        printf("    httpEncode64_2() returned \"%s\", expected \"%s\"...\n",
+	       encode, base64_tests[i][1]);
       }
     }
-  }
-  else
-  {
+
+    if (!j)
+      puts("PASS");
+
    /*
-    * Test HTTP GET requests...
+    * httpGetHostname()
     */
 
-    http = NULL;
-    out = stdout;
+    fputs("httpGetHostname(): ", stdout);
 
-    for (i = 1; i < argc; i ++)
+    if (httpGetHostname(hostname, sizeof(hostname)))
+      printf("PASS (%s)\n", hostname);
+    else
     {
-      if (!strcmp(argv[i], "-o"))
-      {
-	i ++;
-	out = fopen(argv[i], "wb");
-	continue;
-      }
+      failures ++;
+      puts("FAIL");
+    }
 
-      httpSeparate(argv[i], scheme, username, host, &port, resource);
+   /*
+    * httpAddrGetList()
+    */
 
-      http = httpConnect(host, port);
-      if (http == NULL)
+    fputs("httpAddrGetList(): ", stdout);
+
+    addrlist = httpAddrGetList(hostname, AF_UNSPEC, NULL);
+    if (addrlist)
+    {
+      for (i = 0, addr = addrlist; addr; i ++, addr = addr->next);
+
+      printf("PASS (%d address(es) for %s)\n", i, hostname);
+      httpAddrFreeList(addrlist);
+    }
+    else
+    {
+      failures ++;
+      puts("FAIL");
+    }
+
+   /*
+    * Test httpSeparateURI()...
+    */
+
+    fputs("httpSeparateURI(): ", stdout);
+    for (i = 0, j = 0; i < (int)(sizeof(uri_tests) / sizeof(uri_tests[0])); i ++)
+    {
+      uri_status = httpSeparateURI(uri_tests[i].uri, scheme, sizeof(scheme),
+                                   username, sizeof(username),
+				   hostname, sizeof(hostname), &port,
+				   resource, sizeof(resource));
+      if (uri_status != uri_tests[i].result ||
+          strcmp(scheme, uri_tests[i].scheme) ||
+	  strcmp(username, uri_tests[i].username) ||
+	  strcmp(hostname, uri_tests[i].hostname) ||
+	  port != uri_tests[i].port ||
+	  strcmp(resource, uri_tests[i].resource))
       {
-	perror(host);
-	continue;
-      }
-      printf("Requesting file \"%s\"...\n", resource);
-      httpClearFields(http);
-      httpSetField(http, HTTP_FIELD_ACCEPT_LANGUAGE, "en");
-      httpGet(http, resource);
-      while ((status = httpUpdate(http)) == HTTP_CONTINUE);
+        failures ++;
 
-      if (status == HTTP_OK)
-	puts("GET OK:");
-      else
-	printf("GET failed with status %d...\n", status);
+	if (!j)
+	{
+	  puts("FAIL");
+	  j = 1;
+	}
 
+        printf("    \"%s\":\n", uri_tests[i].uri);
 
-      start  = time(NULL);
-      length = httpGetLength2(http);
-      total  = 0;
+	if (uri_status != uri_tests[i].result)
+	  printf("        Returned %s instead of %s\n",
+	         uri_status_strings[uri_status + 8],
+		 uri_status_strings[uri_tests[i].result + 8]);
 
-      while ((bytes = httpRead(http, buffer, sizeof(buffer))) > 0)
+        if (strcmp(scheme, uri_tests[i].scheme))
+	  printf("        Scheme \"%s\" instead of \"%s\"\n",
+	         scheme, uri_tests[i].scheme);
+
+	if (strcmp(username, uri_tests[i].username))
+	  printf("        Username \"%s\" instead of \"%s\"\n",
+	         username, uri_tests[i].username);
+
+	if (strcmp(hostname, uri_tests[i].hostname))
+	  printf("        Hostname \"%s\" instead of \"%s\"\n",
+	         hostname, uri_tests[i].hostname);
+
+	if (port != uri_tests[i].port)
+	  printf("        Port %d instead of %d\n",
+	         port, uri_tests[i].port);
+
+	if (strcmp(resource, uri_tests[i].resource))
+	  printf("        Resource \"%s\" instead of \"%s\"\n",
+	         resource, uri_tests[i].resource);
+      }
+    }
+
+    if (!j)
+      printf("PASS (%d URIs tested)\n",
+             (int)(sizeof(uri_tests) / sizeof(uri_tests[0])));
+
+   /*
+    * Test httpAssembleURI()...
+    */
+
+    fputs("httpAssembleURI(): ", stdout);
+    for (i = 0, j = 0, k = 0;
+         i < (int)(sizeof(uri_tests) / sizeof(uri_tests[0]));
+	 i ++)
+      if (uri_tests[i].result == HTTP_URI_OK &&
+          !strstr(uri_tests[i].uri, "%64") &&
+          strstr(uri_tests[i].uri, "//"))
       {
-	total += bytes;
-	fwrite(buffer, bytes, 1, out);
-	if (out != stdout)
+        k ++;
+	uri_status = httpAssembleURI(buffer, sizeof(buffer),
+	                             uri_tests[i].scheme,
+				     uri_tests[i].username,
+	                             uri_tests[i].hostname,
+				     uri_tests[i].assemble_port,
+				     uri_tests[i].resource);
+
+        if (uri_status != HTTP_URI_OK)
 	{
-          current = time(NULL);
-          if (current == start) current ++;
-          printf("\r" CUPS_LLFMT "/" CUPS_LLFMT " bytes ("
-	         CUPS_LLFMT " bytes/sec)      ", total, length,
-        	 total / (current - start));
-          fflush(stdout);
+          failures ++;
+
+	  if (!j)
+	  {
+	    puts("FAIL");
+	    j = 1;
+	  }
+
+          printf("    \"%s\": %s\n", uri_tests[i].uri,
+	         uri_status_strings[uri_status + 8]);
+        }
+	else if (strcmp(buffer, uri_tests[i].uri))
+	{
+          failures ++;
+
+	  if (!j)
+	  {
+	    puts("FAIL");
+	    j = 1;
+	  }
+
+          printf("    \"%s\": assembled = \"%s\"\n", uri_tests[i].uri,
+	         buffer);
 	}
       }
+
+    if (!j)
+      printf("PASS (%d URIs tested)\n", k);
+
+   /*
+    * Show a summary and return...
+    */
+
+    if (failures)
+      printf("\n%d TESTS FAILED!\n", failures);
+    else
+      puts("\nALL TESTS PASSED!");
+
+    return (failures);
+  }
+
+ /*
+  * Test HTTP GET requests...
+  */
+
+  http = NULL;
+  out = stdout;
+
+  for (i = 1; i < argc; i ++)
+  {
+    if (!strcmp(argv[i], "-o"))
+    {
+      i ++;
+      if (i >= argc)
+        break;
+
+      out = fopen(argv[i], "wb");
+      continue;
     }
 
-    puts("Closing connection to server...");
-    httpClose(http);
+    httpSeparateURI(argv[i], scheme, sizeof(scheme), username, sizeof(username),
+                    hostname, sizeof(hostname), &port,
+		    resource, sizeof(resource));
 
-    if (out != stdout)
-      fclose(out);
+    http = httpConnectEncrypt(hostname, port, HTTP_ENCRYPT_IF_REQUESTED);
+    if (http == NULL)
+    {
+      perror(hostname);
+      continue;
+    }
+    printf("Requesting file \"%s\"...\n", resource);
+    httpClearFields(http);
+    httpSetField(http, HTTP_FIELD_ACCEPT_LANGUAGE, "en");
+    httpGet(http, resource);
+    while ((status = httpUpdate(http)) == HTTP_CONTINUE);
+
+    if (status == HTTP_OK)
+      puts("GET OK:");
+    else
+      printf("GET failed with status %d...\n", status);
+
+
+    start  = time(NULL);
+    length = httpGetLength2(http);
+    total  = 0;
+
+    while ((bytes = httpRead(http, buffer, sizeof(buffer))) > 0)
+    {
+      total += bytes;
+      fwrite(buffer, bytes, 1, out);
+      if (out != stdout)
+      {
+        current = time(NULL);
+        if (current == start) current ++;
+        printf("\r" CUPS_LLFMT "/" CUPS_LLFMT " bytes ("
+	       CUPS_LLFMT " bytes/sec)      ", total, length,
+               total / (current - start));
+        fflush(stdout);
+      }
+    }
   }
 
+  puts("Closing connection to server...");
+  httpClose(http);
+
+  if (out != stdout)
+    fclose(out);
+
   return (0);
 }
 
 
 /*
- * End of "$Id: testhttp.c 4730 2005-09-30 21:45:34Z mike $".
+ * End of "$Id: testhttp.c 4809 2005-10-21 19:43:55Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/testi18n.c cupsys-1.1.99.b1.r4748/cups/testi18n.c
--- cupsys-1.1.99.b1.r4748~/cups/testi18n.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/testi18n.c	2005-10-11 04:23:23.958633000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: testi18n.c 4683 2005-09-21 22:17:44Z mike $"
+ * "$Id: testi18n.c 4767 2005-10-10 19:23:23Z mike $"
  *
  *   Internationalization test for Common UNIX Printing System (CUPS).
  *
@@ -51,65 +51,72 @@
  * Local Globals...
  */
 
-static const char *program_synopsis[] =         /* Program help */
+static const char *program_synopsis[] = /* Program help */
 {
   "testi18n [-vh]",
   "         -v  verbose (print each called function and result)",
   "         -h  help (print this synopsis)",
   "",
   "'testi18n' is a utility to test CUPS internationalization",
-  "Copyright 2002 by Easy Software Products.",
+  "Copyright 1997-2005 by Easy Software Products.",
   NULL
 };
-static int      error_count = 0;                /* Total error count */
+static int	error_count = 0;	/* Total error count */
 
 
 /*
  * Local functions...
  */
 
-static void     print_synopsis(void);
-static void     print_utf8(const char *msg, const cups_utf8_t *src);
-static void     print_utf16(const char *msg, const cups_utf16_t *src);
-static void     print_utf32(const char *msg, const cups_utf32_t *src);
-static int      test_transcode(const int verbose);
-static int      test_normalize(const int verbose);
+static void	print_synopsis(void);
+static void	print_utf8(const char *msg, const cups_utf8_t *src);
+static void	print_utf16(const char *msg, const cups_utf16_t *src);
+static void	print_utf32(const char *msg, const cups_utf32_t *src);
+static int	test_transcode(const int verbose);
+static int	test_normalize(const int verbose);
 
 
 /*
  * 'main()' - Main entry for internationalization test module.
  */
-int                                     /* O - Exit code */
-main(int  argc,                         /* I - Argument Count */
-     char *argv[])                      /* I - Arguments */
+
+int					/* O - Exit code */
+main(int  argc,				/* I - Argument Count */
+     char *argv[])			/* I - Arguments */
 {
-  int           ai;                     /* Argument index */
-  char          *ap;                    /* Argument pointer */
-  int           verbose = 0;            /* Verbose flag */
-  int           errors;                 /* Error count */
+  int		ai;			/* Argument index */
+  char		*ap;			/* Argument pointer */
+  int		verbose;		/* Verbose flag */
+  int		errors;			/* Error count */
 
 
  /*
   * Check for switches...
   */
 
+  verbose = 0;
+
   for (ai = 1; ai < argc; ai ++)
   {
     ap = argv[ai];
     if (*ap != '-')
       break;
+
     for (ap ++; *ap != '\0'; ap ++)
     {
       switch (*ap)
       {
-        case 'v':                       /* verbose */
-          verbose = 1;
-          break;
-        case 'h':                       /* help */
-          print_synopsis();
-          return (0);
-        default:
-          break;
+	case 'v':			/* verbose */
+	  verbose = 1;
+	  break;
+
+	case 'h':			/* help */
+	  print_synopsis();
+	  return (0);
+
+	default:
+	  print_synopsis();
+	  return (1);
       }
     }
   }
@@ -129,6 +136,7 @@
   return (error_count > 0);
 }
 
+
 /*
  * 'print_synopsis()' - Print program synopsis (help).
  */
@@ -136,115 +144,115 @@
 static void
 print_synopsis(void)
 {
-  int           i;                      /* Looping variable */
-  const char    *line;                  /* Pointer to synopsis line */
+  int	i;				/* Looping variable */
 
 
-  for (i = 0;; i ++)
-  {
-    line = program_synopsis[i];
-    if (line == NULL)
-      break;
-    printf ("%s\n", line);
-  }
-  return;
+  for (i = 0; program_synopsis[i]; i ++)
+    puts(program_synopsis[i]);
 }
 
+
 /*
  * 'print_utf8()' - Print UTF-8 string with (optional) message.
  */
 
 void
-print_utf8(const char        *msg,      /* I - Message String */
-           const cups_utf8_t *src)      /* I - UTF-8 Source String */
+print_utf8(const char	     *msg,	/* I - Message String */
+	   const cups_utf8_t *src)	/* I - UTF-8 Source String */
 {
   if (msg != NULL)
-    printf ("%s:", msg);
+    printf("%s:", msg);
+
   for (; *src; src ++)
-    printf (" %02x", (int) *src);
-  printf ("\n");
+    printf(" %02x", *src);
+  printf("\n");
   return;
 }
 
+
 /*
  * 'print_utf16()' - Print UTF-16 string with (optional) message.
  */
 
 void
-print_utf16(const char         *msg,    /* I - Message String */
-            const cups_utf16_t *src)    /* I - UTF-16 Source String */
+print_utf16(const char	       *msg,	/* I - Message String */
+	    const cups_utf16_t *src)	/* I - UTF-16 Source String */
 {
   if (msg != NULL)
-    printf ("%s:", msg);
+    printf("%s:", msg);
   for (; *src; src ++)
-    printf (" %04x", (int) *src);
-  printf ("\n");
+    printf(" %04x", (int) *src);
+  printf("\n");
   return;
 }
 
+
 /*
  * 'print_utf32()' - Print UTF-32 string with (optional) message.
  */
 
 void
-print_utf32(const char         *msg,    /* I - Message String */
-            const cups_utf32_t *src)    /* I - UTF-32 Source String */
+print_utf32(const char	       *msg,	/* I - Message String */
+	    const cups_utf32_t *src)	/* I - UTF-32 Source String */
 {
   if (msg != NULL)
-    printf ("%s:", msg);
+    printf("%s:", msg);
   for (; *src; src ++)
-    printf (" %04x", (int) *src);
-  printf ("\n");
+    printf(" %04x", (int) *src);
+  printf("\n");
   return;
 }
 
+
 /*
  * 'test_transcode()' - Test 'transcode.c' module.
  */
 
-static int                              /* O - Zero or error count */
-test_transcode(const int verbose)       /* I - Verbose flag */
+static int				/* O - Zero or error count */
+test_transcode(const int verbose)	/* I - Verbose flag */
 {
-  FILE          *fp;                    /* File pointer */
-  int           count;                  /* File line counter */
-  char          line[1024];             /* File line source string */
-  int           len;                    /* Length (count) of string */
-  char          legsrc[1024];           /* Legacy source string */
-  char          legdest[1024];          /* Legacy destination string */
-  cups_utf8_t   utf8latin[] =           /* UTF-8 Latin-1 source */
+  FILE		*fp;			/* File pointer */
+  int		count;			/* File line counter */
+  char		line[1024];		/* File line source string */
+  int		len;			/* Length (count) of string */
+  char		legsrc[1024];		/* Legacy source string */
+  char		legdest[1024];		/* Legacy destination string */
+  cups_utf8_t	utf8latin[] =		/* UTF-8 Latin-1 source */
     { 0x41, 0x20, 0x21, 0x3D, 0x20, 0xC3, 0x84, 0x2E, 0x00 };
     /* "A != <A WITH DIAERESIS>." - use ISO 8859-1 */
-  cups_utf8_t   utf8repla[] =           /* UTF-8 Latin-1 replacement */
+  cups_utf8_t	utf8repla[] =		/* UTF-8 Latin-1 replacement */
     { 0x41, 0x20, 0xE2, 0x89, 0xA2, 0x20, 0xC3, 0x84, 0x2E, 0x00 };
     /* "A <NOT IDENTICAL TO> <A WITH DIAERESIS>." */
-  cups_utf8_t   utf8greek[] =           /* UTF-8 Greek source string */
+  cups_utf8_t	utf8greek[] =		/* UTF-8 Greek source string */
     { 0x41, 0x20, 0x21, 0x3D, 0x20, 0xCE, 0x91, 0x2E, 0x00 };
     /* "A != <ALHPA>." - use ISO 8859-7 */
-  cups_utf8_t   utf8japan[] =           /* UTF-8 Japanese source */
+  cups_utf8_t	utf8japan[] =		/* UTF-8 Japanese source */
     { 0x41, 0x20, 0x21, 0x3D, 0x20, 0xEE, 0x9C, 0x80, 0x2E, 0x00 };
     /* "A != <PRIVATE U+E700>." - use Windows 932 or EUC-JP */
-  cups_utf8_t   utf8taiwan[] =          /* UTF-8 Chinese source */
+  cups_utf8_t	utf8taiwan[] =		/* UTF-8 Chinese source */
     { 0x41, 0x20, 0x21, 0x3D, 0x20, 0xE4, 0xB9, 0x82, 0x2E, 0x00 };
     /* "A != <CJK U+4E42>." - use Windows 950 (Big5) or EUC-TW */
-  cups_utf8_t   utf8good[] =            /* UTF-8 good 16-bit source */
+  cups_utf8_t	utf8good[] =		/* UTF-8 good 16-bit source */
     { 0x41, 0x20, 0xE2, 0x89, 0xA2, 0x20, 0xC3, 0x84, 0x2E, 0x00 };
     /* "A <NOT IDENTICAL TO> <A WITH DIAERESIS>." */
-  cups_utf8_t   utf8bad[] =             /* UTF-8 bad 16-bit source */
+  cups_utf8_t	utf8bad[] =		/* UTF-8 bad 16-bit source */
     { 0x41, 0x20, 0xE2, 0x89, 0xA2, 0x20, 0xF8, 0x84, 0x2E, 0x00 };
     /* "A <NOT IDENTICAL TO> <...bad stuff...>." */
-  cups_utf8_t   utf8dest[1024];         /* UTF-8 destination string */
-  cups_utf16_t  utf16sur[] =            /* UTF-16 with surrogates */
+  cups_utf8_t	utf8dest[1024];		/* UTF-8 destination string */
+  cups_utf16_t	utf16sur[] =		/* UTF-16 with surrogates */
     { 0xD800, 0xDC00, 0x20, 0x21, 0x3D, 0x20, 0xC4, 0x2E, 0x00 };
     /* "<Surrogate pair> != <A WITH DIAERESIS>." */
-  cups_utf16_t  utf16src[1024];         /* UTF-16 source string */
-  cups_utf16_t  utf16dest[1024];        /* UTF-16 destination string */
-  cups_utf32_t  utf32src[1024];         /* UTF-32 source string */
-  cups_utf32_t  utf32dest[1024];        /* UTF-32 destination string */
-  _cups_vmap_t   *vmap;                  /* VBCS charmap pointer */
+  cups_utf16_t	utf16src[1024];		/* UTF-16 source string */
+  cups_utf16_t	utf16dest[1024];	/* UTF-16 destination string */
+  cups_utf32_t	utf32src[1024];		/* UTF-32 source string */
+  cups_utf32_t	utf32dest[1024];	/* UTF-32 destination string */
+  _cups_vmap_t	 *vmap;			 /* VBCS charmap pointer */
+
 
  /*
   * Test with (inserted) and (deleted) leading BOM...
   */
+
   if (verbose)
   {
     printf("\ntesti18n: Testing 'transcode.c'...\n");
@@ -254,38 +262,49 @@
  /*
   * Test UTF-8 to UTF-32/EUC-JP on demo file...
   */
+
   if (verbose)
   {
     printf("\ntesti18n: Testing UTF-8 source 'utf8demo.txt'...\n");
     printf(" testing UTF-8 to UTF-32...\n");
     printf(" testing UTF-8 to EUC-JP...\n");
   }
+
   if ((fp = fopen("utf8demo.txt", "r")) == NULL)
     return (1);
+
   for (count = 0;;)
   {
     if (fgets(line, 1024, fp) == NULL)
       break;
+
     count ++;
-    len = cupsUTF8ToUTF32(utf32dest, line, 1024);
+
+    len = cupsUTF8ToUTF32(utf32dest, (cups_utf8_t *)line, 1024);
     if (len < 0)
       printf(" error line: %d (UTF-8 to UTF-32)\n", count);
-    len = cupsUTF8ToCharset(legdest, line, 1024, CUPS_EUC_JP);
+
+    len = cupsUTF8ToCharset(legdest, (cups_utf8_t *)line, 1024, CUPS_EUC_JP);
     if (len < 0)
       printf(" error line: %d (UTF-8 to EUC-JP)\n", count);
   }
+
   fclose(fp);
+
   if (verbose)
     printf(" total lines: %d\n", count);
 
  /*
   * Test VBCS charmap load for EUC-JP...
   */
+
   if (verbose)
     printf("\ntesti18n: Loading VBCS charmap EUC-JP (Japanese)...\n");
+
   vmap = (_cups_vmap_t *) cupsCharmapGet(CUPS_EUC_JP);
   if (vmap == NULL)
     return (1);
+
   if (verbose)
   {
     printf(" charcount: %d\n", vmap->charcount);
@@ -295,11 +314,14 @@
  /*
   * Test VBCS charmap load for EUC-TW...
   */
+
   if (verbose)
     printf("\ntesti18n: Loading VBCS charmap EUC-TW (Taiwan)...\n");
+
   vmap = (_cups_vmap_t *) cupsCharmapGet(CUPS_EUC_TW);
   if (vmap == NULL)
     return (1);
+
   if (verbose)
   {
     printf(" charcount: %d\n", vmap->charcount);
@@ -309,24 +331,33 @@
  /*
   * Test UTF-8 to legacy charset (ISO 8859-1)...
   */
+
   if (verbose)
     printf("\ntesti18n: Testing UTF-8 to ISO 8859-1 (Latin1)...\n");
+
   legdest[0] = 0;
+
   len = cupsUTF8ToCharset(legdest, utf8latin, 1024, CUPS_ISO8859_1);
   if (len < 0)
     return (1);
+
   if (verbose)
   {
     print_utf8(" utf8latin", utf8latin);
     print_utf8(" legdest  ", (cups_utf8_t *) legdest);
   }
-  strcpy (legsrc, legdest);
+
+  strcpy(legsrc, legdest);
+
   len = cupsCharsetToUTF8(utf8dest, legsrc, 1024, CUPS_ISO8859_1);
+
   if (len < 0)
     return (1);
+
   if (len != strlen ((char *) utf8latin))
     return (1);
-  if (memcmp (utf8latin, utf8dest, len) != 0)
+
+  if (memcmp(utf8latin, utf8dest, len) != 0)
     return (1);
 
  /*
@@ -357,13 +388,13 @@
     print_utf8(" utf8greek", utf8greek);
     print_utf8(" legdest  ", (cups_utf8_t *) legdest);
   }
-  strcpy (legsrc, legdest);
+  strcpy(legsrc, legdest);
   len = cupsCharsetToUTF8(utf8dest, legsrc, 1024, CUPS_ISO8859_7);
   if (len < 0)
     return (1);
   if (len != strlen ((char *) utf8greek))
     return (1);
-  if (memcmp (utf8greek, utf8dest, len) != 0)
+  if (memcmp(utf8greek, utf8dest, len) != 0)
     return (1);
 
  /*
@@ -380,13 +411,13 @@
     print_utf8(" utf8japan", utf8japan);
     print_utf8(" legdest  ", (cups_utf8_t *) legdest);
   }
-  strcpy (legsrc, legdest);
+  strcpy(legsrc, legdest);
   len = cupsCharsetToUTF8(utf8dest, legsrc, 1024, CUPS_WINDOWS_932);
   if (len < 0)
     return (1);
   if (len != strlen ((char *) utf8japan))
     return (1);
-  if (memcmp (utf8japan, utf8dest, len) != 0)
+  if (memcmp(utf8japan, utf8dest, len) != 0)
     return (1);
 
  /*
@@ -403,13 +434,13 @@
     print_utf8(" utf8japan", utf8japan);
     print_utf8(" legdest  ", (cups_utf8_t *) legdest);
   }
-  strcpy (legsrc, legdest);
+  strcpy(legsrc, legdest);
   len = cupsCharsetToUTF8(utf8dest, legsrc, 1024, CUPS_EUC_JP);
   if (len < 0)
     return (1);
   if (len != strlen ((char *) utf8japan))
     return (1);
-  if (memcmp (utf8japan, utf8dest, len) != 0)
+  if (memcmp(utf8japan, utf8dest, len) != 0)
     return (1);
 
  /*
@@ -426,13 +457,13 @@
     print_utf8(" utf8taiwan", utf8taiwan);
     print_utf8(" legdest   ", (cups_utf8_t *) legdest);
   }
-  strcpy (legsrc, legdest);
+  strcpy(legsrc, legdest);
   len = cupsCharsetToUTF8(utf8dest, legsrc, 1024, CUPS_WINDOWS_950);
   if (len < 0)
     return (1);
   if (len != strlen ((char *) utf8taiwan))
     return (1);
-  if (memcmp (utf8taiwan, utf8dest, len) != 0)
+  if (memcmp(utf8taiwan, utf8dest, len) != 0)
     return (1);
 
  /*
@@ -449,13 +480,13 @@
     print_utf8(" utf8taiwan", utf8taiwan);
     print_utf8(" legdest   ", (cups_utf8_t *) legdest);
   }
-  strcpy (legsrc, legdest);
+  strcpy(legsrc, legdest);
   len = cupsCharsetToUTF8(utf8dest, legsrc, 1024, CUPS_EUC_TW);
   if (len < 0)
     return (1);
   if (len != strlen ((char *) utf8taiwan))
     return (1);
-  if (memcmp (utf8taiwan, utf8dest, len) != 0)
+  if (memcmp(utf8taiwan, utf8dest, len) != 0)
     return (1);
 
  /*
@@ -477,7 +508,7 @@
     return (1);
   if (len != strlen ((char *) utf8good))
     return (1);
-  if (memcmp (utf8good, utf8dest, len) != 0)
+  if (memcmp(utf8good, utf8dest, len) != 0)
     return (1);
 
  /*
@@ -510,7 +541,7 @@
     return (1);
   if (len != strlen ((char *) utf8good))
     return (1);
-  if (memcmp (utf8good, utf8dest, len) != 0)
+  if (memcmp(utf8good, utf8dest, len) != 0)
     return (1);
 
  /*
@@ -536,28 +567,29 @@
   return (0);
 }
 
+
 /*
  * 'test_normalize()' - Test 'normalize.c' module.
  */
 
-static int                              /* O - Zero or error count */
-test_normalize(const int verbose)       /* I - Verbose flag */
+static int				/* O - Zero or error count */
+test_normalize(const int verbose)	/* I - Verbose flag */
 {
-  FILE          *fp;                    /* File pointer */
-  int           count;                  /* File line counter */
-  char          line[1024];             /* File line source string */
-  int           len;                    /* Length (count) of string */
-  int           diff;                   /* Difference of two strings */
-  int           prop;                   /* Property of a character */
-  int           i;                      /* Looping variable */
-  cups_utf32_t  utf32char;              /* UTF-32 character */
-  cups_utf8_t   utf8src[1024];          /* UTF-8 source string */
-  cups_utf8_t   utf8dest[1024];         /* UTF-8 destination string */
-  cups_utf16_t  utf16src[] =            /* UTF-16 non-normal source */
+  FILE		*fp;			/* File pointer */
+  int		count;			/* File line counter */
+  char		line[1024];		/* File line source string */
+  int		len;			/* Length (count) of string */
+  int		diff;			/* Difference of two strings */
+  int		prop;			/* Property of a character */
+  int		i;			/* Looping variable */
+  cups_utf32_t	utf32char;		/* UTF-32 character */
+  cups_utf8_t	utf8src[1024];		/* UTF-8 source string */
+  cups_utf8_t	utf8dest[1024];		/* UTF-8 destination string */
+  cups_utf16_t	utf16src[] =		/* UTF-16 non-normal source */
     { 0x0149, 0x20, 0x21, 0x3D, 0x20, 0xC4, 0x2E, 0x00 };
     /* "<SMALL N PRECEDED BY APOSTROPHE> != <A WITH DIAERESIS>." */
-  cups_utf16_t  utf16dest[1024];        /* UTF-16 destination string */
-  cups_utf32_t  utf32dest[1024];        /* UTF-32 destination string */
+  cups_utf16_t	utf16dest[1024];	/* UTF-16 destination string */
+  cups_utf32_t	utf32dest[1024];	/* UTF-32 destination string */
 
   if (verbose)
     printf("\ntesti18n: Testing 'normalize.c'...\n");
@@ -579,13 +611,13 @@
     if (fgets(line, 1024, fp) == NULL)
       break;
     count ++;
-    len = cupsUTF8Normalize(utf8dest, line, 1024, CUPS_NORM_NFKD);
+    len = cupsUTF8Normalize(utf8dest, (cups_utf8_t *)line, 1024, CUPS_NORM_NFKD);
     if (len < 0)
       printf(" error line: %d (UTF-8 to NFKD)\n", count);
-    len = cupsUTF8Normalize(utf8dest, line, 1024, CUPS_NORM_NFC);
+    len = cupsUTF8Normalize(utf8dest, (cups_utf8_t *)line, 1024, CUPS_NORM_NFC);
     if (len < 0)
       printf(" error line: %d (UTF-8 to NFC)\n", count);
-    len = cupsUTF8ToUTF32(utf32dest, line, 1024);
+    len = cupsUTF8ToUTF32(utf32dest, (cups_utf8_t *)line, 1024);
     if (len < 0)
     {
       printf(" error line: %d (UTF-8 to UTF-32)\n", count);
@@ -594,21 +626,21 @@
     for (i = 0; i < len; i ++)
     {
       prop = cupsUTF32CharacterProperty(utf32dest[i],
-                                        CUPS_PROP_GENERAL_CATEGORY);
+					CUPS_PROP_GENERAL_CATEGORY);
       if (prop < 0)
-        printf(" error line: %d (Prop - General Category)\n", count);
+	printf(" error line: %d (Prop - General Category)\n", count);
       prop = cupsUTF32CharacterProperty(utf32dest[i],
-                                        CUPS_PROP_BIDI_CATEGORY);
+					CUPS_PROP_BIDI_CATEGORY);
       if (prop < 0)
-        printf(" error line: %d (Prop - Bidi Category)\n", count);
+	printf(" error line: %d (Prop - Bidi Category)\n", count);
       prop = cupsUTF32CharacterProperty(utf32dest[i],
-                                        CUPS_PROP_COMBINING_CLASS);
+					CUPS_PROP_COMBINING_CLASS);
       if (prop < 0)
-        printf(" error line: %d (Prop - Combining Class)\n", count);
+	printf(" error line: %d (Prop - Combining Class)\n", count);
       prop = cupsUTF32CharacterProperty(utf32dest[i],
-                                        CUPS_PROP_BREAK_CLASS);
+					CUPS_PROP_BREAK_CLASS);
       if (prop < 0)
-        printf(" error line: %d (Prop - Break Class)\n", count);
+	printf(" error line: %d (Prop - Break Class)\n", count);
     }
   }
   fclose(fp);
@@ -623,7 +655,7 @@
   len = cupsUTF16ToUTF8(utf8dest, utf16src, 1024);
   if (len < 0)
     return (1);
-  strcpy ((char *) utf8src, (char *) utf8dest);
+  strcpy((char *) utf8src, (char *) utf8dest);
   len = cupsUTF8Normalize(utf8dest, utf8src, 1024, CUPS_NORM_NFKD);
   if (len < 0)
     return (1);
@@ -711,12 +743,12 @@
     printf("\ntesti18n: Testing UTF-8 caseless comparison..\n");
   diff = cupsUTF8CompareCaseless(utf8src, utf8dest);
   if (verbose)
-    printf (" diff: %d\n", diff);
+    printf(" diff: %d\n", diff);
   if (verbose)
     printf("\ntesti18n: Testing UTF-8 identifier comparison..\n");
   diff = cupsUTF8CompareIdentifier(utf8src, utf8dest);
   if (verbose)
-    printf (" diff: %d\n", diff);
+    printf(" diff: %d\n", diff);
 
  /*
   * Test UTF-32 character properties...
@@ -732,17 +764,17 @@
   prop = cupsUTF32CharacterProperty (utf32char,
     CUPS_PROP_BIDI_CATEGORY);
   if (verbose)
-    printf(" utf32char: %04lx  bidi category    %d\n", utf32char, prop);
+    printf(" utf32char: %04lx  bidi category	%d\n", utf32char, prop);
   utf32char = 0x0308;
   prop = cupsUTF32CharacterProperty (utf32char,
     CUPS_PROP_COMBINING_CLASS);
   if (verbose)
-    printf(" utf32char: %04lx  combining class  %d\n", utf32char, prop);
+    printf(" utf32char: %04lx  combining class	%d\n", utf32char, prop);
   utf32char = 0x0009;
   prop = cupsUTF32CharacterProperty (utf32char,
     CUPS_PROP_BREAK_CLASS);
   if (verbose)
-    printf(" utf32char: %04lx  break class      %d\n", utf32char, prop);
+    printf(" utf32char: %04lx  break class	%d\n", utf32char, prop);
 
  /*
   * Test cupsNormalizeMapsFlush()...
@@ -755,5 +787,5 @@
 
 
 /*
- * End of "$Id: testi18n.c 4683 2005-09-21 22:17:44Z mike $"
+ * End of "$Id: testi18n.c 4767 2005-10-10 19:23:23Z mike $"
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/testmime.dsp cupsys-1.1.99.b1.r4748/cups/testmime.dsp
--- cupsys-1.1.99.b1.r4748~/cups/testmime.dsp	1999-12-21 11:26:49.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/testmime.dsp	1970-01-01 09:00:00.000000000 +0900
@@ -1,102 +0,0 @@
-# Microsoft Developer Studio Project File - Name="testmime" - Package Owner=<4>
-# Microsoft Developer Studio Generated Build File, Format Version 6.00
-# ** DO NOT EDIT **
-
-# TARGTYPE "Win32 (x86) Console Application" 0x0103
-
-CFG=testmime - Win32 Debug
-!MESSAGE This is not a valid makefile. To build this project using NMAKE,
-!MESSAGE use the Export Makefile command and run
-!MESSAGE 
-!MESSAGE NMAKE /f "testmime.mak".
-!MESSAGE 
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f "testmime.mak" CFG="testmime - Win32 Debug"
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE "testmime - Win32 Release" (based on "Win32 (x86) Console Application")
-!MESSAGE "testmime - Win32 Debug" (based on "Win32 (x86) Console Application")
-!MESSAGE 
-
-# Begin Project
-# PROP AllowPerConfigDependencies 0
-# PROP Scc_ProjName ""
-# PROP Scc_LocalPath ""
-CPP=cl.exe
-RSC=rc.exe
-
-!IF  "$(CFG)" == "testmime - Win32 Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "Release"
-# PROP BASE Intermediate_Dir "Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Release"
-# PROP Intermediate_Dir "Release"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
-# ADD CPP /nologo /MT /W3 /GX /O2 /I ".." /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
-# ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 cups.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:"testmime.exe"
-
-!ELSEIF  "$(CFG)" == "testmime - Win32 Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "testmime___Win32_Debug"
-# PROP BASE Intermediate_Dir "testmime___Win32_Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Debug"
-# PROP Intermediate_Dir "Debug"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
-# ADD CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /I ".." /I "../visualc" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
-# ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 cupsd.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /incremental:no /debug /machine:I386 /out:"testmimed.exe" /pdbtype:sept
-
-!ENDIF 
-
-# Begin Target
-
-# Name "testmime - Win32 Release"
-# Name "testmime - Win32 Debug"
-# Begin Group "Source Files"
-
-# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-# Begin Source File
-
-SOURCE=.\testmime.c
-# End Source File
-# End Group
-# Begin Group "Header Files"
-
-# PROP Default_Filter "h;hpp;hxx;hm;inl"
-# Begin Source File
-
-SOURCE=.\mime.h
-# End Source File
-# End Group
-# End Target
-# End Project
diff -urNad cupsys-1.1.99.b1.r4748~/cups/testppd.dsp cupsys-1.1.99.b1.r4748/cups/testppd.dsp
--- cupsys-1.1.99.b1.r4748~/cups/testppd.dsp	1999-12-21 11:26:49.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/testppd.dsp	1970-01-01 09:00:00.000000000 +0900
@@ -1,102 +0,0 @@
-# Microsoft Developer Studio Project File - Name="testppd" - Package Owner=<4>
-# Microsoft Developer Studio Generated Build File, Format Version 6.00
-# ** DO NOT EDIT **
-
-# TARGTYPE "Win32 (x86) Console Application" 0x0103
-
-CFG=testppd - Win32 Debug
-!MESSAGE This is not a valid makefile. To build this project using NMAKE,
-!MESSAGE use the Export Makefile command and run
-!MESSAGE 
-!MESSAGE NMAKE /f "testppd.mak".
-!MESSAGE 
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f "testppd.mak" CFG="testppd - Win32 Debug"
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE "testppd - Win32 Release" (based on "Win32 (x86) Console Application")
-!MESSAGE "testppd - Win32 Debug" (based on "Win32 (x86) Console Application")
-!MESSAGE 
-
-# Begin Project
-# PROP AllowPerConfigDependencies 0
-# PROP Scc_ProjName ""
-# PROP Scc_LocalPath ""
-CPP=cl.exe
-RSC=rc.exe
-
-!IF  "$(CFG)" == "testppd - Win32 Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "Release"
-# PROP BASE Intermediate_Dir "Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Release"
-# PROP Intermediate_Dir "Release"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
-# ADD CPP /nologo /MT /W3 /GX /O2 /I ".." /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
-# ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 cups.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:"testppd.exe"
-
-!ELSEIF  "$(CFG)" == "testppd - Win32 Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "testppd___Win32_Debug"
-# PROP BASE Intermediate_Dir "testppd___Win32_Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Debug"
-# PROP Intermediate_Dir "Debug"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
-# ADD CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /I ".." /I "../visualc" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
-# ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 cupsd.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /incremental:no /debug /machine:I386 /out:"testppdd.exe" /pdbtype:sept
-
-!ENDIF 
-
-# Begin Target
-
-# Name "testppd - Win32 Release"
-# Name "testppd - Win32 Debug"
-# Begin Group "Source Files"
-
-# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-# Begin Source File
-
-SOURCE=.\testppd.c
-# End Source File
-# End Group
-# Begin Group "Header Files"
-
-# PROP Default_Filter "h;hpp;hxx;hm;inl"
-# Begin Source File
-
-SOURCE=.\ppd.h
-# End Source File
-# End Group
-# End Target
-# End Project
diff -urNad cupsys-1.1.99.b1.r4748~/cups/transcode.c cupsys-1.1.99.b1.r4748/cups/transcode.c
--- cupsys-1.1.99.b1.r4748~/cups/transcode.c	2005-09-22 07:17:44.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/transcode.c	2005-11-11 21:53:38.810647000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: transcode.c 4683 2005-09-21 22:17:44Z mike $"
+ * "$Id: transcode.c 4828 2005-11-11 12:53:38Z mike $"
  *
  *   Transcoding support for the Common UNIX Printing System (CUPS).
  *
@@ -397,7 +397,7 @@
     const int maxout)                   /* I - Max output */
 {
   cups_utf8_t   *first = (cups_utf8_t *) src;
-  int           srclen;         /* Source string length */
+  size_t        srclen;         /* Source string length */
   int           i;              /* Looping variable */
   cups_utf32_t  ch;             /* Character value */
   cups_utf32_t  next;           /* Next character value */
@@ -1143,7 +1143,7 @@
         vmap->char2uni[(int) leadchar] = crow;
       }
       crow += (int) (legchar & 0xff);
-      *crow = (cups_vbcs_t) unichar;
+      *crow = (cups_ucs2_t) unichar;
     }
     else
     {
@@ -1165,7 +1165,7 @@
         vmap->wide2uni = wide2uni;
       }
       wide2uni->widechar = (cups_vbcs_t) legchar;
-      wide2uni->unichar = unichar;
+      wide2uni->unichar = (cups_ucs2_t)unichar;
       wide2uni ++;
     }
 
@@ -1648,5 +1648,5 @@
 }
 
 /*
- * End of "$Id: transcode.c 4683 2005-09-21 22:17:44Z mike $"
+ * End of "$Id: transcode.c 4828 2005-11-11 12:53:38Z mike $"
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/usersys.c cupsys-1.1.99.b1.r4748/cups/usersys.c
--- cupsys-1.1.99.b1.r4748~/cups/usersys.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/usersys.c	2005-10-14 04:39:05.160337000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: usersys.c 4683 2005-09-21 22:17:44Z mike $"
+ * "$Id: usersys.c 4785 2005-10-13 19:39:05Z mike $"
  *
  *   User, system, and password routines for the Common UNIX Printing
  *   System (CUPS).
@@ -53,7 +53,7 @@
  * 'cupsEncryption()' - Get the default encryption settings...
  */
 
-http_encryption_t
+http_encryption_t			/* O - Encryption settings */
 cupsEncryption(void)
 {
   cups_file_t	*fp;			/* client.conf file */
@@ -217,6 +217,11 @@
 	  fp = cupsFileOpen(CUPS_SERVERROOT "/client.conf", "r");
       }
 
+#ifdef CUPS_DEFAULT_DOMAINSOCKET
+      if (!access(CUPS_DEFAULT_DOMAINSOCKET, 0))
+        server = CUPS_DEFAULT_DOMAINSOCKET;
+      else
+#endif /* CUPS_DEFAULT_DOMAINSOCKET */
       server = "localhost";
 
       if (fp != NULL)
@@ -248,12 +253,17 @@
     strlcpy(cg->server, server, sizeof(cg->server));
 
     if (cg->server[0] != '/' && (port = strrchr(cg->server, ':')) != NULL &&
-        isdigit(port[1] & 255))
+        !strchr(port, ']') && isdigit(port[1] & 255))
     {
       *port++ = '\0';
 
       ippSetPort(atoi(port));
     }
+
+    if (cg->server[0] == '/')
+      strcpy(cg->servername, "localhost");
+    else
+      strlcpy(cg->servername, cg->server, sizeof(cg->servername));
   }
 
   return (cg->server);
@@ -284,13 +294,32 @@
 void
 cupsSetServer(const char *server)	/* I - Server name */
 {
+  char		*port;			/* Pointer to port */
   _cups_globals_t *cg = _cupsGlobals();	/* Pointer to library globals */
 
 
   if (server)
+  {
     strlcpy(cg->server, server, sizeof(cg->server));
+
+    if (cg->server[0] != '/' && (port = strrchr(cg->server, ':')) != NULL &&
+        !strchr(port, ']') && isdigit(port[1] & 255))
+    {
+      *port++ = '\0';
+
+      ippSetPort(atoi(port));
+    }
+
+    if (cg->server[0] == '/')
+      strcpy(cg->servername, "localhost");
+    else
+      strlcpy(cg->servername, cg->server, sizeof(cg->servername));
+  }
   else
-    cg->server[0] = '\0';
+  {
+    cg->server[0]     = '\0';
+    cg->servername[0] = '\0';
+  }
 }
 
 
@@ -422,5 +451,5 @@
 
 
 /*
- * End of "$Id: usersys.c 4683 2005-09-21 22:17:44Z mike $".
+ * End of "$Id: usersys.c 4785 2005-10-13 19:39:05Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups/util.c cupsys-1.1.99.b1.r4748/cups/util.c
--- cupsys-1.1.99.b1.r4748~/cups/util.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups/util.c	2005-11-11 21:53:38.810647000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: util.c 4745 2005-10-03 13:55:57Z mike $"
+ * "$Id: util.c 4828 2005-11-11 12:53:38Z mike $"
  *
  *   Printing utilities for the Common UNIX Printing System (CUPS).
  *
@@ -97,6 +97,17 @@
   }
 
  /*
+  * Create a printer URI...
+  */
+
+  if (httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                       "/printers/%s", printer) != HTTP_URI_OK)
+  {
+    cg->last_error = IPP_INTERNAL_ERROR;
+    return (0);
+  }
+
+ /*
   * Build an IPP_CANCEL_JOB request, which requires the following
   * attributes:
   *
@@ -123,7 +134,6 @@
 
   cupsLangFree(language);
 
-  snprintf(uri, sizeof(uri), "ipp://%s:%d/printers/%s", hostname, ippPort(), printer);
   ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri",
                NULL, uri);
 
@@ -154,7 +164,7 @@
 		  const char *filename)	/* I - File to send or NULL */
 {
   ipp_t		*response;		/* IPP response data */
-  off_t		length;			/* Content-Length value */
+  size_t	length;			/* Content-Length value */
   http_status_t	status;			/* Status of HTTP request */
   FILE		*file;			/* File to send */
   struct stat	fileinfo;		/* File information */
@@ -285,7 +295,7 @@
 
         rewind(file);
 
-        while ((bytes = fread(buffer, 1, sizeof(buffer), file)) > 0)
+        while ((bytes = (int)fread(buffer, 1, sizeof(buffer), file)) > 0)
 	{
 	  if (httpCheck(http))
 	  {
@@ -645,6 +655,8 @@
 
 /*
  * 'cupsGetDefault2()' - Get the default printer or class.
+ *
+ * @since CUPS 1.1.21@
  */
 
 const char *				/* O - Default printer or NULL */
@@ -758,6 +770,8 @@
 
 /*
  * 'cupsGetJobs2()' - Get the jobs from the server.
+ *
+ * @since CUPS 1.1.21@
  */
 
 int					/* O - Number of jobs */
@@ -802,6 +816,10 @@
 		};
 
 
+ /*
+  * Range check input...
+  */
+
   if (!http || !jobs)
   {
     cg->last_error = IPP_INTERNAL_ERROR;
@@ -809,6 +827,23 @@
   }
 
  /*
+  * Get the right URI...
+  */
+
+  if (mydest)
+  {
+    if (httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                         "/printers/%s", mydest) != HTTP_URI_OK)
+    {
+      cg->last_error = IPP_INTERNAL_ERROR;
+      return (-1);
+    }
+  }
+  else
+    strcpy(uri, "ipp://localhost/jobs");
+
+
+ /*
   * Build an IPP_GET_JOBS request, which requires the following
   * attributes:
   *
@@ -836,11 +871,6 @@
 
   cupsLangFree(language);
 
-  if (mydest)
-    snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", mydest);
-  else
-    strcpy(uri, "ipp://localhost/jobs");
-
   ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI,
                "printer-uri", NULL, uri);
 
@@ -1040,6 +1070,8 @@
 
 /*
  * 'cupsGetPPD2()' - Get the PPD file for a printer.
+ *
+ * @since CUPS 1.1.21@
  */
 
 const char *				/* O - Filename for PPD file */
@@ -1085,16 +1117,27 @@
   }
 
  /*
+  * Setup the printer URI...
+  */
+
+  if (httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                       "/printers/%s", name) != HTTP_URI_OK)
+  {
+    cg->last_error = IPP_INTERNAL_ERROR;
+    return (NULL);
+  }
+
+ /*
   * Get the port number we are connect to...
   */
 
 #ifdef AF_INET6
-  if (http->hostaddr.addr.sa_family == AF_INET6)
-    http_port = ntohs(http->hostaddr.ipv6.sin6_port);
+  if (http->hostaddr->addr.sa_family == AF_INET6)
+    http_port = ntohs(http->hostaddr->ipv6.sin6_port);
   else
 #endif /* AF_INET6 */
-  if (http->hostaddr.addr.sa_family == AF_INET)
-    http_port = ntohs(http->hostaddr.ipv4.sin_port);
+  if (http->hostaddr->addr.sa_family == AF_INET)
+    http_port = ntohs(http->hostaddr->ipv4.sin_port);
   else
     http_port = ippPort(); 
 
@@ -1125,7 +1168,6 @@
 
   cupsLangFree(language);
 
-  snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", name);
   ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI,
                "printer-uri", NULL, uri);
 
@@ -1422,6 +1464,8 @@
 
 /*
  * 'cupsPrintFile2()' - Print a file to a printer or class.
+ *
+ * @since CUPS 1.1.21@
  */
 
 int					/* O - Job ID */
@@ -1486,6 +1530,8 @@
 
 /*
  * 'cupsPrintFiles2()' - Print one or more files to a printer or class.
+ *
+ * @since CUPS 1.1.21@
  */
 
 int					/* O - Job ID */
@@ -1518,7 +1564,21 @@
   */
 
   if (!http || !name || num_files < 1 || files == NULL)
+  {
+    cg->last_error = IPP_INTERNAL_ERROR;
     return (0);
+  }
+
+ /*
+  * Setup the printer URI...
+  */
+
+  if (httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                       "/printers/%s", name) != HTTP_URI_OK)
+  {
+    cg->last_error = IPP_INTERNAL_ERROR;
+    return (0);
+  }
 
  /*
   * Setup the request data...
@@ -1532,15 +1592,15 @@
   */
 
   if ((request = ippNew()) == NULL)
+  {
+    cg->last_error = IPP_INTERNAL_ERROR;
     return (0);
+  }
 
   request->request.op.operation_id = num_files == 1 ? IPP_PRINT_JOB :
                                                       IPP_CREATE_JOB;
   request->request.op.request_id   = 1;
 
-  snprintf(uri, sizeof(uri), "ipp://%s:%d/printers/%s", http->hostname,
-           ippPort(), name);
-
   ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_CHARSET,
                "attributes-charset", NULL, cupsLangEncoding(language));
 
@@ -1615,8 +1675,7 @@
       request->request.op.operation_id = IPP_SEND_DOCUMENT;
       request->request.op.request_id   = 1;
 
-      snprintf(uri, sizeof(uri), "ipp://%s:%d/jobs/%d", http->hostname,
-               ippPort(), jobid);
+      snprintf(uri, sizeof(uri), "ipp://localhost/jobs/%d", jobid);
 
       ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_CHARSET,
         	   "attributes-charset", NULL, cupsLangEncoding(language));
@@ -1710,7 +1769,7 @@
 
   if (cg->http != NULL)
   {
-    if (strcasecmp(cg->http->hostname, hostname) == 0)
+    if (!strcasecmp(cg->http->hostname, hostname))
       return (printer);
 
     httpClose(cg->http);
@@ -1731,5 +1790,5 @@
 
 
 /*
- * End of "$Id: util.c 4745 2005-10-03 13:55:57Z mike $".
+ * End of "$Id: util.c 4828 2005-11-11 12:53:38Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/cups-config.in cupsys-1.1.99.b1.r4748/cups-config.in
--- cupsys-1.1.99.b1.r4748~/cups-config.in	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups-config.in	2005-10-19 22:48:06.018726000 +0900
@@ -1,6 +1,6 @@
 #! /bin/sh
 #
-# "$Id: cups-config.in 4494 2005-02-18 02:18:11Z mike $"
+# "$Id: cups-config.in 4802 2005-10-19 13:48:06Z mike $"
 # 
 #   CUPS configuration utility.
 #
@@ -40,7 +40,7 @@
 # flags for C++ compiler:
 CFLAGS=""
 LDFLAGS="@EXPORT_LDFLAGS@"
-LIBS="@EXPORT_SSLLIBS@ @NETLIBS@ @COMMONLIBS@"
+LIBS="@EXPORT_SSLLIBS@ @LIBS@"
 IMGLIBS="@EXPORT_LIBTIFF@ @EXPORT_LIBJPEG@ @EXPORT_LIBPNG@ @EXPORT_LIBZ@"
 
 if test $includedir != /usr/include; then
@@ -130,5 +130,5 @@
 done
 
 #
-# End of "$Id: cups-config.in 4494 2005-02-18 02:18:11Z mike $".
+# End of "$Id: cups-config.in 4802 2005-10-19 13:48:06Z mike $".
 #
diff -urNad cupsys-1.1.99.b1.r4748~/cups.dsw cupsys-1.1.99.b1.r4748/cups.dsw
--- cupsys-1.1.99.b1.r4748~/cups.dsw	2003-11-06 04:11:54.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups.dsw	1970-01-01 09:00:00.000000000 +0900
@@ -1,29 +0,0 @@
-Microsoft Developer Studio Workspace File, Format Version 6.00
-# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
-
-###############################################################################
-
-Project: "cups"=".\cups\cups.dsp" - Package Owner=<4>
-
-Package=<5>
-{{{
-}}}
-
-Package=<4>
-{{{
-}}}
-
-###############################################################################
-
-Global:
-
-Package=<5>
-{{{
-}}}
-
-Package=<3>
-{{{
-}}}
-
-###############################################################################
-
diff -urNad cupsys-1.1.99.b1.r4748~/cups.list.in cupsys-1.1.99.b1.r4748/cups.list.in
--- cupsys-1.1.99.b1.r4748~/cups.list.in	2005-02-18 11:18:11.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups.list.in	1970-01-01 09:00:00.000000000 +0900
@@ -1,407 +0,0 @@
-#
-# "$Id: cups.list.in 4494 2005-02-18 02:18:11Z mike $"
-#
-#   ESP Package Manager (EPM) file list for the Common UNIX Printing
-#   System (CUPS).
-#
-#   Copyright 1997-2005 by Easy Software Products, all rights reserved.
-#
-#   These coded instructions, statements, and computer programs are the
-#   property of Easy Software Products and are protected by Federal
-#   copyright law.  Distribution and use rights are outlined in the file
-#   "LICENSE.txt" which should have been included with this file.  If this
-#   file is missing or damaged please contact Easy Software Products
-#   at:
-#
-#       Attn: CUPS Licensing Information
-#       Easy Software Products
-#       44141 Airport View Drive, Suite 204
-#       Hollywood, Maryland 20636 USA
-#
-#       Voice: (301) 373-9600
-#       EMail: cups-info@cups.org
-#         WWW: http://www.cups.org
-#
-
-# Product information
-%product Common UNIX Printing System
-%copyright 1993-2005 by Easy Software Products, All Rights Reserved.
-%vendor Easy Software Products
-%license LICENSE.txt
-%readme README.txt
-%version @CUPS_VERSION@
-%description The Common UNIX Printing System provides a portable printing
-%description layer for UNIX operating systems.  It has been developed by
-%description Easy Software Products to promote a standard printing solution
-%description for all UNIX vendors and users.  CUPS provides the System V and
-%description Berkeley command-line interfaces. 
-%provides cups-devel
-%provides cups-libs
-%provides cupsys
-%provides cupsys-bsd
-%provides cupsys-client
-%provides cupsys-devel
-%provides libcups1
-%provides libcupsys2
-%provides libcupsys2-dev
-
-%format rpm deb portable
-%provides @LIBCUPS@
-%provides @LIBCUPSIMAGE@
-%format all
-
-#
-# GNU variables...
-#
-
-$prefix=@prefix@
-$exec_prefix=@exec_prefix@
-$bindir=@bindir@
-$datadir=@datadir@
-$includedir=@includedir@
-$infodir=@infodir@
-$libdir=@libdir@
-$libexecdir=@libexecdir@
-$localstatedir=@localstatedir@
-$mandir=@mandir@
-$oldincludedir=@oldincludedir@
-$sbindir=@sbindir@
-$sharedstatedir=@sharedstatedir@
-$srcdir=@srcdir@
-$sysconfdir=@sysconfdir@
-$top_srcdir=@top_srcdir@
-
-#
-# ESP variables...
-#
-
-$AMANDIR=@AMANDIR@
-$BINDIR=@bindir@
-$DATADIR=@CUPS_DATADIR@
-$DOCDIR=@CUPS_DOCROOT@
-$INCLUDEDIR=${includedir}
-$INITDIR=@INITDIR@
-$INITDDIR=@INITDDIR@
-$LIBDIR=${libdir}
-$LOCALEDIR=@CUPS_LOCALEDIR@
-$LOGDIR=@CUPS_LOGDIR@
-$MANDIR=@mandir@
-$PAMDIR=@PAMDIR@
-$PMANDIR=@PMANDIR@
-$REQUESTS=@CUPS_REQUESTS@
-$SBINDIR=@sbindir@
-$SERVERBIN=@CUPS_SERVERBIN@
-$SERVERROOT=@CUPS_SERVERROOT@
-
-$CUPS_USER=@CUPS_USER@
-$CUPS_GROUP=@CUPS_GROUP@
-
-$CAT1EXT=@CAT1EXT@
-$CAT3EXT=@CAT3EXT@
-$CAT5EXT=@CAT5EXT@
-$CAT8EXT=@CAT8EXT@
-$MAN8EXT=@MAN8EXT@
-$MAN8DIR=@MAN8DIR@
-
-$DSOLIBS=@DSOLIBS@
-
-# Make sure the MD5 password file is now owned by CUPS_USER...
-%postinstall if test -f $SERVERROOT/passwd.md5; then
-%postinstall chown $CUPS_USER $SERVERROOT/passwd.md5
-%postinstall fi
-
-# Make sure the shared libraries are refreshed...
-%system linux
-%postinstall ldconfig
-%system all
-
-# Server programs
-%system all
-# Server files
-f 0555 root sys $SBINDIR/cupsd scheduler/cupsd
-
-d 0555 root sys $SERVERBIN -
-d 0555 root sys $SERVERBIN/backend -
-f 0555 root sys $SERVERBIN/backend/ipp backend/ipp
-l 0555 root sys $SERVERBIN/backend/http ipp
-f 0555 root sys $SERVERBIN/backend/lpd backend/lpd
-f 0555 root sys $SERVERBIN/backend/parallel backend/parallel
-f 0555 root sys $SERVERBIN/backend/scsi backend/scsi
-f 0555 root sys $SERVERBIN/backend/serial backend/serial
-f 0555 root sys $SERVERBIN/backend/socket backend/socket
-f 0555 root sys $SERVERBIN/backend/usb backend/usb
-d 0555 root sys $SERVERBIN/cgi-bin -
-f 0555 root sys $SERVERBIN/cgi-bin/admin.cgi cgi-bin/admin.cgi
-f 0555 root sys $SERVERBIN/cgi-bin/classes.cgi cgi-bin/classes.cgi
-f 0555 root sys $SERVERBIN/cgi-bin/jobs.cgi cgi-bin/jobs.cgi
-f 0555 root sys $SERVERBIN/cgi-bin/printers.cgi cgi-bin/printers.cgi
-d 0555 root sys $SERVERBIN/daemon -
-f 0555 root sys $SERVERBIN/daemon/cups-lpd scheduler/cups-lpd
-f 0555 root sys $SERVERBIN/daemon/cups-polld scheduler/cups-polld
-d 0555 root sys $SERVERBIN/filter -
-f 0555 root sys $SERVERBIN/filter/gziptoany filter/gziptoany
-f 0555 root sys $SERVERBIN/filter/hpgltops filter/hpgltops
-f 0555 root sys $SERVERBIN/filter/imagetops filter/imagetops
-f 0555 root sys $SERVERBIN/filter/imagetoraster filter/imagetoraster
-f 0555 root sys $SERVERBIN/filter/pdftops pdftops/pdftops
-f 0555 root sys $SERVERBIN/filter/pstops filter/pstops
-f 0555 root sys $SERVERBIN/filter/rastertodymo filter/rastertodymo
-f 0555 root sys $SERVERBIN/filter/rastertoepson filter/rastertoepson
-f 0555 root sys $SERVERBIN/filter/rastertohp filter/rastertohp
-f 0555 root sys $SERVERBIN/filter/texttops filter/texttops
-
-# Admin commands
-d 0555 root sys $SBINDIR -
-l 0555 root sys $SBINDIR/disable accept
-l 0555 root sys $SBINDIR/enable accept
-l 0555 root sys $LIBDIR/accept $SBINDIR/accept
-d 0555 root sys $LIBDIR -
-l 0555 root sys $LIBDIR/lpadmin $SBINDIR/lpadmin
-l 0555 root sys $LIBDIR/reject accept
-f 0555 root sys $SBINDIR/accept systemv/accept
-f 0555 root sys $SBINDIR/cupsaddsmb systemv/cupsaddsmb
-f 0555 root sys $SBINDIR/lpadmin systemv/lpadmin
-f 0555 root sys $SBINDIR/lpc berkeley/lpc
-f 0555 root sys $SBINDIR/lpinfo systemv/lpinfo
-f 0555 root sys $SBINDIR/lpmove systemv/lpmove
-l 0555 root sys $SBINDIR/reject accept
-
-%system irix
-l 0555 root sys /usr/etc/lpc $SBINDIR/lpc
-%system all
-
-# User commands
-d 0555 root sys $BINDIR -
-f 0555 root sys $BINDIR/cancel systemv/cancel
-f 0555 root sys $BINDIR/cupstestppd systemv/cupstestppd
-f 0555 root sys $BINDIR/lp systemv/lp
-f 0555 root sys $BINDIR/lpoptions systemv/lpoptions
-f 4555 $CUPS_USER sys $BINDIR/lppasswd systemv/lppasswd
-f 0555 root sys $BINDIR/lpq berkeley/lpq
-f 0555 root sys $BINDIR/lpr berkeley/lpr
-f 0555 root sys $BINDIR/lprm berkeley/lprm
-f 0555 root sys $BINDIR/lpstat systemv/lpstat
-
-%system irix
-l 0555 root sys /usr/bsd/lpq $BINDIR/lpq
-l 0555 root sys /usr/bsd/lpr $BINDIR/lpr
-l 0555 root sys /usr/bsd/lprm $BINDIR/lprm
-%system all
-
-# DSOs
-%if DSOLIBS
-%system hpux
-f 0555 root sys $LIBDIR/libcups.sl.2 cups/libcups.sl.2
-l 0555 root sys $LIBDIR/libcups.sl libcups.sl.2
-f 0555 root sys $LIBDIR/libcupsimage.sl.2 filter/libcupsimage.sl.2
-l 0555 root sys $LIBDIR/libcupsimage.sl libcupsimage.sl.2
-%system aix
-f 0555 root sys $LIBDIR/libcups_s.a cups/libcups_s.a
-f 0555 root sys $LIBDIR/libcupsimage_s.a filter/libcupsimage_s.a
-%system darwin
-f 0555 root sys $LIBDIR/libcups.2.dylib cups/libcups.2.dylib
-l 0555 root sys $LIBDIR/libcups.dylib libcups.2.dylib
-f 0555 root sys $LIBDIR/libcupsimage.2.dylib filter/libcupsimage.2.dylib
-l 0555 root sys $LIBDIR/libcupsimage.dylib libcupsimage.2.dylib
-%system !hpux !aix !darwin
-f 0555 root sys $LIBDIR/libcups.so.2 cups/libcups.so.2
-l 0555 root sys $LIBDIR/libcups.so libcups.so.2
-f 0555 root sys $LIBDIR/libcupsimage.so.2 filter/libcupsimage.so.2
-l 0555 root sys $LIBDIR/libcupsimage.so libcupsimage.so.2
-%system all
-%endif
-
-# Directories
-d 0755 root sys $LOGDIR -
-d 0700 $CUPS_USER sys $REQUESTS -
-d 1700 $CUPS_USER sys $REQUESTS/tmp -
-
-# Data files
-f 0444 root sys $LOCALEDIR/C/cups_C locale/C/cups_C
-f 0444 root sys $LOCALEDIR/be/cups_be locale/be/cups_be
-f 0444 root sys $LOCALEDIR/cs/cups_cs locale/cs/cups_cs
-f 0444 root sys $LOCALEDIR/de/cups_de locale/de/cups_de
-f 0444 root sys $LOCALEDIR/en/cups_en locale/en/cups_en
-f 0444 root sys $LOCALEDIR/en_US/cups_en_US locale/en_US/cups_en_US
-f 0444 root sys $LOCALEDIR/es/cups_es locale/es/cups_es
-f 0444 root sys $LOCALEDIR/fr/cups_fr locale/fr/cups_fr
-f 0444 root sys $LOCALEDIR/it/cups_it locale/it/cups_it
-f 0444 root sys $LOCALEDIR/ru_RU/cups_ru_RU locale/ru_RU/cups_ru_RU
-f 0444 root sys $LOCALEDIR/sv/cups_sv locale/sv/cups_sv
-f 0444 root sys $LOCALEDIR/uk/cups_uk locale/uk/cups_uk
-f 0444 root sys $LOCALEDIR/uk_UA/cups_uk_UA locale/uk_UA/cups_uk_UA
-f 0444 root sys $LOCALEDIR/zh_CN/cups_zh_CN locale/zh_CN/cups_zh_CN
-
-d 0555 root sys $DATADIR -
-
-d 0555 root sys $DATADIR/banners -
-f 0444 root sys $DATADIR/banners/classified data/classified
-f 0444 root sys $DATADIR/banners/confidential data/confidential
-f 0444 root sys $DATADIR/banners/secret data/secret
-f 0444 root sys $DATADIR/banners/standard data/standard
-f 0444 root sys $DATADIR/banners/topsecret data/topsecret
-f 0444 root sys $DATADIR/banners/unclassified data/unclassified
-
-d 0555 root sys $DATADIR/charsets -
-f 0444 root sys $DATADIR/charsets/windows-874 data/windows-874
-f 0444 root sys $DATADIR/charsets/windows-1250 data/windows-1250
-f 0444 root sys $DATADIR/charsets/windows-1251 data/windows-1251
-f 0444 root sys $DATADIR/charsets/windows-1252 data/windows-1252
-f 0444 root sys $DATADIR/charsets/windows-1253 data/windows-1253
-f 0444 root sys $DATADIR/charsets/windows-1254 data/windows-1254
-f 0444 root sys $DATADIR/charsets/windows-1255 data/windows-1255
-f 0444 root sys $DATADIR/charsets/windows-1256 data/windows-1256
-f 0444 root sys $DATADIR/charsets/windows-1257 data/windows-1257
-f 0444 root sys $DATADIR/charsets/windows-1258 data/windows-1258
-f 0444 root sys $DATADIR/charsets/iso-8859-1 data/iso-8859-1
-f 0444 root sys $DATADIR/charsets/iso-8859-2 data/iso-8859-2
-f 0444 root sys $DATADIR/charsets/iso-8859-3 data/iso-8859-3
-f 0444 root sys $DATADIR/charsets/iso-8859-4 data/iso-8859-4
-f 0444 root sys $DATADIR/charsets/iso-8859-5 data/iso-8859-5
-f 0444 root sys $DATADIR/charsets/iso-8859-6 data/iso-8859-6
-f 0444 root sys $DATADIR/charsets/iso-8859-7 data/iso-8859-7
-f 0444 root sys $DATADIR/charsets/iso-8859-8 data/iso-8859-8
-f 0444 root sys $DATADIR/charsets/iso-8859-9 data/iso-8859-9
-f 0444 root sys $DATADIR/charsets/iso-8859-10 data/iso-8859-10
-f 0444 root sys $DATADIR/charsets/iso-8859-13 data/iso-8859-13
-f 0444 root sys $DATADIR/charsets/iso-8859-14 data/iso-8859-14
-f 0444 root sys $DATADIR/charsets/iso-8859-15 data/iso-8859-15
-f 0444 root sys $DATADIR/charsets/utf-8 data/utf-8
-
-d 0555 root sys $DATADIR/data -
-f 0444 root sys $DATADIR/data/HPGLprolog data/HPGLprolog
-f 0444 root sys $DATADIR/data/psglyphs data/psglyphs
-f 0444 root sys $DATADIR/data/testprint.ps data/testprint.ps
-
-d 0555 root sys $DATADIR/fonts -
-f 0444 root sys $DATADIR/fonts fonts/Courier*
-f 0444 root sys $DATADIR/fonts/Symbol fonts/Symbol
-
-d 0555 root sys $DATADIR/model -
-f 0444 root sys $DATADIR/model ppd/*.ppd
-
-d 0555 root sys $DATADIR/templates -
-c 0444 root sys $DATADIR/templates templates/*.tmpl
-
-# Config files
-d 0555 root sys $SERVERROOT -
-d 0711 $CUPS_USER $CUPS_GROUP $SERVERROOT/certs -
-d 0755 root sys $SERVERROOT/interfaces -
-d 0755 root sys $SERVERROOT/ppd -
-c 0600 root sys $SERVERROOT conf/*.conf
-c 0600 root sys $SERVERROOT/mime.convs conf/mime.convs
-c 0600 root sys $SERVERROOT/mime.types conf/mime.types
-
-%if PAMDIR
-d 0555 root sys $PAMDIR -
-c 0644 root sys $PAMDIR/cups conf/@PAMFILE@
-%endif
-
-# Developer files
-f 0555 root sys $BINDIR/cups-config cups-config
-d 0555 root sys $INCLUDEDIR/cups -
-f 0444 root sys $INCLUDEDIR/cups/cups.h cups/cups.h
-f 0444 root sys $INCLUDEDIR/cups/http.h cups/http.h
-f 0444 root sys $INCLUDEDIR/cups/image.h filter/image.h
-f 0444 root sys $INCLUDEDIR/cups/ipp.h cups/ipp.h
-f 0444 root sys $INCLUDEDIR/cups/language.h cups/language.h
-f 0444 root sys $INCLUDEDIR/cups/md5.h cups/md5.h
-f 0444 root sys $INCLUDEDIR/cups/ppd.h cups/ppd.h
-f 0444 root sys $INCLUDEDIR/cups/raster.h filter/raster.h
-
-f 0444 root sys $LIBDIR/libcups.a cups/libcups.a
-f 0444 root sys $LIBDIR/libcupsimage.a filter/libcupsimage.a
-
-# Documentation files
-d 0555 root sys $DOCDIR -
-f 0444 root sys $DOCDIR doc/*.css
-f 0444 root sys $DOCDIR doc/*.html
-f 0444 root sys $DOCDIR doc/*.pdf
-f 0444 root sys $DOCDIR/robots.txt doc/robots.txt
-d 0555 root sys $DOCDIR/images -
-f 0444 root sys $DOCDIR/images doc/images/*.gif
-
-# Man pages
-d 0555 root sys $AMANDIR -
-d 0555 root sys $AMANDIR/cat$MAN8DIR -
-d 0555 root sys $AMANDIR/man$MAN8DIR -
-d 0555 root sys $MANDIR -
-d 0555 root sys $MANDIR/cat1 -
-d 0555 root sys $MANDIR/cat5 -
-d 0555 root sys $MANDIR/man1 -
-d 0555 root sys $MANDIR/man5 -
-d 0555 root sys $PMANDIR -
-d 0555 root sys $PMANDIR/cat3 -
-d 0555 root sys $PMANDIR/man3 -
-
-f 0444 root sys $MANDIR/cat1/backend.$CAT1EXT man/backend.$CAT1EXT
-f 0444 root sys $MANDIR/cat1/cups-config.$CAT1EXT man/cups-config.$CAT1EXT
-f 0444 root sys $MANDIR/cat1/cupstestppd.$CAT1EXT man/cupstestppd.$CAT1EXT
-f 0444 root sys $MANDIR/cat1/filter.$CAT1EXT man/filter.$CAT1EXT
-f 0444 root sys $MANDIR/cat1/lpoptions.$CAT1EXT man/lpoptions.$CAT1EXT
-f 0444 root sys $MANDIR/cat1/lppasswd.$CAT1EXT man/lppasswd.$CAT1EXT
-f 0444 root sys $MANDIR/cat1/lpq.$CAT1EXT man/lpq.$CAT1EXT
-f 0444 root sys $MANDIR/cat1/lprm.$CAT1EXT man/lprm.$CAT1EXT
-f 0444 root sys $MANDIR/cat1/lpr.$CAT1EXT man/lpr.$CAT1EXT
-f 0444 root sys $MANDIR/cat1/lpstat.$CAT1EXT man/lpstat.$CAT1EXT
-f 0444 root sys $MANDIR/cat1/lp.$CAT1EXT man/lp.$CAT1EXT
-l 0444 root sys $MANDIR/cat1/cancel.$CAT1EXT lp.$CAT1EXT
-
-f 0444 root sys $MANDIR/cat5/classes.conf.$CAT5EXT man/classes.conf.$CAT5EXT
-f 0444 root sys $MANDIR/cat5/cupsd.conf.$CAT5EXT man/cupsd.conf.$CAT5EXT
-f 0444 root sys $MANDIR/cat5/mime.convs.$CAT5EXT man/mime.convs.$CAT5EXT
-f 0444 root sys $MANDIR/cat5/mime.types.$CAT5EXT man/mime.types.$CAT5EXT
-f 0444 root sys $MANDIR/cat5/printers.conf.$CAT5EXT man/printers.conf.$CAT5EXT
-
-f 0444 root sys $AMANDIR/cat$MAN8DIR/accept.$CAT8EXT man/accept.$CAT8EXT
-l 0444 root sys $AMANDIR/cat$MAN8DIR/reject.$CAT8EXT accept.$CAT8EXT
-f 0444 root sys $AMANDIR/cat$MAN8DIR/cupsaddsmb.$CAT8EXT man/cupsaddsmb.$CAT8EXT
-f 0444 root sys $AMANDIR/cat$MAN8DIR/cups-lpd.$CAT8EXT man/cups-lpd.$CAT8EXT
-f 0444 root sys $AMANDIR/cat$MAN8DIR/cups-polld.$CAT8EXT man/cups-polld.$CAT8EXT
-f 0444 root sys $AMANDIR/cat$MAN8DIR/cupsd.$CAT8EXT man/cupsd.$CAT8EXT
-f 0444 root sys $AMANDIR/cat$MAN8DIR/enable.$CAT8EXT man/enable.$CAT8EXT
-l 0444 root sys $AMANDIR/cat$MAN8DIR/disable.$CAT8EXT enable.$CAT8EXT
-f 0444 root sys $AMANDIR/cat$MAN8DIR/lpadmin.$CAT8EXT man/lpadmin.$CAT8EXT
-f 0444 root sys $AMANDIR/cat$MAN8DIR/lpc.$CAT8EXT man/lpc.$CAT8EXT
-f 0444 root sys $AMANDIR/cat$MAN8DIR/lpinfo.$CAT8EXT man/lpinfo.$CAT8EXT
-f 0444 root sys $AMANDIR/cat$MAN8DIR/lpmove.$CAT8EXT man/lpmove.$CAT8EXT
-
-f 0444 root sys $MANDIR/man1/backend.1 man/backend.man
-f 0444 root sys $MANDIR/man1/cups-config.1 man/cups-config.man
-f 0444 root sys $MANDIR/man1/cupstestppd.1 man/cupstestppd.man
-f 0444 root sys $MANDIR/man1/filter.1 man/filter.man
-f 0444 root sys $MANDIR/man1/lpoptions.1 man/lpoptions.man
-f 0444 root sys $MANDIR/man1/lppasswd.1 man/lppasswd.man
-f 0444 root sys $MANDIR/man1/lpq.1 man/lpq.man
-f 0444 root sys $MANDIR/man1/lprm.1 man/lprm.man
-f 0444 root sys $MANDIR/man1/lpr.1 man/lpr.man
-f 0444 root sys $MANDIR/man1/lpstat.1 man/lpstat.man
-f 0444 root sys $MANDIR/man1/lp.1 man/lp.man
-l 0444 root sys $MANDIR/man1/cancel.1 lp.1
-
-f 0444 root sys $MANDIR/man5/classes.conf.5 man/classes.conf.man
-f 0444 root sys $MANDIR/man5/cupsd.conf.5 man/cupsd.conf.man
-f 0444 root sys $MANDIR/man5/mime.convs.5 man/mime.convs.man
-f 0444 root sys $MANDIR/man5/mime.types.5 man/mime.types.man
-f 0444 root sys $MANDIR/man5/printers.conf.5 man/printers.conf.man
-
-f 0444 root sys $AMANDIR/man$MAN8DIR/accept.$MAN8EXT man/accept.man
-l 0444 root sys $AMANDIR/man$MAN8DIR/reject.$MAN8EXT accept.$MAN8EXT
-f 0444 root sys $AMANDIR/man$MAN8DIR/cupsaddsmb.$MAN8EXT man/cupsaddsmb.man
-f 0444 root sys $AMANDIR/man$MAN8DIR/cups-lpd.$MAN8EXT man/cups-lpd.man
-f 0444 root sys $AMANDIR/man$MAN8DIR/cups-polld.$MAN8EXT man/cups-polld.man
-f 0444 root sys $AMANDIR/man$MAN8DIR/cupsd.$MAN8EXT man/cupsd.man
-f 0444 root sys $AMANDIR/man$MAN8DIR/enable.$MAN8EXT man/enable.man
-l 0444 root sys $AMANDIR/man$MAN8DIR/disable.$MAN8EXT enable.$MAN8EXT
-f 0444 root sys $AMANDIR/man$MAN8DIR/lpadmin.$MAN8EXT man/lpadmin.man
-f 0444 root sys $AMANDIR/man$MAN8DIR/lpc.$MAN8EXT man/lpc.man
-f 0444 root sys $AMANDIR/man$MAN8DIR/lpinfo.$MAN8EXT man/lpinfo.man
-f 0444 root sys $AMANDIR/man$MAN8DIR/lpmove.$MAN8EXT man/lpmove.man
-
-# Startup script
-%system all
-i 0555 root sys cups cups.sh
-
-#
-# End of "$Id: cups.list.in 4494 2005-02-18 02:18:11Z mike $".
-#
diff -urNad cupsys-1.1.99.b1.r4748~/cups.spec cupsys-1.1.99.b1.r4748/cups.spec
--- cupsys-1.1.99.b1.r4748~/cups.spec	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups.spec	1970-01-01 09:00:00.000000000 +0900
@@ -1,258 +0,0 @@
-#
-# "$Id: cups.spec 4787 2005-10-13 20:13:21Z mike $"
-#
-#   RPM "spec" file for the Common UNIX Printing System (CUPS).
-#
-#   Original version by Jason McMullan <jmcc@ontv.com>.
-#
-#   Copyright 1999-2005 by Easy Software Products, all rights reserved.
-#
-#   These coded instructions, statements, and computer programs are the
-#   property of Easy Software Products and are protected by Federal
-#   copyright law.  Distribution and use rights are outlined in the file
-#   "LICENSE.txt" which should have been included with this file.  If this
-#   file is missing or damaged please contact Easy Software Products
-#   at:
-#
-#       Attn: CUPS Licensing Information
-#       Easy Software Products
-#       44141 Airport View Drive, Suite 204
-#       Hollywood, Maryland 20636 USA
-#
-#       Voice: (301) 373-9600
-#       EMail: cups-info@cups.org
-#         WWW: http://www.cups.org
-#
-
-Summary: Common Unix Printing System
-Name: cups
-Version: 1.2svn
-Release: 0
-Epoch: 1
-License: GPL
-Group: System Environment/Daemons
-Source: ftp://ftp.easysw.com/pub/cups/%{version}/cups-%{version}-source.tar.gz
-Url: http://www.cups.org
-Packager: Anonymous <anonymous@foo.com>
-Vendor: Easy Software Products
-
-# Use buildroot so as not to disturb the version already installed
-BuildRoot: /tmp/%{name}-root
-
-# Dependencies...
-Requires: %{name}-libs = %{epoch}:%{version}
-Obsoletes: lpd, lpr, LPRng
-Provides: lpd, lpr, LPRng
-
-%package devel
-Summary: Common Unix Printing System - development environment
-Group: Development/Libraries
-Requires: %{name}-libs = %{epoch}:%{version}
-
-%package libs
-Summary: Common Unix Printing System - shared libraries
-Group: System Environment/Libraries
-Provides: libcups1
-
-%package lpd
-Summary: Common Unix Printing System - LPD support
-Group: System Environment/Daemons
-Requires: %{name} = %{epoch}:%{version} xinetd
-
-%description
-The Common UNIX Printing System provides a portable printing layer for 
-UNIX operating systems. It has been developed by Easy Software Products 
-to promote a standard printing solution for all UNIX vendors and users. 
-CUPS provides the System V and Berkeley command-line interfaces. 
-
-%description devel
-The Common UNIX Printing System provides a portable printing layer for 
-UNIX operating systems. This is the development package for creating
-additional printer drivers and other CUPS services.
-
-%description libs
-The Common UNIX Printing System provides a portable printing layer for 
-UNIX operating systems. This package contains the CUPS shared libraries.
-
-%description lpd
-The Common UNIX Printing System provides a portable printing layer for 
-UNIX operating systems. This package provides LPD client support.
-
-%prep
-%setup
-
-%build
-CFLAGS="$RPM_OPT_FLAGS" CXXFLAGS="$RPM_OPT_FLAGS" LDFLAGS="$RPM_OPT_FLAGS" ./configure
-
-# If we got this far, all prerequisite libraries must be here.
-make
-
-%install
-# Make sure the RPM_BUILD_ROOT directory exists.
-rm -rf $RPM_BUILD_ROOT
-
-make BUILDROOT=$RPM_BUILD_ROOT install
-
-%post
-ldconfig
-
-if test -x /sbin/chkconfig; then
-	/sbin/chkconfig --add cups
-	/sbin/chkconfig cups on
-fi
-
-# these lines automatically start cupsd after installation; commented out
-# by request...
-#if test -f /sbin/init.d/cups; then
-#	/sbin/init.d/cups start
-#fi
-#if test -f /etc/rc.d/init.d/cups; then
-#	/etc/rc.d/init.d/cups start
-#fi
-#if test -f /etc/init.d/cups; then
-#	/etc/init.d/cups start
-#fi
-
-%preun
-if test -f /sbin/init.d/cups; then
-	/sbin/init.d/cups stop
-fi
-if test -f /etc/rc.d/init.d/cups; then
-	/etc/rc.d/init.d/cups stop
-fi
-if test -f /etc/init.d/cups; then
-	/etc/init.d/cups stop
-fi
-
-if test -x /sbin/chkconfig; then
-	/sbin/chkconfig --del cups
-fi
-
-%clean
-rm -rf $RPM_BUILD_ROOT
-
-%files
-%defattr(-,root,root)
-%dir /etc/cups
-%config(noreplace) /etc/cups/*.conf
-%dir /etc/cups/interfaces
-/etc/cups/mime.types
-/etc/cups/mime.convs
-%dir /etc/cups/ppd
-%dir /etc/pam.d
-/etc/pam.d/*
-
-# RC dirs are a pain under Linux...  Uncomment the appropriate ones if you
-# don't use Red Hat or Mandrake...
-
-/etc/init.d/*
-/etc/rc0.d/*
-/etc/rc2.d/*
-/etc/rc3.d/*
-/etc/rc5.d/*
-
-# OLD RedHat/Mandrake
-#/etc/rc.d/init.d/*
-#/etc/rc.d/rc0.d/*
-#/etc/rc.d/rc2.d/*
-#/etc/rc.d/rc3.d/*
-#/etc/rc.d/rc5.d/*
-
-#/sbin/rc.d/*
-#/sbin/rc.d/rc0.d/*
-#/sbin/rc.d/rc2.d/*
-#/sbin/rc.d/rc3.d/*
-#/sbin/rc.d/rc5.d/*
-
-/usr/bin/cancel
-/usr/bin/cupstestppd
-/usr/bin/lp*
-%dir /usr/lib/cups
-%dir /usr/lib/cups/backend
-/usr/lib/cups/backend/*
-%dir /usr/lib/cups/cgi-bin
-/usr/lib/cups/cgi-bin/*
-%dir /usr/lib/cups/daemon
-/usr/lib/cups/daemon/cups-deviced
-/usr/lib/cups/daemon/cups-driverd
-/usr/lib/cups/daemon/cups-polld
-%dir /usr/lib/cups/driver
-%dir /usr/lib/cups/filter
-/usr/lib/cups/filter/*
-
-/usr/sbin/*
-%dir /usr/share/cups
-/usr/share/cups/*
-%dir /usr/share/doc/cups
-/usr/share/doc/cups/*
-%dir /usr/share/locale
-/usr/share/locale/*
-
-%dir /usr/share/man/cat1
-/usr/share/man/cat1/cancel.1
-/usr/share/man/cat1/cupstestppd.1
-/usr/share/man/cat1/lp.1
-/usr/share/man/cat1/lpoptions.1
-/usr/share/man/cat1/lppasswd.1
-/usr/share/man/cat1/lpq.1
-/usr/share/man/cat1/lpr.1
-/usr/share/man/cat1/lprm.1
-/usr/share/man/cat1/lpstat.1
-%dir /usr/share/man/cat5
-/usr/share/man/cat5/*
-%dir /usr/share/man/cat8
-/usr/share/man/cat8/*
-%dir /usr/share/man/man1
-/usr/share/man/man1/cancel.1.gz
-/usr/share/man/man1/cupstestppd.1.gz
-/usr/share/man/man1/lp.1.gz
-/usr/share/man/man1/lpoptions.1.gz
-/usr/share/man/man1/lppasswd.1.gz
-/usr/share/man/man1/lpq.1.gz
-/usr/share/man/man1/lpr.1.gz
-/usr/share/man/man1/lprm.1.gz
-/usr/share/man/man1/lpstat.1.gz
-%dir /usr/share/man/man5
-/usr/share/man/man5/*
-%dir /usr/share/man/man8
-/usr/share/man/man8/*
-
-%dir /var/cache/cups
-%dir /var/cache/cups/ppd
-%dir /var/log/cups
-%dir /var/run/cups
-%attr(0711,lp,root) %dir /var/run/cups/certs
-%attr(0700,lp,root) %dir /var/spool/cups
-%attr(1700,lp,root) %dir /var/spool/cups/tmp
-
-%files devel
-%defattr(-,root,root)
-%dir /usr/share/man/cat1
-/usr/share/man/cat1/backend.1
-/usr/share/man/cat1/cups-config.1
-/usr/share/man/cat1/filter.1
-%dir /usr/share/man/man1
-/usr/share/man/man1/backend.1.gz
-/usr/share/man/man1/cups-config.1.gz
-/usr/share/man/man1/filter.1.gz
-
-/usr/bin/cups-config
-%dir /usr/include/cups
-/usr/include/cups/*
-/usr/lib/*.a
-/usr/lib/*.so
-
-%files libs
-%defattr(-,root,root)
-/usr/lib/*.so.*
-
-%files lpd
-%defattr(-,root,root)
-%dir /usr/lib/cups
-%dir /usr/lib/cups/daemon
-/usr/lib/cups/daemon/cups-lpd
-#/etc/xinetd.d/cups-lpd
-
-#
-# End of "$Id: cups.spec 4787 2005-10-13 20:13:21Z mike $".
-#
diff -urNad cupsys-1.1.99.b1.r4748~/cups.spec.in cupsys-1.1.99.b1.r4748/cups.spec.in
--- cupsys-1.1.99.b1.r4748~/cups.spec.in	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/cups.spec.in	1970-01-01 09:00:00.000000000 +0900
@@ -1,258 +0,0 @@
-#
-# "$Id: cups.spec 4604 2005-08-26 23:40:29Z mike $"
-#
-#   RPM "spec" file for the Common UNIX Printing System (CUPS).
-#
-#   Original version by Jason McMullan <jmcc@ontv.com>.
-#
-#   Copyright 1999-2005 by Easy Software Products, all rights reserved.
-#
-#   These coded instructions, statements, and computer programs are the
-#   property of Easy Software Products and are protected by Federal
-#   copyright law.  Distribution and use rights are outlined in the file
-#   "LICENSE.txt" which should have been included with this file.  If this
-#   file is missing or damaged please contact Easy Software Products
-#   at:
-#
-#       Attn: CUPS Licensing Information
-#       Easy Software Products
-#       44141 Airport View Drive, Suite 204
-#       Hollywood, Maryland 20636 USA
-#
-#       Voice: (301) 373-9600
-#       EMail: cups-info@cups.org
-#         WWW: http://www.cups.org
-#
-
-Summary: Common Unix Printing System
-Name: cups
-Version: @CUPS_VERSION@
-Release: 0
-Epoch: 1
-License: GPL
-Group: System Environment/Daemons
-Source: ftp://ftp.easysw.com/pub/cups/%{version}/cups-%{version}-source.tar.gz
-Url: http://www.cups.org
-Packager: Anonymous <anonymous@foo.com>
-Vendor: Easy Software Products
-
-# Use buildroot so as not to disturb the version already installed
-BuildRoot: /tmp/%{name}-root
-
-# Dependencies...
-Requires: %{name}-libs = %{epoch}:%{version}
-Obsoletes: lpd, lpr, LPRng
-Provides: lpd, lpr, LPRng
-
-%package devel
-Summary: Common Unix Printing System - development environment
-Group: Development/Libraries
-Requires: %{name}-libs = %{epoch}:%{version}
-
-%package libs
-Summary: Common Unix Printing System - shared libraries
-Group: System Environment/Libraries
-Provides: libcups1
-
-%package lpd
-Summary: Common Unix Printing System - LPD support
-Group: System Environment/Daemons
-Requires: %{name} = %{epoch}:%{version} xinetd
-
-%description
-The Common UNIX Printing System provides a portable printing layer for 
-UNIX operating systems. It has been developed by Easy Software Products 
-to promote a standard printing solution for all UNIX vendors and users. 
-CUPS provides the System V and Berkeley command-line interfaces. 
-
-%description devel
-The Common UNIX Printing System provides a portable printing layer for 
-UNIX operating systems. This is the development package for creating
-additional printer drivers and other CUPS services.
-
-%description libs
-The Common UNIX Printing System provides a portable printing layer for 
-UNIX operating systems. This package contains the CUPS shared libraries.
-
-%description lpd
-The Common UNIX Printing System provides a portable printing layer for 
-UNIX operating systems. This package provides LPD client support.
-
-%prep
-%setup
-
-%build
-CFLAGS="$RPM_OPT_FLAGS" CXXFLAGS="$RPM_OPT_FLAGS" LDFLAGS="$RPM_OPT_FLAGS" ./configure
-
-# If we got this far, all prerequisite libraries must be here.
-make
-
-%install
-# Make sure the RPM_BUILD_ROOT directory exists.
-rm -rf $RPM_BUILD_ROOT
-
-make BUILDROOT=$RPM_BUILD_ROOT install
-
-%post
-ldconfig
-
-if test -x /sbin/chkconfig; then
-	/sbin/chkconfig --add cups
-	/sbin/chkconfig cups on
-fi
-
-# these lines automatically start cupsd after installation; commented out
-# by request...
-#if test -f /sbin/init.d/cups; then
-#	/sbin/init.d/cups start
-#fi
-#if test -f /etc/rc.d/init.d/cups; then
-#	/etc/rc.d/init.d/cups start
-#fi
-#if test -f /etc/init.d/cups; then
-#	/etc/init.d/cups start
-#fi
-
-%preun
-if test -f /sbin/init.d/cups; then
-	/sbin/init.d/cups stop
-fi
-if test -f /etc/rc.d/init.d/cups; then
-	/etc/rc.d/init.d/cups stop
-fi
-if test -f /etc/init.d/cups; then
-	/etc/init.d/cups stop
-fi
-
-if test -x /sbin/chkconfig; then
-	/sbin/chkconfig --del cups
-fi
-
-%clean
-rm -rf $RPM_BUILD_ROOT
-
-%files
-%defattr(-,root,root)
-%dir /etc/cups
-%config(noreplace) /etc/cups/*.conf
-%dir /etc/cups/interfaces
-/etc/cups/mime.types
-/etc/cups/mime.convs
-%dir /etc/cups/ppd
-%dir /etc/pam.d
-/etc/pam.d/*
-
-# RC dirs are a pain under Linux...  Uncomment the appropriate ones if you
-# don't use Red Hat or Mandrake...
-
-/etc/init.d/*
-/etc/rc0.d/*
-/etc/rc2.d/*
-/etc/rc3.d/*
-/etc/rc5.d/*
-
-# OLD RedHat/Mandrake
-#/etc/rc.d/init.d/*
-#/etc/rc.d/rc0.d/*
-#/etc/rc.d/rc2.d/*
-#/etc/rc.d/rc3.d/*
-#/etc/rc.d/rc5.d/*
-
-#/sbin/rc.d/*
-#/sbin/rc.d/rc0.d/*
-#/sbin/rc.d/rc2.d/*
-#/sbin/rc.d/rc3.d/*
-#/sbin/rc.d/rc5.d/*
-
-/usr/bin/cancel
-/usr/bin/cupstestppd
-/usr/bin/lp*
-%dir /usr/lib/cups
-%dir /usr/lib/cups/backend
-/usr/lib/cups/backend/*
-%dir /usr/lib/cups/cgi-bin
-/usr/lib/cups/cgi-bin/*
-%dir /usr/lib/cups/daemon
-/usr/lib/cups/daemon/cups-deviced
-/usr/lib/cups/daemon/cups-driverd
-/usr/lib/cups/daemon/cups-polld
-%dir /usr/lib/cups/driver
-%dir /usr/lib/cups/filter
-/usr/lib/cups/filter/*
-
-/usr/sbin/*
-%dir /usr/share/cups
-/usr/share/cups/*
-%dir /usr/share/doc/cups
-/usr/share/doc/cups/*
-%dir /usr/share/locale
-/usr/share/locale/*
-
-%dir /usr/share/man/cat1
-/usr/share/man/cat1/cancel.1
-/usr/share/man/cat1/cupstestppd.1
-/usr/share/man/cat1/lp.1
-/usr/share/man/cat1/lpoptions.1
-/usr/share/man/cat1/lppasswd.1
-/usr/share/man/cat1/lpq.1
-/usr/share/man/cat1/lpr.1
-/usr/share/man/cat1/lprm.1
-/usr/share/man/cat1/lpstat.1
-%dir /usr/share/man/cat5
-/usr/share/man/cat5/*
-%dir /usr/share/man/cat8
-/usr/share/man/cat8/*
-%dir /usr/share/man/man1
-/usr/share/man/man1/cancel.1.gz
-/usr/share/man/man1/cupstestppd.1.gz
-/usr/share/man/man1/lp.1.gz
-/usr/share/man/man1/lpoptions.1.gz
-/usr/share/man/man1/lppasswd.1.gz
-/usr/share/man/man1/lpq.1.gz
-/usr/share/man/man1/lpr.1.gz
-/usr/share/man/man1/lprm.1.gz
-/usr/share/man/man1/lpstat.1.gz
-%dir /usr/share/man/man5
-/usr/share/man/man5/*
-%dir /usr/share/man/man8
-/usr/share/man/man8/*
-
-%dir /var/cache/cups
-%dir /var/cache/cups/ppd
-%dir /var/log/cups
-%dir /var/run/cups
-%attr(0711,lp,root) %dir /var/run/cups/certs
-%attr(0700,lp,root) %dir /var/spool/cups
-%attr(1700,lp,root) %dir /var/spool/cups/tmp
-
-%files devel
-%defattr(-,root,root)
-%dir /usr/share/man/cat1
-/usr/share/man/cat1/backend.1
-/usr/share/man/cat1/cups-config.1
-/usr/share/man/cat1/filter.1
-%dir /usr/share/man/man1
-/usr/share/man/man1/backend.1.gz
-/usr/share/man/man1/cups-config.1.gz
-/usr/share/man/man1/filter.1.gz
-
-/usr/bin/cups-config
-%dir /usr/include/cups
-/usr/include/cups/*
-/usr/lib/*.a
-/usr/lib/*.so
-
-%files libs
-%defattr(-,root,root)
-/usr/lib/*.so.*
-
-%files lpd
-%defattr(-,root,root)
-%dir /usr/lib/cups
-%dir /usr/lib/cups/daemon
-/usr/lib/cups/daemon/cups-lpd
-#/etc/xinetd.d/cups-lpd
-
-#
-# End of "$Id: cups.spec 4604 2005-08-26 23:40:29Z mike $".
-#
diff -urNad cupsys-1.1.99.b1.r4748~/doc/Makefile cupsys-1.1.99.b1.r4748/doc/Makefile
--- cupsys-1.1.99.b1.r4748~/doc/Makefile	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/doc/Makefile	2005-10-14 05:10:22.000693000 +0900
@@ -1,5 +1,5 @@
 #
-# "$Id: Makefile 4748 2005-10-03 20:56:40Z mike $"
+# "$Id: Makefile 4786 2005-10-13 20:10:22Z mike $"
 #
 #   Documentation makefile for the Common UNIX Printing System (CUPS).
 #
@@ -29,7 +29,8 @@
 #
 
 WEBPAGES	=	cups.css cupsdoc.css index.html robots.txt
-WEBIMAGES	=	images/accept-jobs.gif \
+WEBIMAGES	=	\
+			images/accept-jobs.gif \
 			images/add-class.gif \
 			images/add-printer.gif \
 			images/add-this-printer.gif \
@@ -88,7 +89,13 @@
 			images/view-access-log.gif \
 			images/view-error-log.gif \
 			images/view-page-log.gif
-HELPFILES	=	help/access_log-reference.html \
+HELPFILES	=	\
+			help/access_log-reference.html \
+			help/api-array.html \
+			help/api-filedir.html \
+			help/api-filter.html \
+			help/api-httpipp.html \
+			help/api-ppd.html \
 			help/classes-conf-reference.html \
 			help/client-conf-reference.html \
 			help/cupsd-conf-reference.html \
diff -urNad cupsys-1.1.99.b1.r4748~/doc/cups.css cupsys-1.1.99.b1.r4748/doc/cups.css
--- cupsys-1.1.99.b1.r4748~/doc/cups.css	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/doc/cups.css	2005-10-14 04:39:05.160337000 +0900
@@ -89,6 +89,19 @@
   border: solid thin;
 }
 
+SPAN.info {
+  background: #999966;
+  border: thin solid #666644;
+  color: #ffffff;
+  font-weight: bold;
+  font-style: italic;
+  white-space: nowrap;
+}
+
+H4 SPAN.info {
+  float: right;
+}
+
 .conflict {
   color: red;
 }
diff -urNad cupsys-1.1.99.b1.r4748~/doc/help/api-array.html cupsys-1.1.99.b1.r4748/doc/help/api-array.html
--- cupsys-1.1.99.b1.r4748~/doc/help/api-array.html	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/doc/help/api-array.html	2005-10-14 04:39:05.160337000 +0900
@@ -2,11 +2,13 @@
 <html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
 <head>
 	<title>Array API</title>
-	<meta name='creator' content='Mini-XML v2.2.3'/>
+	<meta name='creator' content='Mini-XML v2.3'/>
 	<style><!--
 	h1, h2, h3, p { font-family: sans-serif; text-align: justify; }
 	tt, pre a:link, pre a:visited, tt a:link, tt a:visited { font-weight: bold; color: #7f0000; }
 	pre { font-weight: bold; color: #7f0000; margin-left: 2em; }
+	span.info { font-weight: bold; font-style: italic; color: #ffffff; background: #000000; }
+	h3 span.info { float: right; }
 	--></style>
 </head>
 <body>
@@ -18,22 +20,24 @@
 <!-- NEW PAGE -->
 <h2><a name='_functions'>Functions</a></h2>
 <ul>
-	<li><a href='#cupsArrayAdd'><tt>cupsArrayAdd()</tt></a></li>
-	<li><a href='#cupsArrayClear'><tt>cupsArrayClear()</tt></a></li>
-	<li><a href='#cupsArrayCount'><tt>cupsArrayCount()</tt></a></li>
-	<li><a href='#cupsArrayCurrent'><tt>cupsArrayCurrent()</tt></a></li>
-	<li><a href='#cupsArrayDelete'><tt>cupsArrayDelete()</tt></a></li>
-	<li><a href='#cupsArrayDup'><tt>cupsArrayDup()</tt></a></li>
-	<li><a href='#cupsArrayFind'><tt>cupsArrayFind()</tt></a></li>
-	<li><a href='#cupsArrayFirst'><tt>cupsArrayFirst()</tt></a></li>
-	<li><a href='#cupsArrayLast'><tt>cupsArrayLast()</tt></a></li>
-	<li><a href='#cupsArrayNew'><tt>cupsArrayNew()</tt></a></li>
-	<li><a href='#cupsArrayNext'><tt>cupsArrayNext()</tt></a></li>
-	<li><a href='#cupsArrayPrev'><tt>cupsArrayPrev()</tt></a></li>
-	<li><a href='#cupsArrayRemove'><tt>cupsArrayRemove()</tt></a></li>
+	<li><a href='#cupsArrayAdd'><tt>cupsArrayAdd()</tt></a> </li>
+	<li><a href='#cupsArrayClear'><tt>cupsArrayClear()</tt></a> </li>
+	<li><a href='#cupsArrayCount'><tt>cupsArrayCount()</tt></a> </li>
+	<li><a href='#cupsArrayCurrent'><tt>cupsArrayCurrent()</tt></a> </li>
+	<li><a href='#cupsArrayDelete'><tt>cupsArrayDelete()</tt></a> </li>
+	<li><a href='#cupsArrayDup'><tt>cupsArrayDup()</tt></a> </li>
+	<li><a href='#cupsArrayFind'><tt>cupsArrayFind()</tt></a> </li>
+	<li><a href='#cupsArrayFirst'><tt>cupsArrayFirst()</tt></a> </li>
+	<li><a href='#cupsArrayLast'><tt>cupsArrayLast()</tt></a> </li>
+	<li><a href='#cupsArrayNew'><tt>cupsArrayNew()</tt></a> </li>
+	<li><a href='#cupsArrayNext'><tt>cupsArrayNext()</tt></a> </li>
+	<li><a href='#cupsArrayPrev'><tt>cupsArrayPrev()</tt></a> </li>
+	<li><a href='#cupsArrayRemove'><tt>cupsArrayRemove()</tt></a> </li>
+	<li><a href='#cupsArrayRestore'><tt>cupsArrayRestore()</tt></a> </li>
+	<li><a href='#cupsArraySave'><tt>cupsArraySave()</tt></a> </li>
 </ul>
 <!-- NEW PAGE -->
-<h3><a name='cupsArrayAdd'>cupsArrayAdd()</a></h3>
+<h3><a name='cupsArrayAdd'>cupsArrayAdd()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Add an element to the array.</p>
@@ -54,7 +58,7 @@
 <h4>Returns</h4>
 <p>1 on success, 0 on failure</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsArrayClear'>cupsArrayClear()</a></h3>
+<h3><a name='cupsArrayClear'>cupsArrayClear()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Clear the array.</p>
@@ -73,7 +77,7 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsArrayCount'>cupsArrayCount()</a></h3>
+<h3><a name='cupsArrayCount'>cupsArrayCount()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get the number of elements in the array.</p>
@@ -92,7 +96,7 @@
 <h4>Returns</h4>
 <p>Number of elements</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsArrayCurrent'>cupsArrayCurrent()</a></h3>
+<h3><a name='cupsArrayCurrent'>cupsArrayCurrent()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Return the current element in the array.</p>
@@ -111,7 +115,7 @@
 <h4>Returns</h4>
 <p>Element</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsArrayDelete'>cupsArrayDelete()</a></h3>
+<h3><a name='cupsArrayDelete'>cupsArrayDelete()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Free all memory used by the array.</p>
@@ -130,7 +134,7 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsArrayDup'>cupsArrayDup()</a></h3>
+<h3><a name='cupsArrayDup'>cupsArrayDup()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Duplicate the array.</p>
@@ -149,7 +153,7 @@
 <h4>Returns</h4>
 <p>Duplicate array</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsArrayFind'>cupsArrayFind()</a></h3>
+<h3><a name='cupsArrayFind'>cupsArrayFind()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Find an elemrnt in the array.</p>
@@ -170,7 +174,7 @@
 <h4>Returns</h4>
 <p>Element found or NULL</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsArrayFirst'>cupsArrayFirst()</a></h3>
+<h3><a name='cupsArrayFirst'>cupsArrayFirst()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get the first element in the array.</p>
@@ -189,7 +193,7 @@
 <h4>Returns</h4>
 <p>First element or NULL</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsArrayLast'>cupsArrayLast()</a></h3>
+<h3><a name='cupsArrayLast'>cupsArrayLast()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get the last element in the array.</p>
@@ -208,7 +212,7 @@
 <h4>Returns</h4>
 <p>Last element or NULL</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsArrayNew'>cupsArrayNew()</a></h3>
+<h3><a name='cupsArrayNew'>cupsArrayNew()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Create a new array.</p>
@@ -216,7 +220,7 @@
 <pre>
 <a href='#cups_array_t'>cups_array_t</a> *
 cupsArrayNew(
-    cups_array_func_t f,
+    <a href='#cups_array_func_t'>cups_array_func_t</a> f,
     void * d);
 </pre>
 <h4>Arguments</h4>
@@ -229,7 +233,7 @@
 <h4>Returns</h4>
 <p>Array</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsArrayNext'>cupsArrayNext()</a></h3>
+<h3><a name='cupsArrayNext'>cupsArrayNext()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get the next element in the array.</p>
@@ -248,7 +252,7 @@
 <h4>Returns</h4>
 <p>Next element or NULL</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsArrayPrev'>cupsArrayPrev()</a></h3>
+<h3><a name='cupsArrayPrev'>cupsArrayPrev()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get the previous element in the array.</p>
@@ -267,7 +271,7 @@
 <h4>Returns</h4>
 <p>Previous element or NULL</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsArrayRemove'>cupsArrayRemove()</a></h3>
+<h3><a name='cupsArrayRemove'>cupsArrayRemove()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Remove an element from the array.</p>
@@ -288,24 +292,64 @@
 <h4>Returns</h4>
 <p>1 on success, 0 on failure</p>
 <!-- NEW PAGE -->
+<h3><a name='cupsArrayRestore'>cupsArrayRestore()</a> </h3>
+<hr noshade/>
+<h4>Description</h4>
+<p>Reset the current element to the last cupsArraySave.</p>
+<h4>Syntax</h4>
+<pre>
+void *
+cupsArrayRestore(
+    <a href='#cups_array_t'>cups_array_t</a> * a);
+</pre>
+<h4>Arguments</h4>
+<p class='table'><table align='center' border='1' width='80%' cellpadding='5' cellspacing='0' width='80%'>
+<thead><tr><th>Name</th><th>Description</th></tr></thead>
+<tbody>
+<tr><td><tt>a</tt></td><td>Array</td></tr>
+</tbody></table></p>
+<h4>Returns</h4>
+<p>New current element</p>
+<!-- NEW PAGE -->
+<h3><a name='cupsArraySave'>cupsArraySave()</a> </h3>
+<hr noshade/>
+<h4>Description</h4>
+<p>Mark the current element for a later cupsArrayRestore.</p>
+<h4>Syntax</h4>
+<pre>
+void
+cupsArraySave(
+    <a href='#cups_array_t'>cups_array_t</a> * a);
+</pre>
+<h4>Arguments</h4>
+<p class='table'><table align='center' border='1' width='80%' cellpadding='5' cellspacing='0' width='80%'>
+<thead><tr><th>Name</th><th>Description</th></tr></thead>
+<tbody>
+<tr><td><tt>a</tt></td><td>Array</td></tr>
+</tbody></table></p>
+<h4>Returns</h4>
+<p>Nothing.</p>
+<!-- NEW PAGE -->
 <h2><a name='_types'>Types</a></h2>
 <ul>
-	<li><a href='#cups_array_t'><tt>cups_array_t</tt></a></li>
-	<li><a href='#second'><tt>second</tt></a></li>
+	<li><a href='#cups_array_func_t'><tt>cups_array_func_t</tt></a> </li>
+	<li><a href='#cups_array_t'><tt>cups_array_t</tt></a> </li>
 </ul>
 <!-- NEW PAGE -->
-<h3><a name='cups_array_t'>cups_array_t</a></h3>
+<h3><a name='cups_array_func_t'>cups_array_func_t</a> </h3>
 <hr noshade/>
+<h4>Description</h4>
+<p>Array comparison function</p>
 <h4>Definition</h4>
 <pre>
-typedef struct _cups_array_s cups_array_t;
+typedef int (*cups_array_func_t)(void *first, void *second, void *data);
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='second'>second</a></h3>
+<h3><a name='cups_array_t'>cups_array_t</a> </h3>
 <hr noshade/>
 <h4>Definition</h4>
 <pre>
-typedef void * second;
+typedef struct _cups_array_s cups_array_t;
 </pre>
 </body>
 </html>
diff -urNad cupsys-1.1.99.b1.r4748~/doc/help/api-filedir.html cupsys-1.1.99.b1.r4748/doc/help/api-filedir.html
--- cupsys-1.1.99.b1.r4748~/doc/help/api-filedir.html	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/doc/help/api-filedir.html	2005-10-14 04:39:05.160337000 +0900
@@ -2,11 +2,13 @@
 <html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
 <head>
 	<title>File and Directory APIs</title>
-	<meta name='creator' content='Mini-XML v2.2.3'/>
+	<meta name='creator' content='Mini-XML v2.3'/>
 	<style><!--
 	h1, h2, h3, p { font-family: sans-serif; text-align: justify; }
 	tt, pre a:link, pre a:visited, tt a:link, tt a:visited { font-weight: bold; color: #7f0000; }
 	pre { font-weight: bold; color: #7f0000; margin-left: 2em; }
+	span.info { font-weight: bold; font-style: italic; color: #ffffff; background: #000000; }
+	h3 span.info { float: right; }
 	--></style>
 </head>
 <body>
@@ -19,34 +21,34 @@
 <!-- NEW PAGE -->
 <h2><a name='_functions'>Functions</a></h2>
 <ul>
-	<li><a href='#cupsDirClose'><tt>cupsDirClose()</tt></a></li>
-	<li><a href='#cupsDirOpen'><tt>cupsDirOpen()</tt></a></li>
-	<li><a href='#cupsDirRead'><tt>cupsDirRead()</tt></a></li>
-	<li><a href='#cupsDirRewind'><tt>cupsDirRewind()</tt></a></li>
-	<li><a href='#cupsFileClose'><tt>cupsFileClose()</tt></a></li>
-	<li><a href='#cupsFileCompression'><tt>cupsFileCompression()</tt></a></li>
-	<li><a href='#cupsFileEOF'><tt>cupsFileEOF()</tt></a></li>
-	<li><a href='#cupsFileFlush'><tt>cupsFileFlush()</tt></a></li>
-	<li><a href='#cupsFileGetChar'><tt>cupsFileGetChar()</tt></a></li>
-	<li><a href='#cupsFileGetConf'><tt>cupsFileGetConf()</tt></a></li>
-	<li><a href='#cupsFileGets'><tt>cupsFileGets()</tt></a></li>
-	<li><a href='#cupsFileLock'><tt>cupsFileLock()</tt></a></li>
-	<li><a href='#cupsFileNumber'><tt>cupsFileNumber()</tt></a></li>
-	<li><a href='#cupsFileOpen'><tt>cupsFileOpen()</tt></a></li>
-	<li><a href='#cupsFileOpenFd'><tt>cupsFileOpenFd()</tt></a></li>
-	<li><a href='#cupsFilePeekChar'><tt>cupsFilePeekChar()</tt></a></li>
-	<li><a href='#cupsFilePrintf'><tt>cupsFilePrintf()</tt></a></li>
-	<li><a href='#cupsFilePutChar'><tt>cupsFilePutChar()</tt></a></li>
-	<li><a href='#cupsFilePuts'><tt>cupsFilePuts()</tt></a></li>
-	<li><a href='#cupsFileRead'><tt>cupsFileRead()</tt></a></li>
-	<li><a href='#cupsFileRewind'><tt>cupsFileRewind()</tt></a></li>
-	<li><a href='#cupsFileSeek'><tt>cupsFileSeek()</tt></a></li>
-	<li><a href='#cupsFileTell'><tt>cupsFileTell()</tt></a></li>
-	<li><a href='#cupsFileUnlock'><tt>cupsFileUnlock()</tt></a></li>
-	<li><a href='#cupsFileWrite'><tt>cupsFileWrite()</tt></a></li>
+	<li><a href='#cupsDirClose'><tt>cupsDirClose()</tt></a> </li>
+	<li><a href='#cupsDirOpen'><tt>cupsDirOpen()</tt></a> </li>
+	<li><a href='#cupsDirRead'><tt>cupsDirRead()</tt></a> </li>
+	<li><a href='#cupsDirRewind'><tt>cupsDirRewind()</tt></a> </li>
+	<li><a href='#cupsFileClose'><tt>cupsFileClose()</tt></a> </li>
+	<li><a href='#cupsFileCompression'><tt>cupsFileCompression()</tt></a> </li>
+	<li><a href='#cupsFileEOF'><tt>cupsFileEOF()</tt></a> </li>
+	<li><a href='#cupsFileFlush'><tt>cupsFileFlush()</tt></a> </li>
+	<li><a href='#cupsFileGetChar'><tt>cupsFileGetChar()</tt></a> </li>
+	<li><a href='#cupsFileGetConf'><tt>cupsFileGetConf()</tt></a> </li>
+	<li><a href='#cupsFileGets'><tt>cupsFileGets()</tt></a> </li>
+	<li><a href='#cupsFileLock'><tt>cupsFileLock()</tt></a> </li>
+	<li><a href='#cupsFileNumber'><tt>cupsFileNumber()</tt></a> </li>
+	<li><a href='#cupsFileOpen'><tt>cupsFileOpen()</tt></a> </li>
+	<li><a href='#cupsFileOpenFd'><tt>cupsFileOpenFd()</tt></a> </li>
+	<li><a href='#cupsFilePeekChar'><tt>cupsFilePeekChar()</tt></a> </li>
+	<li><a href='#cupsFilePrintf'><tt>cupsFilePrintf()</tt></a> </li>
+	<li><a href='#cupsFilePutChar'><tt>cupsFilePutChar()</tt></a> </li>
+	<li><a href='#cupsFilePuts'><tt>cupsFilePuts()</tt></a> </li>
+	<li><a href='#cupsFileRead'><tt>cupsFileRead()</tt></a> </li>
+	<li><a href='#cupsFileRewind'><tt>cupsFileRewind()</tt></a> </li>
+	<li><a href='#cupsFileSeek'><tt>cupsFileSeek()</tt></a> </li>
+	<li><a href='#cupsFileTell'><tt>cupsFileTell()</tt></a> </li>
+	<li><a href='#cupsFileUnlock'><tt>cupsFileUnlock()</tt></a> </li>
+	<li><a href='#cupsFileWrite'><tt>cupsFileWrite()</tt></a> </li>
 </ul>
 <!-- NEW PAGE -->
-<h3><a name='cupsDirClose'>cupsDirClose()</a></h3>
+<h3><a name='cupsDirClose'>cupsDirClose()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Close a directory.</p>
@@ -65,7 +67,7 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsDirOpen'>cupsDirOpen()</a></h3>
+<h3><a name='cupsDirOpen'>cupsDirOpen()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Open a directory.</p>
@@ -84,7 +86,7 @@
 <h4>Returns</h4>
 <p>Directory</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsDirRead'>cupsDirRead()</a></h3>
+<h3><a name='cupsDirRead'>cupsDirRead()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Read the next directory entry.</p>
@@ -103,7 +105,7 @@
 <h4>Returns</h4>
 <p>Directory entry</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsDirRewind'>cupsDirRewind()</a></h3>
+<h3><a name='cupsDirRewind'>cupsDirRewind()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Rewind to the start of the directory.</p>
@@ -122,7 +124,7 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFileClose'>cupsFileClose()</a></h3>
+<h3><a name='cupsFileClose'>cupsFileClose()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Close a CUPS file.</p>
@@ -141,7 +143,7 @@
 <h4>Returns</h4>
 <p>0 on success, -1 on error</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFileCompression'>cupsFileCompression()</a></h3>
+<h3><a name='cupsFileCompression'>cupsFileCompression()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Return whether a file is compressed.</p>
@@ -160,7 +162,7 @@
 <h4>Returns</h4>
 <p>CUPS_FILE_NONE or CUPS_FILE_GZIP</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFileEOF'>cupsFileEOF()</a></h3>
+<h3><a name='cupsFileEOF'>cupsFileEOF()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Return the end-of-file status.</p>
@@ -179,7 +181,7 @@
 <h4>Returns</h4>
 <p>1 on EOF, 0 otherwise</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFileFlush'>cupsFileFlush()</a></h3>
+<h3><a name='cupsFileFlush'>cupsFileFlush()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Flush pending output.</p>
@@ -198,7 +200,7 @@
 <h4>Returns</h4>
 <p>0 on success, -1 on error</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFileGetChar'>cupsFileGetChar()</a></h3>
+<h3><a name='cupsFileGetChar'>cupsFileGetChar()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get a single character from a file.</p>
@@ -217,7 +219,7 @@
 <h4>Returns</h4>
 <p>Character or -1 on EOF</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFileGetConf'>cupsFileGetConf()</a></h3>
+<h3><a name='cupsFileGetConf'>cupsFileGetConf()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get a line from a configuration file...</p>
@@ -244,7 +246,7 @@
 <h4>Returns</h4>
 <p>Line read of NULL on eof/error</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFileGets'>cupsFileGets()</a></h3>
+<h3><a name='cupsFileGets'>cupsFileGets()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get a CR and/or LF-terminated line.</p>
@@ -267,7 +269,7 @@
 <h4>Returns</h4>
 <p>Line read or NULL on eof/error</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFileLock'>cupsFileLock()</a></h3>
+<h3><a name='cupsFileLock'>cupsFileLock()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Temporarily lock access to a file.</p>
@@ -288,7 +290,7 @@
 <h4>Returns</h4>
 <p>0 on success, -1 on error</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFileNumber'>cupsFileNumber()</a></h3>
+<h3><a name='cupsFileNumber'>cupsFileNumber()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Return the file descriptor associated with a CUPS file.</p>
@@ -307,7 +309,7 @@
 <h4>Returns</h4>
 <p>File descriptor</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFileOpen'>cupsFileOpen()</a></h3>
+<h3><a name='cupsFileOpen'>cupsFileOpen()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Open a CUPS file.</p>
@@ -328,7 +330,7 @@
 <h4>Returns</h4>
 <p>CUPS file or NULL</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFileOpenFd'>cupsFileOpenFd()</a></h3>
+<h3><a name='cupsFileOpenFd'>cupsFileOpenFd()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Open a CUPS file using a file descriptor.</p>
@@ -349,7 +351,7 @@
 <h4>Returns</h4>
 <p>CUPS file or NULL</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFilePeekChar'>cupsFilePeekChar()</a></h3>
+<h3><a name='cupsFilePeekChar'>cupsFilePeekChar()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Peek at the next character from a file.</p>
@@ -368,7 +370,7 @@
 <h4>Returns</h4>
 <p>Character or -1 on EOF</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFilePrintf'>cupsFilePrintf()</a></h3>
+<h3><a name='cupsFilePrintf'>cupsFilePrintf()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Write a formatted string.</p>
@@ -391,7 +393,7 @@
 <h4>Returns</h4>
 <p>Number of bytes written or -1</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFilePutChar'>cupsFilePutChar()</a></h3>
+<h3><a name='cupsFilePutChar'>cupsFilePutChar()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Write a character.</p>
@@ -412,7 +414,7 @@
 <h4>Returns</h4>
 <p>0 on success, -1 on error</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFilePuts'>cupsFilePuts()</a></h3>
+<h3><a name='cupsFilePuts'>cupsFilePuts()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Write a string.</p>
@@ -433,7 +435,7 @@
 <h4>Returns</h4>
 <p>Number of bytes written or -1</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFileRead'>cupsFileRead()</a></h3>
+<h3><a name='cupsFileRead'>cupsFileRead()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Read from a file.</p>
@@ -456,7 +458,7 @@
 <h4>Returns</h4>
 <p>Number of bytes read or -1</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFileRewind'>cupsFileRewind()</a></h3>
+<h3><a name='cupsFileRewind'>cupsFileRewind()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Rewind a file.</p>
@@ -475,7 +477,7 @@
 <h4>Returns</h4>
 <p>New file position or -1</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFileSeek'>cupsFileSeek()</a></h3>
+<h3><a name='cupsFileSeek'>cupsFileSeek()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Seek in a file.</p>
@@ -496,7 +498,7 @@
 <h4>Returns</h4>
 <p>New file position or -1</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFileTell'>cupsFileTell()</a></h3>
+<h3><a name='cupsFileTell'>cupsFileTell()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Return the current file position.</p>
@@ -515,7 +517,7 @@
 <h4>Returns</h4>
 <p>File position</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFileUnlock'>cupsFileUnlock()</a></h3>
+<h3><a name='cupsFileUnlock'>cupsFileUnlock()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Unlock access to a file.</p>
@@ -534,7 +536,7 @@
 <h4>Returns</h4>
 <p>0 on success, -1 on error</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFileWrite'>cupsFileWrite()</a></h3>
+<h3><a name='cupsFileWrite'>cupsFileWrite()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Write to a file.</p>
@@ -559,10 +561,10 @@
 <!-- NEW PAGE -->
 <h2><a name='_structures'>Structures</a></h2>
 <ul>
-	<li><a href='#cups_dentry_s'><tt>cups_dentry_s</tt></a></li>
+	<li><a href='#cups_dentry_s'><tt>cups_dentry_s</tt></a> </li>
 </ul>
 <!-- NEW PAGE -->
-<h3><a name='cups_dentry_s'>cups_dentry_s</a></h3>
+<h3><a name='cups_dentry_s'>cups_dentry_s</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Directory entry type</p>
@@ -578,18 +580,18 @@
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>fileinfo</tt></td><td>File information</td></tr>
-<tr><td><tt>filename[260]</tt></td><td>File name</td></tr>
+<tr><td><tt>fileinfo</tt> </td><td>File information</td></tr>
+<tr><td><tt>filename[260]</tt> </td><td>File name</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
 <h2><a name='_types'>Types</a></h2>
 <ul>
-	<li><a href='#cups_dentry_t'><tt>cups_dentry_t</tt></a></li>
-	<li><a href='#cups_dir_t'><tt>cups_dir_t</tt></a></li>
-	<li><a href='#cups_file_t'><tt>cups_file_t</tt></a></li>
+	<li><a href='#cups_dentry_t'><tt>cups_dentry_t</tt></a> </li>
+	<li><a href='#cups_dir_t'><tt>cups_dir_t</tt></a> </li>
+	<li><a href='#cups_file_t'><tt>cups_file_t</tt></a> </li>
 </ul>
 <!-- NEW PAGE -->
-<h3><a name='cups_dentry_t'>cups_dentry_t</a></h3>
+<h3><a name='cups_dentry_t'>cups_dentry_t</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Directory entry type</p>
@@ -598,14 +600,14 @@
 typedef struct <a href='#cups_dentry_s'>cups_dentry_s</a> cups_dentry_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='cups_dir_t'>cups_dir_t</a></h3>
+<h3><a name='cups_dir_t'>cups_dir_t</a> </h3>
 <hr noshade/>
 <h4>Definition</h4>
 <pre>
 typedef struct _cups_dir_s cups_dir_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='cups_file_t'>cups_file_t</a></h3>
+<h3><a name='cups_file_t'>cups_file_t</a> </h3>
 <hr noshade/>
 <h4>Definition</h4>
 <pre>
diff -urNad cupsys-1.1.99.b1.r4748~/doc/help/api-filter.html cupsys-1.1.99.b1.r4748/doc/help/api-filter.html
--- cupsys-1.1.99.b1.r4748~/doc/help/api-filter.html	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/doc/help/api-filter.html	2005-10-14 04:39:05.160337000 +0900
@@ -2,11 +2,13 @@
 <html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
 <head>
 	<title>Filter and Backend APIs</title>
-	<meta name='creator' content='Mini-XML v2.2.3'/>
+	<meta name='creator' content='Mini-XML v2.3'/>
 	<style><!--
 	h1, h2, h3, p { font-family: sans-serif; text-align: justify; }
 	tt, pre a:link, pre a:visited, tt a:link, tt a:visited { font-weight: bold; color: #7f0000; }
 	pre { font-weight: bold; color: #7f0000; margin-left: 2em; }
+	span.info { font-weight: bold; font-style: italic; color: #ffffff; background: #000000; }
+	h3 span.info { float: right; }
 	--></style>
 </head>
 <body>
@@ -17,11 +19,11 @@
 <!-- NEW PAGE -->
 <h2><a name='_functions'>Functions</a></h2>
 <ul>
-	<li><a href='#cupsBackchannelRead'><tt>cupsBackchannelRead()</tt></a></li>
-	<li><a href='#cupsBackchannelWrite'><tt>cupsBackchannelWrite()</tt></a></li>
+	<li><a href='#cupsBackchannelRead'><tt>cupsBackchannelRead()</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#cupsBackchannelWrite'><tt>cupsBackchannelWrite()</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
 </ul>
 <!-- NEW PAGE -->
-<h3><a name='cupsBackchannelRead'>cupsBackchannelRead()</a></h3>
+<h3><a name='cupsBackchannelRead'>cupsBackchannelRead()</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Read data from the backchannel.
@@ -29,7 +31,9 @@
 Reads up to &quot;bytes&quot; bytes from the backchannel. The &quot;timeout&quot;
 parameter controls how many seconds to wait for the data - use
 0.0 to return immediately if there is no data, -1.0 to wait
-for data indefinitely.</p>
+for data indefinitely.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 int
@@ -49,7 +53,7 @@
 <h4>Returns</h4>
 <p>Bytes read or -1 on error</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsBackchannelWrite'>cupsBackchannelWrite()</a></h3>
+<h3><a name='cupsBackchannelWrite'>cupsBackchannelWrite()</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Write data to the backchannel.
@@ -57,7 +61,9 @@
 Writes &quot;bytes&quot; bytes to the backchannel. The &quot;timeout&quot; parameter
 controls how many seconds to wait for the data to be written - use
 0.0 to return immediately if the data cannot be written, -1.0 to wait
-indefinitely.</p>
+indefinitely.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 int
diff -urNad cupsys-1.1.99.b1.r4748~/doc/help/api-httpipp.html cupsys-1.1.99.b1.r4748/doc/help/api-httpipp.html
--- cupsys-1.1.99.b1.r4748~/doc/help/api-httpipp.html	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/doc/help/api-httpipp.html	2005-10-14 04:39:05.160337000 +0900
@@ -2,11 +2,13 @@
 <html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
 <head>
 	<title>HTTP and IPP APIs</title>
-	<meta name='creator' content='Mini-XML v2.2.3'/>
+	<meta name='creator' content='Mini-XML v2.3'/>
 	<style><!--
 	h1, h2, h3, p { font-family: sans-serif; text-align: justify; }
 	tt, pre a:link, pre a:visited, tt a:link, tt a:visited { font-weight: bold; color: #7f0000; }
 	pre { font-weight: bold; color: #7f0000; margin-left: 2em; }
+	span.info { font-weight: bold; font-style: italic; color: #ffffff; background: #000000; }
+	h3 span.info { float: right; }
 	--></style>
 </head>
 <body>
@@ -16,14 +18,24 @@
 	<li><a href='#_functions'>Functions</a></li>
 	<li><a href='#_structures'>Structures</a></li>
 	<li><a href='#_types'>Types</a></li>
+	<li><a href='#_unions'>Unions</a></li>
 </ul>
 <!-- NEW PAGE -->
 <h2><a name='_enumerations'>Enumerations</a></h2>
 <ul>
-	<li><a href='#cups_ptype_e'><tt>cups_ptype_e</tt></a></li>
+	<li><a href='#cups_ptype_e'><tt>cups_ptype_e</tt></a> </li>
+	<li><a href='#http_auth_e'><tt>http_auth_e</tt></a> </li>
+	<li><a href='#http_encoding_e'><tt>http_encoding_e</tt></a> </li>
+	<li><a href='#http_encryption_e'><tt>http_encryption_e</tt></a> </li>
+	<li><a href='#http_field_e'><tt>http_field_e</tt></a> </li>
+	<li><a href='#http_keepalive_e'><tt>http_keepalive_e</tt></a> </li>
+	<li><a href='#http_state_e'><tt>http_state_e</tt></a> </li>
+	<li><a href='#http_status_e'><tt>http_status_e</tt></a> </li>
+	<li><a href='#http_uri_status_e'><tt>http_uri_status_e</tt></a> <span class='info'>&nbsp;CUPS1.2&nbsp;</span></li>
+	<li><a href='#http_version_e'><tt>http_version_e</tt></a> </li>
 </ul>
 <!-- NEW PAGE -->
-<h3><a name='cups_ptype_e'>cups_ptype_e</a></h3>
+<h3><a name='cups_ptype_e'>cups_ptype_e</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Not a typedef'd enum so we can OR</p>
@@ -31,162 +43,367 @@
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>CUPS_PRINTER_BIND</tt></td><td>Can bind output</td></tr>
-<tr><td><tt>CUPS_PRINTER_BW</tt></td><td>Can do B&amp;W printing</td></tr>
-<tr><td><tt>CUPS_PRINTER_CLASS</tt></td><td>Printer class</td></tr>
-<tr><td><tt>CUPS_PRINTER_COLLATE</tt></td><td>Can collage copies</td></tr>
-<tr><td><tt>CUPS_PRINTER_COLOR</tt></td><td>Can do color printing</td></tr>
-<tr><td><tt>CUPS_PRINTER_COPIES</tt></td><td>Can do copies</td></tr>
-<tr><td><tt>CUPS_PRINTER_COVER</tt></td><td>Can cover output</td></tr>
-<tr><td><tt>CUPS_PRINTER_DEFAULT</tt></td><td>Default printer on network</td></tr>
-<tr><td><tt>CUPS_PRINTER_DELETE</tt></td><td>Delete printer</td></tr>
-<tr><td><tt>CUPS_PRINTER_DUPLEX</tt></td><td>Can do duplexing</td></tr>
-<tr><td><tt>CUPS_PRINTER_FAX</tt></td><td>Fax queue</td></tr>
-<tr><td><tt>CUPS_PRINTER_IMPLICIT</tt></td><td>Implicit class</td></tr>
-<tr><td><tt>CUPS_PRINTER_LARGE</tt></td><td>Can do D/E/A1/A0</td></tr>
-<tr><td><tt>CUPS_PRINTER_LOCAL</tt></td><td>Local printer or class</td></tr>
-<tr><td><tt>CUPS_PRINTER_MEDIUM</tt></td><td>Can do Tabloid/B/C/A3/A2</td></tr>
-<tr><td><tt>CUPS_PRINTER_NOT_SHARED</tt></td><td>Printer is not shared</td></tr>
-<tr><td><tt>CUPS_PRINTER_OPTIONS</tt></td><td>~(CLASS | REMOTE | IMPLICIT)</td></tr>
-<tr><td><tt>CUPS_PRINTER_PUNCH</tt></td><td>Can punch output</td></tr>
-<tr><td><tt>CUPS_PRINTER_REJECTING</tt></td><td>Printer is rejecting jobs</td></tr>
-<tr><td><tt>CUPS_PRINTER_REMOTE</tt></td><td>Remote printer or class</td></tr>
-<tr><td><tt>CUPS_PRINTER_SMALL</tt></td><td>Can do Letter/Legal/A4</td></tr>
-<tr><td><tt>CUPS_PRINTER_SORT</tt></td><td>Can sort output</td></tr>
-<tr><td><tt>CUPS_PRINTER_STAPLE</tt></td><td>Can staple output</td></tr>
-<tr><td><tt>CUPS_PRINTER_VARIABLE</tt></td><td>Can do variable sizes</td></tr>
+<tr><td><tt>CUPS_PRINTER_AUTHENTICATED</tt> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></td><td>Printer requires authentication </td></tr>
+<tr><td><tt>CUPS_PRINTER_BIND</tt> </td><td>Can bind output</td></tr>
+<tr><td><tt>CUPS_PRINTER_BW</tt> </td><td>Can do B&amp;W printing</td></tr>
+<tr><td><tt>CUPS_PRINTER_CLASS</tt> </td><td>Printer class</td></tr>
+<tr><td><tt>CUPS_PRINTER_COLLATE</tt> </td><td>Can collage copies</td></tr>
+<tr><td><tt>CUPS_PRINTER_COLOR</tt> </td><td>Can do color printing</td></tr>
+<tr><td><tt>CUPS_PRINTER_COPIES</tt> </td><td>Can do copies</td></tr>
+<tr><td><tt>CUPS_PRINTER_COVER</tt> </td><td>Can cover output</td></tr>
+<tr><td><tt>CUPS_PRINTER_DEFAULT</tt> </td><td>Default printer on network</td></tr>
+<tr><td><tt>CUPS_PRINTER_DELETE</tt> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></td><td>Delete printer </td></tr>
+<tr><td><tt>CUPS_PRINTER_DUPLEX</tt> </td><td>Can do duplexing</td></tr>
+<tr><td><tt>CUPS_PRINTER_FAX</tt> </td><td>Fax queue</td></tr>
+<tr><td><tt>CUPS_PRINTER_IMPLICIT</tt> </td><td>Implicit class</td></tr>
+<tr><td><tt>CUPS_PRINTER_LARGE</tt> </td><td>Can do D/E/A1/A0</td></tr>
+<tr><td><tt>CUPS_PRINTER_LOCAL</tt> </td><td>Local printer or class</td></tr>
+<tr><td><tt>CUPS_PRINTER_MEDIUM</tt> </td><td>Can do Tabloid/B/C/A3/A2</td></tr>
+<tr><td><tt>CUPS_PRINTER_NOT_SHARED</tt> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></td><td>Printer is not shared </td></tr>
+<tr><td><tt>CUPS_PRINTER_OPTIONS</tt> </td><td>~(CLASS | REMOTE | IMPLICIT)</td></tr>
+<tr><td><tt>CUPS_PRINTER_PUNCH</tt> </td><td>Can punch output</td></tr>
+<tr><td><tt>CUPS_PRINTER_REJECTING</tt> </td><td>Printer is rejecting jobs</td></tr>
+<tr><td><tt>CUPS_PRINTER_REMOTE</tt> </td><td>Remote printer or class</td></tr>
+<tr><td><tt>CUPS_PRINTER_SMALL</tt> </td><td>Can do Letter/Legal/A4</td></tr>
+<tr><td><tt>CUPS_PRINTER_SORT</tt> </td><td>Can sort output</td></tr>
+<tr><td><tt>CUPS_PRINTER_STAPLE</tt> </td><td>Can staple output</td></tr>
+<tr><td><tt>CUPS_PRINTER_VARIABLE</tt> </td><td>Can do variable sizes</td></tr>
+</tbody></table></p>
+<!-- NEW PAGE -->
+<h3><a name='http_auth_e'>http_auth_e</a> </h3>
+<hr noshade/>
+<h4>Description</h4>
+<p>HTTP authentication types</p>
+<h4>Values</h4>
+<p class='table'><table align='center' border='1' width='80%'>
+<thead><tr><th>Name</th><th>Description</th></tr></thead>
+<tbody>
+<tr><td><tt>HTTP_AUTH_BASIC</tt> </td><td>Basic authentication in use</td></tr>
+<tr><td><tt>HTTP_AUTH_MD5</tt> </td><td>Digest authentication in use</td></tr>
+<tr><td><tt>HTTP_AUTH_MD5_INT</tt> </td><td>Digest authentication in use for body</td></tr>
+<tr><td><tt>HTTP_AUTH_MD5_SESS</tt> </td><td>MD5-session authentication in use</td></tr>
+<tr><td><tt>HTTP_AUTH_MD5_SESS_INT</tt> </td><td>MD5-session authentication in use for body</td></tr>
+<tr><td><tt>HTTP_AUTH_NONE</tt> </td><td>No authentication in use</td></tr>
+</tbody></table></p>
+<!-- NEW PAGE -->
+<h3><a name='http_encoding_e'>http_encoding_e</a> </h3>
+<hr noshade/>
+<h4>Description</h4>
+<p>HTTP transfer encoding values</p>
+<h4>Values</h4>
+<p class='table'><table align='center' border='1' width='80%'>
+<thead><tr><th>Name</th><th>Description</th></tr></thead>
+<tbody>
+<tr><td><tt>HTTP_ENCODE_CHUNKED</tt> </td><td>Data is chunked</td></tr>
+<tr><td><tt>HTTP_ENCODE_LENGTH</tt> </td><td>Data is sent with Content-Length</td></tr>
+</tbody></table></p>
+<!-- NEW PAGE -->
+<h3><a name='http_encryption_e'>http_encryption_e</a> </h3>
+<hr noshade/>
+<h4>Description</h4>
+<p>HTTP encryption values</p>
+<h4>Values</h4>
+<p class='table'><table align='center' border='1' width='80%'>
+<thead><tr><th>Name</th><th>Description</th></tr></thead>
+<tbody>
+<tr><td><tt>HTTP_ENCRYPT_ALWAYS</tt> </td><td>Always encrypt (SSL)</td></tr>
+<tr><td><tt>HTTP_ENCRYPT_IF_REQUESTED</tt> </td><td>Encrypt if requested (TLS upgrade)</td></tr>
+<tr><td><tt>HTTP_ENCRYPT_NEVER</tt> </td><td>Never encrypt</td></tr>
+<tr><td><tt>HTTP_ENCRYPT_REQUIRED</tt> </td><td>Encryption is required (TLS upgrade)</td></tr>
+</tbody></table></p>
+<!-- NEW PAGE -->
+<h3><a name='http_field_e'>http_field_e</a> </h3>
+<hr noshade/>
+<h4>Description</h4>
+<p>HTTP field names</p>
+<h4>Values</h4>
+<p class='table'><table align='center' border='1' width='80%'>
+<thead><tr><th>Name</th><th>Description</th></tr></thead>
+<tbody>
+<tr><td><tt>HTTP_FIELD_ACCEPT_LANGUAGE</tt> </td><td>Accept-Language field</td></tr>
+<tr><td><tt>HTTP_FIELD_ACCEPT_RANGES</tt> </td><td>Accept-Ranges field</td></tr>
+<tr><td><tt>HTTP_FIELD_AUTHORIZATION</tt> </td><td>Authorization field</td></tr>
+<tr><td><tt>HTTP_FIELD_CONNECTION</tt> </td><td>Connection field</td></tr>
+<tr><td><tt>HTTP_FIELD_CONTENT_ENCODING</tt> </td><td>Content-Encoding field</td></tr>
+<tr><td><tt>HTTP_FIELD_CONTENT_LANGUAGE</tt> </td><td>Content-Language field</td></tr>
+<tr><td><tt>HTTP_FIELD_CONTENT_LENGTH</tt> </td><td>Content-Length field</td></tr>
+<tr><td><tt>HTTP_FIELD_CONTENT_LOCATION</tt> </td><td>Content-Location field</td></tr>
+<tr><td><tt>HTTP_FIELD_CONTENT_MD5</tt> </td><td>Content-MD5 field</td></tr>
+<tr><td><tt>HTTP_FIELD_CONTENT_RANGE</tt> </td><td>Content-Range field</td></tr>
+<tr><td><tt>HTTP_FIELD_CONTENT_TYPE</tt> </td><td>Content-Type field</td></tr>
+<tr><td><tt>HTTP_FIELD_CONTENT_VERSION</tt> </td><td>Content-Version field</td></tr>
+<tr><td><tt>HTTP_FIELD_DATE</tt> </td><td>Date field</td></tr>
+<tr><td><tt>HTTP_FIELD_HOST</tt> </td><td>Host field</td></tr>
+<tr><td><tt>HTTP_FIELD_IF_MODIFIED_SINCE</tt> </td><td>If-Modified-Since field</td></tr>
+<tr><td><tt>HTTP_FIELD_IF_UNMODIFIED_SINCE</tt> </td><td>If-Unmodified-Since field</td></tr>
+<tr><td><tt>HTTP_FIELD_KEEP_ALIVE</tt> </td><td>Keep-Alive field</td></tr>
+<tr><td><tt>HTTP_FIELD_LAST_MODIFIED</tt> </td><td>Last-Modified field</td></tr>
+<tr><td><tt>HTTP_FIELD_LINK</tt> </td><td>Link field</td></tr>
+<tr><td><tt>HTTP_FIELD_LOCATION</tt> </td><td>Location field</td></tr>
+<tr><td><tt>HTTP_FIELD_MAX</tt> </td><td>Maximum field index</td></tr>
+<tr><td><tt>HTTP_FIELD_RANGE</tt> </td><td>Range field</td></tr>
+<tr><td><tt>HTTP_FIELD_REFERER</tt> </td><td>Referer field</td></tr>
+<tr><td><tt>HTTP_FIELD_RETRY_AFTER</tt> </td><td>Retry-After field</td></tr>
+<tr><td><tt>HTTP_FIELD_TRANSFER_ENCODING</tt> </td><td>Transfer-Encoding field</td></tr>
+<tr><td><tt>HTTP_FIELD_UNKNOWN</tt> </td><td>Unknown field</td></tr>
+<tr><td><tt>HTTP_FIELD_UPGRADE</tt> </td><td>Upgrade field</td></tr>
+<tr><td><tt>HTTP_FIELD_USER_AGENT</tt> </td><td>User-Agent field</td></tr>
+<tr><td><tt>HTTP_FIELD_WWW_AUTHENTICATE</tt> </td><td>WWW-Authenticate field</td></tr>
+</tbody></table></p>
+<!-- NEW PAGE -->
+<h3><a name='http_keepalive_e'>http_keepalive_e</a> </h3>
+<hr noshade/>
+<h4>Description</h4>
+<p>HTTP keep-alive values</p>
+<h4>Values</h4>
+<p class='table'><table align='center' border='1' width='80%'>
+<thead><tr><th>Name</th><th>Description</th></tr></thead>
+<tbody>
+<tr><td><tt>HTTP_KEEPALIVE_OFF</tt> </td><td>No keep alive support</td></tr>
+<tr><td><tt>HTTP_KEEPALIVE_ON</tt> </td><td>Use keep alive</td></tr>
+</tbody></table></p>
+<!-- NEW PAGE -->
+<h3><a name='http_state_e'>http_state_e</a> </h3>
+<hr noshade/>
+<h4>Description</h4>
+<p>HTTP state values; states
+are server-oriented...</p>
+<h4>Values</h4>
+<p class='table'><table align='center' border='1' width='80%'>
+<thead><tr><th>Name</th><th>Description</th></tr></thead>
+<tbody>
+<tr><td><tt>HTTP_CLOSE</tt> </td><td>CLOSE command, waiting for blank line</td></tr>
+<tr><td><tt>HTTP_DELETE</tt> </td><td>DELETE command, waiting for blank line</td></tr>
+<tr><td><tt>HTTP_GET</tt> </td><td>GET command, waiting for blank line</td></tr>
+<tr><td><tt>HTTP_GET_SEND</tt> </td><td>GET command, sending data</td></tr>
+<tr><td><tt>HTTP_HEAD</tt> </td><td>HEAD command, waiting for blank line</td></tr>
+<tr><td><tt>HTTP_OPTIONS</tt> </td><td>OPTIONS command, waiting for blank line</td></tr>
+<tr><td><tt>HTTP_POST</tt> </td><td>POST command, waiting for blank line</td></tr>
+<tr><td><tt>HTTP_POST_RECV</tt> </td><td>POST command, receiving data</td></tr>
+<tr><td><tt>HTTP_POST_SEND</tt> </td><td>POST command, sending data</td></tr>
+<tr><td><tt>HTTP_PUT</tt> </td><td>PUT command, waiting for blank line</td></tr>
+<tr><td><tt>HTTP_PUT_RECV</tt> </td><td>PUT command, receiving data</td></tr>
+<tr><td><tt>HTTP_STATUS</tt> </td><td>Command complete, sending status</td></tr>
+<tr><td><tt>HTTP_TRACE</tt> </td><td>TRACE command, waiting for blank line</td></tr>
+<tr><td><tt>HTTP_WAITING</tt> </td><td>Waiting for command</td></tr>
+</tbody></table></p>
+<!-- NEW PAGE -->
+<h3><a name='http_status_e'>http_status_e</a> </h3>
+<hr noshade/>
+<h4>Description</h4>
+<p>HTTP status codes</p>
+<h4>Values</h4>
+<p class='table'><table align='center' border='1' width='80%'>
+<thead><tr><th>Name</th><th>Description</th></tr></thead>
+<tbody>
+<tr><td><tt>HTTP_ACCEPTED</tt> </td><td>DELETE command was successful</td></tr>
+<tr><td><tt>HTTP_BAD_GATEWAY</tt> </td><td>Bad gateway</td></tr>
+<tr><td><tt>HTTP_BAD_REQUEST</tt> </td><td>Bad request</td></tr>
+<tr><td><tt>HTTP_CONFLICT</tt> </td><td>Request is self-conflicting</td></tr>
+<tr><td><tt>HTTP_CONTINUE</tt> </td><td>Everything OK, keep going...</td></tr>
+<tr><td><tt>HTTP_CREATED</tt> </td><td>PUT command was successful</td></tr>
+<tr><td><tt>HTTP_ERROR</tt> </td><td>An error response from httpXxxx()</td></tr>
+<tr><td><tt>HTTP_FORBIDDEN</tt> </td><td>Forbidden to access this URI</td></tr>
+<tr><td><tt>HTTP_GATEWAY_TIMEOUT</tt> </td><td>Gateway connection timed out</td></tr>
+<tr><td><tt>HTTP_GONE</tt> </td><td>Server has gone away</td></tr>
+<tr><td><tt>HTTP_LENGTH_REQUIRED</tt> </td><td>A content length or encoding is required</td></tr>
+<tr><td><tt>HTTP_METHOD_NOT_ALLOWED</tt> </td><td>Method is not allowed</td></tr>
+<tr><td><tt>HTTP_MOVED_PERMANENTLY</tt> </td><td>Document has moved permanently</td></tr>
+<tr><td><tt>HTTP_MOVED_TEMPORARILY</tt> </td><td>Document has moved temporarily</td></tr>
+<tr><td><tt>HTTP_MULTIPLE_CHOICES</tt> </td><td>Multiple files match request</td></tr>
+<tr><td><tt>HTTP_NOT_ACCEPTABLE</tt> </td><td>Not Acceptable</td></tr>
+<tr><td><tt>HTTP_NOT_AUTHORITATIVE</tt> </td><td>Information isn't authoritative</td></tr>
+<tr><td><tt>HTTP_NOT_FOUND</tt> </td><td>URI was not found</td></tr>
+<tr><td><tt>HTTP_NOT_IMPLEMENTED</tt> </td><td>Feature not implemented</td></tr>
+<tr><td><tt>HTTP_NOT_MODIFIED</tt> </td><td>File not modified</td></tr>
+<tr><td><tt>HTTP_NOT_SUPPORTED</tt> </td><td>HTTP version not supported</td></tr>
+<tr><td><tt>HTTP_NO_CONTENT</tt> </td><td>Successful command, no new data</td></tr>
+<tr><td><tt>HTTP_OK</tt> </td><td>OPTIONS/GET/HEAD/POST/TRACE command was successful</td></tr>
+<tr><td><tt>HTTP_PARTIAL_CONTENT</tt> </td><td>Only a partial file was recieved/sent</td></tr>
+<tr><td><tt>HTTP_PAYMENT_REQUIRED</tt> </td><td>Payment required</td></tr>
+<tr><td><tt>HTTP_PRECONDITION</tt> </td><td>Precondition failed</td></tr>
+<tr><td><tt>HTTP_PROXY_AUTHENTICATION</tt> </td><td>Proxy Authentication is Required</td></tr>
+<tr><td><tt>HTTP_REQUEST_TIMEOUT</tt> </td><td>Request timed out</td></tr>
+<tr><td><tt>HTTP_REQUEST_TOO_LARGE</tt> </td><td>Request entity too large</td></tr>
+<tr><td><tt>HTTP_RESET_CONTENT</tt> </td><td>Content was reset/recreated</td></tr>
+<tr><td><tt>HTTP_SEE_OTHER</tt> </td><td>See this other link...</td></tr>
+<tr><td><tt>HTTP_SERVER_ERROR</tt> </td><td>Internal server error</td></tr>
+<tr><td><tt>HTTP_SERVICE_UNAVAILABLE</tt> </td><td>Service is unavailable</td></tr>
+<tr><td><tt>HTTP_SWITCHING_PROTOCOLS</tt> </td><td>HTTP upgrade to TLS/SSL</td></tr>
+<tr><td><tt>HTTP_UNAUTHORIZED</tt> </td><td>Unauthorized to access host</td></tr>
+<tr><td><tt>HTTP_UNSUPPORTED_MEDIATYPE</tt> </td><td>The requested media type is unsupported</td></tr>
+<tr><td><tt>HTTP_UPGRADE_REQUIRED</tt> </td><td>Upgrade to SSL/TLS required</td></tr>
+<tr><td><tt>HTTP_URI_TOO_LONG</tt> </td><td>URI too long</td></tr>
+<tr><td><tt>HTTP_USE_PROXY</tt> </td><td>Must use a proxy to access this URI</td></tr>
+</tbody></table></p>
+<!-- NEW PAGE -->
+<h3><a name='http_uri_status_e'>http_uri_status_e</a> <span class='info'>&nbsp;CUPS1.2&nbsp;</span></h3>
+<hr noshade/>
+<h4>Description</h4>
+<p>URI separation status </p>
+<h4>Values</h4>
+<p class='table'><table align='center' border='1' width='80%'>
+<thead><tr><th>Name</th><th>Description</th></tr></thead>
+<tbody>
+<tr><td><tt>HTTP_URI_BAD_ARGUMENTS</tt> </td><td>Bad arguments to function (error)</td></tr>
+<tr><td><tt>HTTP_URI_BAD_HOSTNAME</tt> </td><td>Bad hostname in URI (error)</td></tr>
+<tr><td><tt>HTTP_URI_BAD_PORT</tt> </td><td>Bad port number in URI (error)</td></tr>
+<tr><td><tt>HTTP_URI_BAD_RESOURCE</tt> </td><td>Bad resource in URI (error)</td></tr>
+<tr><td><tt>HTTP_URI_BAD_SCHEME</tt> </td><td>Bad scheme in URI (error)</td></tr>
+<tr><td><tt>HTTP_URI_BAD_URI</tt> </td><td>Bad/empty URI (error)</td></tr>
+<tr><td><tt>HTTP_URI_BAD_USERNAME</tt> </td><td>Bad username in URI (error)</td></tr>
+<tr><td><tt>HTTP_URI_MISSING_RESOURCE</tt> </td><td>Missing resource in URI (warning)</td></tr>
+<tr><td><tt>HTTP_URI_MISSING_SCHEME</tt> </td><td>Missing scheme in URI (warning)</td></tr>
+<tr><td><tt>HTTP_URI_OK</tt> </td><td>URI decoded OK</td></tr>
+<tr><td><tt>HTTP_URI_UNKNOWN_SCHEME</tt> </td><td>Unknown scheme in URI (warning)</td></tr>
+</tbody></table></p>
+<!-- NEW PAGE -->
+<h3><a name='http_version_e'>http_version_e</a> </h3>
+<hr noshade/>
+<h4>Description</h4>
+<p>HTTP version numbers</p>
+<h4>Values</h4>
+<p class='table'><table align='center' border='1' width='80%'>
+<thead><tr><th>Name</th><th>Description</th></tr></thead>
+<tbody>
+<tr><td><tt>HTTP_0_9</tt> </td><td>HTTP/0.9</td></tr>
+<tr><td><tt>HTTP_1_0</tt> </td><td>HTTP/1.0</td></tr>
+<tr><td><tt>HTTP_1_1</tt> </td><td>HTTP/1.1</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
 <h2><a name='_functions'>Functions</a></h2>
 <ul>
-	<li><a href='#cupsAddDest'><tt>cupsAddDest()</tt></a></li>
-	<li><a href='#cupsAddOption'><tt>cupsAddOption()</tt></a></li>
-	<li><a href='#cupsCancelJob'><tt>cupsCancelJob()</tt></a></li>
-	<li><a href='#cupsDoAuthentication'><tt>cupsDoAuthentication()</tt></a></li>
-	<li><a href='#cupsDoFileRequest'><tt>cupsDoFileRequest()</tt></a></li>
-	<li><a href='#cupsEncodeOptions'><tt>cupsEncodeOptions()</tt></a></li>
-	<li><a href='#cupsEncodeOptions2'><tt>cupsEncodeOptions2()</tt></a></li>
-	<li><a href='#cupsEncryption'><tt>cupsEncryption()</tt></a></li>
-	<li><a href='#cupsFreeDests'><tt>cupsFreeDests()</tt></a></li>
-	<li><a href='#cupsFreeJobs'><tt>cupsFreeJobs()</tt></a></li>
-	<li><a href='#cupsFreeOptions'><tt>cupsFreeOptions()</tt></a></li>
-	<li><a href='#cupsGetClasses'><tt>cupsGetClasses()</tt></a></li>
-	<li><a href='#cupsGetDefault'><tt>cupsGetDefault()</tt></a></li>
-	<li><a href='#cupsGetDefault2'><tt>cupsGetDefault2()</tt></a></li>
-	<li><a href='#cupsGetDest'><tt>cupsGetDest()</tt></a></li>
-	<li><a href='#cupsGetDests'><tt>cupsGetDests()</tt></a></li>
-	<li><a href='#cupsGetDests2'><tt>cupsGetDests2()</tt></a></li>
-	<li><a href='#cupsGetFd'><tt>cupsGetFd()</tt></a></li>
-	<li><a href='#cupsGetFile'><tt>cupsGetFile()</tt></a></li>
-	<li><a href='#cupsGetJobs'><tt>cupsGetJobs()</tt></a></li>
-	<li><a href='#cupsGetJobs2'><tt>cupsGetJobs2()</tt></a></li>
-	<li><a href='#cupsGetOption'><tt>cupsGetOption()</tt></a></li>
-	<li><a href='#cupsGetPPD'><tt>cupsGetPPD()</tt></a></li>
-	<li><a href='#cupsGetPPD2'><tt>cupsGetPPD2()</tt></a></li>
-	<li><a href='#cupsGetPassword'><tt>cupsGetPassword()</tt></a></li>
-	<li><a href='#cupsGetPrinters'><tt>cupsGetPrinters()</tt></a></li>
-	<li><a href='#cupsLastError'><tt>cupsLastError()</tt></a></li>
-	<li><a href='#cupsMarkOptions'><tt>cupsMarkOptions()</tt></a></li>
-	<li><a href='#cupsParseOptions'><tt>cupsParseOptions()</tt></a></li>
-	<li><a href='#cupsPrintFile'><tt>cupsPrintFile()</tt></a></li>
-	<li><a href='#cupsPrintFile2'><tt>cupsPrintFile2()</tt></a></li>
-	<li><a href='#cupsPrintFiles'><tt>cupsPrintFiles()</tt></a></li>
-	<li><a href='#cupsPrintFiles2'><tt>cupsPrintFiles2()</tt></a></li>
-	<li><a href='#cupsPutFd'><tt>cupsPutFd()</tt></a></li>
-	<li><a href='#cupsPutFile'><tt>cupsPutFile()</tt></a></li>
-	<li><a href='#cupsServer'><tt>cupsServer()</tt></a></li>
-	<li><a href='#cupsSetDests'><tt>cupsSetDests()</tt></a></li>
-	<li><a href='#cupsSetDests2'><tt>cupsSetDests2()</tt></a></li>
-	<li><a href='#cupsSetEncryption'><tt>cupsSetEncryption()</tt></a></li>
-	<li><a href='#cupsSetPasswordCB'><tt>cupsSetPasswordCB()</tt></a></li>
-	<li><a href='#cupsSetServer'><tt>cupsSetServer()</tt></a></li>
-	<li><a href='#cupsSetUser'><tt>cupsSetUser()</tt></a></li>
-	<li><a href='#cupsUser'><tt>cupsUser()</tt></a></li>
-	<li><a href='#httpAddrAny'><tt>httpAddrAny()</tt></a></li>
-	<li><a href='#httpAddrEqual'><tt>httpAddrEqual()</tt></a></li>
-	<li><a href='#httpAddrLoad'><tt>httpAddrLoad()</tt></a></li>
-	<li><a href='#httpAddrLocalhost'><tt>httpAddrLocalhost()</tt></a></li>
-	<li><a href='#httpAddrLookup'><tt>httpAddrLookup()</tt></a></li>
-	<li><a href='#httpAddrString'><tt>httpAddrString()</tt></a></li>
-	<li><a href='#httpCheck'><tt>httpCheck()</tt></a></li>
-	<li><a href='#httpClearCookie'><tt>httpClearCookie()</tt></a></li>
-	<li><a href='#httpClose'><tt>httpClose()</tt></a></li>
-	<li><a href='#httpConnect'><tt>httpConnect()</tt></a></li>
-	<li><a href='#httpConnectEncrypt'><tt>httpConnectEncrypt()</tt></a></li>
-	<li><a href='#httpDecode64'><tt>httpDecode64()</tt></a></li>
-	<li><a href='#httpDecode64_2'><tt>httpDecode64_2()</tt></a></li>
-	<li><a href='#httpDelete'><tt>httpDelete()</tt></a></li>
-	<li><a href='#httpEncode64'><tt>httpEncode64()</tt></a></li>
-	<li><a href='#httpEncode64_2'><tt>httpEncode64_2()</tt></a></li>
-	<li><a href='#httpEncryption'><tt>httpEncryption()</tt></a></li>
-	<li><a href='#httpFlush'><tt>httpFlush()</tt></a></li>
-	<li><a href='#httpFlushWrite'><tt>httpFlushWrite()</tt></a></li>
-	<li><a href='#httpGet'><tt>httpGet()</tt></a></li>
-	<li><a href='#httpGetDateString'><tt>httpGetDateString()</tt></a></li>
-	<li><a href='#httpGetDateString2'><tt>httpGetDateString2()</tt></a></li>
-	<li><a href='#httpGetDateTime'><tt>httpGetDateTime()</tt></a></li>
-	<li><a href='#httpGetHostByName'><tt>httpGetHostByName()</tt></a></li>
-	<li><a href='#httpGetHostname'><tt>httpGetHostname()</tt></a></li>
-	<li><a href='#httpGetLength'><tt>httpGetLength()</tt></a></li>
-	<li><a href='#httpGetSubField'><tt>httpGetSubField()</tt></a></li>
-	<li><a href='#httpGets'><tt>httpGets()</tt></a></li>
-	<li><a href='#httpHead'><tt>httpHead()</tt></a></li>
-	<li><a href='#httpInitialize'><tt>httpInitialize()</tt></a></li>
-	<li><a href='#httpMD5'><tt>httpMD5()</tt></a></li>
-	<li><a href='#httpMD5Final'><tt>httpMD5Final()</tt></a></li>
-	<li><a href='#httpMD5String'><tt>httpMD5String()</tt></a></li>
-	<li><a href='#httpOptions'><tt>httpOptions()</tt></a></li>
-	<li><a href='#httpPost'><tt>httpPost()</tt></a></li>
-	<li><a href='#httpPrintf'><tt>httpPrintf()</tt></a></li>
-	<li><a href='#httpPut'><tt>httpPut()</tt></a></li>
-	<li><a href='#httpRead'><tt>httpRead()</tt></a></li>
-	<li><a href='#httpReconnect'><tt>httpReconnect()</tt></a></li>
-	<li><a href='#httpSeparate'><tt>httpSeparate()</tt></a></li>
-	<li><a href='#httpSeparate2'><tt>httpSeparate2()</tt></a></li>
-	<li><a href='#httpSetCookie'><tt>httpSetCookie()</tt></a></li>
-	<li><a href='#httpSetField'><tt>httpSetField()</tt></a></li>
-	<li><a href='#httpStatus'><tt>httpStatus()</tt></a></li>
-	<li><a href='#httpTrace'><tt>httpTrace()</tt></a></li>
-	<li><a href='#httpUpdate'><tt>httpUpdate()</tt></a></li>
-	<li><a href='#httpWait'><tt>httpWait()</tt></a></li>
-	<li><a href='#httpWrite'><tt>httpWrite()</tt></a></li>
-	<li><a href='#ippAddBoolean'><tt>ippAddBoolean()</tt></a></li>
-	<li><a href='#ippAddBooleans'><tt>ippAddBooleans()</tt></a></li>
-	<li><a href='#ippAddCollection'><tt>ippAddCollection()</tt></a></li>
-	<li><a href='#ippAddCollections'><tt>ippAddCollections()</tt></a></li>
-	<li><a href='#ippAddDate'><tt>ippAddDate()</tt></a></li>
-	<li><a href='#ippAddInteger'><tt>ippAddInteger()</tt></a></li>
-	<li><a href='#ippAddIntegers'><tt>ippAddIntegers()</tt></a></li>
-	<li><a href='#ippAddRange'><tt>ippAddRange()</tt></a></li>
-	<li><a href='#ippAddRanges'><tt>ippAddRanges()</tt></a></li>
-	<li><a href='#ippAddResolution'><tt>ippAddResolution()</tt></a></li>
-	<li><a href='#ippAddResolutions'><tt>ippAddResolutions()</tt></a></li>
-	<li><a href='#ippAddSeparator'><tt>ippAddSeparator()</tt></a></li>
-	<li><a href='#ippAddString'><tt>ippAddString()</tt></a></li>
-	<li><a href='#ippAddStrings'><tt>ippAddStrings()</tt></a></li>
-	<li><a href='#ippDateToTime'><tt>ippDateToTime()</tt></a></li>
-	<li><a href='#ippDelete'><tt>ippDelete()</tt></a></li>
-	<li><a href='#ippDeleteAttribute'><tt>ippDeleteAttribute()</tt></a></li>
-	<li><a href='#ippErrorString'><tt>ippErrorString()</tt></a></li>
-	<li><a href='#ippErrorValue'><tt>ippErrorValue()</tt></a></li>
-	<li><a href='#ippFindAttribute'><tt>ippFindAttribute()</tt></a></li>
-	<li><a href='#ippFindNextAttribute'><tt>ippFindNextAttribute()</tt></a></li>
-	<li><a href='#ippLength'><tt>ippLength()</tt></a></li>
-	<li><a href='#ippNew'><tt>ippNew()</tt></a></li>
-	<li><a href='#ippOpString'><tt>ippOpString()</tt></a></li>
-	<li><a href='#ippOpValue'><tt>ippOpValue()</tt></a></li>
-	<li><a href='#ippPort'><tt>ippPort()</tt></a></li>
-	<li><a href='#ippRead'><tt>ippRead()</tt></a></li>
-	<li><a href='#ippReadFile'><tt>ippReadFile()</tt></a></li>
-	<li><a href='#ippReadIO'><tt>ippReadIO()</tt></a></li>
-	<li><a href='#ippSetPort'><tt>ippSetPort()</tt></a></li>
-	<li><a href='#ippTimeToDate'><tt>ippTimeToDate()</tt></a></li>
-	<li><a href='#ippWrite'><tt>ippWrite()</tt></a></li>
-	<li><a href='#ippWriteFile'><tt>ippWriteFile()</tt></a></li>
-	<li><a href='#ippWriteIO'><tt>ippWriteIO()</tt></a></li>
+	<li><a href='#cupsAddDest'><tt>cupsAddDest()</tt></a> </li>
+	<li><a href='#cupsAddOption'><tt>cupsAddOption()</tt></a> </li>
+	<li><a href='#cupsCancelJob'><tt>cupsCancelJob()</tt></a> </li>
+	<li><a href='#cupsDoAuthentication'><tt>cupsDoAuthentication()</tt></a> <span class='info'>&nbsp;CUPS 1.1.20&nbsp;</span></li>
+	<li><a href='#cupsDoFileRequest'><tt>cupsDoFileRequest()</tt></a> </li>
+	<li><a href='#cupsEncodeOptions'><tt>cupsEncodeOptions()</tt></a> </li>
+	<li><a href='#cupsEncodeOptions2'><tt>cupsEncodeOptions2()</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#cupsEncryption'><tt>cupsEncryption()</tt></a> </li>
+	<li><a href='#cupsFreeDests'><tt>cupsFreeDests()</tt></a> </li>
+	<li><a href='#cupsFreeJobs'><tt>cupsFreeJobs()</tt></a> </li>
+	<li><a href='#cupsFreeOptions'><tt>cupsFreeOptions()</tt></a> </li>
+	<li><a href='#cupsGetClasses'><tt>cupsGetClasses()</tt></a> </li>
+	<li><a href='#cupsGetDefault'><tt>cupsGetDefault()</tt></a> </li>
+	<li><a href='#cupsGetDefault2'><tt>cupsGetDefault2()</tt></a> <span class='info'>&nbsp;CUPS 1.1.21&nbsp;</span></li>
+	<li><a href='#cupsGetDest'><tt>cupsGetDest()</tt></a> </li>
+	<li><a href='#cupsGetDests'><tt>cupsGetDests()</tt></a> </li>
+	<li><a href='#cupsGetDests2'><tt>cupsGetDests2()</tt></a> <span class='info'>&nbsp;CUPS 1.1.21&nbsp;</span></li>
+	<li><a href='#cupsGetFd'><tt>cupsGetFd()</tt></a> <span class='info'>&nbsp;CUPS 1.1.20&nbsp;</span></li>
+	<li><a href='#cupsGetFile'><tt>cupsGetFile()</tt></a> <span class='info'>&nbsp;CUPS 1.1.20&nbsp;</span></li>
+	<li><a href='#cupsGetJobs'><tt>cupsGetJobs()</tt></a> </li>
+	<li><a href='#cupsGetJobs2'><tt>cupsGetJobs2()</tt></a> <span class='info'>&nbsp;CUPS 1.1.21&nbsp;</span></li>
+	<li><a href='#cupsGetOption'><tt>cupsGetOption()</tt></a> </li>
+	<li><a href='#cupsGetPPD'><tt>cupsGetPPD()</tt></a> </li>
+	<li><a href='#cupsGetPPD2'><tt>cupsGetPPD2()</tt></a> <span class='info'>&nbsp;CUPS 1.1.21&nbsp;</span></li>
+	<li><a href='#cupsGetPassword'><tt>cupsGetPassword()</tt></a> </li>
+	<li><a href='#cupsGetPrinters'><tt>cupsGetPrinters()</tt></a> </li>
+	<li><a href='#cupsLastError'><tt>cupsLastError()</tt></a> </li>
+	<li><a href='#cupsMarkOptions'><tt>cupsMarkOptions()</tt></a> </li>
+	<li><a href='#cupsParseOptions'><tt>cupsParseOptions()</tt></a> </li>
+	<li><a href='#cupsPrintFile'><tt>cupsPrintFile()</tt></a> </li>
+	<li><a href='#cupsPrintFile2'><tt>cupsPrintFile2()</tt></a> <span class='info'>&nbsp;CUPS 1.1.21&nbsp;</span></li>
+	<li><a href='#cupsPrintFiles'><tt>cupsPrintFiles()</tt></a> </li>
+	<li><a href='#cupsPrintFiles2'><tt>cupsPrintFiles2()</tt></a> <span class='info'>&nbsp;CUPS 1.1.21&nbsp;</span></li>
+	<li><a href='#cupsPutFd'><tt>cupsPutFd()</tt></a> <span class='info'>&nbsp;CUPS 1.1.20&nbsp;</span></li>
+	<li><a href='#cupsPutFile'><tt>cupsPutFile()</tt></a> <span class='info'>&nbsp;CUPS 1.1.20&nbsp;</span></li>
+	<li><a href='#cupsServer'><tt>cupsServer()</tt></a> </li>
+	<li><a href='#cupsSetDests'><tt>cupsSetDests()</tt></a> </li>
+	<li><a href='#cupsSetDests2'><tt>cupsSetDests2()</tt></a> <span class='info'>&nbsp;CUPS 1.1.21&nbsp;</span></li>
+	<li><a href='#cupsSetEncryption'><tt>cupsSetEncryption()</tt></a> </li>
+	<li><a href='#cupsSetPasswordCB'><tt>cupsSetPasswordCB()</tt></a> </li>
+	<li><a href='#cupsSetServer'><tt>cupsSetServer()</tt></a> </li>
+	<li><a href='#cupsSetUser'><tt>cupsSetUser()</tt></a> </li>
+	<li><a href='#cupsUser'><tt>cupsUser()</tt></a> </li>
+	<li><a href='#httpAddrAny'><tt>httpAddrAny()</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#httpAddrEqual'><tt>httpAddrEqual()</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#httpAddrLength'><tt>httpAddrLength()</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#httpAddrLocalhost'><tt>httpAddrLocalhost()</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#httpAddrLookup'><tt>httpAddrLookup()</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#httpAddrString'><tt>httpAddrString()</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#httpCheck'><tt>httpCheck()</tt></a> </li>
+	<li><a href='#httpClearCookie'><tt>httpClearCookie()</tt></a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></li>
+	<li><a href='#httpClose'><tt>httpClose()</tt></a> </li>
+	<li><a href='#httpConnect'><tt>httpConnect()</tt></a> </li>
+	<li><a href='#httpConnectEncrypt'><tt>httpConnectEncrypt()</tt></a> </li>
+	<li><a href='#httpDecode64'><tt>httpDecode64()</tt></a> </li>
+	<li><a href='#httpDecode64_2'><tt>httpDecode64_2()</tt></a> <span class='info'>&nbsp;CUPS 1.1.21&nbsp;</span></li>
+	<li><a href='#httpDelete'><tt>httpDelete()</tt></a> </li>
+	<li><a href='#httpEncode64'><tt>httpEncode64()</tt></a> </li>
+	<li><a href='#httpEncode64_2'><tt>httpEncode64_2()</tt></a> <span class='info'>&nbsp;CUPS 1.1.21&nbsp;</span></li>
+	<li><a href='#httpEncryption'><tt>httpEncryption()</tt></a> </li>
+	<li><a href='#httpFlush'><tt>httpFlush()</tt></a> </li>
+	<li><a href='#httpFlushWrite'><tt>httpFlushWrite()</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#httpGet'><tt>httpGet()</tt></a> </li>
+	<li><a href='#httpGetDateString'><tt>httpGetDateString()</tt></a> <span class='info'>&nbsp;DEPRECATED&nbsp;</span></li>
+	<li><a href='#httpGetDateString2'><tt>httpGetDateString2()</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#httpGetDateTime'><tt>httpGetDateTime()</tt></a> </li>
+	<li><a href='#httpGetHostByName'><tt>httpGetHostByName()</tt></a> <span class='info'>&nbsp;DEPRECATED&nbsp;</span></li>
+	<li><a href='#httpGetHostname'><tt>httpGetHostname()</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#httpGetLength'><tt>httpGetLength()</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#httpGetLength2'><tt>httpGetLength2()</tt></a> </li>
+	<li><a href='#httpGetSubField'><tt>httpGetSubField()</tt></a> </li>
+	<li><a href='#httpGets'><tt>httpGets()</tt></a> </li>
+	<li><a href='#httpHead'><tt>httpHead()</tt></a> </li>
+	<li><a href='#httpInitialize'><tt>httpInitialize()</tt></a> </li>
+	<li><a href='#httpMD5'><tt>httpMD5()</tt></a> </li>
+	<li><a href='#httpMD5Final'><tt>httpMD5Final()</tt></a> </li>
+	<li><a href='#httpMD5String'><tt>httpMD5String()</tt></a> </li>
+	<li><a href='#httpOptions'><tt>httpOptions()</tt></a> </li>
+	<li><a href='#httpPost'><tt>httpPost()</tt></a> </li>
+	<li><a href='#httpPrintf'><tt>httpPrintf()</tt></a> </li>
+	<li><a href='#httpPut'><tt>httpPut()</tt></a> </li>
+	<li><a href='#httpRead'><tt>httpRead()</tt></a> </li>
+	<li><a href='#httpReconnect'><tt>httpReconnect()</tt></a> </li>
+	<li><a href='#httpSeparate'><tt>httpSeparate()</tt></a> </li>
+	<li><a href='#httpSeparate2'><tt>httpSeparate2()</tt></a> <span class='info'>&nbsp;CUPS 1.1.21&nbsp;</span></li>
+	<li><a href='#httpSeparate3'><tt>httpSeparate3()</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#httpSetCookie'><tt>httpSetCookie()</tt></a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></li>
+	<li><a href='#httpSetField'><tt>httpSetField()</tt></a> </li>
+	<li><a href='#httpSetLength'><tt>httpSetLength()</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#httpStatus'><tt>httpStatus()</tt></a> </li>
+	<li><a href='#httpTrace'><tt>httpTrace()</tt></a> </li>
+	<li><a href='#httpUpdate'><tt>httpUpdate()</tt></a> </li>
+	<li><a href='#httpWait'><tt>httpWait()</tt></a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></li>
+	<li><a href='#httpWrite'><tt>httpWrite()</tt></a> </li>
+	<li><a href='#ippAddBoolean'><tt>ippAddBoolean()</tt></a> </li>
+	<li><a href='#ippAddBooleans'><tt>ippAddBooleans()</tt></a> </li>
+	<li><a href='#ippAddCollection'><tt>ippAddCollection()</tt></a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></li>
+	<li><a href='#ippAddCollections'><tt>ippAddCollections()</tt></a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></li>
+	<li><a href='#ippAddDate'><tt>ippAddDate()</tt></a> </li>
+	<li><a href='#ippAddInteger'><tt>ippAddInteger()</tt></a> </li>
+	<li><a href='#ippAddIntegers'><tt>ippAddIntegers()</tt></a> </li>
+	<li><a href='#ippAddRange'><tt>ippAddRange()</tt></a> </li>
+	<li><a href='#ippAddRanges'><tt>ippAddRanges()</tt></a> </li>
+	<li><a href='#ippAddResolution'><tt>ippAddResolution()</tt></a> </li>
+	<li><a href='#ippAddResolutions'><tt>ippAddResolutions()</tt></a> </li>
+	<li><a href='#ippAddSeparator'><tt>ippAddSeparator()</tt></a> </li>
+	<li><a href='#ippAddString'><tt>ippAddString()</tt></a> </li>
+	<li><a href='#ippAddStrings'><tt>ippAddStrings()</tt></a> </li>
+	<li><a href='#ippDateToTime'><tt>ippDateToTime()</tt></a> </li>
+	<li><a href='#ippDelete'><tt>ippDelete()</tt></a> </li>
+	<li><a href='#ippDeleteAttribute'><tt>ippDeleteAttribute()</tt></a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></li>
+	<li><a href='#ippErrorString'><tt>ippErrorString()</tt></a> </li>
+	<li><a href='#ippErrorValue'><tt>ippErrorValue()</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#ippFindAttribute'><tt>ippFindAttribute()</tt></a> </li>
+	<li><a href='#ippFindNextAttribute'><tt>ippFindNextAttribute()</tt></a> </li>
+	<li><a href='#ippLength'><tt>ippLength()</tt></a> </li>
+	<li><a href='#ippNew'><tt>ippNew()</tt></a> </li>
+	<li><a href='#ippOpString'><tt>ippOpString()</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#ippOpValue'><tt>ippOpValue()</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#ippPort'><tt>ippPort()</tt></a> </li>
+	<li><a href='#ippRead'><tt>ippRead()</tt></a> </li>
+	<li><a href='#ippReadFile'><tt>ippReadFile()</tt></a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></li>
+	<li><a href='#ippReadIO'><tt>ippReadIO()</tt></a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></li>
+	<li><a href='#ippSetPort'><tt>ippSetPort()</tt></a> </li>
+	<li><a href='#ippTimeToDate'><tt>ippTimeToDate()</tt></a> </li>
+	<li><a href='#ippWrite'><tt>ippWrite()</tt></a> </li>
+	<li><a href='#ippWriteFile'><tt>ippWriteFile()</tt></a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></li>
+	<li><a href='#ippWriteIO'><tt>ippWriteIO()</tt></a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></li>
 </ul>
 <!-- NEW PAGE -->
-<h3><a name='cupsAddDest'>cupsAddDest()</a></h3>
+<h3><a name='cupsAddDest'>cupsAddDest()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Add a destination to the list of destinations.</p>
@@ -211,7 +428,7 @@
 <h4>Returns</h4>
 <p>New number of destinations</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsAddOption'>cupsAddOption()</a></h3>
+<h3><a name='cupsAddOption'>cupsAddOption()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Add an option to an option array.</p>
@@ -236,7 +453,7 @@
 <h4>Returns</h4>
 <p>Number of options</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsCancelJob'>cupsCancelJob()</a></h3>
+<h3><a name='cupsCancelJob'>cupsCancelJob()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Cancel a print job.</p>
@@ -257,10 +474,12 @@
 <h4>Returns</h4>
 <p>1 on success, 0 on failure</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsDoAuthentication'>cupsDoAuthentication()</a></h3>
+<h3><a name='cupsDoAuthentication'>cupsDoAuthentication()</a> <span class='info'>&nbsp;CUPS 1.1.20&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Authenticate a request...</p>
+<p>Authenticate a request...
+
+</p>
 <h4>Syntax</h4>
 <pre>
 int
@@ -280,7 +499,7 @@
 <h4>Returns</h4>
 <p>0 on success, -1 on error</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsDoFileRequest'>cupsDoFileRequest()</a></h3>
+<h3><a name='cupsDoFileRequest'>cupsDoFileRequest()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Do an IPP request...</p>
@@ -305,7 +524,7 @@
 <h4>Returns</h4>
 <p>Response data</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsEncodeOptions'>cupsEncodeOptions()</a></h3>
+<h3><a name='cupsEncodeOptions'>cupsEncodeOptions()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Encode printer options into IPP attributes.</p>
@@ -328,10 +547,12 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsEncodeOptions2'>cupsEncodeOptions2()</a></h3>
+<h3><a name='cupsEncodeOptions2'>cupsEncodeOptions2()</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Encode printer options into IPP attributes for a group.</p>
+<p>Encode printer options into IPP attributes for a group.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 void
@@ -353,26 +574,21 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsEncryption'>cupsEncryption()</a></h3>
+<h3><a name='cupsEncryption'>cupsEncryption()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Include necessary headers...</p>
+<p>Get the default encryption settings...</p>
 <h4>Syntax</h4>
 <pre>
 <a href='#http_encryption_t'>http_encryption_t</a>
-cupsEncryption(
-    void);
+cupsEncryption(void);
 </pre>
 <h4>Arguments</h4>
-<p class='table'><table align='center' border='1' width='80%' cellpadding='5' cellspacing='0' width='80%'>
-<thead><tr><th>Name</th><th>Description</th></tr></thead>
-<tbody>
-<tr><td><tt>void</tt></td><td></td></tr>
-</tbody></table></p>
+<p>None.</p>
 <h4>Returns</h4>
-<p>Get the default encryption settings...</p>
+<p>Encryption settings</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFreeDests'>cupsFreeDests()</a></h3>
+<h3><a name='cupsFreeDests'>cupsFreeDests()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Free the memory used by the list of destinations.</p>
@@ -393,7 +609,7 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFreeJobs'>cupsFreeJobs()</a></h3>
+<h3><a name='cupsFreeJobs'>cupsFreeJobs()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Free memory used by job data.</p>
@@ -414,7 +630,7 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsFreeOptions'>cupsFreeOptions()</a></h3>
+<h3><a name='cupsFreeOptions'>cupsFreeOptions()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Free all memory used by options.</p>
@@ -435,7 +651,7 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsGetClasses'>cupsGetClasses()</a></h3>
+<h3><a name='cupsGetClasses'>cupsGetClasses()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get a list of printer classes.</p>
@@ -454,29 +670,26 @@
 <h4>Returns</h4>
 <p>Number of classes</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsGetDefault'>cupsGetDefault()</a></h3>
+<h3><a name='cupsGetDefault'>cupsGetDefault()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get the default printer or class.</p>
 <h4>Syntax</h4>
 <pre>
 const char *
-cupsGetDefault(
-    void);
+cupsGetDefault(void);
 </pre>
 <h4>Arguments</h4>
-<p class='table'><table align='center' border='1' width='80%' cellpadding='5' cellspacing='0' width='80%'>
-<thead><tr><th>Name</th><th>Description</th></tr></thead>
-<tbody>
-<tr><td><tt>void</tt></td><td></td></tr>
-</tbody></table></p>
+<p>None.</p>
 <h4>Returns</h4>
 <p>Default printer or NULL</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsGetDefault2'>cupsGetDefault2()</a></h3>
+<h3><a name='cupsGetDefault2'>cupsGetDefault2()</a> <span class='info'>&nbsp;CUPS 1.1.21&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Get the default printer or class.</p>
+<p>Get the default printer or class.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 const char *
@@ -492,7 +705,7 @@
 <h4>Returns</h4>
 <p>Default printer or NULL</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsGetDest'>cupsGetDest()</a></h3>
+<h3><a name='cupsGetDest'>cupsGetDest()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get the named destination from the list.</p>
@@ -517,7 +730,7 @@
 <h4>Returns</h4>
 <p>Destination pointer or NULL</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsGetDests'>cupsGetDests()</a></h3>
+<h3><a name='cupsGetDests'>cupsGetDests()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get the list of destinations.</p>
@@ -536,10 +749,12 @@
 <h4>Returns</h4>
 <p>Number of destinations</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsGetDests2'>cupsGetDests2()</a></h3>
+<h3><a name='cupsGetDests2'>cupsGetDests2()</a> <span class='info'>&nbsp;CUPS 1.1.21&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Get the list of destinations.</p>
+<p>Get the list of destinations.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 int
@@ -557,10 +772,12 @@
 <h4>Returns</h4>
 <p>Number of destinations</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsGetFd'>cupsGetFd()</a></h3>
+<h3><a name='cupsGetFd'>cupsGetFd()</a> <span class='info'>&nbsp;CUPS 1.1.20&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Get a file from the server.</p>
+<p>Get a file from the server.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 http_status_t
@@ -580,10 +797,12 @@
 <h4>Returns</h4>
 <p>Status</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsGetFile'>cupsGetFile()</a></h3>
+<h3><a name='cupsGetFile'>cupsGetFile()</a> <span class='info'>&nbsp;CUPS 1.1.20&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Get a file from the server.</p>
+<p>Get a file from the server.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 http_status_t
@@ -603,7 +822,7 @@
 <h4>Returns</h4>
 <p>Status</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsGetJobs'>cupsGetJobs()</a></h3>
+<h3><a name='cupsGetJobs'>cupsGetJobs()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get the jobs from the server.</p>
@@ -628,10 +847,12 @@
 <h4>Returns</h4>
 <p>Number of jobs</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsGetJobs2'>cupsGetJobs2()</a></h3>
+<h3><a name='cupsGetJobs2'>cupsGetJobs2()</a> <span class='info'>&nbsp;CUPS 1.1.21&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Get the jobs from the server.</p>
+<p>Get the jobs from the server.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 int
@@ -655,7 +876,7 @@
 <h4>Returns</h4>
 <p>Number of jobs</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsGetOption'>cupsGetOption()</a></h3>
+<h3><a name='cupsGetOption'>cupsGetOption()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get an option value.</p>
@@ -678,7 +899,7 @@
 <h4>Returns</h4>
 <p>Option value or NULL</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsGetPPD'>cupsGetPPD()</a></h3>
+<h3><a name='cupsGetPPD'>cupsGetPPD()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get the PPD file for a printer.</p>
@@ -697,10 +918,12 @@
 <h4>Returns</h4>
 <p>Filename for PPD file</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsGetPPD2'>cupsGetPPD2()</a></h3>
+<h3><a name='cupsGetPPD2'>cupsGetPPD2()</a> <span class='info'>&nbsp;CUPS 1.1.21&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Get the PPD file for a printer.</p>
+<p>Get the PPD file for a printer.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 const char *
@@ -718,7 +941,7 @@
 <h4>Returns</h4>
 <p>Filename for PPD file</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsGetPassword'>cupsGetPassword()</a></h3>
+<h3><a name='cupsGetPassword'>cupsGetPassword()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get a password from the user...</p>
@@ -737,7 +960,7 @@
 <h4>Returns</h4>
 <p>Password</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsGetPrinters'>cupsGetPrinters()</a></h3>
+<h3><a name='cupsGetPrinters'>cupsGetPrinters()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get a list of printers.</p>
@@ -756,26 +979,21 @@
 <h4>Returns</h4>
 <p>Number of printers</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsLastError'>cupsLastError()</a></h3>
+<h3><a name='cupsLastError'>cupsLastError()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Return the last IPP error that occurred.</p>
 <h4>Syntax</h4>
 <pre>
 ipp_status_t
-cupsLastError(
-    void);
+cupsLastError(void);
 </pre>
 <h4>Arguments</h4>
-<p class='table'><table align='center' border='1' width='80%' cellpadding='5' cellspacing='0' width='80%'>
-<thead><tr><th>Name</th><th>Description</th></tr></thead>
-<tbody>
-<tr><td><tt>void</tt></td><td></td></tr>
-</tbody></table></p>
+<p>None.</p>
 <h4>Returns</h4>
 <p>IPP error code</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsMarkOptions'>cupsMarkOptions()</a></h3>
+<h3><a name='cupsMarkOptions'>cupsMarkOptions()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Mark command-line options in a PPD file.</p>
@@ -798,7 +1016,7 @@
 <h4>Returns</h4>
 <p>1 if conflicting</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsParseOptions'>cupsParseOptions()</a></h3>
+<h3><a name='cupsParseOptions'>cupsParseOptions()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Parse options from a command-line argument.</p>
@@ -821,7 +1039,7 @@
 <h4>Returns</h4>
 <p>Number of options found</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsPrintFile'>cupsPrintFile()</a></h3>
+<h3><a name='cupsPrintFile'>cupsPrintFile()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Print a file to a printer or class.</p>
@@ -848,10 +1066,12 @@
 <h4>Returns</h4>
 <p>Job ID</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsPrintFile2'>cupsPrintFile2()</a></h3>
+<h3><a name='cupsPrintFile2'>cupsPrintFile2()</a> <span class='info'>&nbsp;CUPS 1.1.21&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Print a file to a printer or class.</p>
+<p>Print a file to a printer or class.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 int
@@ -877,7 +1097,7 @@
 <h4>Returns</h4>
 <p>Job ID</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsPrintFiles'>cupsPrintFiles()</a></h3>
+<h3><a name='cupsPrintFiles'>cupsPrintFiles()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Print one or more files to a printer or class.</p>
@@ -906,10 +1126,12 @@
 <h4>Returns</h4>
 <p>Job ID</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsPrintFiles2'>cupsPrintFiles2()</a></h3>
+<h3><a name='cupsPrintFiles2'>cupsPrintFiles2()</a> <span class='info'>&nbsp;CUPS 1.1.21&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Print one or more files to a printer or class.</p>
+<p>Print one or more files to a printer or class.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 int
@@ -937,10 +1159,12 @@
 <h4>Returns</h4>
 <p>Job ID</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsPutFd'>cupsPutFd()</a></h3>
+<h3><a name='cupsPutFd'>cupsPutFd()</a> <span class='info'>&nbsp;CUPS 1.1.20&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Put a file on the server.</p>
+<p>Put a file on the server.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 http_status_t
@@ -960,10 +1184,12 @@
 <h4>Returns</h4>
 <p>Status</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsPutFile'>cupsPutFile()</a></h3>
+<h3><a name='cupsPutFile'>cupsPutFile()</a> <span class='info'>&nbsp;CUPS 1.1.20&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Put a file on the server.</p>
+<p>Put a file on the server.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 http_status_t
@@ -983,26 +1209,21 @@
 <h4>Returns</h4>
 <p>Status</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsServer'>cupsServer()</a></h3>
+<h3><a name='cupsServer'>cupsServer()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Return the hostname of the default server...</p>
 <h4>Syntax</h4>
 <pre>
 const char *
-cupsServer(
-    void);
+cupsServer(void);
 </pre>
 <h4>Arguments</h4>
-<p class='table'><table align='center' border='1' width='80%' cellpadding='5' cellspacing='0' width='80%'>
-<thead><tr><th>Name</th><th>Description</th></tr></thead>
-<tbody>
-<tr><td><tt>void</tt></td><td></td></tr>
-</tbody></table></p>
+<p>None.</p>
 <h4>Returns</h4>
 <p>Server name</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsSetDests'>cupsSetDests()</a></h3>
+<h3><a name='cupsSetDests'>cupsSetDests()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Set the list of destinations.</p>
@@ -1023,10 +1244,12 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsSetDests2'>cupsSetDests2()</a></h3>
+<h3><a name='cupsSetDests2'>cupsSetDests2()</a> <span class='info'>&nbsp;CUPS 1.1.21&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Set the list of destinations.</p>
+<p>Set the list of destinations.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 int
@@ -1046,7 +1269,7 @@
 <h4>Returns</h4>
 <p>0 on success, -1 on error</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsSetEncryption'>cupsSetEncryption()</a></h3>
+<h3><a name='cupsSetEncryption'>cupsSetEncryption()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Set the encryption preference.</p>
@@ -1065,26 +1288,21 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsSetPasswordCB'>cupsSetPasswordCB()</a></h3>
+<h3><a name='cupsSetPasswordCB'>cupsSetPasswordCB()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Set the password callback for CUPS.</p>
 <h4>Syntax</h4>
 <pre>
 void
-cupsSetPasswordCB(
-    const char * (*cb)(const char *));
+cupsSetPasswordCB(void);
 </pre>
 <h4>Arguments</h4>
-<p class='table'><table align='center' border='1' width='80%' cellpadding='5' cellspacing='0' width='80%'>
-<thead><tr><th>Name</th><th>Description</th></tr></thead>
-<tbody>
-<tr><td><tt>(*cb)(const char *)</tt></td><td>Callback function</td></tr>
-</tbody></table></p>
+<p>None.</p>
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsSetServer'>cupsSetServer()</a></h3>
+<h3><a name='cupsSetServer'>cupsSetServer()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Set the default server name...</p>
@@ -1103,7 +1321,7 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsSetUser'>cupsSetUser()</a></h3>
+<h3><a name='cupsSetUser'>cupsSetUser()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Set the default user name...</p>
@@ -1122,29 +1340,26 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='cupsUser'>cupsUser()</a></h3>
+<h3><a name='cupsUser'>cupsUser()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Return the current user's name.</p>
 <h4>Syntax</h4>
 <pre>
 const char *
-cupsUser(
-    void);
+cupsUser(void);
 </pre>
 <h4>Arguments</h4>
-<p class='table'><table align='center' border='1' width='80%' cellpadding='5' cellspacing='0' width='80%'>
-<thead><tr><th>Name</th><th>Description</th></tr></thead>
-<tbody>
-<tr><td><tt>void</tt></td><td></td></tr>
-</tbody></table></p>
+<p>None.</p>
 <h4>Returns</h4>
 <p>User name</p>
 <!-- NEW PAGE -->
-<h3><a name='httpAddrAny'>httpAddrAny()</a></h3>
+<h3><a name='httpAddrAny'>httpAddrAny()</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Check for the &quot;any&quot; address.</p>
+<p>Check for the &quot;any&quot; address.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 int
@@ -1160,10 +1375,12 @@
 <h4>Returns</h4>
 <p>1 if &quot;any&quot;, 0 otherwise</p>
 <!-- NEW PAGE -->
-<h3><a name='httpAddrEqual'>httpAddrEqual()</a></h3>
+<h3><a name='httpAddrEqual'>httpAddrEqual()</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Compare two addresses.</p>
+<p>Compare two addresses.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 int
@@ -1181,35 +1398,33 @@
 <h4>Returns</h4>
 <p>1 if equal, 0 if !=</p>
 <!-- NEW PAGE -->
-<h3><a name='httpAddrLoad'>httpAddrLoad()</a></h3>
+<h3><a name='httpAddrLength'>httpAddrLength()</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Load a host entry address into an HTTP address.</p>
+<p>Return the length of the address in bytes.
+
+</p>
 <h4>Syntax</h4>
 <pre>
-void
-httpAddrLoad(
-    const struct hostent * host,
-    int port,
-    int n,
-    <a href='#http_addr_t'>http_addr_t</a> * addr);
+int
+httpAddrLength(
+    const <a href='#http_addr_t'>http_addr_t</a> * addr);
 </pre>
 <h4>Arguments</h4>
 <p class='table'><table align='center' border='1' width='80%' cellpadding='5' cellspacing='0' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>host</tt></td><td>Host entry</td></tr>
-<tr><td><tt>port</tt></td><td>Port number</td></tr>
-<tr><td><tt>n</tt></td><td>Index into host entry</td></tr>
-<tr><td><tt>addr</tt></td><td>Address to load</td></tr>
+<tr><td><tt>addr</tt></td><td>Address</td></tr>
 </tbody></table></p>
 <h4>Returns</h4>
-<p>Nothing.</p>
+<p>Length in bytes</p>
 <!-- NEW PAGE -->
-<h3><a name='httpAddrLocalhost'>httpAddrLocalhost()</a></h3>
+<h3><a name='httpAddrLocalhost'>httpAddrLocalhost()</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Check for the local loopback address.</p>
+<p>Check for the local loopback address.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 int
@@ -1225,10 +1440,12 @@
 <h4>Returns</h4>
 <p>1 if local host, 0 otherwise</p>
 <!-- NEW PAGE -->
-<h3><a name='httpAddrLookup'>httpAddrLookup()</a></h3>
+<h3><a name='httpAddrLookup'>httpAddrLookup()</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Lookup the hostname associated with the address.</p>
+<p>Lookup the hostname associated with the address.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 char *
@@ -1248,10 +1465,12 @@
 <h4>Returns</h4>
 <p>Host name</p>
 <!-- NEW PAGE -->
-<h3><a name='httpAddrString'>httpAddrString()</a></h3>
+<h3><a name='httpAddrString'>httpAddrString()</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Convert an IP address to a dotted string.</p>
+<p>Convert an IP address to a dotted string.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 char *
@@ -1271,7 +1490,7 @@
 <h4>Returns</h4>
 <p>IP string</p>
 <!-- NEW PAGE -->
-<h3><a name='httpCheck'>httpCheck()</a></h3>
+<h3><a name='httpCheck'>httpCheck()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Check to see if there is a pending response from the server.</p>
@@ -1290,10 +1509,12 @@
 <h4>Returns</h4>
 <p>0 = no data, 1 = data available</p>
 <!-- NEW PAGE -->
-<h3><a name='httpClearCookie'>httpClearCookie()</a></h3>
+<h3><a name='httpClearCookie'>httpClearCookie()</a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Clear the cookie value(s).</p>
+<p>Clear the cookie value(s).
+
+</p>
 <h4>Syntax</h4>
 <pre>
 void
@@ -1309,7 +1530,7 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='httpClose'>httpClose()</a></h3>
+<h3><a name='httpClose'>httpClose()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Close an HTTP connection...</p>
@@ -1328,7 +1549,7 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='httpConnect'>httpConnect()</a></h3>
+<h3><a name='httpConnect'>httpConnect()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Connect to a HTTP server.</p>
@@ -1349,7 +1570,7 @@
 <h4>Returns</h4>
 <p>New HTTP connection</p>
 <!-- NEW PAGE -->
-<h3><a name='httpConnectEncrypt'>httpConnectEncrypt()</a></h3>
+<h3><a name='httpConnectEncrypt'>httpConnectEncrypt()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Connect to a HTTP server using encryption.</p>
@@ -1372,7 +1593,7 @@
 <h4>Returns</h4>
 <p>New HTTP connection</p>
 <!-- NEW PAGE -->
-<h3><a name='httpDecode64'>httpDecode64()</a></h3>
+<h3><a name='httpDecode64'>httpDecode64()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Base64-decode a string.</p>
@@ -1393,10 +1614,12 @@
 <h4>Returns</h4>
 <p>Decoded string</p>
 <!-- NEW PAGE -->
-<h3><a name='httpDecode64_2'>httpDecode64_2()</a></h3>
+<h3><a name='httpDecode64_2'>httpDecode64_2()</a> <span class='info'>&nbsp;CUPS 1.1.21&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Base64-decode a string.</p>
+<p>Base64-decode a string.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 char *
@@ -1416,7 +1639,7 @@
 <h4>Returns</h4>
 <p>Decoded string</p>
 <!-- NEW PAGE -->
-<h3><a name='httpDelete'>httpDelete()</a></h3>
+<h3><a name='httpDelete'>httpDelete()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Send a DELETE request to the server.</p>
@@ -1437,7 +1660,7 @@
 <h4>Returns</h4>
 <p>Status of call (0 = success)</p>
 <!-- NEW PAGE -->
-<h3><a name='httpEncode64'>httpEncode64()</a></h3>
+<h3><a name='httpEncode64'>httpEncode64()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Base64-encode a string.</p>
@@ -1458,10 +1681,12 @@
 <h4>Returns</h4>
 <p>Encoded string</p>
 <!-- NEW PAGE -->
-<h3><a name='httpEncode64_2'>httpEncode64_2()</a></h3>
+<h3><a name='httpEncode64_2'>httpEncode64_2()</a> <span class='info'>&nbsp;CUPS 1.1.21&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Base64-encode a string.</p>
+<p>Base64-encode a string.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 char *
@@ -1483,7 +1708,7 @@
 <h4>Returns</h4>
 <p>Encoded string</p>
 <!-- NEW PAGE -->
-<h3><a name='httpEncryption'>httpEncryption()</a></h3>
+<h3><a name='httpEncryption'>httpEncryption()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Set the required encryption on the link.</p>
@@ -1504,7 +1729,7 @@
 <h4>Returns</h4>
 <p>-1 on error, 0 on success</p>
 <!-- NEW PAGE -->
-<h3><a name='httpFlush'>httpFlush()</a></h3>
+<h3><a name='httpFlush'>httpFlush()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Flush data from a HTTP connection.</p>
@@ -1523,10 +1748,12 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='httpFlushWrite'>httpFlushWrite()</a></h3>
+<h3><a name='httpFlushWrite'>httpFlushWrite()</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Flush data in write buffer.</p>
+<p>Flush data in write buffer.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 int
@@ -1542,7 +1769,7 @@
 <h4>Returns</h4>
 <p>Bytes written or -1 on error</p>
 <!-- NEW PAGE -->
-<h3><a name='httpGet'>httpGet()</a></h3>
+<h3><a name='httpGet'>httpGet()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Send a GET request to the server.</p>
@@ -1563,12 +1790,12 @@
 <h4>Returns</h4>
 <p>Status of call (0 = success)</p>
 <!-- NEW PAGE -->
-<h3><a name='httpGetDateString'>httpGetDateString()</a></h3>
+<h3><a name='httpGetDateString'>httpGetDateString()</a> <span class='info'>&nbsp;DEPRECATED&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get a formatted date/time string from a time value.
 
-@deprecated</p>
+</p>
 <h4>Syntax</h4>
 <pre>
 const char *
@@ -1584,10 +1811,12 @@
 <h4>Returns</h4>
 <p>Date/time string</p>
 <!-- NEW PAGE -->
-<h3><a name='httpGetDateString2'>httpGetDateString2()</a></h3>
+<h3><a name='httpGetDateString2'>httpGetDateString2()</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Get a formatted date/time string from a time value.</p>
+<p>Get a formatted date/time string from a time value.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 const char *
@@ -1607,7 +1836,7 @@
 <h4>Returns</h4>
 <p>Date/time string</p>
 <!-- NEW PAGE -->
-<h3><a name='httpGetDateTime'>httpGetDateTime()</a></h3>
+<h3><a name='httpGetDateTime'>httpGetDateTime()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get a time value from a formatted date/time string.</p>
@@ -1626,11 +1855,13 @@
 <h4>Returns</h4>
 <p>UNIX time</p>
 <!-- NEW PAGE -->
-<h3><a name='httpGetHostByName'>httpGetHostByName()</a></h3>
+<h3><a name='httpGetHostByName'>httpGetHostByName()</a> <span class='info'>&nbsp;DEPRECATED&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Lookup a hostname or IP address, and return
-address records for the specified name.</p>
+<p>Lookup a hostname or IPv4 address, and return
+address records for the specified name.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 struct hostent *
@@ -1646,13 +1877,15 @@
 <h4>Returns</h4>
 <p>Host entry</p>
 <!-- NEW PAGE -->
-<h3><a name='httpGetHostname'>httpGetHostname()</a></h3>
+<h3><a name='httpGetHostname'>httpGetHostname()</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get the FQDN for the local system.
 
 This function uses both gethostname() and gethostbyname() to
-get the local hostname with domain.</p>
+get the local hostname with domain.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 const char *
@@ -1670,11 +1903,16 @@
 <h4>Returns</h4>
 <p>FQDN for this system</p>
 <!-- NEW PAGE -->
-<h3><a name='httpGetLength'>httpGetLength()</a></h3>
+<h3><a name='httpGetLength'>httpGetLength()</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get the amount of data remaining from the
-content-length or transfer-encoding fields.</p>
+content-length or transfer-encoding fields.
+
+This function is deprecated and will not return lengths larger than
+2^31 - 1; use httpGetLength2() instead.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 int
@@ -1690,7 +1928,30 @@
 <h4>Returns</h4>
 <p>Content length</p>
 <!-- NEW PAGE -->
-<h3><a name='httpGetSubField'>httpGetSubField()</a></h3>
+<h3><a name='httpGetLength2'>httpGetLength2()</a> </h3>
+<hr noshade/>
+<h4>Description</h4>
+<p>Get the amount of data remaining from the
+content-length or transfer-encoding fields.
+
+This function returns the complete content length, even for
+content larger than 2^31 - 1.</p>
+<h4>Syntax</h4>
+<pre>
+off_t
+httpGetLength2(
+    <a href='#http_t'>http_t</a> * http);
+</pre>
+<h4>Arguments</h4>
+<p class='table'><table align='center' border='1' width='80%' cellpadding='5' cellspacing='0' width='80%'>
+<thead><tr><th>Name</th><th>Description</th></tr></thead>
+<tbody>
+<tr><td><tt>http</tt></td><td>HTTP data</td></tr>
+</tbody></table></p>
+<h4>Returns</h4>
+<p>Content length</p>
+<!-- NEW PAGE -->
+<h3><a name='httpGetSubField'>httpGetSubField()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get a sub-field value.</p>
@@ -1715,7 +1976,7 @@
 <h4>Returns</h4>
 <p>Value or NULL</p>
 <!-- NEW PAGE -->
-<h3><a name='httpGets'>httpGets()</a></h3>
+<h3><a name='httpGets'>httpGets()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get a line of text from a HTTP connection.</p>
@@ -1738,7 +1999,7 @@
 <h4>Returns</h4>
 <p>Line or NULL</p>
 <!-- NEW PAGE -->
-<h3><a name='httpHead'>httpHead()</a></h3>
+<h3><a name='httpHead'>httpHead()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Send a HEAD request to the server.</p>
@@ -1759,7 +2020,7 @@
 <h4>Returns</h4>
 <p>Status of call (0 = success)</p>
 <!-- NEW PAGE -->
-<h3><a name='httpInitialize'>httpInitialize()</a></h3>
+<h3><a name='httpInitialize'>httpInitialize()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Initialize the HTTP interface library and set the
@@ -1767,19 +2028,14 @@
 <h4>Syntax</h4>
 <pre>
 void
-httpInitialize(
-    void);
+httpInitialize(void);
 </pre>
 <h4>Arguments</h4>
-<p class='table'><table align='center' border='1' width='80%' cellpadding='5' cellspacing='0' width='80%'>
-<thead><tr><th>Name</th><th>Description</th></tr></thead>
-<tbody>
-<tr><td><tt>void</tt></td><td></td></tr>
-</tbody></table></p>
+<p>None.</p>
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='httpMD5'>httpMD5()</a></h3>
+<h3><a name='httpMD5'>httpMD5()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Compute the MD5 sum of the username:group:password.</p>
@@ -1804,7 +2060,7 @@
 <h4>Returns</h4>
 <p>MD5 sum</p>
 <!-- NEW PAGE -->
-<h3><a name='httpMD5Final'>httpMD5Final()</a></h3>
+<h3><a name='httpMD5Final'>httpMD5Final()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Combine the MD5 sum of the username, group, and password
@@ -1831,7 +2087,7 @@
 <h4>Returns</h4>
 <p>New sum</p>
 <!-- NEW PAGE -->
-<h3><a name='httpMD5String'>httpMD5String()</a></h3>
+<h3><a name='httpMD5String'>httpMD5String()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Convert an MD5 sum to a character string.</p>
@@ -1852,7 +2108,7 @@
 <h4>Returns</h4>
 <p>MD5 sum in hex</p>
 <!-- NEW PAGE -->
-<h3><a name='httpOptions'>httpOptions()</a></h3>
+<h3><a name='httpOptions'>httpOptions()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Send an OPTIONS request to the server.</p>
@@ -1873,7 +2129,7 @@
 <h4>Returns</h4>
 <p>Status of call (0 = success)</p>
 <!-- NEW PAGE -->
-<h3><a name='httpPost'>httpPost()</a></h3>
+<h3><a name='httpPost'>httpPost()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Send a POST request to the server.</p>
@@ -1894,7 +2150,7 @@
 <h4>Returns</h4>
 <p>Status of call (0 = success)</p>
 <!-- NEW PAGE -->
-<h3><a name='httpPrintf'>httpPrintf()</a></h3>
+<h3><a name='httpPrintf'>httpPrintf()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Print a formatted string to a HTTP connection.</p>
@@ -1917,7 +2173,7 @@
 <h4>Returns</h4>
 <p>Number of bytes written</p>
 <!-- NEW PAGE -->
-<h3><a name='httpPut'>httpPut()</a></h3>
+<h3><a name='httpPut'>httpPut()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Send a PUT request to the server.</p>
@@ -1938,7 +2194,7 @@
 <h4>Returns</h4>
 <p>Status of call (0 = success)</p>
 <!-- NEW PAGE -->
-<h3><a name='httpRead'>httpRead()</a></h3>
+<h3><a name='httpRead'>httpRead()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Read data from a HTTP connection.</p>
@@ -1961,7 +2217,7 @@
 <h4>Returns</h4>
 <p>Number of bytes read</p>
 <!-- NEW PAGE -->
-<h3><a name='httpReconnect'>httpReconnect()</a></h3>
+<h3><a name='httpReconnect'>httpReconnect()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Reconnect to a HTTP server...</p>
@@ -1980,7 +2236,7 @@
 <h4>Returns</h4>
 <p>0 on success, non-zero on failure</p>
 <!-- NEW PAGE -->
-<h3><a name='httpSeparate'>httpSeparate()</a></h3>
+<h3><a name='httpSeparate'>httpSeparate()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Separate a Universal Resource Identifier into its
@@ -2010,11 +2266,13 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='httpSeparate2'>httpSeparate2()</a></h3>
+<h3><a name='httpSeparate2'>httpSeparate2()</a> <span class='info'>&nbsp;CUPS 1.1.21&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Separate a Universal Resource Identifier into its
-components.</p>
+components.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 void
@@ -2048,10 +2306,52 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='httpSetCookie'>httpSetCookie()</a></h3>
+<h3><a name='httpSeparate3'>httpSeparate3()</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Set the cookie value(s)...</p>
+<p>Separate a Universal Resource Identifier into its
+components.
+
+</p>
+<h4>Syntax</h4>
+<pre>
+http_uri_status_t
+httpSeparate3(
+    const char * uri,
+    char * scheme,
+    int schemelen,
+    char * username,
+    int usernamelen,
+    char * host,
+    int hostlen,
+    int * port,
+    char * resource,
+    int resourcelen);
+</pre>
+<h4>Arguments</h4>
+<p class='table'><table align='center' border='1' width='80%' cellpadding='5' cellspacing='0' width='80%'>
+<thead><tr><th>Name</th><th>Description</th></tr></thead>
+<tbody>
+<tr><td><tt>uri</tt></td><td>Universal Resource Identifier</td></tr>
+<tr><td><tt>scheme</tt></td><td>Scheme (http, https, etc.)</td></tr>
+<tr><td><tt>schemelen</tt></td><td>Size of scheme buffer</td></tr>
+<tr><td><tt>username</tt></td><td>Username</td></tr>
+<tr><td><tt>usernamelen</tt></td><td>Size of username buffer</td></tr>
+<tr><td><tt>host</tt></td><td>Hostname</td></tr>
+<tr><td><tt>hostlen</tt></td><td>Size of hostname buffer</td></tr>
+<tr><td><tt>port</tt></td><td>Port number to use</td></tr>
+<tr><td><tt>resource</tt></td><td>Resource/filename</td></tr>
+<tr><td><tt>resourcelen</tt></td><td>Size of resource buffer</td></tr>
+</tbody></table></p>
+<h4>Returns</h4>
+<p>Result of separation</p>
+<!-- NEW PAGE -->
+<h3><a name='httpSetCookie'>httpSetCookie()</a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></h3>
+<hr noshade/>
+<h4>Description</h4>
+<p>Set the cookie value(s)...
+
+</p>
 <h4>Syntax</h4>
 <pre>
 void
@@ -2069,7 +2369,7 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='httpSetField'>httpSetField()</a></h3>
+<h3><a name='httpSetField'>httpSetField()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Set the value of an HTTP header.</p>
@@ -2092,7 +2392,30 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='httpStatus'>httpStatus()</a></h3>
+<h3><a name='httpSetLength'>httpSetLength()</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
+<hr noshade/>
+<h4>Description</h4>
+<p>Set the content-length and content-encoding.
+
+</p>
+<h4>Syntax</h4>
+<pre>
+void
+httpSetLength(
+    <a href='#http_t'>http_t</a> * http,
+    off_t length);
+</pre>
+<h4>Arguments</h4>
+<p class='table'><table align='center' border='1' width='80%' cellpadding='5' cellspacing='0' width='80%'>
+<thead><tr><th>Name</th><th>Description</th></tr></thead>
+<tbody>
+<tr><td><tt>http</tt></td><td>HTTP data</td></tr>
+<tr><td><tt>length</tt></td><td>Length (0 for chunked)</td></tr>
+</tbody></table></p>
+<h4>Returns</h4>
+<p>Nothing.</p>
+<!-- NEW PAGE -->
+<h3><a name='httpStatus'>httpStatus()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Return a short string describing a HTTP status code.</p>
@@ -2111,7 +2434,7 @@
 <h4>Returns</h4>
 <p>String or NULL</p>
 <!-- NEW PAGE -->
-<h3><a name='httpTrace'>httpTrace()</a></h3>
+<h3><a name='httpTrace'>httpTrace()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Send an TRACE request to the server.</p>
@@ -2132,7 +2455,7 @@
 <h4>Returns</h4>
 <p>Status of call (0 = success)</p>
 <!-- NEW PAGE -->
-<h3><a name='httpUpdate'>httpUpdate()</a></h3>
+<h3><a name='httpUpdate'>httpUpdate()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Update the current HTTP state for incoming data.</p>
@@ -2151,10 +2474,12 @@
 <h4>Returns</h4>
 <p>HTTP status</p>
 <!-- NEW PAGE -->
-<h3><a name='httpWait'>httpWait()</a></h3>
+<h3><a name='httpWait'>httpWait()</a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Wait for data available on a connection.</p>
+<p>Wait for data available on a connection.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 int
@@ -2172,7 +2497,7 @@
 <h4>Returns</h4>
 <p>1 if data is available, 0 otherwise</p>
 <!-- NEW PAGE -->
-<h3><a name='httpWrite'>httpWrite()</a></h3>
+<h3><a name='httpWrite'>httpWrite()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Write data to a HTTP connection.</p>
@@ -2195,7 +2520,7 @@
 <h4>Returns</h4>
 <p>Number of bytes written</p>
 <!-- NEW PAGE -->
-<h3><a name='ippAddBoolean'>ippAddBoolean()</a></h3>
+<h3><a name='ippAddBoolean'>ippAddBoolean()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Add a boolean attribute to an IPP request.</p>
@@ -2220,7 +2545,7 @@
 <h4>Returns</h4>
 <p>New attribute</p>
 <!-- NEW PAGE -->
-<h3><a name='ippAddBooleans'>ippAddBooleans()</a></h3>
+<h3><a name='ippAddBooleans'>ippAddBooleans()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Add an array of boolean values.</p>
@@ -2247,10 +2572,12 @@
 <h4>Returns</h4>
 <p>New attribute</p>
 <!-- NEW PAGE -->
-<h3><a name='ippAddCollection'>ippAddCollection()</a></h3>
+<h3><a name='ippAddCollection'>ippAddCollection()</a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Add a collection value.</p>
+<p>Add a collection value.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 <a href='#ipp_attribute_t'>ipp_attribute_t</a> *
@@ -2272,10 +2599,12 @@
 <h4>Returns</h4>
 <p>New attribute</p>
 <!-- NEW PAGE -->
-<h3><a name='ippAddCollections'>ippAddCollections()</a></h3>
+<h3><a name='ippAddCollections'>ippAddCollections()</a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Add an array of collection values.</p>
+<p>Add an array of collection values.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 <a href='#ipp_attribute_t'>ipp_attribute_t</a> *
@@ -2299,7 +2628,7 @@
 <h4>Returns</h4>
 <p>New attribute</p>
 <!-- NEW PAGE -->
-<h3><a name='ippAddDate'>ippAddDate()</a></h3>
+<h3><a name='ippAddDate'>ippAddDate()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Add a date attribute to an IPP request.</p>
@@ -2324,7 +2653,7 @@
 <h4>Returns</h4>
 <p>New attribute</p>
 <!-- NEW PAGE -->
-<h3><a name='ippAddInteger'>ippAddInteger()</a></h3>
+<h3><a name='ippAddInteger'>ippAddInteger()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Add a integer attribute to an IPP request.</p>
@@ -2351,7 +2680,7 @@
 <h4>Returns</h4>
 <p>New attribute</p>
 <!-- NEW PAGE -->
-<h3><a name='ippAddIntegers'>ippAddIntegers()</a></h3>
+<h3><a name='ippAddIntegers'>ippAddIntegers()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Add an array of integer values.</p>
@@ -2380,7 +2709,7 @@
 <h4>Returns</h4>
 <p>New attribute</p>
 <!-- NEW PAGE -->
-<h3><a name='ippAddRange'>ippAddRange()</a></h3>
+<h3><a name='ippAddRange'>ippAddRange()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Add a range of values to an IPP request.</p>
@@ -2407,7 +2736,7 @@
 <h4>Returns</h4>
 <p>New attribute</p>
 <!-- NEW PAGE -->
-<h3><a name='ippAddRanges'>ippAddRanges()</a></h3>
+<h3><a name='ippAddRanges'>ippAddRanges()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Add ranges of values to an IPP request.</p>
@@ -2436,7 +2765,7 @@
 <h4>Returns</h4>
 <p>New attribute</p>
 <!-- NEW PAGE -->
-<h3><a name='ippAddResolution'>ippAddResolution()</a></h3>
+<h3><a name='ippAddResolution'>ippAddResolution()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Add a resolution value to an IPP request.</p>
@@ -2465,7 +2794,7 @@
 <h4>Returns</h4>
 <p>New attribute</p>
 <!-- NEW PAGE -->
-<h3><a name='ippAddResolutions'>ippAddResolutions()</a></h3>
+<h3><a name='ippAddResolutions'>ippAddResolutions()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Add resolution values to an IPP request.</p>
@@ -2496,7 +2825,7 @@
 <h4>Returns</h4>
 <p>New attribute</p>
 <!-- NEW PAGE -->
-<h3><a name='ippAddSeparator'>ippAddSeparator()</a></h3>
+<h3><a name='ippAddSeparator'>ippAddSeparator()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Add a group separator to an IPP request.</p>
@@ -2515,7 +2844,7 @@
 <h4>Returns</h4>
 <p>New attribute</p>
 <!-- NEW PAGE -->
-<h3><a name='ippAddString'>ippAddString()</a></h3>
+<h3><a name='ippAddString'>ippAddString()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Add a language-encoded string to an IPP request.</p>
@@ -2544,7 +2873,7 @@
 <h4>Returns</h4>
 <p>New attribute</p>
 <!-- NEW PAGE -->
-<h3><a name='ippAddStrings'>ippAddStrings()</a></h3>
+<h3><a name='ippAddStrings'>ippAddStrings()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Add language-encoded strings to an IPP request.</p>
@@ -2575,7 +2904,7 @@
 <h4>Returns</h4>
 <p>New attribute</p>
 <!-- NEW PAGE -->
-<h3><a name='ippDateToTime'>ippDateToTime()</a></h3>
+<h3><a name='ippDateToTime'>ippDateToTime()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Convert from RFC 1903 Date/Time format to UNIX time
@@ -2595,7 +2924,7 @@
 <h4>Returns</h4>
 <p>UNIX time value</p>
 <!-- NEW PAGE -->
-<h3><a name='ippDelete'>ippDelete()</a></h3>
+<h3><a name='ippDelete'>ippDelete()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Delete an IPP request.</p>
@@ -2614,10 +2943,12 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='ippDeleteAttribute'>ippDeleteAttribute()</a></h3>
+<h3><a name='ippDeleteAttribute'>ippDeleteAttribute()</a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Delete a single attribute in an IPP request.</p>
+<p>Delete a single attribute in an IPP request.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 void
@@ -2635,7 +2966,7 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='ippErrorString'>ippErrorString()</a></h3>
+<h3><a name='ippErrorString'>ippErrorString()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Return a name for the given status code.</p>
@@ -2654,10 +2985,12 @@
 <h4>Returns</h4>
 <p>Text string</p>
 <!-- NEW PAGE -->
-<h3><a name='ippErrorValue'>ippErrorValue()</a></h3>
+<h3><a name='ippErrorValue'>ippErrorValue()</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Return a status code for the given name.</p>
+<p>Return a status code for the given name.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 ipp_status_t
@@ -2673,7 +3006,7 @@
 <h4>Returns</h4>
 <p>IPP status code</p>
 <!-- NEW PAGE -->
-<h3><a name='ippFindAttribute'>ippFindAttribute()</a></h3>
+<h3><a name='ippFindAttribute'>ippFindAttribute()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Find a named attribute in a request...</p>
@@ -2696,7 +3029,7 @@
 <h4>Returns</h4>
 <p>Matching attribute</p>
 <!-- NEW PAGE -->
-<h3><a name='ippFindNextAttribute'>ippFindNextAttribute()</a></h3>
+<h3><a name='ippFindNextAttribute'>ippFindNextAttribute()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Find the next named attribute in a request...</p>
@@ -2719,7 +3052,7 @@
 <h4>Returns</h4>
 <p>Matching attribute</p>
 <!-- NEW PAGE -->
-<h3><a name='ippLength'>ippLength()</a></h3>
+<h3><a name='ippLength'>ippLength()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Compute the length of an IPP request.</p>
@@ -2738,29 +3071,26 @@
 <h4>Returns</h4>
 <p>Size of IPP request</p>
 <!-- NEW PAGE -->
-<h3><a name='ippNew'>ippNew()</a></h3>
+<h3><a name='ippNew'>ippNew()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Allocate a new IPP request.</p>
 <h4>Syntax</h4>
 <pre>
 <a href='#ipp_t'>ipp_t</a> *
-ippNew(
-    void);
+ippNew(void);
 </pre>
 <h4>Arguments</h4>
-<p class='table'><table align='center' border='1' width='80%' cellpadding='5' cellspacing='0' width='80%'>
-<thead><tr><th>Name</th><th>Description</th></tr></thead>
-<tbody>
-<tr><td><tt>void</tt></td><td></td></tr>
-</tbody></table></p>
+<p>None.</p>
 <h4>Returns</h4>
 <p>New IPP request</p>
 <!-- NEW PAGE -->
-<h3><a name='ippOpString'>ippOpString()</a></h3>
+<h3><a name='ippOpString'>ippOpString()</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Return a name for the given operation id.</p>
+<p>Return a name for the given operation id.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 const char *
@@ -2776,10 +3106,12 @@
 <h4>Returns</h4>
 <p>Name</p>
 <!-- NEW PAGE -->
-<h3><a name='ippOpValue'>ippOpValue()</a></h3>
+<h3><a name='ippOpValue'>ippOpValue()</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Return an operation id for the given name.</p>
+<p>Return an operation id for the given name.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 ipp_op_t
@@ -2795,26 +3127,21 @@
 <h4>Returns</h4>
 <p>Operation ID</p>
 <!-- NEW PAGE -->
-<h3><a name='ippPort'>ippPort()</a></h3>
+<h3><a name='ippPort'>ippPort()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Return the default IPP port number.</p>
 <h4>Syntax</h4>
 <pre>
 int
-ippPort(
-    void);
+ippPort(void);
 </pre>
 <h4>Arguments</h4>
-<p class='table'><table align='center' border='1' width='80%' cellpadding='5' cellspacing='0' width='80%'>
-<thead><tr><th>Name</th><th>Description</th></tr></thead>
-<tbody>
-<tr><td><tt>void</tt></td><td></td></tr>
-</tbody></table></p>
+<p>None.</p>
 <h4>Returns</h4>
 <p>Port number</p>
 <!-- NEW PAGE -->
-<h3><a name='ippRead'>ippRead()</a></h3>
+<h3><a name='ippRead'>ippRead()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Read data for an IPP request from a HTTP connection.</p>
@@ -2835,10 +3162,12 @@
 <h4>Returns</h4>
 <p>Current state</p>
 <!-- NEW PAGE -->
-<h3><a name='ippReadFile'>ippReadFile()</a></h3>
+<h3><a name='ippReadFile'>ippReadFile()</a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Read data for an IPP request from a file.</p>
+<p>Read data for an IPP request from a file.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 ipp_state_t
@@ -2856,16 +3185,18 @@
 <h4>Returns</h4>
 <p>Current state</p>
 <!-- NEW PAGE -->
-<h3><a name='ippReadIO'>ippReadIO()</a></h3>
+<h3><a name='ippReadIO'>ippReadIO()</a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Read data for an IPP request.</p>
+<p>Read data for an IPP request.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 ipp_state_t
 ippReadIO(
     void * src,
-    ipp_iocb_t cb,
+    <a href='#ipp_iocb_t'>ipp_iocb_t</a> cb,
     int blocking,
     <a href='#ipp_t'>ipp_t</a> * parent,
     <a href='#ipp_t'>ipp_t</a> * ipp);
@@ -2883,7 +3214,7 @@
 <h4>Returns</h4>
 <p>Current state</p>
 <!-- NEW PAGE -->
-<h3><a name='ippSetPort'>ippSetPort()</a></h3>
+<h3><a name='ippSetPort'>ippSetPort()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Set the default port number.</p>
@@ -2902,7 +3233,7 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='ippTimeToDate'>ippTimeToDate()</a></h3>
+<h3><a name='ippTimeToDate'>ippTimeToDate()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Convert from UNIX time to RFC 1903 format.</p>
@@ -2921,7 +3252,7 @@
 <h4>Returns</h4>
 <p>RFC-1903 date/time data</p>
 <!-- NEW PAGE -->
-<h3><a name='ippWrite'>ippWrite()</a></h3>
+<h3><a name='ippWrite'>ippWrite()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Write data for an IPP request to a HTTP connection.</p>
@@ -2942,10 +3273,12 @@
 <h4>Returns</h4>
 <p>Current state</p>
 <!-- NEW PAGE -->
-<h3><a name='ippWriteFile'>ippWriteFile()</a></h3>
+<h3><a name='ippWriteFile'>ippWriteFile()</a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Write data for an IPP request to a file.</p>
+<p>Write data for an IPP request to a file.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 ipp_state_t
@@ -2963,16 +3296,18 @@
 <h4>Returns</h4>
 <p>Current state</p>
 <!-- NEW PAGE -->
-<h3><a name='ippWriteIO'>ippWriteIO()</a></h3>
+<h3><a name='ippWriteIO'>ippWriteIO()</a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Write data for an IPP request.</p>
+<p>Write data for an IPP request.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 ipp_state_t
 ippWriteIO(
     void * dst,
-    ipp_iocb_t cb,
+    <a href='#ipp_iocb_t'>ipp_iocb_t</a> cb,
     int blocking,
     <a href='#ipp_t'>ipp_t</a> * parent,
     <a href='#ipp_t'>ipp_t</a> * ipp);
@@ -2992,14 +3327,16 @@
 <!-- NEW PAGE -->
 <h2><a name='_structures'>Structures</a></h2>
 <ul>
-	<li><a href='#cups_dest_s'><tt>cups_dest_s</tt></a></li>
-	<li><a href='#cups_job_s'><tt>cups_job_s</tt></a></li>
-	<li><a href='#cups_option_s'><tt>cups_option_s</tt></a></li>
-	<li><a href='#ipp_attribute_s'><tt>ipp_attribute_s</tt></a></li>
-	<li><a href='#ipp_str'><tt>ipp_str</tt></a></li>
+	<li><a href='#cups_dest_s'><tt>cups_dest_s</tt></a> </li>
+	<li><a href='#cups_job_s'><tt>cups_job_s</tt></a> </li>
+	<li><a href='#cups_option_s'><tt>cups_option_s</tt></a> </li>
+	<li><a href='#http_addrlist_s'><tt>http_addrlist_s</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#http_s'><tt>http_s</tt></a> </li>
+	<li><a href='#ipp_attribute_s'><tt>ipp_attribute_s</tt></a> </li>
+	<li><a href='#ipp_str'><tt>ipp_str</tt></a> </li>
 </ul>
 <!-- NEW PAGE -->
-<h3><a name='cups_dest_s'>cups_dest_s</a></h3>
+<h3><a name='cups_dest_s'>cups_dest_s</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Destination</p>
@@ -3007,8 +3344,8 @@
 <pre>
 struct cups_dest_s
 {
+  char *name, * instance;
   int is_default;
-  char * name;
   int num_options;
   <a href='#cups_option_t'>cups_option_t</a> * options;
 };
@@ -3017,13 +3354,13 @@
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>is_default</tt></td><td>Is this printer the default?</td></tr>
-<tr><td><tt>name</tt></td><td>Printer or class name</td></tr>
-<tr><td><tt>num_options</tt></td><td>Number of options</td></tr>
-<tr><td><tt>options</tt></td><td>Options</td></tr>
+<tr><td><tt>instance</tt> </td><td>Local instance name or NULL</td></tr>
+<tr><td><tt>is_default</tt> </td><td>Is this printer the default?</td></tr>
+<tr><td><tt>num_options</tt> </td><td>Number of options</td></tr>
+<tr><td><tt>options</tt> </td><td>Options</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
-<h3><a name='cups_job_s'>cups_job_s</a></h3>
+<h3><a name='cups_job_s'>cups_job_s</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Job</p>
@@ -3031,29 +3368,25 @@
 <pre>
 struct cups_job_s
 {
-  time_t completed_time;
-  char * dest;
+  char *dest, *title, *user, * format;
   int id;
-  creation_time processing_time;
-  int size;
+  int size, priority;
+  time_t completed_time, creation_time, processing_time;
   ipp_jstate_t state;
-  title * user;
 };
 </pre>
 <h4>Members</h4>
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>completed_time</tt></td><td>Time the job was completed</td></tr>
-<tr><td><tt>dest</tt></td><td>Printer or class name</td></tr>
-<tr><td><tt>id</tt></td><td>The job ID</td></tr>
-<tr><td><tt>processing_time</tt></td><td>Time the job was processed</td></tr>
-<tr><td><tt>size</tt></td><td>Size in kilobytes</td></tr>
-<tr><td><tt>state</tt></td><td>Job state</td></tr>
-<tr><td><tt>user</tt></td><td>User the submitted the job</td></tr>
+<tr><td><tt>format</tt> </td><td>Document format</td></tr>
+<tr><td><tt>id</tt> </td><td>The job ID</td></tr>
+<tr><td><tt>priority</tt> </td><td>Priority (1-100)</td></tr>
+<tr><td><tt>processing_time</tt> </td><td>Time the job was processed</td></tr>
+<tr><td><tt>state</tt> </td><td>Job state</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
-<h3><a name='cups_option_s'>cups_option_s</a></h3>
+<h3><a name='cups_option_s'>cups_option_s</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Printer Options</p>
@@ -3069,11 +3402,108 @@
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>name</tt></td><td>Name of option</td></tr>
-<tr><td><tt>value</tt></td><td>Value of option</td></tr>
+<tr><td><tt>name</tt> </td><td>Name of option</td></tr>
+<tr><td><tt>value</tt> </td><td>Value of option</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
-<h3><a name='ipp_attribute_s'>ipp_attribute_s</a></h3>
+<h3><a name='http_addrlist_s'>http_addrlist_s</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
+<hr noshade/>
+<h4>Description</h4>
+<p>Socket address list, which is
+used to enumerate all of the
+addresses that are associated
+with a hostname. </p>
+<h4>Definition</h4>
+<pre>
+struct http_addrlist_s
+{
+  <a href='#http_addr_t'>http_addr_t</a> addr;
+  struct <a href='#http_addrlist_s'>http_addrlist_s</a> * next;
+};
+</pre>
+<h4>Members</h4>
+<p class='table'><table align='center' border='1' width='80%'>
+<thead><tr><th>Name</th><th>Description</th></tr></thead>
+<tbody>
+<tr><td><tt>addr</tt> </td><td>Address</td></tr>
+<tr><td><tt>next</tt> </td><td>Pointer to next address in list</td></tr>
+</tbody></table></p>
+<!-- NEW PAGE -->
+<h3><a name='http_s'>http_s</a> </h3>
+<hr noshade/>
+<h4>Description</h4>
+<p>HTTP connection structure.</p>
+<h4>Definition</h4>
+<pre>
+struct http_s
+{
+  time_t activity;
+  <a href='#http_addrlist_t'>http_addrlist_t</a> * addrlist;
+  int auth_type;
+  int blocking;
+  char buffer[HTTP_MAX_BUFFER];
+  char * cookie;
+  char * data;
+  <a href='#http_encoding_t'>http_encoding_t</a> data_encoding;
+  off_t data_remaining;
+  int digest_tries;
+  <a href='#http_encryption_t'>http_encryption_t</a> encryption;
+  int error;
+  http_status_t expect;
+  int fd;
+  char hostname[HTTP_MAX_HOST], fields[HTTP_FIELD_MAX][HTTP_MAX_VALUE];
+  <a href='#http_addr_t'>http_addr_t</a> * hostaddr;
+  fd_set * input_set;
+  http_keepalive_t keep_alive;
+  _cups_md5_state_t md5_state;
+  char nonce[HTTP_MAX_VALUE];
+  int nonce_count;
+  <a href='#http_state_t'>http_state_t</a> state;
+  http_status_t status;
+  void * tls;
+  int used;
+  char authstring[HTTP_MAX_VALUE], userpass[HTTP_MAX_VALUE];
+  http_version_t version;
+  char wbuffer[HTTP_MAX_BUFFER];
+  int wused;
+};
+</pre>
+<h4>Members</h4>
+<p class='table'><table align='center' border='1' width='80%'>
+<thead><tr><th>Name</th><th>Description</th></tr></thead>
+<tbody>
+<tr><td><tt>activity</tt> </td><td>Time since last read/write</td></tr>
+<tr><td><tt>addrlist</tt> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></td><td>List of valid addresses </td></tr>
+<tr><td><tt>auth_type</tt> </td><td>Authentication in use</td></tr>
+<tr><td><tt>blocking</tt> </td><td>To block or not to block</td></tr>
+<tr><td><tt>buffer[HTTP_MAX_BUFFER]</tt> </td><td>Buffer for incoming data</td></tr>
+<tr><td><tt>cookie</tt> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></td><td>Cookie value(s) </td></tr>
+<tr><td><tt>data</tt> </td><td>Pointer to data buffer</td></tr>
+<tr><td><tt>data_encoding</tt> </td><td>Chunked or not</td></tr>
+<tr><td><tt>data_remaining</tt> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></td><td>Number of bytes left </td></tr>
+<tr><td><tt>digest_tries</tt> <span class='info'>&nbsp;CUPS 1.1.20&nbsp;</span></td><td>Number of tries for digest auth </td></tr>
+<tr><td><tt>encryption</tt> </td><td>Encryption requirements</td></tr>
+<tr><td><tt>error</tt> </td><td>Last error on read</td></tr>
+<tr><td><tt>expect</tt> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></td><td>Expect: header </td></tr>
+<tr><td><tt>fd</tt> </td><td>File descriptor for this socket</td></tr>
+<tr><td><tt>fields[HTTP_FIELD_MAX][HTTP_MAX_VALUE]</tt> </td><td>Field values</td></tr>
+<tr><td><tt>hostaddr</tt> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></td><td>Current host address and port </td></tr>
+<tr><td><tt>input_set</tt> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></td><td>select() set for httpWait() </td></tr>
+<tr><td><tt>keep_alive</tt> </td><td>Keep-alive supported?</td></tr>
+<tr><td><tt>md5_state</tt> </td><td>MD5 state</td></tr>
+<tr><td><tt>nonce[HTTP_MAX_VALUE]</tt> </td><td>Nonce value</td></tr>
+<tr><td><tt>nonce_count</tt> </td><td>Nonce count</td></tr>
+<tr><td><tt>state</tt> </td><td>State of client</td></tr>
+<tr><td><tt>status</tt> </td><td>Status of last request</td></tr>
+<tr><td><tt>tls</tt> </td><td>TLS state information</td></tr>
+<tr><td><tt>used</tt> </td><td>Number of bytes used in buffer</td></tr>
+<tr><td><tt>userpass[HTTP_MAX_VALUE]</tt> <span class='info'>&nbsp;CUPS 1.1.20&nbsp;</span></td><td>Username:password string </td></tr>
+<tr><td><tt>version</tt> </td><td>Protocol version</td></tr>
+<tr><td><tt>wbuffer[HTTP_MAX_BUFFER]</tt> </td><td>Buffer for outgoing data</td></tr>
+<tr><td><tt>wused</tt> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></td><td>Write buffer bytes used </td></tr>
+</tbody></table></p>
+<!-- NEW PAGE -->
+<h3><a name='ipp_attribute_s'>ipp_attribute_s</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Attribute</p>
@@ -3081,10 +3511,10 @@
 <pre>
 struct ipp_attribute_s
 {
-  ipp_tag_t group_tag;
   char * name;
   struct <a href='#ipp_attribute_s'>ipp_attribute_s</a> * next;
   int num_values;
+  ipp_tag_t group_tag, value_tag;
   <a href='#ipp_value_t'>ipp_value_t</a> values[1];
 };
 </pre>
@@ -3092,14 +3522,14 @@
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>group_tag</tt></td><td>Job/Printer/Operation group tag</td></tr>
-<tr><td><tt>name</tt></td><td>Name of attribute</td></tr>
-<tr><td><tt>next</tt></td><td>Next attribute in list</td></tr>
-<tr><td><tt>num_values</tt></td><td>Number of values</td></tr>
-<tr><td><tt>values[1]</tt></td><td>Values</td></tr>
+<tr><td><tt>name</tt> </td><td>Name of attribute</td></tr>
+<tr><td><tt>next</tt> </td><td>Next attribute in list</td></tr>
+<tr><td><tt>num_values</tt> </td><td>Number of values</td></tr>
+<tr><td><tt>value_tag</tt> </td><td>What type of value is it?</td></tr>
+<tr><td><tt>values[1]</tt> </td><td>Values</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
-<h3><a name='ipp_str'>ipp_str</a></h3>
+<h3><a name='ipp_str'>ipp_str</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>IPP Request/Response/Notification</p>
@@ -3107,9 +3537,9 @@
 <pre>
 struct ipp_str
 {
-  <a href='#ipp_attribute_t'>ipp_attribute_t</a> * attrs;
-  last * current;
+  <a href='#ipp_attribute_t'>ipp_attribute_t</a> *attrs, *last, * current;
   ipp_tag_t curtag;
+  <a href='#ipp_attribute_t'>ipp_attribute_t</a> * prev;
   <a href='#ipp_request_t'>ipp_request_t</a> request;
   ipp_state_t state;
 };
@@ -3118,33 +3548,35 @@
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>attrs</tt></td><td>Attributes</td></tr>
-<tr><td><tt>current</tt></td><td>Current attribute (for read/write)</td></tr>
-<tr><td><tt>curtag</tt></td><td>Current attribute group tag</td></tr>
-<tr><td><tt>request</tt></td><td>Request header</td></tr>
-<tr><td><tt>state</tt></td><td>State of request</td></tr>
+<tr><td><tt>current</tt> </td><td>Current attribute (for read/write)</td></tr>
+<tr><td><tt>curtag</tt> </td><td>Current attribute group tag</td></tr>
+<tr><td><tt>prev</tt> </td><td>Previous attribute (for read)</td></tr>
+<tr><td><tt>request</tt> </td><td>Request header</td></tr>
+<tr><td><tt>state</tt> </td><td>State of request</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
 <h2><a name='_types'>Types</a></h2>
 <ul>
-	<li><a href='#cups_dest_t'><tt>cups_dest_t</tt></a></li>
-	<li><a href='#cups_job_t'><tt>cups_job_t</tt></a></li>
-	<li><a href='#cups_option_t'><tt>cups_option_t</tt></a></li>
-	<li><a href='#cups_ptype_t'><tt>cups_ptype_t</tt></a></li>
-	<li><a href='#http_addr_t'><tt>http_addr_t</tt></a></li>
-	<li><a href='#http_auth_t'><tt>http_auth_t</tt></a></li>
-	<li><a href='#http_encoding_t'><tt>http_encoding_t</tt></a></li>
-	<li><a href='#http_encryption_t'><tt>http_encryption_t</tt></a></li>
-	<li><a href='#http_state_t'><tt>http_state_t</tt></a></li>
-	<li><a href='#http_t'><tt>http_t</tt></a></li>
-	<li><a href='#ipp_attribute_t'><tt>ipp_attribute_t</tt></a></li>
-	<li><a href='#ipp_request_t'><tt>ipp_request_t</tt></a></li>
-	<li><a href='#ipp_t'><tt>ipp_t</tt></a></li>
-	<li><a href='#ipp_uchar_t'><tt>ipp_uchar_t</tt></a></li>
-	<li><a href='#ipp_value_t'><tt>ipp_value_t</tt></a></li>
+	<li><a href='#cups_dest_t'><tt>cups_dest_t</tt></a> </li>
+	<li><a href='#cups_job_t'><tt>cups_job_t</tt></a> </li>
+	<li><a href='#cups_option_t'><tt>cups_option_t</tt></a> </li>
+	<li><a href='#cups_ptype_t'><tt>cups_ptype_t</tt></a> </li>
+	<li><a href='#http_addr_t'><tt>http_addr_t</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#http_addrlist_t'><tt>http_addrlist_t</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#http_auth_t'><tt>http_auth_t</tt></a> </li>
+	<li><a href='#http_encoding_t'><tt>http_encoding_t</tt></a> </li>
+	<li><a href='#http_encryption_t'><tt>http_encryption_t</tt></a> </li>
+	<li><a href='#http_state_t'><tt>http_state_t</tt></a> </li>
+	<li><a href='#http_t'><tt>http_t</tt></a> </li>
+	<li><a href='#ipp_attribute_t'><tt>ipp_attribute_t</tt></a> </li>
+	<li><a href='#ipp_iocb_t'><tt>ipp_iocb_t</tt></a> </li>
+	<li><a href='#ipp_request_t'><tt>ipp_request_t</tt></a> </li>
+	<li><a href='#ipp_t'><tt>ipp_t</tt></a> </li>
+	<li><a href='#ipp_uchar_t'><tt>ipp_uchar_t</tt></a> </li>
+	<li><a href='#ipp_value_t'><tt>ipp_value_t</tt></a> </li>
 </ul>
 <!-- NEW PAGE -->
-<h3><a name='cups_dest_t'>cups_dest_t</a></h3>
+<h3><a name='cups_dest_t'>cups_dest_t</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Destination</p>
@@ -3153,7 +3585,7 @@
 typedef struct <a href='#cups_dest_s'>cups_dest_s</a> cups_dest_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='cups_job_t'>cups_job_t</a></h3>
+<h3><a name='cups_job_t'>cups_job_t</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Job</p>
@@ -3162,7 +3594,7 @@
 typedef struct <a href='#cups_job_s'>cups_job_s</a> cups_job_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='cups_option_t'>cups_option_t</a></h3>
+<h3><a name='cups_option_t'>cups_option_t</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Printer Options</p>
@@ -3171,68 +3603,84 @@
 typedef struct <a href='#cups_option_s'>cups_option_s</a> cups_option_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='cups_ptype_t'>cups_ptype_t</a></h3>
+<h3><a name='cups_ptype_t'>cups_ptype_t</a> </h3>
 <hr noshade/>
 <h4>Definition</h4>
 <pre>
 typedef unsigned cups_ptype_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='http_addr_t'>http_addr_t</a></h3>
+<h3><a name='http_addr_t'>http_addr_t</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>HTTP address structure (makes using IPv6 a little easier and more portable.)</p>
+<p>Socket address union, which
+makes using IPv6 and other
+address types easier and
+more portable. </p>
 <h4>Definition</h4>
 <pre>
-typedef union http_addr_t;
+typedef union <a href='#http_addr_u'>http_addr_u</a> / http_addr_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='http_auth_t'>http_auth_t</a></h3>
+<h3><a name='http_addrlist_t'>http_addrlist_t</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>HTTP authentication types...</p>
+<p>Socket address list, which is
+used to enumerate all of the
+addresses that are associated
+with a hostname. </p>
 <h4>Definition</h4>
 <pre>
-typedef enum http_auth_t;
+typedef struct <a href='#http_addrlist_s'>http_addrlist_s</a> / http_addrlist_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='http_encoding_t'>http_encoding_t</a></h3>
+<h3><a name='http_auth_t'>http_auth_t</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>HTTP transfer encoding values...</p>
+<p>HTTP authentication types</p>
 <h4>Definition</h4>
 <pre>
-typedef enum http_encoding_t;
+typedef enum <a href='#http_auth_e'>http_auth_e</a> http_auth_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='http_encryption_t'>http_encryption_t</a></h3>
+<h3><a name='http_encoding_t'>http_encoding_t</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>HTTP encryption values...</p>
+<p>HTTP transfer encoding values</p>
 <h4>Definition</h4>
 <pre>
-typedef enum http_encryption_t;
+typedef enum <a href='#http_encoding_e'>http_encoding_e</a> http_encoding_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='http_state_t'>http_state_t</a></h3>
+<h3><a name='http_encryption_t'>http_encryption_t</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>States are server-oriented</p>
+<p>HTTP encryption values</p>
 <h4>Definition</h4>
 <pre>
-typedef enum http_state_t;
+typedef enum <a href='#http_encryption_e'>http_encryption_e</a> http_encryption_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='http_t'>http_t</a></h3>
+<h3><a name='http_state_t'>http_state_t</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>HTTP connection structure...</p>
+<p>HTTP state values; states
+are server-oriented...</p>
 <h4>Definition</h4>
 <pre>
-typedef struct http_t;
+typedef enum <a href='#http_state_e'>http_state_e</a> / http_state_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='ipp_attribute_t'>ipp_attribute_t</a></h3>
+<h3><a name='http_t'>http_t</a> </h3>
+<hr noshade/>
+<h4>Description</h4>
+<p>HTTP connection structure.</p>
+<h4>Definition</h4>
+<pre>
+typedef struct <a href='#http_s'>http_s</a> http_t;
+</pre>
+<!-- NEW PAGE -->
+<h3><a name='ipp_attribute_t'>ipp_attribute_t</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Attribute</p>
@@ -3241,30 +3689,39 @@
 typedef struct <a href='#ipp_attribute_s'>ipp_attribute_s</a> ipp_attribute_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='ipp_request_t'>ipp_request_t</a></h3>
+<h3><a name='ipp_iocb_t'>ipp_iocb_t</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Request Header</p>
+<p>IPP IO Callback Function</p>
+<h4>Definition</h4>
+<pre>
+typedef int (*ipp_iocb_t)(void *, <a href='#ipp_uchar_t'>ipp_uchar_t</a> *, int);
+</pre>
+<!-- NEW PAGE -->
+<h3><a name='ipp_request_t'>ipp_request_t</a> </h3>
+<hr noshade/>
+<h4>Description</h4>
+<p>New in CUPS 1.1.19</p>
 <h4>Definition</h4>
 <pre>
 typedef union ipp_request_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='ipp_t'>ipp_t</a></h3>
+<h3><a name='ipp_t'>ipp_t</a> </h3>
 <hr noshade/>
 <h4>Definition</h4>
 <pre>
 typedef struct <a href='#ipp_str'>ipp_str</a> ipp_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='ipp_uchar_t'>ipp_uchar_t</a></h3>
+<h3><a name='ipp_uchar_t'>ipp_uchar_t</a> </h3>
 <hr noshade/>
 <h4>Definition</h4>
 <pre>
 typedef unsigned char ipp_uchar_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='ipp_value_t'>ipp_value_t</a></h3>
+<h3><a name='ipp_value_t'>ipp_value_t</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Attribute Value</p>
@@ -3272,5 +3729,39 @@
 <pre>
 typedef union ipp_value_t;
 </pre>
+<!-- NEW PAGE -->
+<h2><a name='_unions'>Unions</a></h2>
+<ul>
+	<li><a href='#http_addr_u'><tt>http_addr_u</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+</ul>
+<!-- NEW PAGE -->
+<h3><a name='http_addr_u'>http_addr_u</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
+<hr noshade/>
+<h4>Description</h4>
+<p>Socket address union, which
+makes using IPv6 and other
+address types easier and
+more portable. </p>
+<h4>Definition</h4>
+<pre>
+union http_addr_u
+{
+  struct sockaddr addr;
+  struct sockaddr_in ipv4;
+  struct sockaddr_in6 ipv6;
+  char pad[256];
+  struct sockaddr_un un;
+};
+</pre>
+<h4>Members</h4>
+<p class='table'><table align='center' border='1' width='80%'>
+<thead><tr><th>Name</th><th>Description</th></tr></thead>
+<tbody>
+<tr><td><tt>addr</tt> </td><td>Base structure for family value</td></tr>
+<tr><td><tt>ipv4</tt> </td><td>IPv4 address</td></tr>
+<tr><td><tt>ipv6</tt> </td><td>IPv6 address</td></tr>
+<tr><td><tt>pad[256]</tt> </td><td>Padding to ensure binary compatibility</td></tr>
+<tr><td><tt>un</tt> </td><td>Domain socket file</td></tr>
+</tbody></table></p>
 </body>
 </html>
diff -urNad cupsys-1.1.99.b1.r4748~/doc/help/api-ppd.html cupsys-1.1.99.b1.r4748/doc/help/api-ppd.html
--- cupsys-1.1.99.b1.r4748~/doc/help/api-ppd.html	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/doc/help/api-ppd.html	2005-10-14 04:39:05.160337000 +0900
@@ -2,11 +2,13 @@
 <html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
 <head>
 	<title>PPD API</title>
-	<meta name='creator' content='Mini-XML v2.2.3'/>
+	<meta name='creator' content='Mini-XML v2.3'/>
 	<style><!--
 	h1, h2, h3, p { font-family: sans-serif; text-align: justify; }
 	tt, pre a:link, pre a:visited, tt a:link, tt a:visited { font-weight: bold; color: #7f0000; }
 	pre { font-weight: bold; color: #7f0000; margin-left: 2em; }
+	span.info { font-weight: bold; font-style: italic; color: #ffffff; background: #000000; }
+	h3 span.info { float: right; }
 	--></style>
 </head>
 <body>
@@ -21,15 +23,15 @@
 <!-- NEW PAGE -->
 <h2><a name='_enumerations'>Enumerations</a></h2>
 <ul>
-	<li><a href='#ppd_conform_e'><tt>ppd_conform_e</tt></a></li>
-	<li><a href='#ppd_cs_e'><tt>ppd_cs_e</tt></a></li>
-	<li><a href='#ppd_ext_ui_e'><tt>ppd_ext_ui_e</tt></a></li>
-	<li><a href='#ppd_section_e'><tt>ppd_section_e</tt></a></li>
-	<li><a href='#ppd_status_e'><tt>ppd_status_e</tt></a></li>
-	<li><a href='#ppd_ui_e'><tt>ppd_ui_e</tt></a></li>
+	<li><a href='#ppd_conform_e'><tt>ppd_conform_e</tt></a> </li>
+	<li><a href='#ppd_cs_e'><tt>ppd_cs_e</tt></a> </li>
+	<li><a href='#ppd_ext_ui_e'><tt>ppd_ext_ui_e</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#ppd_section_e'><tt>ppd_section_e</tt></a> </li>
+	<li><a href='#ppd_status_e'><tt>ppd_status_e</tt></a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></li>
+	<li><a href='#ppd_ui_e'><tt>ppd_ui_e</tt></a> </li>
 </ul>
 <!-- NEW PAGE -->
-<h3><a name='ppd_conform_e'>ppd_conform_e</a></h3>
+<h3><a name='ppd_conform_e'>ppd_conform_e</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Conformance Levels</p>
@@ -37,11 +39,11 @@
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>PPD_CONFORM_RELAXED</tt></td><td>Relax whitespace and control char</td></tr>
-<tr><td><tt>PPD_CONFORM_STRICT</tt></td><td>Require strict conformance</td></tr>
+<tr><td><tt>PPD_CONFORM_RELAXED</tt> </td><td>Relax whitespace and control char</td></tr>
+<tr><td><tt>PPD_CONFORM_STRICT</tt> </td><td>Require strict conformance</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
-<h3><a name='ppd_cs_e'>ppd_cs_e</a></h3>
+<h3><a name='ppd_cs_e'>ppd_cs_e</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Colorspaces</p>
@@ -49,33 +51,33 @@
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>PPD_CS_CMY</tt></td><td>CMY colorspace</td></tr>
-<tr><td><tt>PPD_CS_CMYK</tt></td><td>CMYK colorspace</td></tr>
-<tr><td><tt>PPD_CS_GRAY</tt></td><td>Grayscale colorspace</td></tr>
-<tr><td><tt>PPD_CS_N</tt></td><td>DeviceN colorspace</td></tr>
-<tr><td><tt>PPD_CS_RGB</tt></td><td>RGB colorspace</td></tr>
-<tr><td><tt>PPD_CS_RGBK</tt></td><td>RGBK (K = gray) colorspace</td></tr>
+<tr><td><tt>PPD_CS_CMY</tt> </td><td>CMY colorspace</td></tr>
+<tr><td><tt>PPD_CS_CMYK</tt> </td><td>CMYK colorspace</td></tr>
+<tr><td><tt>PPD_CS_GRAY</tt> </td><td>Grayscale colorspace</td></tr>
+<tr><td><tt>PPD_CS_N</tt> </td><td>DeviceN colorspace</td></tr>
+<tr><td><tt>PPD_CS_RGB</tt> </td><td>RGB colorspace</td></tr>
+<tr><td><tt>PPD_CS_RGBK</tt> </td><td>RGBK (K = gray) colorspace</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
-<h3><a name='ppd_ext_ui_e'>ppd_ext_ui_e</a></h3>
+<h3><a name='ppd_ext_ui_e'>ppd_ext_ui_e</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Extended UI Types</p>
+<p>Extended UI Types </p>
 <h4>Values</h4>
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>PPD_UI_CUPS_CURVE</tt></td><td>Specify start, end, and gamma numbers</td></tr>
-<tr><td><tt>PPD_UI_CUPS_GAMMA</tt></td><td>Specify a gamma number</td></tr>
-<tr><td><tt>PPD_UI_CUPS_INTEGER</tt></td><td>Specify an integer number</td></tr>
-<tr><td><tt>PPD_UI_CUPS_INTEGER_ARRAY</tt></td><td>Specify an array of integer numbers</td></tr>
-<tr><td><tt>PPD_UI_CUPS_REAL</tt></td><td>Specify a real number</td></tr>
-<tr><td><tt>PPD_UI_CUPS_REAL_ARRAY</tt></td><td>Specify an array of real numbers</td></tr>
-<tr><td><tt>PPD_UI_CUPS_TEXT</tt></td><td>Specify a string</td></tr>
-<tr><td><tt>PPD_UI_CUPS_XY_ARRAY</tt></td><td>Specify an array of X/Y real numbers</td></tr>
+<tr><td><tt>PPD_UI_CUPS_CURVE</tt> </td><td>Specify start, end, and gamma numbers</td></tr>
+<tr><td><tt>PPD_UI_CUPS_GAMMA</tt> </td><td>Specify a gamma number</td></tr>
+<tr><td><tt>PPD_UI_CUPS_INTEGER</tt> </td><td>Specify an integer number</td></tr>
+<tr><td><tt>PPD_UI_CUPS_INTEGER_ARRAY</tt> </td><td>Specify an array of integer numbers</td></tr>
+<tr><td><tt>PPD_UI_CUPS_REAL</tt> </td><td>Specify a real number</td></tr>
+<tr><td><tt>PPD_UI_CUPS_REAL_ARRAY</tt> </td><td>Specify an array of real numbers</td></tr>
+<tr><td><tt>PPD_UI_CUPS_TEXT</tt> </td><td>Specify a string</td></tr>
+<tr><td><tt>PPD_UI_CUPS_XY_ARRAY</tt> </td><td>Specify an array of X/Y real numbers</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
-<h3><a name='ppd_section_e'>ppd_section_e</a></h3>
+<h3><a name='ppd_section_e'>ppd_section_e</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Order dependency sections</p>
@@ -83,45 +85,45 @@
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>PPD_ORDER_ANY</tt></td><td>Option code can be anywhere in the file</td></tr>
-<tr><td><tt>PPD_ORDER_DOCUMENT</tt></td><td>... must be in the DocumentSetup section</td></tr>
-<tr><td><tt>PPD_ORDER_EXIT</tt></td><td>... must be sent prior to the document</td></tr>
-<tr><td><tt>PPD_ORDER_JCL</tt></td><td>... must be sent as a JCL command</td></tr>
-<tr><td><tt>PPD_ORDER_PAGE</tt></td><td>... must be in the PageSetup section</td></tr>
-<tr><td><tt>PPD_ORDER_PROLOG</tt></td><td>... must be in the Prolog section</td></tr>
+<tr><td><tt>PPD_ORDER_ANY</tt> </td><td>Option code can be anywhere in the file</td></tr>
+<tr><td><tt>PPD_ORDER_DOCUMENT</tt> </td><td>... must be in the DocumentSetup section</td></tr>
+<tr><td><tt>PPD_ORDER_EXIT</tt> </td><td>... must be sent prior to the document</td></tr>
+<tr><td><tt>PPD_ORDER_JCL</tt> </td><td>... must be sent as a JCL command</td></tr>
+<tr><td><tt>PPD_ORDER_PAGE</tt> </td><td>... must be in the PageSetup section</td></tr>
+<tr><td><tt>PPD_ORDER_PROLOG</tt> </td><td>... must be in the Prolog section</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
-<h3><a name='ppd_status_e'>ppd_status_e</a></h3>
+<h3><a name='ppd_status_e'>ppd_status_e</a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Status Codes</p>
+<p>Status Codes </p>
 <h4>Values</h4>
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>PPD_ALLOC_ERROR</tt></td><td>Memory allocation error</td></tr>
-<tr><td><tt>PPD_BAD_OPEN_GROUP</tt></td><td>Bad OpenGroup</td></tr>
-<tr><td><tt>PPD_BAD_OPEN_UI</tt></td><td>Bad OpenUI/JCLOpenUI</td></tr>
-<tr><td><tt>PPD_BAD_ORDER_DEPENDENCY</tt></td><td>Bad OrderDependency</td></tr>
-<tr><td><tt>PPD_BAD_UI_CONSTRAINTS</tt></td><td>Bad UIConstraints</td></tr>
-<tr><td><tt>PPD_FILE_OPEN_ERROR</tt></td><td>Unable to open PPD file</td></tr>
-<tr><td><tt>PPD_ILLEGAL_CHARACTER</tt></td><td>Illegal control character</td></tr>
-<tr><td><tt>PPD_ILLEGAL_MAIN_KEYWORD</tt></td><td>Illegal main keyword string</td></tr>
-<tr><td><tt>PPD_ILLEGAL_OPTION_KEYWORD</tt></td><td>Illegal option keyword string</td></tr>
-<tr><td><tt>PPD_ILLEGAL_TRANSLATION</tt></td><td>Illegal translation string</td></tr>
-<tr><td><tt>PPD_ILLEGAL_WHITESPACE</tt></td><td>Illegal whitespace character</td></tr>
-<tr><td><tt>PPD_INTERNAL_ERROR</tt></td><td>Internal error</td></tr>
-<tr><td><tt>PPD_LINE_TOO_LONG</tt></td><td>Line longer than 255 chars</td></tr>
-<tr><td><tt>PPD_MISSING_ASTERISK</tt></td><td>Missing asterisk in column 0</td></tr>
-<tr><td><tt>PPD_MISSING_PPDADOBE4</tt></td><td>Missing PPD-Adobe-4.x header</td></tr>
-<tr><td><tt>PPD_MISSING_VALUE</tt></td><td>Missing value string</td></tr>
-<tr><td><tt>PPD_NESTED_OPEN_GROUP</tt></td><td>OpenGroup without a CloseGroup first</td></tr>
-<tr><td><tt>PPD_NESTED_OPEN_UI</tt></td><td>OpenUI/JCLOpenUI without a CloseUI/JCLCloseUI first</td></tr>
-<tr><td><tt>PPD_NULL_FILE</tt></td><td>NULL PPD file pointer</td></tr>
-<tr><td><tt>PPD_OK</tt></td><td>OK</td></tr>
+<tr><td><tt>PPD_ALLOC_ERROR</tt> </td><td>Memory allocation error</td></tr>
+<tr><td><tt>PPD_BAD_OPEN_GROUP</tt> </td><td>Bad OpenGroup</td></tr>
+<tr><td><tt>PPD_BAD_OPEN_UI</tt> </td><td>Bad OpenUI/JCLOpenUI</td></tr>
+<tr><td><tt>PPD_BAD_ORDER_DEPENDENCY</tt> </td><td>Bad OrderDependency</td></tr>
+<tr><td><tt>PPD_BAD_UI_CONSTRAINTS</tt> </td><td>Bad UIConstraints</td></tr>
+<tr><td><tt>PPD_FILE_OPEN_ERROR</tt> </td><td>Unable to open PPD file</td></tr>
+<tr><td><tt>PPD_ILLEGAL_CHARACTER</tt> </td><td>Illegal control character</td></tr>
+<tr><td><tt>PPD_ILLEGAL_MAIN_KEYWORD</tt> </td><td>Illegal main keyword string</td></tr>
+<tr><td><tt>PPD_ILLEGAL_OPTION_KEYWORD</tt> </td><td>Illegal option keyword string</td></tr>
+<tr><td><tt>PPD_ILLEGAL_TRANSLATION</tt> </td><td>Illegal translation string</td></tr>
+<tr><td><tt>PPD_ILLEGAL_WHITESPACE</tt> </td><td>Illegal whitespace character</td></tr>
+<tr><td><tt>PPD_INTERNAL_ERROR</tt> </td><td>Internal error</td></tr>
+<tr><td><tt>PPD_LINE_TOO_LONG</tt> </td><td>Line longer than 255 chars</td></tr>
+<tr><td><tt>PPD_MISSING_ASTERISK</tt> </td><td>Missing asterisk in column 0</td></tr>
+<tr><td><tt>PPD_MISSING_PPDADOBE4</tt> </td><td>Missing PPD-Adobe-4.x header</td></tr>
+<tr><td><tt>PPD_MISSING_VALUE</tt> </td><td>Missing value string</td></tr>
+<tr><td><tt>PPD_NESTED_OPEN_GROUP</tt> </td><td>OpenGroup without a CloseGroup first</td></tr>
+<tr><td><tt>PPD_NESTED_OPEN_UI</tt> </td><td>OpenUI/JCLOpenUI without a CloseUI/JCLCloseUI first</td></tr>
+<tr><td><tt>PPD_NULL_FILE</tt> </td><td>NULL PPD file pointer</td></tr>
+<tr><td><tt>PPD_OK</tt> </td><td>OK</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
-<h3><a name='ppd_ui_e'>ppd_ui_e</a></h3>
+<h3><a name='ppd_ui_e'>ppd_ui_e</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>UI Types</p>
@@ -129,41 +131,41 @@
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>PPD_UI_BOOLEAN</tt></td><td>True or False option</td></tr>
-<tr><td><tt>PPD_UI_PICKMANY</tt></td><td>Pick zero or more from a list</td></tr>
-<tr><td><tt>PPD_UI_PICKONE</tt></td><td>Pick one from a list</td></tr>
+<tr><td><tt>PPD_UI_BOOLEAN</tt> </td><td>True or False option</td></tr>
+<tr><td><tt>PPD_UI_PICKMANY</tt> </td><td>Pick zero or more from a list</td></tr>
+<tr><td><tt>PPD_UI_PICKONE</tt> </td><td>Pick one from a list</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
 <h2><a name='_functions'>Functions</a></h2>
 <ul>
-	<li><a href='#ppdClose'><tt>ppdClose()</tt></a></li>
-	<li><a href='#ppdCollect'><tt>ppdCollect()</tt></a></li>
-	<li><a href='#ppdConflicts'><tt>ppdConflicts()</tt></a></li>
-	<li><a href='#ppdEmit'><tt>ppdEmit()</tt></a></li>
-	<li><a href='#ppdEmitFd'><tt>ppdEmitFd()</tt></a></li>
-	<li><a href='#ppdEmitJCL'><tt>ppdEmitJCL()</tt></a></li>
-	<li><a href='#ppdEmitJCLEnd'><tt>ppdEmitJCLEnd()</tt></a></li>
-	<li><a href='#ppdErrorString'><tt>ppdErrorString()</tt></a></li>
-	<li><a href='#ppdFindAttr'><tt>ppdFindAttr()</tt></a></li>
-	<li><a href='#ppdFindChoice'><tt>ppdFindChoice()</tt></a></li>
-	<li><a href='#ppdFindMarkedChoice'><tt>ppdFindMarkedChoice()</tt></a></li>
-	<li><a href='#ppdFindNextAttr'><tt>ppdFindNextAttr()</tt></a></li>
-	<li><a href='#ppdFindOption'><tt>ppdFindOption()</tt></a></li>
-	<li><a href='#ppdIsMarked'><tt>ppdIsMarked()</tt></a></li>
-	<li><a href='#ppdLastError'><tt>ppdLastError()</tt></a></li>
-	<li><a href='#ppdMarkDefaults'><tt>ppdMarkDefaults()</tt></a></li>
-	<li><a href='#ppdMarkOption'><tt>ppdMarkOption()</tt></a></li>
-	<li><a href='#ppdOpen'><tt>ppdOpen()</tt></a></li>
-	<li><a href='#ppdOpen2'><tt>ppdOpen2()</tt></a></li>
-	<li><a href='#ppdOpenFd'><tt>ppdOpenFd()</tt></a></li>
-	<li><a href='#ppdOpenFile'><tt>ppdOpenFile()</tt></a></li>
-	<li><a href='#ppdPageLength'><tt>ppdPageLength()</tt></a></li>
-	<li><a href='#ppdPageSize'><tt>ppdPageSize()</tt></a></li>
-	<li><a href='#ppdPageWidth'><tt>ppdPageWidth()</tt></a></li>
-	<li><a href='#ppdSetConformance'><tt>ppdSetConformance()</tt></a></li>
+	<li><a href='#ppdClose'><tt>ppdClose()</tt></a> </li>
+	<li><a href='#ppdCollect'><tt>ppdCollect()</tt></a> </li>
+	<li><a href='#ppdConflicts'><tt>ppdConflicts()</tt></a> </li>
+	<li><a href='#ppdEmit'><tt>ppdEmit()</tt></a> </li>
+	<li><a href='#ppdEmitFd'><tt>ppdEmitFd()</tt></a> </li>
+	<li><a href='#ppdEmitJCL'><tt>ppdEmitJCL()</tt></a> </li>
+	<li><a href='#ppdEmitJCLEnd'><tt>ppdEmitJCLEnd()</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#ppdErrorString'><tt>ppdErrorString()</tt></a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></li>
+	<li><a href='#ppdFindAttr'><tt>ppdFindAttr()</tt></a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></li>
+	<li><a href='#ppdFindChoice'><tt>ppdFindChoice()</tt></a> </li>
+	<li><a href='#ppdFindMarkedChoice'><tt>ppdFindMarkedChoice()</tt></a> </li>
+	<li><a href='#ppdFindNextAttr'><tt>ppdFindNextAttr()</tt></a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></li>
+	<li><a href='#ppdFindOption'><tt>ppdFindOption()</tt></a> </li>
+	<li><a href='#ppdIsMarked'><tt>ppdIsMarked()</tt></a> </li>
+	<li><a href='#ppdLastError'><tt>ppdLastError()</tt></a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></li>
+	<li><a href='#ppdMarkDefaults'><tt>ppdMarkDefaults()</tt></a> </li>
+	<li><a href='#ppdMarkOption'><tt>ppdMarkOption()</tt></a> </li>
+	<li><a href='#ppdOpen'><tt>ppdOpen()</tt></a> </li>
+	<li><a href='#ppdOpen2'><tt>ppdOpen2()</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#ppdOpenFd'><tt>ppdOpenFd()</tt></a> </li>
+	<li><a href='#ppdOpenFile'><tt>ppdOpenFile()</tt></a> </li>
+	<li><a href='#ppdPageLength'><tt>ppdPageLength()</tt></a> </li>
+	<li><a href='#ppdPageSize'><tt>ppdPageSize()</tt></a> </li>
+	<li><a href='#ppdPageWidth'><tt>ppdPageWidth()</tt></a> </li>
+	<li><a href='#ppdSetConformance'><tt>ppdSetConformance()</tt></a> <span class='info'>&nbsp;CUPS 1.1.20&nbsp;</span></li>
 </ul>
 <!-- NEW PAGE -->
-<h3><a name='ppdClose'>ppdClose()</a></h3>
+<h3><a name='ppdClose'>ppdClose()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Free all memory used by the PPD file.</p>
@@ -182,7 +184,7 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdCollect'>ppdCollect()</a></h3>
+<h3><a name='ppdCollect'>ppdCollect()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Collect all marked options that reside in the specified
@@ -206,7 +208,7 @@
 <h4>Returns</h4>
 <p>Number of options marked</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdConflicts'>ppdConflicts()</a></h3>
+<h3><a name='ppdConflicts'>ppdConflicts()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Check to see if there are any conflicts.</p>
@@ -225,7 +227,7 @@
 <h4>Returns</h4>
 <p>Number of conflicts found</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdEmit'>ppdEmit()</a></h3>
+<h3><a name='ppdEmit'>ppdEmit()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Emit code for marked options to a file.</p>
@@ -248,7 +250,7 @@
 <h4>Returns</h4>
 <p>0 on success, -1 on failure</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdEmitFd'>ppdEmitFd()</a></h3>
+<h3><a name='ppdEmitFd'>ppdEmitFd()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Emit code for marked options to a file.</p>
@@ -271,7 +273,7 @@
 <h4>Returns</h4>
 <p>0 on success, -1 on failure</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdEmitJCL'>ppdEmitJCL()</a></h3>
+<h3><a name='ppdEmitJCL'>ppdEmitJCL()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Emit code for JCL options to a file.</p>
@@ -298,10 +300,12 @@
 <h4>Returns</h4>
 <p>0 on success, -1 on failure</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdEmitJCLEnd'>ppdEmitJCLEnd()</a></h3>
+<h3><a name='ppdEmitJCLEnd'>ppdEmitJCLEnd()</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Emit JCLEnd code to a file.</p>
+<p>Emit JCLEnd code to a file.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 int
@@ -319,10 +323,12 @@
 <h4>Returns</h4>
 <p>0 on success, -1 on failure</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdErrorString'>ppdErrorString()</a></h3>
+<h3><a name='ppdErrorString'>ppdErrorString()</a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Returns the text assocated with a status.</p>
+<p>Returns the text assocated with a status.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 const char *
@@ -338,10 +344,12 @@
 <h4>Returns</h4>
 <p>Status string</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdFindAttr'>ppdFindAttr()</a></h3>
+<h3><a name='ppdFindAttr'>ppdFindAttr()</a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Find the first matching attribute...</p>
+<p>Find the first matching attribute...
+
+</p>
 <h4>Syntax</h4>
 <pre>
 <a href='#ppd_attr_t'>ppd_attr_t</a> *
@@ -361,7 +369,7 @@
 <h4>Returns</h4>
 <p>Attribute or NULL if not found</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdFindChoice'>ppdFindChoice()</a></h3>
+<h3><a name='ppdFindChoice'>ppdFindChoice()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Return a pointer to an option choice.</p>
@@ -382,7 +390,7 @@
 <h4>Returns</h4>
 <p>Choice pointer or NULL</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdFindMarkedChoice'>ppdFindMarkedChoice()</a></h3>
+<h3><a name='ppdFindMarkedChoice'>ppdFindMarkedChoice()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Return the marked choice for the specified option.</p>
@@ -403,10 +411,12 @@
 <h4>Returns</h4>
 <p>Pointer to choice or NULL</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdFindNextAttr'>ppdFindNextAttr()</a></h3>
+<h3><a name='ppdFindNextAttr'>ppdFindNextAttr()</a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Find the next matching attribute...</p>
+<p>Find the next matching attribute...
+
+</p>
 <h4>Syntax</h4>
 <pre>
 <a href='#ppd_attr_t'>ppd_attr_t</a> *
@@ -426,7 +436,7 @@
 <h4>Returns</h4>
 <p>Attribute or NULL if not found</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdFindOption'>ppdFindOption()</a></h3>
+<h3><a name='ppdFindOption'>ppdFindOption()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Return a pointer to the specified option.</p>
@@ -447,7 +457,7 @@
 <h4>Returns</h4>
 <p>Pointer to option or NULL</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdIsMarked'>ppdIsMarked()</a></h3>
+<h3><a name='ppdIsMarked'>ppdIsMarked()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Check to see if an option is marked...</p>
@@ -470,10 +480,12 @@
 <h4>Returns</h4>
 <p>Non-zero if option is marked</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdLastError'>ppdLastError()</a></h3>
+<h3><a name='ppdLastError'>ppdLastError()</a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Return the status from the last ppdOpen*().</p>
+<p>Return the status from the last ppdOpen*().
+
+</p>
 <h4>Syntax</h4>
 <pre>
 ppd_status_t
@@ -489,7 +501,7 @@
 <h4>Returns</h4>
 <p>Status code</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdMarkDefaults'>ppdMarkDefaults()</a></h3>
+<h3><a name='ppdMarkDefaults'>ppdMarkDefaults()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Mark all default options in the PPD file.</p>
@@ -508,7 +520,7 @@
 <h4>Returns</h4>
 <p>Nothing.</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdMarkOption'>ppdMarkOption()</a></h3>
+<h3><a name='ppdMarkOption'>ppdMarkOption()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Mark an option in a PPD file.
@@ -536,7 +548,7 @@
 <h4>Returns</h4>
 <p>Number of conflicts</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdOpen'>ppdOpen()</a></h3>
+<h3><a name='ppdOpen'>ppdOpen()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Read a PPD file into memory.</p>
@@ -555,10 +567,12 @@
 <h4>Returns</h4>
 <p>PPD file record</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdOpen2'>ppdOpen2()</a></h3>
+<h3><a name='ppdOpen2'>ppdOpen2()</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Read a PPD file into memory.</p>
+<p>Read a PPD file into memory.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 <a href='#ppd_file_t'>ppd_file_t</a> *
@@ -574,7 +588,7 @@
 <h4>Returns</h4>
 <p>PPD file record</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdOpenFd'>ppdOpenFd()</a></h3>
+<h3><a name='ppdOpenFd'>ppdOpenFd()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Read a PPD file into memory.</p>
@@ -593,7 +607,7 @@
 <h4>Returns</h4>
 <p>PPD file record</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdOpenFile'>ppdOpenFile()</a></h3>
+<h3><a name='ppdOpenFile'>ppdOpenFile()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Read a PPD file into memory.</p>
@@ -612,7 +626,7 @@
 <h4>Returns</h4>
 <p>PPD file record</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdPageLength'>ppdPageLength()</a></h3>
+<h3><a name='ppdPageLength'>ppdPageLength()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get the page length for the given size.</p>
@@ -633,7 +647,7 @@
 <h4>Returns</h4>
 <p>Length of page in points or 0.0</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdPageSize'>ppdPageSize()</a></h3>
+<h3><a name='ppdPageSize'>ppdPageSize()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get the page size record for the given size.</p>
@@ -654,7 +668,7 @@
 <h4>Returns</h4>
 <p>Size record for page or NULL</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdPageWidth'>ppdPageWidth()</a></h3>
+<h3><a name='ppdPageWidth'>ppdPageWidth()</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Get the page width for the given size.</p>
@@ -675,10 +689,12 @@
 <h4>Returns</h4>
 <p>Width of page in points or 0.0</p>
 <!-- NEW PAGE -->
-<h3><a name='ppdSetConformance'>ppdSetConformance()</a></h3>
+<h3><a name='ppdSetConformance'>ppdSetConformance()</a> <span class='info'>&nbsp;CUPS 1.1.20&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Set the conformance level for PPD files.</p>
+<p>Set the conformance level for PPD files.
+
+</p>
 <h4>Syntax</h4>
 <pre>
 void
@@ -696,22 +712,22 @@
 <!-- NEW PAGE -->
 <h2><a name='_structures'>Structures</a></h2>
 <ul>
-	<li><a href='#ppd_attr_str'><tt>ppd_attr_str</tt></a></li>
-	<li><a href='#ppd_choice_str'><tt>ppd_choice_str</tt></a></li>
-	<li><a href='#ppd_emul_str'><tt>ppd_emul_str</tt></a></li>
-	<li><a href='#ppd_ext_option_str'><tt>ppd_ext_option_str</tt></a></li>
-	<li><a href='#ppd_ext_param_str'><tt>ppd_ext_param_str</tt></a></li>
-	<li><a href='#ppd_file_str'><tt>ppd_file_str</tt></a></li>
-	<li><a href='#ppd_group_str'><tt>ppd_group_str</tt></a></li>
-	<li><a href='#ppd_option_str'><tt>ppd_option_str</tt></a></li>
-	<li><a href='#ppd_profile_str'><tt>ppd_profile_str</tt></a></li>
-	<li><a href='#ppd_size_str'><tt>ppd_size_str</tt></a></li>
+	<li><a href='#ppd_attr_str'><tt>ppd_attr_str</tt></a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></li>
+	<li><a href='#ppd_choice_str'><tt>ppd_choice_str</tt></a> </li>
+	<li><a href='#ppd_emul_str'><tt>ppd_emul_str</tt></a> </li>
+	<li><a href='#ppd_ext_option_str'><tt>ppd_ext_option_str</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#ppd_ext_param_str'><tt>ppd_ext_param_str</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#ppd_file_str'><tt>ppd_file_str</tt></a> </li>
+	<li><a href='#ppd_group_str'><tt>ppd_group_str</tt></a> </li>
+	<li><a href='#ppd_option_str'><tt>ppd_option_str</tt></a> </li>
+	<li><a href='#ppd_profile_str'><tt>ppd_profile_str</tt></a> </li>
+	<li><a href='#ppd_size_str'><tt>ppd_size_str</tt></a> </li>
 </ul>
 <!-- NEW PAGE -->
-<h3><a name='ppd_attr_str'>ppd_attr_str</a></h3>
+<h3><a name='ppd_attr_str'>ppd_attr_str</a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>PPD Attribute Structure</p>
+<p>PPD Attribute Structure </p>
 <h4>Definition</h4>
 <pre>
 struct ppd_attr_str
@@ -726,13 +742,13 @@
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>name[PPD_MAX_NAME]</tt></td><td>Name of attribute (cupsXYZ)</td></tr>
-<tr><td><tt>spec[PPD_MAX_NAME]</tt></td><td>Specifier string, if any</td></tr>
-<tr><td><tt>text[PPD_MAX_TEXT]</tt></td><td>Human-readable text, if any</td></tr>
-<tr><td><tt>value</tt></td><td>Value string</td></tr>
+<tr><td><tt>name[PPD_MAX_NAME]</tt> </td><td>Name of attribute (cupsXYZ)</td></tr>
+<tr><td><tt>spec[PPD_MAX_NAME]</tt> </td><td>Specifier string, if any</td></tr>
+<tr><td><tt>text[PPD_MAX_TEXT]</tt> </td><td>Human-readable text, if any</td></tr>
+<tr><td><tt>value</tt> </td><td>Value string</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
-<h3><a name='ppd_choice_str'>ppd_choice_str</a></h3>
+<h3><a name='ppd_choice_str'>ppd_choice_str</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Option choices</p>
@@ -751,14 +767,14 @@
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>choice[PPD_MAX_NAME]</tt></td><td>Computer-readable option name</td></tr>
-<tr><td><tt>code</tt></td><td>Code to send for this option</td></tr>
-<tr><td><tt>marked</tt></td><td>0 if not selected, 1 otherwise</td></tr>
-<tr><td><tt>option</tt></td><td>Pointer to parent option structure</td></tr>
-<tr><td><tt>text[PPD_MAX_TEXT]</tt></td><td>Human-readable option name</td></tr>
+<tr><td><tt>choice[PPD_MAX_NAME]</tt> </td><td>Computer-readable option name</td></tr>
+<tr><td><tt>code</tt> </td><td>Code to send for this option</td></tr>
+<tr><td><tt>marked</tt> </td><td>0 if not selected, 1 otherwise</td></tr>
+<tr><td><tt>option</tt> </td><td>Pointer to parent option structure</td></tr>
+<tr><td><tt>text[PPD_MAX_TEXT]</tt> </td><td>Human-readable option name</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
-<h3><a name='ppd_emul_str'>ppd_emul_str</a></h3>
+<h3><a name='ppd_emul_str'>ppd_emul_str</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Emulators</p>
@@ -775,15 +791,15 @@
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>name[PPD_MAX_NAME]</tt></td><td>Emulator name</td></tr>
-<tr><td><tt>start</tt></td><td>Code to switch to this emulation</td></tr>
-<tr><td><tt>stop</tt></td><td>Code to stop this emulation</td></tr>
+<tr><td><tt>name[PPD_MAX_NAME]</tt> </td><td>Emulator name</td></tr>
+<tr><td><tt>start</tt> </td><td>Code to switch to this emulation</td></tr>
+<tr><td><tt>stop</tt> </td><td>Code to stop this emulation</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
-<h3><a name='ppd_ext_option_str'>ppd_ext_option_str</a></h3>
+<h3><a name='ppd_ext_option_str'>ppd_ext_option_str</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Extended Options</p>
+<p>Extended Options </p>
 <h4>Definition</h4>
 <pre>
 struct ppd_ext_option_str
@@ -800,18 +816,18 @@
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>code</tt></td><td>Generic PS code for extended options</td></tr>
-<tr><td><tt>keyword[PPD_MAX_NAME]</tt></td><td>Name of option that is being extended...</td></tr>
-<tr><td><tt>marked</tt></td><td>Extended option is marked</td></tr>
-<tr><td><tt>num_params</tt></td><td>Number of parameters</td></tr>
-<tr><td><tt>option</tt></td><td>Option that is being extended...</td></tr>
-<tr><td><tt>params</tt></td><td>Parameters</td></tr>
+<tr><td><tt>code</tt> </td><td>Generic PS code for extended options</td></tr>
+<tr><td><tt>keyword[PPD_MAX_NAME]</tt> </td><td>Name of option that is being extended...</td></tr>
+<tr><td><tt>marked</tt> </td><td>Extended option is marked</td></tr>
+<tr><td><tt>num_params</tt> </td><td>Number of parameters</td></tr>
+<tr><td><tt>option</tt> </td><td>Option that is being extended...</td></tr>
+<tr><td><tt>params</tt> </td><td>Parameters</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
-<h3><a name='ppd_ext_param_str'>ppd_ext_param_str</a></h3>
+<h3><a name='ppd_ext_param_str'>ppd_ext_param_str</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Extended Parameter</p>
+<p>Extended Parameter </p>
 <h4>Definition</h4>
 <pre>
 struct ppd_ext_param_str
@@ -828,15 +844,15 @@
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>defval</tt></td><td>Default values</td></tr>
-<tr><td><tt>keyword[PPD_MAX_NAME]</tt></td><td>Parameter name</td></tr>
-<tr><td><tt>maxval</tt></td><td>Maximum numeric values</td></tr>
-<tr><td><tt>minval</tt></td><td>Minimum numeric values</td></tr>
-<tr><td><tt>text[PPD_MAX_TEXT]</tt></td><td>Human-readable text</td></tr>
-<tr><td><tt>value</tt></td><td>Current values</td></tr>
+<tr><td><tt>defval</tt> </td><td>Default values</td></tr>
+<tr><td><tt>keyword[PPD_MAX_NAME]</tt> </td><td>Parameter name</td></tr>
+<tr><td><tt>maxval</tt> </td><td>Maximum numeric values</td></tr>
+<tr><td><tt>minval</tt> </td><td>Minimum numeric values</td></tr>
+<tr><td><tt>text[PPD_MAX_TEXT]</tt> </td><td>Human-readable text</td></tr>
+<tr><td><tt>value</tt> </td><td>Current values</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
-<h3><a name='ppd_file_str'>ppd_file_str</a></h3>
+<h3><a name='ppd_file_str'>ppd_file_str</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Files</p>
@@ -897,56 +913,56 @@
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>accurate_screens</tt></td><td>1 = supports accurate screens, 0 = not</td></tr>
-<tr><td><tt>attrs</tt></td><td>Attributes</td></tr>
-<tr><td><tt>color_device</tt></td><td>1 = color device, 0 = grayscale</td></tr>
-<tr><td><tt>colorspace</tt></td><td>Default colorspace</td></tr>
-<tr><td><tt>consts</tt></td><td>UI/Non-UI constraints</td></tr>
-<tr><td><tt>contone_only</tt></td><td>1 = continuous tone only, 0 = not</td></tr>
-<tr><td><tt>cur_attr</tt></td><td>Current attribute</td></tr>
-<tr><td><tt>custom_margins[4]</tt></td><td>Margins around page</td></tr>
-<tr><td><tt>custom_max[2]</tt></td><td>Maximum variable page size</td></tr>
-<tr><td><tt>custom_min[2]</tt></td><td>Minimum variable page size</td></tr>
-<tr><td><tt>emulations</tt></td><td>Emulations and the code to invoke them</td></tr>
-<tr><td><tt>extended</tt></td><td>Extended options</td></tr>
-<tr><td><tt>filters</tt></td><td>Filter strings...</td></tr>
-<tr><td><tt>flip_duplex</tt></td><td>1 = Flip page for back sides</td></tr>
-<tr><td><tt>fonts</tt></td><td>Pre-loaded fonts</td></tr>
-<tr><td><tt>groups</tt></td><td>UI groups</td></tr>
-<tr><td><tt>jcl_begin</tt></td><td>Start JCL commands</td></tr>
-<tr><td><tt>jcl_end</tt></td><td>End JCL commands</td></tr>
-<tr><td><tt>jcl_ps</tt></td><td>Enter PostScript interpreter</td></tr>
-<tr><td><tt>landscape</tt></td><td>-90 or 90</td></tr>
-<tr><td><tt>lang_encoding</tt></td><td>Language encoding</td></tr>
-<tr><td><tt>lang_version</tt></td><td>Language version (English, Spanish, etc.)</td></tr>
-<tr><td><tt>language_level</tt></td><td>Language level of device</td></tr>
-<tr><td><tt>manual_copies</tt></td><td>1 = Copies done manually, 0 = hardware</td></tr>
-<tr><td><tt>manufacturer</tt></td><td>Manufacturer name</td></tr>
-<tr><td><tt>model_number</tt></td><td>Device-specific model number</td></tr>
-<tr><td><tt>modelname</tt></td><td>Model name (general)</td></tr>
-<tr><td><tt>nickname</tt></td><td>Nickname (specific)</td></tr>
-<tr><td><tt>num_attrs</tt></td><td>Number of attributes</td></tr>
-<tr><td><tt>num_consts</tt></td><td>Number of UI/Non-UI constraints</td></tr>
-<tr><td><tt>num_emulations</tt></td><td>Number of emulations supported</td></tr>
-<tr><td><tt>num_extended</tt></td><td>Number of extended options</td></tr>
-<tr><td><tt>num_filters</tt></td><td>Number of filters</td></tr>
-<tr><td><tt>num_fonts</tt></td><td>Number of pre-loaded fonts</td></tr>
-<tr><td><tt>num_groups</tt></td><td>Number of UI groups</td></tr>
-<tr><td><tt>num_profiles</tt></td><td>Number of sRGB color profiles</td></tr>
-<tr><td><tt>num_sizes</tt></td><td>Number of page sizes</td></tr>
-<tr><td><tt>patches</tt></td><td>Patch commands to be sent to printer</td></tr>
-<tr><td><tt>pcfilename</tt></td><td>PCFileName string</td></tr>
-<tr><td><tt>product</tt></td><td>Product name (from PS RIP/interpreter)</td></tr>
-<tr><td><tt>profiles</tt></td><td>sRGB color profiles</td></tr>
-<tr><td><tt>protocols</tt></td><td>Protocols (BCP, TBCP) string</td></tr>
-<tr><td><tt>shortnickname</tt></td><td>Short version of nickname</td></tr>
-<tr><td><tt>sizes</tt></td><td>Page sizes</td></tr>
-<tr><td><tt>throughput</tt></td><td>Pages per minute</td></tr>
-<tr><td><tt>ttrasterizer</tt></td><td>Truetype rasterizer</td></tr>
-<tr><td><tt>variable_sizes</tt></td><td>1 = supports variable sizes, 0 = doesn't</td></tr>
+<tr><td><tt>accurate_screens</tt> </td><td>1 = supports accurate screens, 0 = not</td></tr>
+<tr><td><tt>attrs</tt> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></td><td>Attributes </td></tr>
+<tr><td><tt>color_device</tt> </td><td>1 = color device, 0 = grayscale</td></tr>
+<tr><td><tt>colorspace</tt> </td><td>Default colorspace</td></tr>
+<tr><td><tt>consts</tt> </td><td>UI/Non-UI constraints</td></tr>
+<tr><td><tt>contone_only</tt> </td><td>1 = continuous tone only, 0 = not</td></tr>
+<tr><td><tt>cur_attr</tt> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></td><td>Current attribute </td></tr>
+<tr><td><tt>custom_margins[4]</tt> </td><td>Margins around page</td></tr>
+<tr><td><tt>custom_max[2]</tt> </td><td>Maximum variable page size</td></tr>
+<tr><td><tt>custom_min[2]</tt> </td><td>Minimum variable page size</td></tr>
+<tr><td><tt>emulations</tt> </td><td>Emulations and the code to invoke them</td></tr>
+<tr><td><tt>extended</tt> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></td><td>Extended options </td></tr>
+<tr><td><tt>filters</tt> </td><td>Filter strings...</td></tr>
+<tr><td><tt>flip_duplex</tt> <span class='info'>&nbsp;CUPS 1.1&nbsp;</span></td><td>1 = Flip page for back sides </td></tr>
+<tr><td><tt>fonts</tt> </td><td>Pre-loaded fonts</td></tr>
+<tr><td><tt>groups</tt> </td><td>UI groups</td></tr>
+<tr><td><tt>jcl_begin</tt> </td><td>Start JCL commands</td></tr>
+<tr><td><tt>jcl_end</tt> </td><td>End JCL commands</td></tr>
+<tr><td><tt>jcl_ps</tt> </td><td>Enter PostScript interpreter</td></tr>
+<tr><td><tt>landscape</tt> </td><td>-90 or 90</td></tr>
+<tr><td><tt>lang_encoding</tt> </td><td>Language encoding</td></tr>
+<tr><td><tt>lang_version</tt> </td><td>Language version (English, Spanish, etc.)</td></tr>
+<tr><td><tt>language_level</tt> </td><td>Language level of device</td></tr>
+<tr><td><tt>manual_copies</tt> </td><td>1 = Copies done manually, 0 = hardware</td></tr>
+<tr><td><tt>manufacturer</tt> </td><td>Manufacturer name</td></tr>
+<tr><td><tt>model_number</tt> </td><td>Device-specific model number</td></tr>
+<tr><td><tt>modelname</tt> </td><td>Model name (general)</td></tr>
+<tr><td><tt>nickname</tt> </td><td>Nickname (specific)</td></tr>
+<tr><td><tt>num_attrs</tt> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></td><td>Number of attributes </td></tr>
+<tr><td><tt>num_consts</tt> </td><td>Number of UI/Non-UI constraints</td></tr>
+<tr><td><tt>num_emulations</tt> </td><td>Number of emulations supported</td></tr>
+<tr><td><tt>num_extended</tt> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></td><td>Number of extended options </td></tr>
+<tr><td><tt>num_filters</tt> </td><td>Number of filters</td></tr>
+<tr><td><tt>num_fonts</tt> </td><td>Number of pre-loaded fonts</td></tr>
+<tr><td><tt>num_groups</tt> </td><td>Number of UI groups</td></tr>
+<tr><td><tt>num_profiles</tt> </td><td>Number of sRGB color profiles</td></tr>
+<tr><td><tt>num_sizes</tt> </td><td>Number of page sizes</td></tr>
+<tr><td><tt>patches</tt> </td><td>Patch commands to be sent to printer</td></tr>
+<tr><td><tt>pcfilename</tt> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></td><td>PCFileName string </td></tr>
+<tr><td><tt>product</tt> </td><td>Product name (from PS RIP/interpreter)</td></tr>
+<tr><td><tt>profiles</tt> </td><td>sRGB color profiles</td></tr>
+<tr><td><tt>protocols</tt> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></td><td>Protocols (BCP, TBCP) string </td></tr>
+<tr><td><tt>shortnickname</tt> </td><td>Short version of nickname</td></tr>
+<tr><td><tt>sizes</tt> </td><td>Page sizes</td></tr>
+<tr><td><tt>throughput</tt> </td><td>Pages per minute</td></tr>
+<tr><td><tt>ttrasterizer</tt> </td><td>Truetype rasterizer</td></tr>
+<tr><td><tt>variable_sizes</tt> </td><td>1 = supports variable sizes, 0 = doesn't</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
-<h3><a name='ppd_group_str'>ppd_group_str</a></h3>
+<h3><a name='ppd_group_str'>ppd_group_str</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Groups</p>
@@ -966,15 +982,15 @@
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>PPD_MAX_NAME]</tt></td><td>Human-readable group name</td></tr>
-<tr><td><tt>name[PPD_MAX_NAME]</tt></td><td>Group name</td></tr>
-<tr><td><tt>num_options</tt></td><td>Number of options</td></tr>
-<tr><td><tt>num_subgroups</tt></td><td>Number of sub-groups</td></tr>
-<tr><td><tt>options</tt></td><td>Options</td></tr>
-<tr><td><tt>subgroups</tt></td><td>Sub-groups (max depth = 1)</td></tr>
+<tr><td><tt>PPD_MAX_NAME]</tt> </td><td>Human-readable group name</td></tr>
+<tr><td><tt>name[PPD_MAX_NAME]</tt> <span class='info'>&nbsp;CUPS 1.1.18&nbsp;</span></td><td>Group name </td></tr>
+<tr><td><tt>num_options</tt> </td><td>Number of options</td></tr>
+<tr><td><tt>num_subgroups</tt> </td><td>Number of sub-groups</td></tr>
+<tr><td><tt>options</tt> </td><td>Options</td></tr>
+<tr><td><tt>subgroups</tt> </td><td>Sub-groups (max depth = 1)</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
-<h3><a name='ppd_option_str'>ppd_option_str</a></h3>
+<h3><a name='ppd_option_str'>ppd_option_str</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Options</p>
@@ -997,18 +1013,18 @@
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>choices</tt></td><td>Option choices</td></tr>
-<tr><td><tt>conflicted</tt></td><td>0 if no conflicts exist, 1 otherwise</td></tr>
-<tr><td><tt>defchoice[PPD_MAX_NAME]</tt></td><td>Default option choice</td></tr>
-<tr><td><tt>keyword[PPD_MAX_NAME]</tt></td><td>Option keyword name (&quot;PageSize&quot;, etc.)</td></tr>
-<tr><td><tt>num_choices</tt></td><td>Number of option choices</td></tr>
-<tr><td><tt>order</tt></td><td>Order number</td></tr>
-<tr><td><tt>section</tt></td><td>Section for command</td></tr>
-<tr><td><tt>text[PPD_MAX_TEXT]</tt></td><td>Human-readable text</td></tr>
-<tr><td><tt>ui</tt></td><td>Type of UI option</td></tr>
+<tr><td><tt>choices</tt> </td><td>Option choices</td></tr>
+<tr><td><tt>conflicted</tt> </td><td>0 if no conflicts exist, 1 otherwise</td></tr>
+<tr><td><tt>defchoice[PPD_MAX_NAME]</tt> </td><td>Default option choice</td></tr>
+<tr><td><tt>keyword[PPD_MAX_NAME]</tt> </td><td>Option keyword name (&quot;PageSize&quot;, etc.)</td></tr>
+<tr><td><tt>num_choices</tt> </td><td>Number of option choices</td></tr>
+<tr><td><tt>order</tt> </td><td>Order number</td></tr>
+<tr><td><tt>section</tt> </td><td>Section for command</td></tr>
+<tr><td><tt>text[PPD_MAX_TEXT]</tt> </td><td>Human-readable text</td></tr>
+<tr><td><tt>ui</tt> </td><td>Type of UI option</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
-<h3><a name='ppd_profile_str'>ppd_profile_str</a></h3>
+<h3><a name='ppd_profile_str'>ppd_profile_str</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>sRGB Color Profiles</p>
@@ -1027,14 +1043,14 @@
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>density</tt></td><td>Ink density to use</td></tr>
-<tr><td><tt>gamma</tt></td><td>Gamma correction to use</td></tr>
-<tr><td><tt>matrix[3][3]</tt></td><td>Transform matrix</td></tr>
-<tr><td><tt>media_type[PPD_MAX_NAME]</tt></td><td>Media type of &quot;-&quot;</td></tr>
-<tr><td><tt>resolution[PPD_MAX_NAME]</tt></td><td>Resolution or &quot;-&quot;</td></tr>
+<tr><td><tt>density</tt> </td><td>Ink density to use</td></tr>
+<tr><td><tt>gamma</tt> </td><td>Gamma correction to use</td></tr>
+<tr><td><tt>matrix[3][3]</tt> </td><td>Transform matrix</td></tr>
+<tr><td><tt>media_type[PPD_MAX_NAME]</tt> </td><td>Media type of &quot;-&quot;</td></tr>
+<tr><td><tt>resolution[PPD_MAX_NAME]</tt> </td><td>Resolution or &quot;-&quot;</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
-<h3><a name='ppd_size_str'>ppd_size_str</a></h3>
+<h3><a name='ppd_size_str'>ppd_size_str</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Page Sizes</p>
@@ -1056,46 +1072,46 @@
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>bottom</tt></td><td>Bottom printable margin in points</td></tr>
-<tr><td><tt>left</tt></td><td>Left printable margin in points</td></tr>
-<tr><td><tt>length</tt></td><td>Length of media in points</td></tr>
-<tr><td><tt>marked</tt></td><td>Page size selected?</td></tr>
-<tr><td><tt>name[PPD_MAX_NAME]</tt></td><td>Media size option</td></tr>
-<tr><td><tt>right</tt></td><td>Right printable margin in points</td></tr>
-<tr><td><tt>top</tt></td><td>Top printable margin in points</td></tr>
-<tr><td><tt>width</tt></td><td>Width of media in points</td></tr>
+<tr><td><tt>bottom</tt> </td><td>Bottom printable margin in points</td></tr>
+<tr><td><tt>left</tt> </td><td>Left printable margin in points</td></tr>
+<tr><td><tt>length</tt> </td><td>Length of media in points</td></tr>
+<tr><td><tt>marked</tt> </td><td>Page size selected?</td></tr>
+<tr><td><tt>name[PPD_MAX_NAME]</tt> </td><td>Media size option</td></tr>
+<tr><td><tt>right</tt> </td><td>Right printable margin in points</td></tr>
+<tr><td><tt>top</tt> </td><td>Top printable margin in points</td></tr>
+<tr><td><tt>width</tt> </td><td>Width of media in points</td></tr>
 </tbody></table></p>
 <!-- NEW PAGE -->
 <h2><a name='_types'>Types</a></h2>
 <ul>
-	<li><a href='#ppd_attr_t'><tt>ppd_attr_t</tt></a></li>
-	<li><a href='#ppd_choice_t'><tt>ppd_choice_t</tt></a></li>
-	<li><a href='#ppd_conform_t'><tt>ppd_conform_t</tt></a></li>
-	<li><a href='#ppd_const_t'><tt>ppd_const_t</tt></a></li>
-	<li><a href='#ppd_emul_t'><tt>ppd_emul_t</tt></a></li>
-	<li><a href='#ppd_ext_option_t'><tt>ppd_ext_option_t</tt></a></li>
-	<li><a href='#ppd_ext_param_t'><tt>ppd_ext_param_t</tt></a></li>
-	<li><a href='#ppd_ext_ui_t'><tt>ppd_ext_ui_t</tt></a></li>
-	<li><a href='#ppd_ext_value_t'><tt>ppd_ext_value_t</tt></a></li>
-	<li><a href='#ppd_file_t'><tt>ppd_file_t</tt></a></li>
-	<li><a href='#ppd_group_t'><tt>ppd_group_t</tt></a></li>
-	<li><a href='#ppd_option_t'><tt>ppd_option_t</tt></a></li>
-	<li><a href='#ppd_profile_t'><tt>ppd_profile_t</tt></a></li>
-	<li><a href='#ppd_section_t'><tt>ppd_section_t</tt></a></li>
-	<li><a href='#ppd_size_t'><tt>ppd_size_t</tt></a></li>
-	<li><a href='#ppd_ui_t'><tt>ppd_ui_t</tt></a></li>
+	<li><a href='#ppd_attr_t'><tt>ppd_attr_t</tt></a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></li>
+	<li><a href='#ppd_choice_t'><tt>ppd_choice_t</tt></a> </li>
+	<li><a href='#ppd_conform_t'><tt>ppd_conform_t</tt></a> </li>
+	<li><a href='#ppd_const_t'><tt>ppd_const_t</tt></a> </li>
+	<li><a href='#ppd_emul_t'><tt>ppd_emul_t</tt></a> </li>
+	<li><a href='#ppd_ext_option_t'><tt>ppd_ext_option_t</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#ppd_ext_param_t'><tt>ppd_ext_param_t</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#ppd_ext_ui_t'><tt>ppd_ext_ui_t</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#ppd_ext_value_t'><tt>ppd_ext_value_t</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
+	<li><a href='#ppd_file_t'><tt>ppd_file_t</tt></a> </li>
+	<li><a href='#ppd_group_t'><tt>ppd_group_t</tt></a> </li>
+	<li><a href='#ppd_option_t'><tt>ppd_option_t</tt></a> </li>
+	<li><a href='#ppd_profile_t'><tt>ppd_profile_t</tt></a> </li>
+	<li><a href='#ppd_section_t'><tt>ppd_section_t</tt></a> </li>
+	<li><a href='#ppd_size_t'><tt>ppd_size_t</tt></a> </li>
+	<li><a href='#ppd_ui_t'><tt>ppd_ui_t</tt></a> </li>
 </ul>
 <!-- NEW PAGE -->
-<h3><a name='ppd_attr_t'>ppd_attr_t</a></h3>
+<h3><a name='ppd_attr_t'>ppd_attr_t</a> <span class='info'>&nbsp;CUPS 1.1.19&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>PPD Attribute Structure</p>
+<p>PPD Attribute Structure </p>
 <h4>Definition</h4>
 <pre>
 typedef struct <a href='#ppd_attr_str'>ppd_attr_str</a> ppd_attr_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='ppd_choice_t'>ppd_choice_t</a></h3>
+<h3><a name='ppd_choice_t'>ppd_choice_t</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Option choices</p>
@@ -1104,7 +1120,7 @@
 typedef struct <a href='#ppd_choice_str'>ppd_choice_str</a> ppd_choice_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='ppd_conform_t'>ppd_conform_t</a></h3>
+<h3><a name='ppd_conform_t'>ppd_conform_t</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Conformance Levels</p>
@@ -1113,7 +1129,7 @@
 typedef enum <a href='#ppd_conform_e'>ppd_conform_e</a> ppd_conform_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='ppd_const_t'>ppd_const_t</a></h3>
+<h3><a name='ppd_const_t'>ppd_const_t</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Constraints</p>
@@ -1122,7 +1138,7 @@
 typedef struct ppd_const_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='ppd_emul_t'>ppd_emul_t</a></h3>
+<h3><a name='ppd_emul_t'>ppd_emul_t</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Emulators</p>
@@ -1131,43 +1147,43 @@
 typedef struct <a href='#ppd_emul_str'>ppd_emul_str</a> ppd_emul_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='ppd_ext_option_t'>ppd_ext_option_t</a></h3>
+<h3><a name='ppd_ext_option_t'>ppd_ext_option_t</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Extended Options</p>
+<p>Extended Options </p>
 <h4>Definition</h4>
 <pre>
 typedef struct <a href='#ppd_ext_option_str'>ppd_ext_option_str</a> ppd_ext_option_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='ppd_ext_param_t'>ppd_ext_param_t</a></h3>
+<h3><a name='ppd_ext_param_t'>ppd_ext_param_t</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Extended Parameter</p>
+<p>Extended Parameter </p>
 <h4>Definition</h4>
 <pre>
 typedef struct <a href='#ppd_ext_param_str'>ppd_ext_param_str</a> ppd_ext_param_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='ppd_ext_ui_t'>ppd_ext_ui_t</a></h3>
+<h3><a name='ppd_ext_ui_t'>ppd_ext_ui_t</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Extended UI Types</p>
+<p>Extended UI Types </p>
 <h4>Definition</h4>
 <pre>
 typedef enum <a href='#ppd_ext_ui_e'>ppd_ext_ui_e</a> ppd_ext_ui_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='ppd_ext_value_t'>ppd_ext_value_t</a></h3>
+<h3><a name='ppd_ext_value_t'>ppd_ext_value_t</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Extended Values</p>
+<p>Extended Values </p>
 <h4>Definition</h4>
 <pre>
 typedef union <a href='#ppd_ext_value_u'>ppd_ext_value_u</a> ppd_ext_value_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='ppd_file_t'>ppd_file_t</a></h3>
+<h3><a name='ppd_file_t'>ppd_file_t</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Files</p>
@@ -1176,7 +1192,7 @@
 typedef struct <a href='#ppd_file_str'>ppd_file_str</a> ppd_file_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='ppd_group_t'>ppd_group_t</a></h3>
+<h3><a name='ppd_group_t'>ppd_group_t</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Groups</p>
@@ -1185,14 +1201,14 @@
 typedef struct <a href='#ppd_group_str'>ppd_group_str</a> ppd_group_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='ppd_option_t'>ppd_option_t</a></h3>
+<h3><a name='ppd_option_t'>ppd_option_t</a> </h3>
 <hr noshade/>
 <h4>Definition</h4>
 <pre>
 typedef struct <a href='#ppd_option_str'>ppd_option_str</a> ppd_option_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='ppd_profile_t'>ppd_profile_t</a></h3>
+<h3><a name='ppd_profile_t'>ppd_profile_t</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>sRGB Color Profiles</p>
@@ -1201,7 +1217,7 @@
 typedef struct <a href='#ppd_profile_str'>ppd_profile_str</a> ppd_profile_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='ppd_section_t'>ppd_section_t</a></h3>
+<h3><a name='ppd_section_t'>ppd_section_t</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Order dependency sections</p>
@@ -1210,7 +1226,7 @@
 typedef enum <a href='#ppd_section_e'>ppd_section_e</a> ppd_section_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='ppd_size_t'>ppd_size_t</a></h3>
+<h3><a name='ppd_size_t'>ppd_size_t</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>Page Sizes</p>
@@ -1219,7 +1235,7 @@
 typedef struct <a href='#ppd_size_str'>ppd_size_str</a> ppd_size_t;
 </pre>
 <!-- NEW PAGE -->
-<h3><a name='ppd_ui_t'>ppd_ui_t</a></h3>
+<h3><a name='ppd_ui_t'>ppd_ui_t</a> </h3>
 <hr noshade/>
 <h4>Description</h4>
 <p>UI Types</p>
@@ -1230,13 +1246,13 @@
 <!-- NEW PAGE -->
 <h2><a name='_unions'>Unions</a></h2>
 <ul>
-	<li><a href='#ppd_ext_value_u'><tt>ppd_ext_value_u</tt></a></li>
+	<li><a href='#ppd_ext_value_u'><tt>ppd_ext_value_u</tt></a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></li>
 </ul>
 <!-- NEW PAGE -->
-<h3><a name='ppd_ext_value_u'>ppd_ext_value_u</a></h3>
+<h3><a name='ppd_ext_value_u'>ppd_ext_value_u</a> <span class='info'>&nbsp;CUPS 1.2&nbsp;</span></h3>
 <hr noshade/>
 <h4>Description</h4>
-<p>Extended Values</p>
+<p>Extended Values </p>
 <h4>Definition</h4>
 <pre>
 union ppd_ext_value_u
@@ -1251,10 +1267,10 @@
 <p class='table'><table align='center' border='1' width='80%'>
 <thead><tr><th>Name</th><th>Description</th></tr></thead>
 <tbody>
-<tr><td><tt>gamma</tt></td><td>Gamma value</td></tr>
-<tr><td><tt>integer</tt></td><td>Integer value</td></tr>
-<tr><td><tt>real</tt></td><td>Real value</td></tr>
-<tr><td><tt>text</tt></td><td>Text value</td></tr>
+<tr><td><tt>gamma</tt> </td><td>Gamma value</td></tr>
+<tr><td><tt>integer</tt> </td><td>Integer value</td></tr>
+<tr><td><tt>real</tt> </td><td>Real value</td></tr>
+<tr><td><tt>text</tt> </td><td>Text value</td></tr>
 </tbody></table></p>
 </body>
 </html>
diff -urNad cupsys-1.1.99.b1.r4748~/doc/index.html cupsys-1.1.99.b1.r4748/doc/index.html
--- cupsys-1.1.99.b1.r4748~/doc/index.html	2005-11-13 13:02:24.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/doc/index.html	1970-01-01 09:00:00.000000000 +0900
@@ -1,136 +0,0 @@
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
-<HTML>
-<HEAD>
-	<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
-	<TITLE>Home - CUPS v1.2svn</TITLE>
-	<LINK REL=STYLESHEET TYPE="text/css" HREF="/cups.css">
-</HEAD>
-<BODY>
-<P><TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="0">
-<TR CLASS="HEADER">
-<TD VALIGN="TOP" WIDTH="15" ROWSPAN="2"><IMG SRC="/images/top-left.gif" WIDTH="15" HEIGHT="80" ALT=""></TD>
-<TD VALIGN="TOP" WIDTH="55" ROWSPAN="2"><IMG SRC="/images/top-middle.gif" WIDTH="55" HEIGHT="80" ALT=""></TD>
-<TD WIDTH="100%" HEIGHT="60"><H1>Common UNIX Printing System v1.2svn</H1></TD>
-<TD ALIGN="RIGHT" VALIGN="TOP" WIDTH="15" ROWSPAN="2"><IMG
-SRC="/images/top-right.gif" WIDTH="15" HEIGHT="15" ALT=""></TD>
-</TR>
-<TR CLASS="HEADER"><TD WIDTH="100%" VALIGN="BOTTOM" NOWRAP>
-
-<A CLASS="sel" HREF="/"><IMG SRC="/images/tab-left.gif" WIDTH="4"
-HEIGHT="4" ALIGN="TOP" BORDER="0"
-ALT="">&nbsp;&nbsp;Home&nbsp;&nbsp;<IMG
-SRC="/images/tab-right.gif" WIDTH="4" HEIGHT="4" ALIGN="TOP"
-BORDER="0" ALT=""></A>
-
-&nbsp;<A CLASS="unsel" HREF="/admin/"><IMG SRC="/images/tab-left.gif" WIDTH="4"
-HEIGHT="4" ALIGN="TOP" BORDER="0"
-ALT="">&nbsp;&nbsp;Administration&nbsp;&nbsp;<IMG
-SRC="/images/tab-right.gif" WIDTH="4" HEIGHT="4" ALIGN="TOP"
-BORDER="0" ALT=""></A>
-
-&nbsp;<A CLASS="unsel" HREF="/classes/"><IMG SRC="/images/tab-left.gif" WIDTH="4"
-HEIGHT="4" ALIGN="TOP" BORDER="0"
-ALT="">&nbsp;&nbsp;Classes&nbsp;&nbsp;<IMG
-SRC="/images/tab-right.gif" WIDTH="4" HEIGHT="4" ALIGN="TOP"
-BORDER="0" ALT=""></A>
-
-&nbsp;<A CLASS="unsel" HREF="/help/"><IMG SRC="/images/tab-left.gif" WIDTH="4"
-HEIGHT="4" ALIGN="TOP" BORDER="0"
-ALT="">&nbsp;&nbsp;Documentation/Help&nbsp;&nbsp;<IMG
-SRC="/images/tab-right.gif" WIDTH="4" HEIGHT="4" ALIGN="TOP"
-BORDER="0" ALT=""></A>
-
-&nbsp;<A CLASS="unsel" HREF="/jobs/"><IMG SRC="/images/tab-left.gif" WIDTH="4"
-HEIGHT="4" ALIGN="TOP" BORDER="0"
-ALT="">&nbsp;&nbsp;Jobs&nbsp;&nbsp;<IMG
-SRC="/images/tab-right.gif" WIDTH="4" HEIGHT="4" ALIGN="TOP"
-BORDER="0" ALT=""></A>
-
-&nbsp;<A CLASS="unsel" HREF="/printers/"><IMG SRC="/images/tab-left.gif" WIDTH="4"
-HEIGHT="4" ALIGN="TOP" BORDER="0"
-ALT="">&nbsp;&nbsp;Printers&nbsp;&nbsp;<IMG
-SRC="/images/tab-right.gif" WIDTH="4" HEIGHT="4" ALIGN="TOP"
-BORDER="0" ALT=""></A>
-
-</TD></TR>
-<TR CLASS="sel">
-<TD COLSPAN="4"></TD>
-</TR>
-<TR CLASS="page">
-<TD WIDTH="15">&nbsp;</TD>
-<TD COLSPAN="2" WIDTH="100%" VALIGN="TOP">
-
-<P><A HREF="http://www.easysw.com/"><IMG
-SRC="/images/esp-logo.gif" ALIGN="RIGHT" WIDTH="110" HEIGHT="68"
-BORDER="0" ALT="Easy Software Products"></A>CUPS (<A
-HREF="http://www.cups.org/">www.cups.org</A>) provides a portable
-printing layer for UNIX<SUP>&reg;</SUP>-based operating systems.
-It is developed and maintained by <A
-HREF="http://www.easysw.com/">Easy Software Products</A> to
-promote a standard printing solution and is the standard printing
-system on MacOS<SUP>&reg;</SUP> X and most Linux<SUP>&reg;</SUP>
-distributions.</P>
-
-<P><TABLE CELLPADDING="0" CELLSPACING="0" BORDER="0" WIDTH="100%">
-<TR CLASS="header">
-<TH ALIGN="LEFT" VALIGN="TOP"><IMG SRC="/images/hdr-top-left.gif"
-WIDTH="16" HEIGHT="16" ALT=""></TH>
-<TH>Common Tasks</TH>
-<TH ALIGN="RIGHT" VALIGN="TOP"><IMG
-SRC="/images/hdr-top-right.gif" WIDTH="16" HEIGHT="16"
-ALT=""></TH>
-</TR>
-<TR CLASS="data">
-<TD></TD>
-<TD WIDTH="100%">
-
-<P>
-<A HREF="/help/"><IMG SRC="/images/help.gif" BORDER="0" ALIGN="MIDDLE" ALT="Help"></A>
-<A HREF="/admin/OP=add-class"><IMG SRC="/images/add-class.gif" BORDER="0" ALIGN="MIDDLE" ALT="Add Class"></A>
-<A HREF="/admin/OP=add-printer"><IMG SRC="/images/add-printer.gif" BORDER="0" ALIGN="MIDDLE" ALT="Add Printer"></A>
-<A HREF="/classes"><IMG SRC="/images/manage-classes.gif" BORDER="0" ALIGN="MIDDLE" ALT="Manage Classes"></A>
-<A HREF="/jobs"><IMG SRC="/images/manage-jobs.gif" BORDER="0" ALIGN="MIDDLE" ALT="Manage Jobs"></A>
-<A HREF="/printers"><IMG SRC="/images/manage-printers.gif" BORDER="0" ALIGN="MIDDLE" ALT="Manage Printers"></A>
-<A HREF="/admin"><IMG SRC="/images/manage-server.gif" BORDER="0" ALIGN="MIDDLE" ALT="Manage Server"></A>
-</P>
-
-<P><I>If asked for a username and password, login with your
-username and password or the "root" username and password.</I></P>
-
-</TD>
-<TD></TD>
-</TR>
-<TR CLASS="header">
-<TH ALIGN="LEFT" VALIGN="BOTTOM"><IMG SRC="/images/hdr-bottom-left.gif"
-WIDTH="16" HEIGHT="16" ALT=""></TH>
-<TH></TH>
-<TH ALIGN="RIGHT" VALIGN="BOTTOM"><IMG
-SRC="/images/hdr-bottom-right.gif" WIDTH="16" HEIGHT="16"
-ALT=""></TH>
-</TR>
-</TABLE></P>
-
-</TD>
-<TD WIDTH="15">&nbsp;</TD>
-</TR>
-<TR CLASS="page">
-<TD COLSPAN="5">&nbsp;</TD>
-</TR>
-<TR CLASS="header">
-<TD VALIGN="BOTTOM" WIDTH="15"><IMG SRC="/images/bottom-left.gif"
-WIDTH="15" HEIGHT="15" ALT=""></TD>
-<TD COLSPAN="2" WIDTH="100%"><SMALL>
-
-<P>The Common UNIX Printing System, CUPS, and the CUPS logo are the
-trademark property of <A HREF="http://www.easysw.com">Easy Software
-Products</A>. CUPS is copyright 1997-2005 by Easy Software Products,
-All Rights Reserved.</P>
-
-</SMALL></TD>
-
-<TD ALIGN="RIGHT" VALIGN="BOTTOM" WIDTH="15"><IMG SRC="/images/bottom-right.gif"
-WIDTH="15" HEIGHT="15" ALT=""></TD>
-</TR>
-</TABLE></P>
-</BODY>
-</HTML>
diff -urNad cupsys-1.1.99.b1.r4748~/doc/index.html.in cupsys-1.1.99.b1.r4748/doc/index.html.in
--- cupsys-1.1.99.b1.r4748~/doc/index.html.in	2005-08-25 21:15:35.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/doc/index.html.in	2005-11-05 00:57:50.182805000 +0900
@@ -86,8 +86,8 @@
 
 <P>
 <A HREF="/help/"><IMG SRC="/images/help.gif" BORDER="0" ALIGN="MIDDLE" ALT="Help"></A>
-<A HREF="/admin/OP=add-class"><IMG SRC="/images/add-class.gif" BORDER="0" ALIGN="MIDDLE" ALT="Add Class"></A>
-<A HREF="/admin/OP=add-printer"><IMG SRC="/images/add-printer.gif" BORDER="0" ALIGN="MIDDLE" ALT="Add Printer"></A>
+<A HREF="/admin?OP=add-class"><IMG SRC="/images/add-class.gif" BORDER="0" ALIGN="MIDDLE" ALT="Add Class"></A>
+<A HREF="/admin?OP=add-printer"><IMG SRC="/images/add-printer.gif" BORDER="0" ALIGN="MIDDLE" ALT="Add Printer"></A>
 <A HREF="/classes"><IMG SRC="/images/manage-classes.gif" BORDER="0" ALIGN="MIDDLE" ALT="Manage Classes"></A>
 <A HREF="/jobs"><IMG SRC="/images/manage-jobs.gif" BORDER="0" ALIGN="MIDDLE" ALT="Manage Jobs"></A>
 <A HREF="/printers"><IMG SRC="/images/manage-printers.gif" BORDER="0" ALIGN="MIDDLE" ALT="Manage Printers"></A>
diff -urNad cupsys-1.1.99.b1.r4748~/filter/Dependencies cupsys-1.1.99.b1.r4748/filter/Dependencies
--- cupsys-1.1.99.b1.r4748~/filter/Dependencies	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/filter/Dependencies	2005-10-20 23:05:42.139882000 +0900
@@ -94,9 +94,9 @@
 pstops.o: ../cups/ppd.h ../cups/file.h ../cups/language.h ../cups/string.h
 pstops.o: ../config.h
 raster.o: raster.h ../cups/ppd.h ../cups/file.h ../cups/string.h ../config.h
-rastertodymo.o: ../cups/cups.h ../cups/ipp.h ../cups/http.h ../cups/md5.h
-rastertodymo.o: ../cups/ppd.h ../cups/file.h ../cups/string.h ../config.h
-rastertodymo.o: raster.h ../cups/ppd.h
+rastertolabel.o: ../cups/cups.h ../cups/ipp.h ../cups/http.h ../cups/md5.h
+rastertolabel.o: ../cups/ppd.h ../cups/file.h ../cups/string.h ../config.h
+rastertolabel.o: raster.h ../cups/ppd.h
 rastertoepson.o: ../cups/cups.h ../cups/ipp.h ../cups/http.h ../cups/md5.h
 rastertoepson.o: ../cups/ppd.h ../cups/file.h ../cups/ppd.h ../cups/string.h
 rastertoepson.o: ../config.h raster.h
diff -urNad cupsys-1.1.99.b1.r4748~/filter/Makefile cupsys-1.1.99.b1.r4748/filter/Makefile
--- cupsys-1.1.99.b1.r4748~/filter/Makefile	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/filter/Makefile	2005-10-20 23:05:42.139882000 +0900
@@ -1,5 +1,5 @@
 #
-# "$Id: Makefile 4673 2005-09-18 04:28:54Z mike $"
+# "$Id: Makefile 4804 2005-10-20 14:05:42Z mike $"
 #
 #   Filter makefile for the Common UNIX Printing System (CUPS).
 #
@@ -27,7 +27,7 @@
 include ../Makedefs
 
 FILTERS	=	gziptoany hpgltops texttops pstops imagetops imagetoraster \
-		rastertodymo rastertoepson rastertohp
+		rastertolabel rastertoepson rastertohp
 TARGETS	=	$(FILTERS) testraster
 
 HPGLOBJS =	hpgl-attr.o hpgl-config.o hpgl-main.o hpgl-prolog.o \
@@ -39,7 +39,7 @@
 FORMOBJS =	form-attr.o form-main.o form-ps.o form-text.o form-tree.o
 OBJS	=	$(HPGLOBJS) $(IMAGEOBJS) $(FORMOBJS) \
 		imagetops.o imagetoraster.o common.o pstops.o raster.o \
-		rastertodymo.o rastertoepson.o rastertohp.o \
+		rastertolabel.o rastertoepson.o rastertohp.o \
 		texttops.o textcommon.o testraster.o gziptoany.o
 
 
@@ -76,6 +76,8 @@
 	for file in $(FILTERS); do \
 		$(INSTALL_BIN) $$file $(SERVERBIN)/filter; \
 	done
+	$(RM) $(SERVERBIN)/filter/rastertodymo
+	$(LN) rastertolabel $(SERVERBIN)/filter/rastertodymo
 	$(INSTALL_DIR) $(LIBDIR)
 	$(INSTALL_LIB) $(LIBCUPSIMAGE) $(LIBDIR)
 	-if test $(LIBCUPSIMAGE) = "libcupsimage.so.2" -o $(LIBCUPSIMAGE) = "libcupsimage.sl.2"; then \
@@ -226,12 +228,12 @@
 
 
 #
-# rastertodymo
+# rastertolabel
 #
 
-rastertodymo:	rastertodymo.o ../cups/$(LIBCUPS) $(LIBCUPSIMAGE)
+rastertolabel:	rastertolabel.o ../cups/$(LIBCUPS) $(LIBCUPSIMAGE)
 	echo Linking $@...
-	$(CC) $(LDFLAGS) -o $@ rastertodymo.o $(LINKCUPSIMAGE) $(IMGLIBS) $(LIBS)
+	$(CC) $(LDFLAGS) -o $@ rastertolabel.o $(LINKCUPSIMAGE) $(IMGLIBS) $(LIBS)
 
 
 #
@@ -279,5 +281,5 @@
 
 
 #
-# End of "$Id: Makefile 4673 2005-09-18 04:28:54Z mike $".
+# End of "$Id: Makefile 4804 2005-10-20 14:05:42Z mike $".
 #
diff -urNad cupsys-1.1.99.b1.r4748~/filter/hpgltops.dsp cupsys-1.1.99.b1.r4748/filter/hpgltops.dsp
--- cupsys-1.1.99.b1.r4748~/filter/hpgltops.dsp	1999-03-21 11:10:17.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/filter/hpgltops.dsp	1970-01-01 09:00:00.000000000 +0900
@@ -1,130 +0,0 @@
-# Microsoft Developer Studio Project File - Name="hpgltops" - Package Owner=<4>
-# Microsoft Developer Studio Generated Build File, Format Version 6.00
-# ** DO NOT EDIT **
-
-# TARGTYPE "Win32 (x86) Console Application" 0x0103
-
-CFG=hpgltops - Win32 Debug
-!MESSAGE This is not a valid makefile. To build this project using NMAKE,
-!MESSAGE use the Export Makefile command and run
-!MESSAGE 
-!MESSAGE NMAKE /f "hpgltops.mak".
-!MESSAGE 
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f "hpgltops.mak" CFG="hpgltops - Win32 Debug"
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE "hpgltops - Win32 Release" (based on "Win32 (x86) Console Application")
-!MESSAGE "hpgltops - Win32 Debug" (based on "Win32 (x86) Console Application")
-!MESSAGE 
-
-# Begin Project
-# PROP AllowPerConfigDependencies 0
-# PROP Scc_ProjName ""
-# PROP Scc_LocalPath ""
-CPP=cl.exe
-RSC=rc.exe
-
-!IF  "$(CFG)" == "hpgltops - Win32 Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "Release"
-# PROP BASE Intermediate_Dir "Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Release"
-# PROP Intermediate_Dir "Release"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
-# ADD CPP /nologo /MT /W3 /GX /O2 /I ".." /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
-# ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib  kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 ../cups/cups.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib  kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:"hpgltops.exe"
-
-!ELSEIF  "$(CFG)" == "hpgltops - Win32 Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "hpgltops___Win32_Debug"
-# PROP BASE Intermediate_Dir "hpgltops___Win32_Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Debug"
-# PROP Intermediate_Dir "Debug"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ  /c
-# ADD CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /I ".." /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ  /c
-# ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib  kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 ../cups/cupsd.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib  kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /incremental:no /debug /machine:I386 /out:"hpgltopsd.exe" /pdbtype:sept
-
-!ENDIF 
-
-# Begin Target
-
-# Name "hpgltops - Win32 Release"
-# Name "hpgltops - Win32 Debug"
-# Begin Group "Source Files"
-
-# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-# Begin Source File
-
-SOURCE=".\hpgl-attr.c"
-# End Source File
-# Begin Source File
-
-SOURCE=".\hpgl-char.c"
-# End Source File
-# Begin Source File
-
-SOURCE=".\hpgl-config.c"
-# End Source File
-# Begin Source File
-
-SOURCE=".\hpgl-input.c"
-# End Source File
-# Begin Source File
-
-SOURCE=".\hpgl-main.c"
-# End Source File
-# Begin Source File
-
-SOURCE=".\hpgl-polygon.c"
-# End Source File
-# Begin Source File
-
-SOURCE=".\hpgl-prolog.c"
-# End Source File
-# Begin Source File
-
-SOURCE=".\hpgl-vector.c"
-# End Source File
-# End Group
-# Begin Group "Header Files"
-
-# PROP Default_Filter "h;hpp;hxx;hm;inl"
-# Begin Source File
-
-SOURCE=.\hpgltops.h
-# End Source File
-# End Group
-# End Target
-# End Project
diff -urNad cupsys-1.1.99.b1.r4748~/filter/image-colorspace.c cupsys-1.1.99.b1.r4748/filter/image-colorspace.c
--- cupsys-1.1.99.b1.r4748~/filter/image-colorspace.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/filter/image-colorspace.c	2005-10-11 04:23:23.958633000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: image-colorspace.c 4741 2005-10-02 04:25:52Z mike $"
+ * "$Id: image-colorspace.c 4767 2005-10-10 19:23:23Z mike $"
  *
  *   Colorspace conversions for the Common UNIX Printing System (CUPS).
  *
@@ -28,39 +28,42 @@
  *
  * Contents:
  *
- *   cupsImageCMYKToBlack()   - Convert CMYK data to black.
- *   cupsImageCMYKToCMY()     - Convert CMYK colors to CMY.
- *   cupsImageCMYKToCMYK()    - Convert CMYK colors to CMYK.
- *   cupsImageCMYKToRGB()     - Convert CMYK colors to device-dependent RGB.
- *   cupsImageCMYKToWhite()   - Convert CMYK colors to luminance.
- *   cupsImageLut()           - Adjust all pixel values with the given LUT.
- *   cupsImageRGBAdjust()     - Adjust the hue and saturation of the given
- *                              RGB colors.
- *   cupsImageRGBToBlack()    - Convert RGB data to black.
- *   cupsImageRGBToCMY()      - Convert RGB colors to CMY.
- *   cupsImageRGBToCMYK()     - Convert RGB colors to CMYK.
- *   cupsImageRGBToRGB()      - Convert RGB colors to device-dependent RGB.
- *   cupsImageRGBToWhite()    - Convert RGB colors to luminance.
- *   cupsImageSetColorSpace() - Set the destination colorspace.
- *   cupsImageSetProfile()    - Set the device color profile.
- *   cupsImageWhiteToBlack()  - Convert luminance colors to black.
- *   cupsImageWhiteToCMY()    - Convert luminance colors to CMY.
- *   cupsImageWhiteToCMYK()   - Convert luminance colors to CMYK.
- *   cupsImageWhiteToRGB()    - Convert luminance data to RGB.
- *   cupsImageWhiteToWhite()  - Convert luminance colors to device-dependent
- *                              luminance.
- *   cielab()                 - Map CIE Lab transformation...
- *   huerotate()              - Rotate the hue, maintaining luminance.
- *   ident()                  - Make an identity matrix.
- *   mult()                   - Multiply two matrices.
- *   rgb_to_lab()             - Convert an RGB color to CIE Lab.
- *   rgb_to_xyz()             - Convert an RGB color to CIE XYZ.
- *   saturate()               - Make a saturation matrix.
- *   xform()                  - Transform a 3D point using a matrix...
- *   xrotate()                - Rotate about the x (red) axis...
- *   yrotate()                - Rotate about the y (green) axis...
- *   zrotate()                - Rotate about the z (blue) axis...
- *   zshear()                 - Shear z using x and y...
+ *   cupsImageCMYKToBlack()         - Convert CMYK data to black.
+ *   cupsImageCMYKToCMY()           - Convert CMYK colors to CMY.
+ *   cupsImageCMYKToCMYK()          - Convert CMYK colors to CMYK.
+ *   cupsImageCMYKToRGB()           - Convert CMYK colors to device-dependent
+ *                                    RGB.
+ *   cupsImageCMYKToWhite()         - Convert CMYK colors to luminance.
+ *   cupsImageLut()                 - Adjust all pixel values with the given
+ *                                    LUT.
+ *   cupsImageRGBAdjust()           - Adjust the hue and saturation of the
+ *                                    given RGB colors.
+ *   cupsImageRGBToBlack()          - Convert RGB data to black.
+ *   cupsImageRGBToCMY()            - Convert RGB colors to CMY.
+ *   cupsImageRGBToCMYK()           - Convert RGB colors to CMYK.
+ *   cupsImageRGBToRGB()            - Convert RGB colors to device-dependent
+ *                                    RGB.
+ *   cupsImageRGBToWhite()          - Convert RGB colors to luminance.
+ *   cupsImageSetProfile()          - Set the device color profile.
+ *   cupsImageSetRasterColorSpace() - Set the destination colorspace.
+ *   cupsImageWhiteToBlack()        - Convert luminance colors to black.
+ *   cupsImageWhiteToCMY()          - Convert luminance colors to CMY.
+ *   cupsImageWhiteToCMYK()         - Convert luminance colors to CMYK.
+ *   cupsImageWhiteToRGB()          - Convert luminance data to RGB.
+ *   cupsImageWhiteToWhite()        - Convert luminance colors to device-
+ *                                    dependent luminance.
+ *   cielab()                       - Map CIE Lab transformation...
+ *   huerotate()                    - Rotate the hue, maintaining luminance.
+ *   ident()                        - Make an identity matrix.
+ *   mult()                         - Multiply two matrices.
+ *   rgb_to_lab()                   - Convert an RGB color to CIE Lab.
+ *   rgb_to_xyz()                   - Convert an RGB color to CIE XYZ.
+ *   saturate()                     - Make a saturation matrix.
+ *   xform()                        - Transform a 3D point using a matrix...
+ *   xrotate()                      - Rotate about the x (red) axis...
+ *   yrotate()                      - Rotate about the y (green) axis...
+ *   zrotate()                      - Rotate about the z (blue) axis...
+ *   zshear()                       - Shear z using x and y...
  */
 
 /*
@@ -898,28 +901,6 @@
 
 
 /*
- * 'cupsImageSetColorSpace()' - Set the destination colorspace.
- */
-
-void
-cupsImageSetColorSpace(cups_cspace_t cs)/* I - Destination colorspace */
-{
- /*
-  * Set the destination colorspace...
-  */
-
-  cupsImageColorSpace  = cs;
-
- /*
-  * Don't use color profiles in colorimetric colorspaces...
-  */
-
-  if (cs >= CUPS_CSPACE_CIEXYZ)
-    cupsImageHaveProfile = 0;
-}
-
-
-/*
  * 'cupsImageSetProfile()' - Set the device color profile.
  */
 
@@ -966,6 +947,29 @@
 
 
 /*
+ * 'cupsImageSetRasterColorSpace()' - Set the destination colorspace.
+ */
+
+void
+cupsImageSetRasterColorSpace(
+    cups_cspace_t cs)			/* I - Destination colorspace */
+{
+ /*
+  * Set the destination colorspace...
+  */
+
+  cupsImageColorSpace  = cs;
+
+ /*
+  * Don't use color profiles in colorimetric colorspaces...
+  */
+
+  if (cs >= CUPS_CSPACE_CIEXYZ)
+    cupsImageHaveProfile = 0;
+}
+
+
+/*
  * 'cupsImageWhiteToBlack()' - Convert luminance colors to black.
  */
 
@@ -1557,5 +1561,5 @@
 
 
 /*
- * End of "$Id: image-colorspace.c 4741 2005-10-02 04:25:52Z mike $".
+ * End of "$Id: image-colorspace.c 4767 2005-10-10 19:23:23Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/filter/imagetoraster.c cupsys-1.1.99.b1.r4748/filter/imagetoraster.c
--- cupsys-1.1.99.b1.r4748~/filter/imagetoraster.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/filter/imagetoraster.c	2005-10-11 04:23:23.958633000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: imagetoraster.c 4741 2005-10-02 04:25:52Z mike $"
+ * "$Id: imagetoraster.c 4767 2005-10-10 19:23:23Z mike $"
  *
  *   Image file to raster filter for the Common UNIX Printing System (CUPS).
  *
@@ -687,7 +687,7 @@
   if (profile)
     cupsImageSetProfile(profile->density, profile->gamma, profile->matrix);
 
-  cupsImageSetColorSpace(header.cupsColorSpace);
+  cupsImageSetRasterColorSpace(header.cupsColorSpace);
 
  /*
   * Create a gamma/brightness LUT...
@@ -4587,5 +4587,5 @@
 
 
 /*
- * End of "$Id: imagetoraster.c 4741 2005-10-02 04:25:52Z mike $".
+ * End of "$Id: imagetoraster.c 4767 2005-10-10 19:23:23Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/filter/pstops.dsp cupsys-1.1.99.b1.r4748/filter/pstops.dsp
--- cupsys-1.1.99.b1.r4748~/filter/pstops.dsp	1999-03-21 11:10:17.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/filter/pstops.dsp	1970-01-01 09:00:00.000000000 +0900
@@ -1,107 +0,0 @@
-# Microsoft Developer Studio Project File - Name="pstops" - Package Owner=<4>
-# Microsoft Developer Studio Generated Build File, Format Version 6.00
-# ** DO NOT EDIT **
-
-# TARGTYPE "Win32 (x86) Console Application" 0x0103
-
-CFG=pstops - Win32 Debug
-!MESSAGE This is not a valid makefile. To build this project using NMAKE,
-!MESSAGE use the Export Makefile command and run
-!MESSAGE 
-!MESSAGE NMAKE /f "pstops.mak".
-!MESSAGE 
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f "pstops.mak" CFG="pstops - Win32 Debug"
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE "pstops - Win32 Release" (based on "Win32 (x86) Console Application")
-!MESSAGE "pstops - Win32 Debug" (based on "Win32 (x86) Console Application")
-!MESSAGE 
-
-# Begin Project
-# PROP AllowPerConfigDependencies 0
-# PROP Scc_ProjName ""
-# PROP Scc_LocalPath ""
-CPP=cl.exe
-RSC=rc.exe
-
-!IF  "$(CFG)" == "pstops - Win32 Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "Release"
-# PROP BASE Intermediate_Dir "Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Release"
-# PROP Intermediate_Dir "Release"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
-# ADD CPP /nologo /MT /W3 /GX /O2 /I ".." /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
-# ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib  kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 ../cups/cups.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib  kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:"pstops.exe"
-
-!ELSEIF  "$(CFG)" == "pstops - Win32 Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "pstops___Win32_Debug"
-# PROP BASE Intermediate_Dir "pstops___Win32_Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Debug"
-# PROP Intermediate_Dir "Debug"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ  /c
-# ADD CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /I ".." /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ  /c
-# ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib  kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 ../cups/cups.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib  kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /incremental:no /debug /machine:I386 /out:"pstopsd.exe" /pdbtype:sept
-
-!ENDIF 
-
-# Begin Target
-
-# Name "pstops - Win32 Release"
-# Name "pstops - Win32 Debug"
-# Begin Group "Source Files"
-
-# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-# Begin Source File
-
-SOURCE=.\pstops.c
-
-!IF  "$(CFG)" == "pstops - Win32 Release"
-
-!ELSEIF  "$(CFG)" == "pstops - Win32 Debug"
-
-# ADD CPP /Zi
-
-!ENDIF 
-
-# End Source File
-# End Group
-# Begin Group "Header Files"
-
-# PROP Default_Filter "h;hpp;hxx;hm;inl"
-# End Group
-# End Target
-# End Project
diff -urNad cupsys-1.1.99.b1.r4748~/filter/raster.c cupsys-1.1.99.b1.r4748/filter/raster.c
--- cupsys-1.1.99.b1.r4748~/filter/raster.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/filter/raster.c	2005-11-12 12:15:10.305626000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: raster.c 4671 2005-09-18 04:12:48Z mike $"
+ * "$Id: raster.c 4829 2005-11-12 03:15:10Z mike $"
  *
  *   Raster file routines for the Common UNIX Printing System (CUPS).
  *
@@ -73,8 +73,8 @@
 static unsigned	cups_raster_read_header(cups_raster_t *r);
 static void	cups_raster_update(cups_raster_t *r);
 static int	cups_raster_write(cups_raster_t *r);
-static int	cups_read(int fd, char *buf, int bytes);
-static int	cups_write(int fd, const char *buf, int bytes);
+static int	cups_read(int fd, unsigned char *buf, int bytes);
+static int	cups_write(int fd, const unsigned char *buf, int bytes);
 
 
 /*
@@ -117,7 +117,8 @@
     * Open for read - get sync word...
     */
 
-    if (cups_read(r->fd, (char *)&(r->sync), sizeof(r->sync)) < sizeof(r->sync))
+    if (cups_read(r->fd, (unsigned char *)&(r->sync), sizeof(r->sync))
+            < sizeof(r->sync))
     {
       free(r);
       return (NULL);
@@ -139,7 +140,8 @@
     */
 
     r->sync = CUPS_RASTER_SYNC;
-    if (cups_write(r->fd, (char *)&(r->sync), sizeof(r->sync)) < sizeof(r->sync))
+    if (cups_write(r->fd, (unsigned char *)&(r->sync), sizeof(r->sync))
+            < sizeof(r->sync))
     {
       free(r);
       return (NULL);
@@ -154,9 +156,10 @@
  * 'cupsRasterReadHeader()' - Read a V1 raster page header.
  */
 
-unsigned					/* O - 1 on success, 0 on fail */
-cupsRasterReadHeader(cups_raster_t      *r,	/* I - Raster stream */
-                     cups_page_header_t *h)	/* I - Pointer to header data */
+unsigned				/* O - 1 on success, 0 on fail */
+cupsRasterReadHeader(
+    cups_raster_t      *r,		/* I - Raster stream */
+    cups_page_header_t *h)		/* I - Pointer to header data */
 {
  /*
   * Get the raster header...
@@ -179,9 +182,10 @@
  * 'cupsRasterReadHeader2()' - Read a V2 raster page header.
  */
 
-unsigned					/* O - 1 on success, 0 on fail */
-cupsRasterReadHeader2(cups_raster_t       *r,	/* I - Raster stream */
-                      cups_page_header2_t *h)	/* I - Pointer to header data */
+unsigned				/* O - 1 on success, 0 on fail */
+cupsRasterReadHeader2(
+    cups_raster_t       *r,		/* I - Raster stream */
+    cups_page_header2_t *h)		/* I - Pointer to header data */
 {
  /*
   * Get the raster header...
@@ -392,9 +396,10 @@
  * 'cupsRasterWriteHeader()' - Write a V2 raster page header.
  */
  
-unsigned					/* O - 1 on success, 0 on failure */
-cupsRasterWriteHeader(cups_raster_t      *r,	/* I - Raster stream */
-                      cups_page_header_t *h)	/* I - Raster page header */
+unsigned				/* O - 1 on success, 0 on failure */
+cupsRasterWriteHeader(
+    cups_raster_t      *r,		/* I - Raster stream */
+    cups_page_header_t *h)		/* I - Raster page header */
 {
   if (r == NULL || r->mode != CUPS_RASTER_WRITE)
     return (0);
@@ -413,7 +418,8 @@
   * Write the raster header...
   */
 
-  return (cups_write(r->fd, (char *)&(r->header), sizeof(r->header)) > 0);
+  return (cups_write(r->fd, (unsigned char *)&(r->header), sizeof(r->header))
+              > 0);
 }
 
 
@@ -421,9 +427,10 @@
  * 'cupsRasterWriteHeader2()' - Write a V2 raster page header.
  */
  
-unsigned					/* O - 1 on success, 0 on failure */
-cupsRasterWriteHeader2(cups_raster_t       *r,	/* I - Raster stream */
-                       cups_page_header2_t *h)	/* I - Raster page header */
+unsigned				/* O - 1 on success, 0 on failure */
+cupsRasterWriteHeader2(
+    cups_raster_t       *r,		/* I - Raster stream */
+    cups_page_header2_t *h)		/* I - Raster page header */
 {
   if (r == NULL || r->mode != CUPS_RASTER_WRITE)
     return (0);
@@ -441,7 +448,8 @@
   * Write the raster header...
   */
 
-  return (cups_write(r->fd, (char *)&(r->header), sizeof(r->header)) > 0);
+  return (cups_write(r->fd, (unsigned char *)&(r->header), sizeof(r->header))
+              > 0);
 }
 
 
@@ -559,11 +567,12 @@
  * 'cups_raster_read_header()' - Read a raster page header.
  */
 
-static unsigned					/* O - 1 on success, 0 on fail */
-cups_raster_read_header(cups_raster_t *r)	/* I - Raster stream */
+static unsigned				/* O - 1 on success, 0 on fail */
+cups_raster_read_header(
+    cups_raster_t *r)			/* I - Raster stream */
 {
-  int		len;				/* Number of words to swap */
-  union swap_s					/* Swapping structure */
+  int		len;			/* Number of words to swap */
+  union swap_s				/* Swapping structure */
   {
     unsigned char	b[4];
     unsigned		v;
@@ -588,7 +597,7 @@
 
   memset(&(r->header), 0, sizeof(r->header));
 
-  if (cups_read(r->fd, (char *)&(r->header), len) < len)
+  if (cups_read(r->fd, (unsigned char *)&(r->header), len) < len)
     return (0);
 
  /*
@@ -760,7 +769,7 @@
       if (cups_write(r->fd, start, r->bpp) < r->bpp)
         return (0);
     }
-    else if (memcmp(start, ptr, r->bpp) == 0)
+    else if (!memcmp(start, ptr, r->bpp))
     {
      /*
       * Encode a sequence of repeating pixels...
@@ -787,7 +796,7 @@
       */
 
       for (count = 1; count < 127 && ptr < (r->pend - r->bpp); count ++, ptr += r->bpp)
-        if (memcmp(ptr, ptr + r->bpp, r->bpp) == 0)
+        if (!memcmp(ptr, ptr + r->bpp, r->bpp))
 	  break;
 
       if (ptr >= (r->pend - r->bpp) && count < 128)
@@ -816,13 +825,13 @@
  * 'cups_read()' - Read bytes from a file.
  */
 
-static int					/* O - Bytes read or -1 */
-cups_read(int  fd,				/* I - File descriptor */
-          char *buf,				/* I - Buffer for read */
-	  int  bytes)				/* I - Number of bytes to read */
+static int				/* O - Bytes read or -1 */
+cups_read(int           fd,		/* I - File descriptor */
+          unsigned char *buf,		/* I - Buffer for read */
+	  int           bytes)		/* I - Number of bytes to read */
 {
-  int	count,					/* Number of bytes read */
-	total;					/* Total bytes read */
+  int	count,				/* Number of bytes read */
+	total;				/* Total bytes read */
 
 
   for (total = 0; total < bytes; total += count, buf += count)
@@ -833,7 +842,7 @@
       return (0);
     else if (count < 0)
     {
-      if (errno != EINTR)
+      if (errno == EINTR)
         count = 0;
       else
         return (-1);
@@ -848,13 +857,13 @@
  * 'cups_write()' - Write bytes to a file.
  */
 
-static int					/* O - Bytes written or -1 */
-cups_write(int        fd,			/* I - File descriptor */
-           const char *buf,			/* I - Bytes to write */
-	   int        bytes)			/* I - Number of bytes to write */
+static int				/* O - Bytes written or -1 */
+cups_write(int                 fd,	/* I - File descriptor */
+           const unsigned char *buf,	/* I - Bytes to write */
+	   int                 bytes)	/* I - Number of bytes to write */
 {
-  int	count,					/* Number of bytes written */
-	total;					/* Total bytes written */
+  int	count,				/* Number of bytes written */
+	total;				/* Total bytes written */
 
 
   for (total = 0; total < bytes; total += count, buf += count)
@@ -863,7 +872,7 @@
 
     if (count < 0)
     {
-      if (errno != EINTR)
+      if (errno == EINTR)
         count = 0;
       else
         return (-1);
@@ -875,5 +884,5 @@
 
 
 /*
- * End of "$Id: raster.c 4671 2005-09-18 04:12:48Z mike $".
+ * End of "$Id: raster.c 4829 2005-11-12 03:15:10Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/filter/rastertodymo.c cupsys-1.1.99.b1.r4748/filter/rastertodymo.c
--- cupsys-1.1.99.b1.r4748~/filter/rastertodymo.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/filter/rastertodymo.c	1970-01-01 09:00:00.000000000 +0900
@@ -1,834 +0,0 @@
-/*
- * "$Id: rastertodymo.c 4501 2005-02-18 19:01:41Z mike $"
- *
- *   Label printer filter for the Common UNIX Printing System (CUPS).
- *
- *   Copyright 2001-2005 by Easy Software Products.
- *
- *   These coded instructions, statements, and computer programs are the
- *   property of Easy Software Products and are protected by Federal
- *   copyright law.  Distribution and use rights are outlined in the file
- *   "LICENSE.txt" which should have been included with this file.  If this
- *   file is missing or damaged please contact Easy Software Products
- *   at:
- *
- *       Attn: CUPS Licensing Information
- *       Easy Software Products
- *       44141 Airport View Drive, Suite 204
- *       Hollywood, Maryland 20636 USA
- *
- *       Voice: (301) 373-9600
- *       EMail: cups-info@cups.org
- *         WWW: http://www.cups.org
- *
- *   This file is subject to the Apple OS-Developed Software exception.
- *
- * Contents:
- *
- *   Setup()        - Prepare the printer for printing.
- *   StartPage()    - Start a page of graphics.
- *   EndPage()      - Finish a page of graphics.
- *   CancelJob()    - Cancel the current job...
- *   OutputLine()   - Output a line of graphics.
- *   ZPLCompress()  - Output a run-length compression sequence.
- *   main()         - Main entry and processing of driver.
- */
-
-/*
- * Include necessary headers...
- */
-
-#include <cups/cups.h>
-#include <cups/string.h>
-#include "raster.h"
-#include <stdlib.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <signal.h>
-
-
-/*
- * This driver filter currently supports Dymo and Zebra label printers.
- *
- * The Dymo portion of the driver has been tested with the 300, 330,
- * and 330 Turbo label printers; it may also work with older models.
- * The Dymo printers support printing at 136, 203, and 300 DPI.
- *
- * The Zebra portion of the driver has been tested with the LP-2844Z label
- * printer; it may also work with other models.  The driver supports both
- * EPL and ZPL as defined in Zebra's on-line developer documentation.
- */
-
-/*
- * Model number constants...
- */
-
-#define DYMO_3x0	0		/* Dymo Labelwriter 300/330/330 Turbo */
-
-#define ZEBRA_EPL_LINE	0x10		/* Zebra EPL line mode printers */
-#define ZEBRA_EPL_PAGE	0x11		/* Zebra EPL page mode printers */
-#define ZEBRA_ZPL	0x12		/* Zebra ZPL-based printers */
-
-
-/*
- * Globals...
- */
-
-unsigned char	*Buffer;		/* Output buffer */
-char		*CompBuffer;		/* Compression buffer */
-unsigned char	*LastBuffer;		/* Last buffer */
-int		LastSet;		/* Number of repeat characters */
-int		ModelNumber,		/* cupsModelNumber attribute */
-		Page,			/* Current page */
-		Feed,			/* Number of lines to skip */
-		Canceled;		/* Non-zero if job is canceled */
-
-
-/*
- * Prototypes...
- */
-
-void	Setup(ppd_file_t *ppd);
-void	StartPage(ppd_file_t *ppd, cups_page_header_t *header);
-void	EndPage(ppd_file_t *ppd, cups_page_header_t *header);
-void	CancelJob(int sig);
-void	OutputLine(ppd_file_t *ppd, cups_page_header_t *header, int y);
-void	ZPLCompress(char repeat_char, int repeat_count);
-
-
-/*
- * 'Setup()' - Prepare the printer for printing.
- */
-
-void
-Setup(ppd_file_t *ppd)			/* I - PPD file */
-{
-  int		i;			/* Looping var */
-
-
- /*
-  * Get the model number from the PPD file...
-  */
-
-  if (ppd)
-    ModelNumber = ppd->model_number;
-
- /*
-  * Initialize based on the model number...
-  */
-
-  switch (ModelNumber)
-  {
-    case DYMO_3x0 :
-       /*
-	* Clear any remaining data...
-	*/
-
-	for (i = 0; i < 100; i ++)
-	  putchar(0x1b);
-
-       /*
-	* Reset the printer...
-	*/
-
-	fputs("\033@", stdout);
-	break;
-
-    case ZEBRA_EPL_LINE :
-	break;
-
-    case ZEBRA_EPL_PAGE :
-	break;
-
-    case ZEBRA_ZPL :
-        break;
-  }
-}
-
-
-/*
- * 'StartPage()' - Start a page of graphics.
- */
-
-void
-StartPage(ppd_file_t *ppd,		/* I - PPD file */
-          cups_page_header_t *header)	/* I - Page header */
-{
-  int	length;				/* Actual label length */
-#if defined(HAVE_SIGACTION) && !defined(HAVE_SIGSET)
-  struct sigaction action;		/* Actions for POSIX signals */
-#endif /* HAVE_SIGACTION && !HAVE_SIGSET */
-
-
- /*
-  * Register a signal handler to eject the current page if the
-  * job is canceled.
-  */
-
-#ifdef HAVE_SIGSET /* Use System V signals over POSIX to avoid bugs */
-  sigset(SIGTERM, CancelJob);
-#elif defined(HAVE_SIGACTION)
-  memset(&action, 0, sizeof(action));
-
-  sigemptyset(&action.sa_mask);
-  action.sa_handler = CancelJob;
-  sigaction(SIGTERM, &action, NULL);
-#else
-  signal(SIGTERM, CancelJob);
-#endif /* HAVE_SIGSET */
-
-  switch (ModelNumber)
-  {
-    case DYMO_3x0 :
-       /*
-	* Setup printer/job attributes...
-	*/
-
-	length = header->PageSize[1] * header->HWResolution[1] / 72;
-
-	printf("\033L%c%c", length >> 8, length);
-	printf("\033D%c", header->cupsBytesPerLine);
-
-	printf("\033%c", header->cupsCompression + 'c'); /* Darkness */
-	break;
-
-    case ZEBRA_EPL_LINE :
-       /*
-        * Set darkness...
-	*/
-
-	printf("D%d", 7 * header->cupsCompression / 100);
-
-       /*
-        * Start buffered output...
-	*/
-
-        putchar('B');
-        break;
-
-    case ZEBRA_EPL_PAGE :
-       /*
-        * Set darkness...
-	*/
-
-	printf("D%d", 15 * header->cupsCompression / 100);
-
-       /*
-        * Set label size...
-	*/
-
-        printf("q%d\n", header->cupsWidth);
-        break;
-
-    case ZEBRA_ZPL :
-       /*
-        * Set darkness...
-	*/
-
-	if (header->cupsCompression > 0)
-	  printf("~SD%02d\n", 30 * header->cupsCompression / 100);
-
-       /*
-        * Start bitmap graphics...
-	*/
-
-        printf("~DGR:CUPS.GRF,%d,%d,\n",
-	       header->cupsHeight * header->cupsBytesPerLine,
-	       header->cupsBytesPerLine);
-
-       /*
-        * Allocate compression buffers...
-	*/
-
-	CompBuffer = malloc(2 * header->cupsBytesPerLine + 1);
-	LastBuffer = malloc(header->cupsBytesPerLine);
-	LastSet    = 0;
-        break;
-  }
-
- /*
-  * Allocate memory for a line of graphics...
-  */
-
-  Buffer = malloc(header->cupsBytesPerLine);
-  Feed   = 0;
-}
-
-
-/*
- * 'EndPage()' - Finish a page of graphics.
- */
-
-void
-EndPage(ppd_file_t *ppd,		/* I - PPD file */
-        cups_page_header_t *header)	/* I - Page header */
-{
-  int		val;			/* Option value */
-  ppd_choice_t	*choice;		/* Marked choice */
-#if defined(HAVE_SIGACTION) && !defined(HAVE_SIGSET)
-  struct sigaction action;		/* Actions for POSIX signals */
-#endif /* HAVE_SIGACTION && !HAVE_SIGSET */
-
-
-  switch (ModelNumber)
-  {
-    case DYMO_3x0 :
-       /*
-	* Eject the current page...
-	*/
-
-	fputs("\033E", stdout);
-	break;
-
-    case ZEBRA_EPL_LINE :
-       /*
-        * End buffered output, eject the label...
-	*/
-
-        putchar('E');
-	break;
-
-    case ZEBRA_EPL_PAGE :
-       /*
-        * Print the label...
-	*/
-
-        puts("P1");
-	break;
-
-    case ZEBRA_ZPL :
-        if (Canceled)
-	{
-	 /*
-	  * Cancel bitmap download...
-	  */
-
-	  puts("~DN");
-	  break;
-	}
-
-       /*
-        * Start label...
-	*/
-
-        puts("^XA");
-
-       /*
-        * Set print rate...
-	*/
-
-	if ((choice = ppdFindMarkedChoice(ppd, "zePrintRate")) != NULL &&
-	    strcmp(choice->choice, "Default"))
-	{
-	  val = atoi(choice->choice);
-	  printf("^PR%d,%d,%d\n", val, val, val);
-	}
-
-       /*
-        * Put label home in default position (0,0)...
-        */
-
-	printf("^LH0,0\n");
-
-       /*
-        * Set media tracking...
-	*/
-
-	if (ppdIsMarked(ppd, "zeMediaTracking", "Continuous"))
-	{
-         /*
-	  * Add label length command for continuous...
-	  */
-
-	  printf("^LL%d\n", header->cupsHeight);
-	  printf("^MNN\n");
-	}
-	else if (ppdIsMarked(ppd, "zeMediaTracking", "Web"))
-          printf("^MNY\n");
-	else if (ppdIsMarked(ppd, "zeMediaTracking", "Mark"))
-	  printf("^MNM\n");
-
-       /*
-        * Set label top
-	*/
-
-	if (header->cupsRowStep != 200)
-	  printf("^LT%u\n", header->cupsRowStep);
-
-       /*
-        * Set media type...
-	*/
-
-	if (!strcmp(header->MediaType, "Thermal"))
-	  printf("^MTT\n");
-	else if (!strcmp(header->MediaType, "Direct"))
-	  printf("^MTD\n");
-
-       /*
-        * Set print mode...
-	*/
-
-	if ((choice = ppdFindMarkedChoice(ppd, "zePrintMode")) != NULL &&
-	    strcmp(choice->choice, "Saved"))
-	{
-	  printf("^MM");
-
-	  if (!strcmp(choice->choice, "Tear"))
-	    printf("T,Y\n");
-	  else if (!strcmp(choice->choice, "Peel"))
-	    printf("P,Y\n");
-	  else if (!strcmp(choice->choice, "Rewind"))
-	    printf("R,Y\n");
-	  else if (!strcmp(choice->choice, "Applicator"))
-	    printf("A,Y\n");
-	  else
-	    printf("C,Y\n");
-	}
-
-       /*
-        * Set tear-off adjust position...
-	*/
-
-	if (header->AdvanceDistance != 1000)
-	{
-	  if ((int)header->AdvanceDistance < 0)
-	    printf("~TA%04d\n", (int)header->AdvanceDistance);
-	  else
-	    printf("~TA%03d\n", (int)header->AdvanceDistance);
-	}
-
-       /*
-        * Allow for reprinting after an error...
-	*/
-
-	if (ppdIsMarked(ppd, "zeErrorReprint", "Always"))
-	  printf("^JZY\n");
-	else if (ppdIsMarked(ppd, "zeErrorReprint", "Never"))
-	  printf("^JZN\n");
-
-       /*
-        * Print multiple copies
-	*/
-
-	if (header->NumCopies > 1)
-	  printf("^PQ%d, 0, 0, N\n", header->NumCopies);
-
-       /*
-        * Display the label image...
-	*/
-
-	puts("^FO0,0^XGR:CUPS.GRF,1,1^FS");
-
-       /*
-        * End the label and eject...
-	*/
-
-        puts("^XZ");
-
-       /*
-        * Free compression buffers...
-	*/
-
-	free(CompBuffer);
-	free(LastBuffer);
-        break;
-  }
-
-  fflush(stdout);
-
- /*
-  * Unregister the signal handler...
-  */
-
-#ifdef HAVE_SIGSET /* Use System V signals over POSIX to avoid bugs */
-  sigset(SIGTERM, SIG_IGN);
-#elif defined(HAVE_SIGACTION)
-  memset(&action, 0, sizeof(action));
-
-  sigemptyset(&action.sa_mask);
-  action.sa_handler = SIG_IGN;
-  sigaction(SIGTERM, &action, NULL);
-#else
-  signal(SIGTERM, SIG_IGN);
-#endif /* HAVE_SIGSET */
-
- /*
-  * Free memory...
-  */
-
-  free(Buffer);
-}
-
-
-/*
- * 'CancelJob()' - Cancel the current job...
- */
-
-void
-CancelJob(int sig)			/* I - Signal */
-{
- /*
-  * Tell the main loop to stop...
-  */
-
-  (void)sig;
-
-  Canceled = 1;
-}
-
-
-/*
- * 'OutputLine()' - Output a line of graphics...
- */
-
-void
-OutputLine(ppd_file_t         *ppd,	/* I - PPD file */
-           cups_page_header_t *header,	/* I - Page header */
-           int                y)	/* I - Line number */
-{
-  int		i;			/* Looping var */
-  unsigned char	*ptr;			/* Pointer into buffer */
-  char		*compptr;		/* Pointer into compression buffer */
-  char		repeat_char;		/* Repeated character */
-  int		repeat_count;		/* Number of repeated characters */
-  static const char *hex = "0123456789ABCDEF";
-					/* Hex digits */
-
-
-  switch (ModelNumber)
-  {
-    case DYMO_3x0 :
-       /*
-	* See if the line is blank; if not, write it to the printer...
-	*/
-
-	if (Buffer[0] ||
-            memcmp(Buffer, Buffer + 1, header->cupsBytesPerLine - 1))
-	{
-          if (Feed)
-	  {
-	    while (Feed > 255)
-	    {
-	      printf("\033f\001%c", 255);
-	      Feed -= 255;
-	    }
-
-	    printf("\033f\001%c", Feed);
-	    Feed = 0;
-          }
-
-          putchar(0x16);
-	  fwrite(Buffer, header->cupsBytesPerLine, 1, stdout);
-	  fflush(stdout);
-
-#ifdef __sgi
-	 /*
-          * This hack works around a bug in the IRIX serial port driver when
-	  * run at high baud rates (e.g. 115200 baud)...  This results in
-	  * slightly slower label printing, but at least the labels come
-	  * out properly.
-	  */
-
-	  sginap(1);
-#endif /* __sgi */
-	}
-	else
-          Feed ++;
-	break;
-
-    case ZEBRA_EPL_LINE :
-        printf("g%03d", header->cupsBytesPerLine);
-	fwrite(Buffer, 1, header->cupsBytesPerLine, stdout);
-	fflush(stdout);
-        break;
-
-    case ZEBRA_EPL_PAGE :
-        printf("GW0,%d,%d,1", y, header->cupsBytesPerLine);
-	fwrite(Buffer, 1, header->cupsBytesPerLine, stdout);
-	putchar('\n');
-	fflush(stdout);
-        break;
-
-    case ZEBRA_ZPL :
-       /*
-	* Determine if this row is the same as the previous line.
-        * If so, output a ':' and return...
-        */
-
-        if (LastSet)
-	{
-	  if (!memcmp(Buffer, LastBuffer, header->cupsBytesPerLine))
-	  {
-	    putchar(':');
-	    return;
-	  }
-	}
-
-       /*
-        * Convert the line to hex digits...
-	*/
-
-	for (ptr = Buffer, compptr = CompBuffer, i = header->cupsBytesPerLine;
-	     i > 0;
-	     i --, ptr ++)
-        {
-	  *compptr++ = hex[*ptr >> 4];
-	  *compptr++ = hex[*ptr & 15];
-	}
-
-        *compptr = '\0';
-
-       /*
-        * Run-length compress the graphics...
-	*/
-
-	for (compptr = CompBuffer, repeat_char = CompBuffer[0], repeat_count = 1;
-	     *compptr;
-	     compptr ++)
-	  if (*compptr == repeat_char)
-	    repeat_count ++;
-	  else
-	  {
-	    ZPLCompress(repeat_char, repeat_count);
-	    repeat_char  = *compptr;
-	    repeat_count = 1;
-	  }
-
-        if (repeat_char == '0')
-	{
-	 /*
-	  * Handle 0's on the end of the line...
-	  */
-
-	  if (repeat_count & 1)
-	    putchar('0');
-
-	  putchar(',');
-	}
-	else
-	  ZPLCompress(repeat_char, repeat_count);
-
-       /*
-        * Save this line for the next round...
-	*/
-
-	memcpy(LastBuffer, Buffer, header->cupsBytesPerLine);
-	LastSet = 1;
-        break;
-  }
-}
-
-
-/*
- * 'ZPLCompress()' - Output a run-length compression sequence.
- */
-
-void
-ZPLCompress(char repeat_char,		/* I - Character to repeat */
-	    int  repeat_count)		/* I - Number of repeated characters */
-{
-  if (repeat_count > 1)
-  {
-   /*
-    * Print as many z's as possible - they are the largest denomination
-    * representing 400 characters (zC stands for 400 adjacent C's)	
-    */	
-
-    while (repeat_count >= 400)
-    {
-      putchar('z');
-      repeat_count -= 400;
-    }
-
-   /*
-    * Then print 'g' through 'y' as multiples of 20 characters...
-    */
-
-    if (repeat_count >= 20)
-    {
-      putchar('f' + repeat_count / 20);
-      repeat_count %= 20;
-    }
-
-   /*
-    * Finally, print 'G' through 'Y' as 1 through 19 characters...
-    */
-
-    if (repeat_count > 0)
-      putchar('F' + repeat_count);
-  }
-
- /*
-  * Then the character to be repeated...
-  */
-
-  putchar(repeat_char);
-}
-
-
-/*
- * 'main()' - Main entry and processing of driver.
- */
-
-int					/* O - Exit status */
-main(int  argc,				/* I - Number of command-line arguments */
-     char *argv[])			/* I - Command-line arguments */
-{
-  int			fd;		/* File descriptor */
-  cups_raster_t		*ras;		/* Raster stream for printing */
-  cups_page_header_t	header;		/* Page header from file */
-  int			y;		/* Current line */
-  ppd_file_t		*ppd;		/* PPD file */
-  int			num_options;	/* Number of options */
-  cups_option_t		*options;	/* Options */
-
-
- /*
-  * Make sure status messages are not buffered...
-  */
-
-  setbuf(stderr, NULL);
-
- /*
-  * Check command-line...
-  */
-
-  if (argc < 6 || argc > 7)
-  {
-   /*
-    * We don't have the correct number of arguments; write an error message
-    * and return.
-    */
-
-    fputs("ERROR: rastertodymo job-id user title copies options [file]\n", stderr);
-    return (1);
-  }
-
- /*
-  * Open the page stream...
-  */
-
-  if (argc == 7)
-  {
-    if ((fd = open(argv[6], O_RDONLY)) == -1)
-    {
-      perror("ERROR: Unable to open raster file - ");
-      sleep(1);
-      return (1);
-    }
-  }
-  else
-    fd = 0;
-
-  ras = cupsRasterOpen(fd, CUPS_RASTER_READ);
-
- /*
-  * Open the PPD file and apply options...
-  */
-
-  num_options = cupsParseOptions(argv[5], 0, &options);
-
-  if ((ppd = ppdOpenFile(getenv("PPD"))) != NULL)
-  {
-    ppdMarkDefaults(ppd);
-    cupsMarkOptions(ppd, num_options, options);
-  }
-
- /*
-  * Initialize the print device...
-  */
-
-  Setup(ppd);
-
- /*
-  * Process pages as needed...
-  */
-
-  Page      = 0;
-  Canceled = 0;
-
-  while (cupsRasterReadHeader(ras, &header))
-  {
-   /*
-    * Write a status message with the page number and number of copies.
-    */
-
-    Page ++;
-
-    fprintf(stderr, "PAGE: %d 1\n", Page);
-
-   /*
-    * Start the page...
-    */
-
-    StartPage(ppd, &header);
-
-   /*
-    * Loop for each line on the page...
-    */
-
-    for (y = 0; y < header.cupsHeight && !Canceled; y ++)
-    {
-     /*
-      * Let the user know how far we have progressed...
-      */
-
-      if ((y & 15) == 0)
-        fprintf(stderr, "INFO: Printing page %d, %d%% complete...\n", Page,
-	        100 * y / header.cupsHeight);
-
-     /*
-      * Read a line of graphics...
-      */
-
-      if (cupsRasterReadPixels(ras, Buffer, header.cupsBytesPerLine) < 1)
-        break;
-
-     /*
-      * Write it to the printer...
-      */
-
-      OutputLine(ppd, &header, y);
-    }
-
-   /*
-    * Eject the page...
-    */
-
-    EndPage(ppd, &header);
-
-    if (Canceled)
-      break;
-  }
-
- /*
-  * Close the raster stream...
-  */
-
-  cupsRasterClose(ras);
-  if (fd != 0)
-    close(fd);
-
- /*
-  * Close the PPD file and free the options...
-  */
-
-  ppdClose(ppd);
-  cupsFreeOptions(num_options, options);
-
- /*
-  * If no pages were printed, send an error message...
-  */
-
-  if (Page == 0)
-    fputs("ERROR: No pages found!\n", stderr);
-  else
-    fputs("INFO: Ready to print.\n", stderr);
-
-  return (Page == 0);
-}
-
-
-/*
- * End of "$Id: rastertodymo.c 4501 2005-02-18 19:01:41Z mike $".
- */
diff -urNad cupsys-1.1.99.b1.r4748~/filter/rastertolabel.c cupsys-1.1.99.b1.r4748/filter/rastertolabel.c
--- cupsys-1.1.99.b1.r4748~/filter/rastertolabel.c	1970-01-01 09:00:00.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/filter/rastertolabel.c	2005-10-20 23:05:42.139882000 +0900
@@ -0,0 +1,913 @@
+/*
+ * "$Id: rastertolabel.c 4804 2005-10-20 14:05:42Z mike $"
+ *
+ *   Label printer filter for the Common UNIX Printing System (CUPS).
+ *
+ *   Copyright 2001-2005 by Easy Software Products.
+ *
+ *   These coded instructions, statements, and computer programs are the
+ *   property of Easy Software Products and are protected by Federal
+ *   copyright law.  Distribution and use rights are outlined in the file
+ *   "LICENSE.txt" which should have been included with this file.  If this
+ *   file is missing or damaged please contact Easy Software Products
+ *   at:
+ *
+ *       Attn: CUPS Licensing Information
+ *       Easy Software Products
+ *       44141 Airport View Drive, Suite 204
+ *       Hollywood, Maryland 20636 USA
+ *
+ *       Voice: (301) 373-9600
+ *       EMail: cups-info@cups.org
+ *         WWW: http://www.cups.org
+ *
+ *   This file is subject to the Apple OS-Developed Software exception.
+ *
+ * Contents:
+ *
+ *   Setup()        - Prepare the printer for printing.
+ *   StartPage()    - Start a page of graphics.
+ *   EndPage()      - Finish a page of graphics.
+ *   CancelJob()    - Cancel the current job...
+ *   OutputLine()   - Output a line of graphics.
+ *   ZPLCompress()  - Output a run-length compression sequence.
+ *   main()         - Main entry and processing of driver.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include <cups/cups.h>
+#include <cups/string.h>
+#include "raster.h"
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <signal.h>
+
+
+/*
+ * This driver filter currently supports Dymo and Zebra label printers.
+ *
+ * The Dymo portion of the driver has been tested with the 300, 330,
+ * and 330 Turbo label printers; it may also work with older models.
+ * The Dymo printers support printing at 136, 203, and 300 DPI.
+ *
+ * The Zebra portion of the driver has been tested with the LP-2844Z label
+ * printer; it may also work with other models.  The driver supports EPL
+ * line mode, EPL page mode, ZPL, and CPCL as defined in Zebra's on-line
+ * developer documentation.
+ */
+
+/*
+ * Model number constants...
+ */
+
+#define DYMO_3x0	0		/* Dymo Labelwriter 300/330/330 Turbo */
+
+#define ZEBRA_EPL_LINE	0x10		/* Zebra EPL line mode printers */
+#define ZEBRA_EPL_PAGE	0x11		/* Zebra EPL page mode printers */
+#define ZEBRA_ZPL	0x12		/* Zebra ZPL-based printers */
+#define ZEBRA_CPCL	0x13		/* Zebra CPCL-based printers */
+
+
+/*
+ * Globals...
+ */
+
+unsigned char	*Buffer;		/* Output buffer */
+char		*CompBuffer;		/* Compression buffer */
+unsigned char	*LastBuffer;		/* Last buffer */
+int		LastSet;		/* Number of repeat characters */
+int		ModelNumber,		/* cupsModelNumber attribute */
+		Page,			/* Current page */
+		Feed,			/* Number of lines to skip */
+		Canceled;		/* Non-zero if job is canceled */
+
+
+/*
+ * Prototypes...
+ */
+
+void	Setup(ppd_file_t *ppd);
+void	StartPage(ppd_file_t *ppd, cups_page_header_t *header);
+void	EndPage(ppd_file_t *ppd, cups_page_header_t *header);
+void	CancelJob(int sig);
+void	OutputLine(ppd_file_t *ppd, cups_page_header_t *header, int y);
+void	ZPLCompress(char repeat_char, int repeat_count);
+
+
+/*
+ * 'Setup()' - Prepare the printer for printing.
+ */
+
+void
+Setup(ppd_file_t *ppd)			/* I - PPD file */
+{
+  int		i;			/* Looping var */
+
+
+ /*
+  * Get the model number from the PPD file...
+  */
+
+  if (ppd)
+    ModelNumber = ppd->model_number;
+
+ /*
+  * Initialize based on the model number...
+  */
+
+  switch (ModelNumber)
+  {
+    case DYMO_3x0 :
+       /*
+	* Clear any remaining data...
+	*/
+
+	for (i = 0; i < 100; i ++)
+	  putchar(0x1b);
+
+       /*
+	* Reset the printer...
+	*/
+
+	fputs("\033@", stdout);
+	break;
+
+    case ZEBRA_EPL_LINE :
+	break;
+
+    case ZEBRA_EPL_PAGE :
+	break;
+
+    case ZEBRA_ZPL :
+        break;
+
+    case ZEBRA_CPCL :
+        break;
+  }
+}
+
+
+/*
+ * 'StartPage()' - Start a page of graphics.
+ */
+
+void
+StartPage(ppd_file_t *ppd,		/* I - PPD file */
+          cups_page_header_t *header)	/* I - Page header */
+{
+  int	length;				/* Actual label length */
+#if defined(HAVE_SIGACTION) && !defined(HAVE_SIGSET)
+  struct sigaction action;		/* Actions for POSIX signals */
+#endif /* HAVE_SIGACTION && !HAVE_SIGSET */
+
+
+ /*
+  * Register a signal handler to eject the current page if the
+  * job is canceled.
+  */
+
+#ifdef HAVE_SIGSET /* Use System V signals over POSIX to avoid bugs */
+  sigset(SIGTERM, CancelJob);
+#elif defined(HAVE_SIGACTION)
+  memset(&action, 0, sizeof(action));
+
+  sigemptyset(&action.sa_mask);
+  action.sa_handler = CancelJob;
+  sigaction(SIGTERM, &action, NULL);
+#else
+  signal(SIGTERM, CancelJob);
+#endif /* HAVE_SIGSET */
+
+  switch (ModelNumber)
+  {
+    case DYMO_3x0 :
+       /*
+	* Setup printer/job attributes...
+	*/
+
+	length = header->PageSize[1] * header->HWResolution[1] / 72;
+
+	printf("\033L%c%c", length >> 8, length);
+	printf("\033D%c", header->cupsBytesPerLine);
+
+	printf("\033%c", header->cupsCompression + 'c'); /* Darkness */
+	break;
+
+    case ZEBRA_EPL_LINE :
+       /*
+        * Set darkness...
+	*/
+
+	printf("D%d", 7 * header->cupsCompression / 100);
+
+       /*
+        * Start buffered output...
+	*/
+
+        putchar('B');
+        break;
+
+    case ZEBRA_EPL_PAGE :
+       /*
+        * Set darkness...
+	*/
+
+	printf("D%d", 15 * header->cupsCompression / 100);
+
+       /*
+        * Set label size...
+	*/
+
+        printf("q%d\n", header->cupsWidth);
+        break;
+
+    case ZEBRA_ZPL :
+       /*
+        * Set darkness...
+	*/
+
+	if (header->cupsCompression > 0)
+	  printf("~SD%02d\n", 30 * header->cupsCompression / 100);
+
+       /*
+        * Start bitmap graphics...
+	*/
+
+        printf("~DGR:CUPS.GRF,%d,%d,\n",
+	       header->cupsHeight * header->cupsBytesPerLine,
+	       header->cupsBytesPerLine);
+
+       /*
+        * Allocate compression buffers...
+	*/
+
+	CompBuffer = malloc(2 * header->cupsBytesPerLine + 1);
+	LastBuffer = malloc(header->cupsBytesPerLine);
+	LastSet    = 0;
+        break;
+
+    case ZEBRA_CPCL :
+       /*
+        * Start label...
+	*/
+
+        printf("!0 %u %u %u %u\r\n", header->HWResolution[0],
+	       header->HWResolution[1], header->cupsHeight,
+	       header->NumCopies);
+        break;
+  }
+
+ /*
+  * Allocate memory for a line of graphics...
+  */
+
+  Buffer = malloc(header->cupsBytesPerLine);
+  Feed   = 0;
+}
+
+
+/*
+ * 'EndPage()' - Finish a page of graphics.
+ */
+
+void
+EndPage(ppd_file_t *ppd,		/* I - PPD file */
+        cups_page_header_t *header)	/* I - Page header */
+{
+  int		val;			/* Option value */
+  ppd_choice_t	*choice;		/* Marked choice */
+#if defined(HAVE_SIGACTION) && !defined(HAVE_SIGSET)
+  struct sigaction action;		/* Actions for POSIX signals */
+#endif /* HAVE_SIGACTION && !HAVE_SIGSET */
+
+
+  switch (ModelNumber)
+  {
+    case DYMO_3x0 :
+       /*
+	* Eject the current page...
+	*/
+
+	fputs("\033E", stdout);
+	break;
+
+    case ZEBRA_EPL_LINE :
+       /*
+        * End buffered output, eject the label...
+	*/
+
+        putchar('E');
+	break;
+
+    case ZEBRA_EPL_PAGE :
+       /*
+        * Print the label...
+	*/
+
+        puts("P1");
+	break;
+
+    case ZEBRA_ZPL :
+        if (Canceled)
+	{
+	 /*
+	  * Cancel bitmap download...
+	  */
+
+	  puts("~DN");
+	  break;
+	}
+
+       /*
+        * Start label...
+	*/
+
+        puts("^XA");
+
+       /*
+        * Set print rate...
+	*/
+
+	if ((choice = ppdFindMarkedChoice(ppd, "zePrintRate")) != NULL &&
+	    strcmp(choice->choice, "Default"))
+	{
+	  val = atoi(choice->choice);
+	  printf("^PR%d,%d,%d\n", val, val, val);
+	}
+
+       /*
+        * Put label home in default position (0,0)...
+        */
+
+	printf("^LH0,0\n");
+
+       /*
+        * Set media tracking...
+	*/
+
+	if (ppdIsMarked(ppd, "zeMediaTracking", "Continuous"))
+	{
+         /*
+	  * Add label length command for continuous...
+	  */
+
+	  printf("^LL%d\n", header->cupsHeight);
+	  printf("^MNN\n");
+	}
+	else if (ppdIsMarked(ppd, "zeMediaTracking", "Web"))
+          printf("^MNY\n");
+	else if (ppdIsMarked(ppd, "zeMediaTracking", "Mark"))
+	  printf("^MNM\n");
+
+       /*
+        * Set label top
+	*/
+
+	if (header->cupsRowStep != 200)
+	  printf("^LT%u\n", header->cupsRowStep);
+
+       /*
+        * Set media type...
+	*/
+
+	if (!strcmp(header->MediaType, "Thermal"))
+	  printf("^MTT\n");
+	else if (!strcmp(header->MediaType, "Direct"))
+	  printf("^MTD\n");
+
+       /*
+        * Set print mode...
+	*/
+
+	if ((choice = ppdFindMarkedChoice(ppd, "zePrintMode")) != NULL &&
+	    strcmp(choice->choice, "Saved"))
+	{
+	  printf("^MM");
+
+	  if (!strcmp(choice->choice, "Tear"))
+	    printf("T,Y\n");
+	  else if (!strcmp(choice->choice, "Peel"))
+	    printf("P,Y\n");
+	  else if (!strcmp(choice->choice, "Rewind"))
+	    printf("R,Y\n");
+	  else if (!strcmp(choice->choice, "Applicator"))
+	    printf("A,Y\n");
+	  else
+	    printf("C,Y\n");
+	}
+
+       /*
+        * Set tear-off adjust position...
+	*/
+
+	if (header->AdvanceDistance != 1000)
+	{
+	  if ((int)header->AdvanceDistance < 0)
+	    printf("~TA%04d\n", (int)header->AdvanceDistance);
+	  else
+	    printf("~TA%03d\n", (int)header->AdvanceDistance);
+	}
+
+       /*
+        * Allow for reprinting after an error...
+	*/
+
+	if (ppdIsMarked(ppd, "zeErrorReprint", "Always"))
+	  printf("^JZY\n");
+	else if (ppdIsMarked(ppd, "zeErrorReprint", "Never"))
+	  printf("^JZN\n");
+
+       /*
+        * Print multiple copies
+	*/
+
+	if (header->NumCopies > 1)
+	  printf("^PQ%d, 0, 0, N\n", header->NumCopies);
+
+       /*
+        * Display the label image...
+	*/
+
+	puts("^FO0,0^XGR:CUPS.GRF,1,1^FS");
+
+       /*
+        * End the label and eject...
+	*/
+
+        puts("^XZ");
+
+       /*
+        * Free compression buffers...
+	*/
+
+	free(CompBuffer);
+	free(LastBuffer);
+        break;
+
+    case ZEBRA_CPCL :
+       /*
+        * Set tear-off adjust position...
+	*/
+
+	if (header->AdvanceDistance)
+          printf("PRESENT-AT %d 1\r\n", (int)header->AdvanceDistance);
+
+       /*
+        * Allow for reprinting after an error...
+	*/
+
+	if (ppdIsMarked(ppd, "zeErrorReprint", "Always"))
+	  puts("ON-OUT-OF-PAPER WAIT\r");
+	else if (ppdIsMarked(ppd, "zeErrorReprint", "Never"))
+	  puts("ON-OUT-OF-PAPER PURGE\r");
+
+       /*
+        * Cut label?
+	*/
+
+	if (header->CutMedia)
+	  puts("CUT\r");
+
+       /*
+        * Set darkness...
+	*/
+
+	if (header->cupsCompression > 0)
+	  printf("TONE %u\n", 2 * header->cupsCompression);
+
+       /*
+        * Set print rate...
+	*/
+
+	if ((choice = ppdFindMarkedChoice(ppd, "zePrintRate")) != NULL &&
+	    strcmp(choice->choice, "Default"))
+	{
+	  val = atoi(choice->choice);
+	  printf("SPEED %d\r\n", val);
+	}
+
+       /*
+        * Print the label...
+	*/
+
+        puts("FORM\r");
+	puts("PRINT\r");
+	break;
+  }
+
+  fflush(stdout);
+
+ /*
+  * Unregister the signal handler...
+  */
+
+#ifdef HAVE_SIGSET /* Use System V signals over POSIX to avoid bugs */
+  sigset(SIGTERM, SIG_IGN);
+#elif defined(HAVE_SIGACTION)
+  memset(&action, 0, sizeof(action));
+
+  sigemptyset(&action.sa_mask);
+  action.sa_handler = SIG_IGN;
+  sigaction(SIGTERM, &action, NULL);
+#else
+  signal(SIGTERM, SIG_IGN);
+#endif /* HAVE_SIGSET */
+
+ /*
+  * Free memory...
+  */
+
+  free(Buffer);
+}
+
+
+/*
+ * 'CancelJob()' - Cancel the current job...
+ */
+
+void
+CancelJob(int sig)			/* I - Signal */
+{
+ /*
+  * Tell the main loop to stop...
+  */
+
+  (void)sig;
+
+  Canceled = 1;
+}
+
+
+/*
+ * 'OutputLine()' - Output a line of graphics...
+ */
+
+void
+OutputLine(ppd_file_t         *ppd,	/* I - PPD file */
+           cups_page_header_t *header,	/* I - Page header */
+           int                y)	/* I - Line number */
+{
+  int		i;			/* Looping var */
+  unsigned char	*ptr;			/* Pointer into buffer */
+  char		*compptr;		/* Pointer into compression buffer */
+  char		repeat_char;		/* Repeated character */
+  int		repeat_count;		/* Number of repeated characters */
+  static const char *hex = "0123456789ABCDEF";
+					/* Hex digits */
+
+
+  switch (ModelNumber)
+  {
+    case DYMO_3x0 :
+       /*
+	* See if the line is blank; if not, write it to the printer...
+	*/
+
+	if (Buffer[0] ||
+            memcmp(Buffer, Buffer + 1, header->cupsBytesPerLine - 1))
+	{
+          if (Feed)
+	  {
+	    while (Feed > 255)
+	    {
+	      printf("\033f\001%c", 255);
+	      Feed -= 255;
+	    }
+
+	    printf("\033f\001%c", Feed);
+	    Feed = 0;
+          }
+
+          putchar(0x16);
+	  fwrite(Buffer, header->cupsBytesPerLine, 1, stdout);
+	  fflush(stdout);
+
+#ifdef __sgi
+	 /*
+          * This hack works around a bug in the IRIX serial port driver when
+	  * run at high baud rates (e.g. 115200 baud)...  This results in
+	  * slightly slower label printing, but at least the labels come
+	  * out properly.
+	  */
+
+	  sginap(1);
+#endif /* __sgi */
+	}
+	else
+          Feed ++;
+	break;
+
+    case ZEBRA_EPL_LINE :
+        printf("g%03d", header->cupsBytesPerLine);
+	fwrite(Buffer, 1, header->cupsBytesPerLine, stdout);
+	fflush(stdout);
+        break;
+
+    case ZEBRA_EPL_PAGE :
+        printf("GW0,%d,%d,1", y, header->cupsBytesPerLine);
+	fwrite(Buffer, 1, header->cupsBytesPerLine, stdout);
+	putchar('\n');
+	fflush(stdout);
+        break;
+
+    case ZEBRA_ZPL :
+       /*
+	* Determine if this row is the same as the previous line.
+        * If so, output a ':' and return...
+        */
+
+        if (LastSet)
+	{
+	  if (!memcmp(Buffer, LastBuffer, header->cupsBytesPerLine))
+	  {
+	    putchar(':');
+	    return;
+	  }
+	}
+
+       /*
+        * Convert the line to hex digits...
+	*/
+
+	for (ptr = Buffer, compptr = CompBuffer, i = header->cupsBytesPerLine;
+	     i > 0;
+	     i --, ptr ++)
+        {
+	  *compptr++ = hex[*ptr >> 4];
+	  *compptr++ = hex[*ptr & 15];
+	}
+
+        *compptr = '\0';
+
+       /*
+        * Run-length compress the graphics...
+	*/
+
+	for (compptr = CompBuffer, repeat_char = CompBuffer[0], repeat_count = 1;
+	     *compptr;
+	     compptr ++)
+	  if (*compptr == repeat_char)
+	    repeat_count ++;
+	  else
+	  {
+	    ZPLCompress(repeat_char, repeat_count);
+	    repeat_char  = *compptr;
+	    repeat_count = 1;
+	  }
+
+        if (repeat_char == '0')
+	{
+	 /*
+	  * Handle 0's on the end of the line...
+	  */
+
+	  if (repeat_count & 1)
+	    putchar('0');
+
+	  putchar(',');
+	}
+	else
+	  ZPLCompress(repeat_char, repeat_count);
+
+       /*
+        * Save this line for the next round...
+	*/
+
+	memcpy(LastBuffer, Buffer, header->cupsBytesPerLine);
+	LastSet = 1;
+        break;
+
+    case ZEBRA_CPCL :
+        printf("CG %u 1 0 %d ", header->cupsBytesPerLine, y);
+
+	for (ptr = Buffer, i = header->cupsBytesPerLine;
+	     i > 0;
+	     i --, ptr ++)
+        {
+	  putchar(hex[*ptr >> 4]);
+	  putchar(hex[*ptr & 15]);
+	}
+
+	puts("\r");
+	break;
+  }
+}
+
+
+/*
+ * 'ZPLCompress()' - Output a run-length compression sequence.
+ */
+
+void
+ZPLCompress(char repeat_char,		/* I - Character to repeat */
+	    int  repeat_count)		/* I - Number of repeated characters */
+{
+  if (repeat_count > 1)
+  {
+   /*
+    * Print as many z's as possible - they are the largest denomination
+    * representing 400 characters (zC stands for 400 adjacent C's)	
+    */	
+
+    while (repeat_count >= 400)
+    {
+      putchar('z');
+      repeat_count -= 400;
+    }
+
+   /*
+    * Then print 'g' through 'y' as multiples of 20 characters...
+    */
+
+    if (repeat_count >= 20)
+    {
+      putchar('f' + repeat_count / 20);
+      repeat_count %= 20;
+    }
+
+   /*
+    * Finally, print 'G' through 'Y' as 1 through 19 characters...
+    */
+
+    if (repeat_count > 0)
+      putchar('F' + repeat_count);
+  }
+
+ /*
+  * Then the character to be repeated...
+  */
+
+  putchar(repeat_char);
+}
+
+
+/*
+ * 'main()' - Main entry and processing of driver.
+ */
+
+int					/* O - Exit status */
+main(int  argc,				/* I - Number of command-line arguments */
+     char *argv[])			/* I - Command-line arguments */
+{
+  int			fd;		/* File descriptor */
+  cups_raster_t		*ras;		/* Raster stream for printing */
+  cups_page_header_t	header;		/* Page header from file */
+  int			y;		/* Current line */
+  ppd_file_t		*ppd;		/* PPD file */
+  int			num_options;	/* Number of options */
+  cups_option_t		*options;	/* Options */
+
+
+ /*
+  * Make sure status messages are not buffered...
+  */
+
+  setbuf(stderr, NULL);
+
+ /*
+  * Check command-line...
+  */
+
+  if (argc < 6 || argc > 7)
+  {
+   /*
+    * We don't have the correct number of arguments; write an error message
+    * and return.
+    */
+
+    fputs("ERROR: rastertodymo job-id user title copies options [file]\n", stderr);
+    return (1);
+  }
+
+ /*
+  * Open the page stream...
+  */
+
+  if (argc == 7)
+  {
+    if ((fd = open(argv[6], O_RDONLY)) == -1)
+    {
+      perror("ERROR: Unable to open raster file - ");
+      sleep(1);
+      return (1);
+    }
+  }
+  else
+    fd = 0;
+
+  ras = cupsRasterOpen(fd, CUPS_RASTER_READ);
+
+ /*
+  * Open the PPD file and apply options...
+  */
+
+  num_options = cupsParseOptions(argv[5], 0, &options);
+
+  if ((ppd = ppdOpenFile(getenv("PPD"))) != NULL)
+  {
+    ppdMarkDefaults(ppd);
+    cupsMarkOptions(ppd, num_options, options);
+  }
+
+ /*
+  * Initialize the print device...
+  */
+
+  Setup(ppd);
+
+ /*
+  * Process pages as needed...
+  */
+
+  Page      = 0;
+  Canceled = 0;
+
+  while (cupsRasterReadHeader(ras, &header))
+  {
+   /*
+    * Write a status message with the page number and number of copies.
+    */
+
+    Page ++;
+
+    fprintf(stderr, "PAGE: %d 1\n", Page);
+
+   /*
+    * Start the page...
+    */
+
+    StartPage(ppd, &header);
+
+   /*
+    * Loop for each line on the page...
+    */
+
+    for (y = 0; y < header.cupsHeight && !Canceled; y ++)
+    {
+     /*
+      * Let the user know how far we have progressed...
+      */
+
+      if ((y & 15) == 0)
+        fprintf(stderr, "INFO: Printing page %d, %d%% complete...\n", Page,
+	        100 * y / header.cupsHeight);
+
+     /*
+      * Read a line of graphics...
+      */
+
+      if (cupsRasterReadPixels(ras, Buffer, header.cupsBytesPerLine) < 1)
+        break;
+
+     /*
+      * Write it to the printer...
+      */
+
+      OutputLine(ppd, &header, y);
+    }
+
+   /*
+    * Eject the page...
+    */
+
+    EndPage(ppd, &header);
+
+    if (Canceled)
+      break;
+  }
+
+ /*
+  * Close the raster stream...
+  */
+
+  cupsRasterClose(ras);
+  if (fd != 0)
+    close(fd);
+
+ /*
+  * Close the PPD file and free the options...
+  */
+
+  ppdClose(ppd);
+  cupsFreeOptions(num_options, options);
+
+ /*
+  * If no pages were printed, send an error message...
+  */
+
+  if (Page == 0)
+    fputs("ERROR: No pages found!\n", stderr);
+  else
+    fputs("INFO: Ready to print.\n", stderr);
+
+  return (Page == 0);
+}
+
+
+/*
+ * End of "$Id: rastertolabel.c 4804 2005-10-20 14:05:42Z mike $".
+ */
diff -urNad cupsys-1.1.99.b1.r4748~/filter/texttops.dsp cupsys-1.1.99.b1.r4748/filter/texttops.dsp
--- cupsys-1.1.99.b1.r4748~/filter/texttops.dsp	1999-03-21 11:10:17.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/filter/texttops.dsp	1970-01-01 09:00:00.000000000 +0900
@@ -1,98 +0,0 @@
-# Microsoft Developer Studio Project File - Name="texttops" - Package Owner=<4>
-# Microsoft Developer Studio Generated Build File, Format Version 6.00
-# ** DO NOT EDIT **
-
-# TARGTYPE "Win32 (x86) Console Application" 0x0103
-
-CFG=texttops - Win32 Debug
-!MESSAGE This is not a valid makefile. To build this project using NMAKE,
-!MESSAGE use the Export Makefile command and run
-!MESSAGE 
-!MESSAGE NMAKE /f "texttops.mak".
-!MESSAGE 
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f "texttops.mak" CFG="texttops - Win32 Debug"
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE "texttops - Win32 Release" (based on "Win32 (x86) Console Application")
-!MESSAGE "texttops - Win32 Debug" (based on "Win32 (x86) Console Application")
-!MESSAGE 
-
-# Begin Project
-# PROP AllowPerConfigDependencies 0
-# PROP Scc_ProjName ""
-# PROP Scc_LocalPath ""
-CPP=cl.exe
-RSC=rc.exe
-
-!IF  "$(CFG)" == "texttops - Win32 Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "Release"
-# PROP BASE Intermediate_Dir "Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Release"
-# PROP Intermediate_Dir "Release"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
-# ADD CPP /nologo /MT /W1 /GX /O2 /I ".." /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
-# ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib  kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 ../cups/cups.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib  kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:"texttops.exe"
-
-!ELSEIF  "$(CFG)" == "texttops - Win32 Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "Debug"
-# PROP BASE Intermediate_Dir "Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Debug"
-# PROP Intermediate_Dir "Debug"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ  /c
-# ADD CPP /nologo /MTd /W1 /Gm /GX /Zi /Od /I ".." /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ  /c
-# ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib  kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 ../cups/cupsd.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib  kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /incremental:no /debug /machine:I386 /out:"texttopsd.exe" /pdbtype:sept
-
-!ENDIF 
-
-# Begin Target
-
-# Name "texttops - Win32 Release"
-# Name "texttops - Win32 Debug"
-# Begin Group "Source Files"
-
-# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-# Begin Source File
-
-SOURCE=.\texttops.c
-# End Source File
-# End Group
-# Begin Group "Header Files"
-
-# PROP Default_Filter "h;hpp;hxx;hm;inl"
-# End Group
-# End Target
-# End Project
diff -urNad cupsys-1.1.99.b1.r4748~/man/Makefile cupsys-1.1.99.b1.r4748/man/Makefile
--- cupsys-1.1.99.b1.r4748~/man/Makefile	2005-09-27 04:33:58.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/man/Makefile	2005-11-13 06:46:52.687523000 +0900
@@ -1,5 +1,5 @@
 #
-# "$Id: Makefile 4703 2005-09-26 19:33:58Z mike $"
+# "$Id: Makefile 4833 2005-11-12 21:46:52Z mike $"
 #
 #   Man page makefile for the Common UNIX Printing System (CUPS).
 #
@@ -29,66 +29,39 @@
 # Man pages...
 #
 
-MAN1	=	backend.man \
-		cups-config.man \
-		cupstestppd.man \
-		filter.man \
-		lp.man \
-		lpoptions.man \
-		lppasswd.man \
-		lpq.man \
-		lprm.man \
-		lpr.man \
-		lpstat.man
-MAN5	=	classes.conf.man \
-		cupsd.conf.man \
-		mime.convs.man \
-		mime.types.man \
-		printers.conf.man
-MAN8	=	accept.man \
-		cupsaddsmb.man \
-		cups-lpd.man \
-		cups-polld.man \
-		cupsd.man \
-		enable.man \
-		lpadmin.man \
-		lpinfo.man \
-		lpmove.man \
-		lpc.man
-
-CAT1	=	backend.$(CAT1EXT) \
-		cups-config.$(CAT1EXT) \
-		cupstestppd.$(CAT1EXT) \
-		filter.$(CAT1EXT) \
-		lp.$(CAT1EXT) \
-		lpoptions.$(CAT1EXT) \
-		lppasswd.$(CAT1EXT) \
-		lpq.$(CAT1EXT) \
-		lprm.$(CAT1EXT) \
-		lpr.$(CAT1EXT) \
-		lpstat.$(CAT1EXT)
-CAT5	=	classes.conf.$(CAT5EXT) \
-		cupsd.conf.$(CAT5EXT) \
-		mime.convs.$(CAT5EXT) \
-		mime.types.$(CAT5EXT) \
-		printers.conf.$(CAT5EXT)
-CAT8	=	accept.$(CAT8EXT) \
-		cupsaddsmb.$(CAT8EXT) \
-		cups-lpd.$(CAT8EXT) \
-		cups-polld.$(CAT8EXT) \
-		cupsd.$(CAT8EXT) \
-		enable.$(CAT8EXT) \
-		lpadmin.$(CAT8EXT) \
-		lpinfo.$(CAT8EXT) \
-		lpmove.$(CAT8EXT) \
-		lpc.$(CAT8EXT)
+MAN1	=	backend.$(MAN1EXT) \
+		cups-config.$(MAN1EXT) \
+		cupstestppd.$(MAN1EXT) \
+		filter.$(MAN1EXT) \
+		lp.$(MAN1EXT) \
+		lpoptions.$(MAN1EXT) \
+		lppasswd.$(MAN1EXT) \
+		lpq.$(MAN1EXT) \
+		lprm.$(MAN1EXT) \
+		lpr.$(MAN1EXT) \
+		lpstat.$(MAN1EXT)
+MAN5	=	classes.conf.$(MAN5EXT) \
+		cupsd.conf.$(MAN5EXT) \
+		mime.convs.$(MAN5EXT) \
+		mime.types.$(MAN5EXT) \
+		printers.conf.$(MAN5EXT)
+MAN8	=	accept.$(MAN8EXT) \
+		cupsaddsmb.$(MAN8EXT) \
+		cups-lpd.$(MAN8EXT) \
+		cups-polld.$(MAN8EXT) \
+		cupsd.$(MAN8EXT) \
+		cupsenable.$(MAN8EXT) \
+		lpadmin.$(MAN8EXT) \
+		lpinfo.$(MAN8EXT) \
+		lpmove.$(MAN8EXT) \
+		lpc.$(MAN8EXT)
 
 
 #
 # Make everything...
 #
 
-all:	$(CAT1) $(CAT5) $(CAT8)
+all:	$(MAN1) $(MAN5) $(MAN8)
 
 
 #
@@ -96,7 +69,7 @@
 #
 
 clean:
-	$(RM) $(CAT1) $(CAT5) $(CAT8)
+	$(RM) $(MAN1) $(MAN5) $(MAN8)
 
 
 #
@@ -114,47 +87,26 @@
 	$(INSTALL_DIR) $(MANDIR)/man1
 	for file in $(MAN1); do \
 		echo Installing $$file in $(MANDIR)/man1...; \
-		$(INSTALL_MAN) $$file $(MANDIR)/man1/`basename $$file man`1; \
+		$(INSTALL_MAN) $$file $(MANDIR)/man1; \
 	done
-	$(RM) $(MANDIR)/man1/cancel.1
-	$(LN) lp.1 $(MANDIR)/man1/cancel.1
+	$(RM) $(MANDIR)/man1/cancel.$(MAN1EXT)
+	$(LN) lp.$(MAN1EXT) $(MANDIR)/man1/cancel.$(MAN1EXT)
 	$(INSTALL_DIR) $(MANDIR)/man5
 	for file in $(MAN5); do \
 		echo Installing $$file in $(MANDIR)/man5...; \
-		$(INSTALL_MAN) $$file $(MANDIR)/man5/`basename $$file man`5; \
+		$(INSTALL_MAN) $$file $(MANDIR)/man5; \
 	done
 	$(INSTALL_DIR) $(AMANDIR)/man$(MAN8EXT)
 	for file in $(MAN8); do \
 		echo Installing $$file in $(AMANDIR)/man$(MAN8EXT)...; \
-		$(INSTALL_MAN) $$file $(AMANDIR)/man$(MAN8EXT)/`basename $$file man`$(MAN8EXT); \
+		$(INSTALL_MAN) $$file $(AMANDIR)/man$(MAN8EXT); \
 	done
 	$(RM) $(AMANDIR)/man$(MAN8EXT)/reject.$(MAN8EXT)
 	$(LN) accept.$(MAN8EXT) $(AMANDIR)/man$(MAN8EXT)/reject.$(MAN8EXT)
-	$(RM) $(AMANDIR)/man$(MAN8EXT)/disable.$(MAN8EXT)
-	$(LN) enable.$(MAN8EXT) $(AMANDIR)/man$(MAN8EXT)/disable.$(MAN8EXT)
-	$(INSTALL_DIR) $(MANDIR)/cat1
-	for file in $(CAT1); do \
-		echo Installing $$file in $(MANDIR)/cat1...; \
-		$(INSTALL_MAN) $$file $(MANDIR)/cat1; \
-	done
-	$(RM) $(MANDIR)/cat1/cancel.$(CAT1EXT)
-	$(LN) lp.$(CAT1EXT) $(MANDIR)/cat1/cancel.$(CAT1EXT)
-	$(INSTALL_DIR) $(MANDIR)/cat5
-	for file in $(CAT5); do \
-		echo Installing $$file in $(MANDIR)/cat5...; \
-		$(INSTALL_MAN) $$file $(MANDIR)/cat5; \
-	done
-	$(INSTALL_DIR) $(AMANDIR)/cat$(MAN8EXT)
-	for file in $(CAT8); do \
-		echo Installing $$file in $(AMANDIR)/cat$(MAN8EXT)...; \
-		$(INSTALL_MAN) $$file $(AMANDIR)/cat$(MAN8EXT); \
-	done
-	$(RM) $(AMANDIR)/cat$(MAN8EXT)/reject.$(CAT8EXT)
-	$(LN) accept.$(CAT8EXT) $(AMANDIR)/cat$(MAN8EXT)/reject.$(CAT8EXT)
-	$(RM) $(AMANDIR)/cat$(MAN8EXT)/disable.$(CAT8EXT)
-	$(LN) enable.$(CAT8EXT) $(AMANDIR)/cat$(MAN8EXT)/disable.$(CAT8EXT)
+	$(RM) $(AMANDIR)/man$(MAN8EXT)/cupsdisable.$(MAN8EXT)
+	$(LN) cupsenable.$(MAN8EXT) $(AMANDIR)/man$(MAN8EXT)/cupsdisable.$(MAN8EXT)
 
 
 #
-# End of "$Id: Makefile 4703 2005-09-26 19:33:58Z mike $".
+# End of "$Id: Makefile 4833 2005-11-12 21:46:52Z mike $".
 #
diff -urNad cupsys-1.1.99.b1.r4748~/man/cupsd.conf.man cupsys-1.1.99.b1.r4748/man/cupsd.conf.man
--- cupsys-1.1.99.b1.r4748~/man/cupsd.conf.man	2005-10-01 09:34:49.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/man/cupsd.conf.man	2005-11-05 03:39:32.279708000 +0900
@@ -1,5 +1,5 @@
 .\"
-.\" "$Id: cupsd.conf.man 4733 2005-10-01 00:34:49Z mike $"
+.\" "$Id: cupsd.conf.man 4819 2005-11-04 18:39:32Z mike $"
 .\"
 .\"   cupsd.conf man page for the Common UNIX Printing System (CUPS).
 .\"
@@ -21,7 +21,7 @@
 .\"       EMail: cups-info@cups.org
 .\"         WWW: http://www.cups.org
 .\"
-.TH cupsd.conf 5 "Common UNIX Printing System" "30 September 2005" "Easy Software Products"
+.TH cupsd.conf 5 "Common UNIX Printing System" "4 November 2005" "Easy Software Products"
 .SH NAME
 cupsd.conf \- server configuration file for cups
 .SH DESCRIPTION
@@ -172,14 +172,6 @@
 .br
 Specifies the error log filename.
 .TP 5
-FaxRetryInterval
-.br
-Specifies the interval between retries of fax jobs in seconds.
-.TP 5
-FaxRetryLimit
-.br
-Specifies the number of retries that are done for fax jobs.
-.TP 5
 FileDevice
 .br
 Specifies whether the file pseudo-device can be used for new
@@ -226,6 +218,14 @@
 .br
 Includes the named file.
 .TP 5
+JobRetryInterval
+.br
+Specifies the interval between retries of jobs in seconds.
+.TP 5
+JobRetryLimit
+.br
+Specifies the number of retries that are done for jobs.
+.TP 5
 KeepAlive
 .br
 Specifies whether or not to support HTTP Keep-Alive.
@@ -439,5 +439,5 @@
 .SH COPYRIGHT
 Copyright 1993-2005 by Easy Software Products, All Rights Reserved.
 .\"
-.\" End of "$Id: cupsd.conf.man 4733 2005-10-01 00:34:49Z mike $".
+.\" End of "$Id: cupsd.conf.man 4819 2005-11-04 18:39:32Z mike $".
 .\"
diff -urNad cupsys-1.1.99.b1.r4748~/man/cupsenable.man cupsys-1.1.99.b1.r4748/man/cupsenable.man
--- cupsys-1.1.99.b1.r4748~/man/cupsenable.man	1970-01-01 09:00:00.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/man/cupsenable.man	2005-11-13 06:46:52.687523000 +0900
@@ -0,0 +1,67 @@
+.\"
+.\" "$Id: cupsenable.man 4833 2005-11-12 21:46:52Z mike $"
+.\"
+.\"   enable/disable man page for the Common UNIX Printing System (CUPS).
+.\"
+.\"   Copyright 1997-2005 by Easy Software Products.
+.\"
+.\"   These coded instructions, statements, and computer programs are the
+.\"   property of Easy Software Products and are protected by Federal
+.\"   copyright law.  Distribution and use rights are outlined in the file
+.\"   "LICENSE.txt" which should have been included with this file.  If this
+.\"   file is missing or damaged please contact Easy Software Products
+.\"   at:
+.\"
+.\"       Attn: CUPS Licensing Information
+.\"       Easy Software Products
+.\"       44141 Airport View Drive, Suite 204
+.\"       Hollywood, Maryland 20636 USA
+.\"
+.\"       Voice: (301) 373-9600
+.\"       EMail: cups-info@cups.org
+.\"         WWW: http://www.cups.org
+.\"
+.TH enable 8 "Common UNIX Printing System" "23 January 2001" "Easy Software Products"
+.SH NAME
+disable, enable \- stop/start printers and classes
+.SH SYNOPSIS
+.B disable
+[ -E ] [ \-c ] [ -h
+.I server
+] [ \-r
+.I reason
+] destination(s)
+.br
+.B enable
+[ -E ] destination(s)
+.SH DESCRIPTION
+\fIenable\fR starts the named printers or classes.
+.LP
+\fIdisable\fR stops the named printers or classes.  The following options may
+be used:
+.TP 5
+\-c
+.br
+Cancels all jobs on the named destination.
+.TP 5
+\-r [ \fIreason\fR ]
+.br
+Sets the message associated with the stopped state. If no reason is specified
+then the message is set to "Reason Unknown".
+.LP
+The \fI-E\fR option forces encryption when connecting to the server.
+.SH COMPATIBILITY
+The CUPS versions of \fIdisable\fR and \fIenable\fR may ask the user for an
+access password depending on the printing system configuration.  This differs
+from the System V versions which require the root user to execute these
+commands.
+.SH SEE ALSO
+accept(8), cancel(1), lp(1), lpadmin(8), lpstat(1), reject(8),
+CUPS Software Administrators Manual,
+http://localhost:631/documentation.html
+.SH COPYRIGHT
+Copyright 1993-2005 by Easy Software Products, All Rights Reserved.
+
+.\"
+.\" End of "$Id: cupsenable.man 4833 2005-11-12 21:46:52Z mike $".
+.\"
diff -urNad cupsys-1.1.99.b1.r4748~/man/enable.man cupsys-1.1.99.b1.r4748/man/enable.man
--- cupsys-1.1.99.b1.r4748~/man/enable.man	2005-02-18 11:09:53.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/man/enable.man	1970-01-01 09:00:00.000000000 +0900
@@ -1,67 +0,0 @@
-.\"
-.\" "$Id: enable.man 4493 2005-02-18 02:09:53Z mike $"
-.\"
-.\"   enable/disable man page for the Common UNIX Printing System (CUPS).
-.\"
-.\"   Copyright 1997-2005 by Easy Software Products.
-.\"
-.\"   These coded instructions, statements, and computer programs are the
-.\"   property of Easy Software Products and are protected by Federal
-.\"   copyright law.  Distribution and use rights are outlined in the file
-.\"   "LICENSE.txt" which should have been included with this file.  If this
-.\"   file is missing or damaged please contact Easy Software Products
-.\"   at:
-.\"
-.\"       Attn: CUPS Licensing Information
-.\"       Easy Software Products
-.\"       44141 Airport View Drive, Suite 204
-.\"       Hollywood, Maryland 20636 USA
-.\"
-.\"       Voice: (301) 373-9600
-.\"       EMail: cups-info@cups.org
-.\"         WWW: http://www.cups.org
-.\"
-.TH enable 8 "Common UNIX Printing System" "23 January 2001" "Easy Software Products"
-.SH NAME
-disable, enable \- stop/start printers and classes
-.SH SYNOPSIS
-.B disable
-[ -E ] [ \-c ] [ -h
-.I server
-] [ \-r
-.I reason
-] destination(s)
-.br
-.B enable
-[ -E ] destination(s)
-.SH DESCRIPTION
-\fIenable\fR starts the named printers or classes.
-.LP
-\fIdisable\fR stops the named printers or classes.  The following options may
-be used:
-.TP 5
-\-c
-.br
-Cancels all jobs on the named destination.
-.TP 5
-\-r [ \fIreason\fR ]
-.br
-Sets the message associated with the stopped state. If no reason is specified
-then the message is set to "Reason Unknown".
-.LP
-The \fI-E\fR option forces encryption when connecting to the server.
-.SH COMPATIBILITY
-The CUPS versions of \fIdisable\fR and \fIenable\fR may ask the user for an
-access password depending on the printing system configuration.  This differs
-from the System V versions which require the root user to execute these
-commands.
-.SH SEE ALSO
-accept(8), cancel(1), lp(1), lpadmin(8), lpstat(1), reject(8),
-CUPS Software Administrators Manual,
-http://localhost:631/documentation.html
-.SH COPYRIGHT
-Copyright 1993-2005 by Easy Software Products, All Rights Reserved.
-
-.\"
-.\" End of "$Id: enable.man 4493 2005-02-18 02:09:53Z mike $".
-.\"
diff -urNad cupsys-1.1.99.b1.r4748~/notifier/Dependencies cupsys-1.1.99.b1.r4748/notifier/Dependencies
--- cupsys-1.1.99.b1.r4748~/notifier/Dependencies	1970-01-01 09:00:00.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/notifier/Dependencies	2005-11-12 12:15:10.305626000 +0900
@@ -0,0 +1,11 @@
+# DO NOT DELETE
+
+indp.o: ../cups/cups.h ../cups/ipp.h ../cups/http.h ../cups/md5.h
+indp.o: ../cups/ppd.h ../cups/file.h ../cups/language.h ../cups/string.h
+indp.o: ../config.h
+mailto.o: ../cups/cups.h ../cups/ipp.h ../cups/http.h ../cups/md5.h
+mailto.o: ../cups/ppd.h ../cups/file.h ../cups/language.h ../cups/string.h
+mailto.o: ../config.h
+testnotify.o: ../cups/cups.h ../cups/ipp.h ../cups/http.h ../cups/md5.h
+testnotify.o: ../cups/ppd.h ../cups/file.h ../cups/language.h
+testnotify.o: ../cups/string.h ../config.h
diff -urNad cupsys-1.1.99.b1.r4748~/notifier/Makefile cupsys-1.1.99.b1.r4748/notifier/Makefile
--- cupsys-1.1.99.b1.r4748~/notifier/Makefile	2005-02-18 11:18:11.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/notifier/Makefile	2005-11-13 06:55:57.819980000 +0900
@@ -1,5 +1,5 @@
 #
-# "$Id: Makefile 4494 2005-02-18 02:18:11Z mike $"
+# "$Id: Makefile 4834 2005-11-12 21:55:57Z mike $"
 #
 #   Notifier makefile for the Common UNIX Printing System (CUPS).
 #
@@ -24,8 +24,9 @@
 
 include ../Makedefs
 
-TARGETS =	indp mailto
-OBJS	=	indp.o mailto.o
+
+TARGETS =	mailto testnotify
+OBJS	=	mailto.o testnotify.o
 
 
 #
@@ -48,22 +49,18 @@
 #
 
 install:
-	-$(MKDIR) $(SERVERBIN)/notifier
-	$(CHMOD) ugo+rx $(SERVERBIN)
-	$(CHMOD) ugo+rx $(SERVERBIN)/notifier
-	$(INSTALL_BIN) $(TARGETS) $(SERVERBIN)/notifier
+	$(INSTALL_DIR) $(SERVERBIN)/notifier
+	for file in $(TARGETS); do \
+		$(INSTALL_BIN) $$file $(SERVERBIN)/notifier; \
+	done
 
 
 #
-# indp
+# Update dependencies (without system header dependencies...)
 #
 
-indp:	indp.o ../cups/$(LIBCUPS)
-	echo Linking $@...
-	$(CC) $(LDFLAGS) -o indp indp.o $(LIBS)
-
-indp.o:	../cups/cups.h ../cups/ipp.h ../cups/language.h	\
-		../cups/string.h
+depend:
+	makedepend -Y -I.. -fDependencies $(OBJS:.o=.c) >/dev/null 2>&1
 
 
 #
@@ -74,12 +71,21 @@
 	echo Linking $@...
 	$(CC) $(LDFLAGS) -o mailto mailto.o $(LIBS)
 
-mailto.o:	../cups/cups.h ../cups/ipp.h ../cups/language.h	\
-		../cups/string.h
 
+#
+# testnotify
+#
+
+testnotify:	testnotify.o ../cups/$(LIBCUPS)
+	echo Linking $@...
+	$(CC) $(LDFLAGS) -o testnotify testnotify.o $(LIBS)
+
+
+$(OBJS):	../Makedefs
+
+include Dependencies
 
-$(OBJS):	../config.h ../Makedefs
 
 #
-# End of "$Id: Makefile 4494 2005-02-18 02:18:11Z mike $".
+# End of "$Id: Makefile 4834 2005-11-12 21:55:57Z mike $".
 #
diff -urNad cupsys-1.1.99.b1.r4748~/notifier/indp.c cupsys-1.1.99.b1.r4748/notifier/indp.c
--- cupsys-1.1.99.b1.r4748~/notifier/indp.c	2005-02-18 11:18:11.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/notifier/indp.c	1970-01-01 09:00:00.000000000 +0900
@@ -1,50 +0,0 @@
-/*
- * "$Id: indp.c 4494 2005-02-18 02:18:11Z mike $"
- *
- *   "mailto" notifier for the Common UNIX Printing System (CUPS).
- *
- *   Copyright 1997-2005 by Easy Software Products.
- *
- *   These coded instructions, statements, and computer programs are the
- *   property of Easy Software Products and are protected by Federal
- *   copyright law.  Distribution and use rights are outlined in the file
- *   "LICENSE.txt" which should have been included with this file.  If this
- *   file is missing or damaged please contact Easy Software Products
- *   at:
- *
- *       Attn: CUPS Licensing Information
- *       Easy Software Products
- *       44141 Airport View Drive, Suite 204
- *       Hollywood, Maryland 20636 USA
- *
- *       Voice: (301) 373-9600
- *       EMail: cups-info@cups.org
- *         WWW: http://www.cups.org
- *
- * Contents:
- *
- */
-
-/*
- * Include necessary headers...
- */
-
-#include <cups/cups.h>
-#include <cups/language.h>
-#include <cups/string.h>
-
-
-/*
- * 'main()' - Main entry for the mailto notifier.
- */
-
-int				/* O - Exit status */
-main(int  argc,			/* I - Number of command-line arguments */
-     char *argv[])		/* I - Command-line arguments */
-{
-}
-
-
-/*
- * End of "$Id: indp.c 4494 2005-02-18 02:18:11Z mike $".
- */
diff -urNad cupsys-1.1.99.b1.r4748~/notifier/mailto.c cupsys-1.1.99.b1.r4748/notifier/mailto.c
--- cupsys-1.1.99.b1.r4748~/notifier/mailto.c	2005-02-18 11:18:11.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/notifier/mailto.c	2005-11-12 12:15:10.305626000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: mailto.c 4494 2005-02-18 02:18:11Z mike $"
+ * "$Id: mailto.c 4829 2005-11-12 03:15:10Z mike $"
  *
  *   "mailto" notifier for the Common UNIX Printing System (CUPS).
  *
@@ -38,13 +38,13 @@
  * 'main()' - Main entry for the mailto notifier.
  */
 
-int				/* O - Exit status */
-main(int  argc,			/* I - Number of command-line arguments */
-     char *argv[])		/* I - Command-line arguments */
+int					/* O - Exit status */
+main(int  argc,				/* I - Number of command-line arguments */
+     char *argv[])			/* I - Command-line arguments */
 {
 }
 
 
 /*
- * End of "$Id: mailto.c 4494 2005-02-18 02:18:11Z mike $".
+ * End of "$Id: mailto.c 4829 2005-11-12 03:15:10Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/notifier/testnotify.c cupsys-1.1.99.b1.r4748/notifier/testnotify.c
--- cupsys-1.1.99.b1.r4748~/notifier/testnotify.c	1970-01-01 09:00:00.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/notifier/testnotify.c	2005-11-12 12:15:10.305626000 +0900
@@ -0,0 +1,285 @@
+/*
+ * "$Id: testnotify.c 4829 2005-11-12 03:15:10Z mike $"
+ *
+ *   Test notifier for the Common UNIX Printing System (CUPS).
+ *
+ *   Copyright 1997-2005 by Easy Software Products.
+ *
+ *   These coded instructions, statements, and computer programs are the
+ *   property of Easy Software Products and are protected by Federal
+ *   copyright law.  Distribution and use rights are outlined in the file
+ *   "LICENSE.txt" which should have been included with this file.  If this
+ *   file is missing or damaged please contact Easy Software Products
+ *   at:
+ *
+ *       Attn: CUPS Licensing Information
+ *       Easy Software Products
+ *       44141 Airport View Drive, Suite 204
+ *       Hollywood, Maryland 20636 USA
+ *
+ *       Voice: (301) 373-9600
+ *       EMail: cups-info@cups.org
+ *         WWW: http://www.cups.org
+ *
+ * Contents:
+ *
+ *   main()             - Main entry for the test notifier.
+ *   print_attributes() - Print the attributes in a request...
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include <cups/cups.h>
+#include <cups/language.h>
+#include <cups/string.h>
+
+
+/*
+ * Local functions...
+ */
+
+void	print_attributes(ipp_t *ipp, int indent);
+
+
+/*
+ * 'main()' - Main entry for the test notifier.
+ */
+
+int					/* O - Exit status */
+main(int  argc,				/* I - Number of command-line arguments */
+     char *argv[])			/* I - Command-line arguments */
+{
+  int		i;			/* Looping var */
+  ipp_t		*event;			/* Event from scheduler */
+  ipp_state_t	state;			/* IPP event state */
+
+
+  setbuf(stderr, NULL);
+
+  fprintf(stderr, "DEBUG: argc=%d\n", argc);
+  for (i = 0; i < argc; i ++)
+    fprintf(stderr, "DEBUG: argv[%d]=\"%s\"\n", i, argv[i]);
+
+  for (;;)
+  {
+    event = ippNew();
+    while ((state = ippReadFile(0, event)) != IPP_DATA)
+    {
+      if (state <= IPP_IDLE)
+        break;
+    }
+
+    if (state == IPP_ERROR)
+      fputs("DEBUG: ippReadFile() returned IPP_ERROR!\n", stderr);
+
+    if (state <= IPP_IDLE)
+    {
+      ippDelete(event);
+      return (0);
+    }
+
+    print_attributes(event, 4);
+    ippDelete(event);
+  }
+}
+
+
+/*
+ * 'print_attributes()' - Print the attributes in a request...
+ */
+
+void
+print_attributes(ipp_t *ipp,		/* I - IPP request */
+                 int   indent)		/* I - Indentation */
+{
+  int			i;		/* Looping var */
+  ipp_tag_t		group;		/* Current group */
+  ipp_attribute_t	*attr;		/* Current attribute */
+  ipp_value_t		*val;		/* Current value */
+  static const char * const tags[] =	/* Value/group tag strings */
+			{
+			  "reserved-00",
+			  "operation-attributes-tag",
+			  "job-attributes-tag",
+			  "end-of-attributes-tag",
+			  "printer-attributes-tag",
+			  "unsupported-attributes-tag",
+			  "subscription-attributes-tag",
+			  "event-attributes-tag",
+			  "reserved-08",
+			  "reserved-09",
+			  "reserved-0A",
+			  "reserved-0B",
+			  "reserved-0C",
+			  "reserved-0D",
+			  "reserved-0E",
+			  "reserved-0F",
+			  "unsupported",
+			  "default",
+			  "unknown",
+			  "no-value",
+			  "reserved-14",
+			  "not-settable",
+			  "delete-attr",
+			  "admin-define",
+			  "reserved-18",
+			  "reserved-19",
+			  "reserved-1A",
+			  "reserved-1B",
+			  "reserved-1C",
+			  "reserved-1D",
+			  "reserved-1E",
+			  "reserved-1F",
+			  "reserved-20",
+			  "integer",
+			  "boolean",
+			  "enum",
+			  "reserved-24",
+			  "reserved-25",
+			  "reserved-26",
+			  "reserved-27",
+			  "reserved-28",
+			  "reserved-29",
+			  "reserved-2a",
+			  "reserved-2b",
+			  "reserved-2c",
+			  "reserved-2d",
+			  "reserved-2e",
+			  "reserved-2f",
+			  "octetString",
+			  "dateTime",
+			  "resolution",
+			  "rangeOfInteger",
+			  "begCollection",
+			  "textWithLanguage",
+			  "nameWithLanguage",
+			  "endCollection",
+			  "reserved-38",
+			  "reserved-39",
+			  "reserved-3a",
+			  "reserved-3b",
+			  "reserved-3c",
+			  "reserved-3d",
+			  "reserved-3e",
+			  "reserved-3f",
+			  "reserved-40",
+			  "textWithoutLanguage",
+			  "nameWithoutLanguage",
+			  "reserved-43",
+			  "keyword",
+			  "uri",
+			  "uriScheme",
+			  "charset",
+			  "naturalLanguage",
+			  "mimeMediaType",
+			  "memberName"
+			};
+
+
+  for (group = IPP_TAG_ZERO, attr = ipp->attrs; attr; attr = attr->next)
+  {
+    if ((attr->group_tag == IPP_TAG_ZERO && indent <= 8) || !attr->name)
+    {
+      group = IPP_TAG_ZERO;
+      fputc('\n', stderr);
+      continue;
+    }
+
+    if (group != attr->group_tag)
+    {
+      group = attr->group_tag;
+
+      fprintf(stderr, "DEBUG: %*s%s:\n\n", indent - 4, "", tags[group]);
+    }
+
+    fprintf(stderr, "DEBUG: %*s%s (", indent, "", attr->name);
+    if (attr->num_values > 1)
+      fputs("1setOf ", stderr);
+    fprintf(stderr, "%s):", tags[attr->value_tag]);
+
+    switch (attr->value_tag)
+    {
+      case IPP_TAG_ENUM :
+      case IPP_TAG_INTEGER :
+          for (i = 0, val = attr->values; i < attr->num_values; i ++, val ++)
+	    fprintf(stderr, " %d", val->integer);
+          fputc('\n', stderr);
+          break;
+
+      case IPP_TAG_BOOLEAN :
+          for (i = 0, val = attr->values; i < attr->num_values; i ++, val ++)
+	    fprintf(stderr, " %s", val->boolean ? "true" : "false");
+          fputc('\n', stderr);
+          break;
+
+      case IPP_TAG_RANGE :
+          for (i = 0, val = attr->values; i < attr->num_values; i ++, val ++)
+	    fprintf(stderr, " %d-%d", val->range.lower, val->range.upper);
+	  fputc('\n', stderr);
+          break;
+
+      case IPP_TAG_DATE :
+          {
+	    time_t	vtime;		/* Date/Time value */
+	    struct tm	*vdate;		/* Date info */
+	    char	vstring[256];	/* Formatted time */
+
+	    for (i = 0, val = attr->values; i < attr->num_values; i ++, val ++)
+	    {
+	      vtime = ippDateToTime(val->date);
+	      vdate = localtime(&vtime);
+	      strftime(vstring, sizeof(vstring), "%c", vdate);
+	      fprintf(stderr, " (%s)", vstring);
+	    }
+          }
+	  fputc('\n', stderr);
+          break;
+
+      case IPP_TAG_RESOLUTION :
+          for (i = 0, val = attr->values; i < attr->num_values; i ++, val ++)
+	    fprintf(stderr, " %dx%d%s", val->resolution.xres,
+	            val->resolution.yres,
+	            val->resolution.units == IPP_RES_PER_INCH ? "dpi" : "dpc");
+	  fputc('\n', stderr);
+          break;
+
+      case IPP_TAG_STRING :
+      case IPP_TAG_TEXTLANG :
+      case IPP_TAG_NAMELANG :
+      case IPP_TAG_TEXT :
+      case IPP_TAG_NAME :
+      case IPP_TAG_KEYWORD :
+      case IPP_TAG_URI :
+      case IPP_TAG_URISCHEME :
+      case IPP_TAG_CHARSET :
+      case IPP_TAG_LANGUAGE :
+      case IPP_TAG_MIMETYPE :
+          for (i = 0, val = attr->values; i < attr->num_values; i ++, val ++)
+	    fprintf(stderr, " \"%s\"", val->string.text);
+	  fputc('\n', stderr);
+          break;
+
+      case IPP_TAG_BEGIN_COLLECTION :
+	  fputc('\n', stderr);
+
+          for (i = 0, val = attr->values; i < attr->num_values; i ++, val ++)
+	  {
+	    if (i)
+	      fputc('\n', stderr);
+	    print_attributes(val->collection, indent + 4);
+	  }
+          break;
+
+      default :
+          fprintf(stderr, "UNKNOWN (%d values)\n", attr->num_values);
+          break;
+    }
+  }
+}
+
+
+/*
+ * End of "$Id: testnotify.c 4829 2005-11-12 03:15:10Z mike $".
+ */
diff -urNad cupsys-1.1.99.b1.r4748~/packaging/LICENSE.rtf cupsys-1.1.99.b1.r4748/packaging/LICENSE.rtf
--- cupsys-1.1.99.b1.r4748~/packaging/LICENSE.rtf	1970-01-01 09:00:00.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/packaging/LICENSE.rtf	2005-11-13 03:48:19.114041000 +0900
@@ -0,0 +1,462 @@
+{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf210
+{\fonttbl\f0\froman\fcharset77 Times-Bold;\f1\froman\fcharset77 Times-Roman;\f2\fnil\fcharset77 LucidaGrande;
+\f3\fmodern\fcharset77 Courier;\f4\fnil\fcharset77 LucidaGrande-Bold;\f5\fmodern\fcharset77 Courier-Oblique;
+}
+{\colortbl;\red255\green255\blue255;\red0\green0\blue238;}
+{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc2\leveljcn2\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid0\'02\'05.;}{\levelnumbers\'01;}}{\listname ;}\listid1}
+{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc2\leveljcn2\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid0\'02\'05.;}{\levelnumbers\'01;}}{\listlevel\levelnfc0\levelnfcn0\leveljc2\leveljcn2\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'05.;}{\levelnumbers\'01;}}{\listname ;}\listid2}
+{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc2\leveljcn2\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid0\'02\'05.;}{\levelnumbers\'01;}}{\listname ;}\listid3}
+{\list\listtemplateid4\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc2\leveljcn2\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid0\'02\'05.;}{\levelnumbers\'01;}}{\listlevel\levelnfc0\levelnfcn0\leveljc2\leveljcn2\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'05.;}{\levelnumbers\'01;}}{\listname ;}\listid4}
+{\list\listtemplateid5\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc2\leveljcn2\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid0\'02\'05.;}{\levelnumbers\'01;}}{\listname ;}\listid5}
+{\list\listtemplateid6\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc2\leveljcn2\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid0\'02\'05.;}{\levelnumbers\'01;}}{\listname ;}\listid6}
+{\list\listtemplateid7\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc2\leveljcn2\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid0\'02\'05.;}{\levelnumbers\'01;}}{\listname ;}\listid7}
+{\list\listtemplateid8\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc2\leveljcn2\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid0\'02\'05.;}{\levelnumbers\'01;}}{\listname ;}\listid8}}
+{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}{\listoverride\listid6\listoverridecount0\ls6}{\listoverride\listid7\listoverridecount0\ls7}{\listoverride\listid8\listoverridecount0\ls8}}
+{\info
+{\title Software License Agreement - Common UNIX Printing System}}\vieww15960\viewh16860\viewkind0
+\deftab720
+\pard\pardeftab720\sa280\qc
+
+\f0\b\fs36 \cf0 Common UNIX Printing System License Agreement\
+\pard\pardeftab720\sa240\qc
+
+\f1\b0\fs24 \cf0 Copyright 1997-2005 by Easy Software Products
+\f2 \uc0\u8232 
+\f1 44141 AIRPORT VIEW DR STE 204
+\f2 \uc0\u8232 
+\f1 HOLLYWOOD, MARYLAND 20636 USA
+\f2 \uc0\u8232 \u8232 
+\f1 Voice: +1.301.373.9600
+\f2 \uc0\u8232 
+\f1 Email: {\field{\*\fldinst{HYPERLINK "mailto:cups-info@cups.org"}}{\fldrslt \cf2 \ul \ulc2 cups-info@cups.org}}
+\f2 \uc0\u8232 
+\f1 WWW: {\field{\*\fldinst{HYPERLINK "http://www.cups.org/"}}{\fldrslt \cf2 \ul \ulc2 http://www.cups.org}}\
+\pard\pardeftab720\sa280\ql\qnatural
+
+\f0\b\fs28 \cf0 Introduction\
+\pard\pardeftab720\sa240\ql\qnatural
+
+\f1\b0\fs24 \cf0 The Common UNIX Printing System
+\fs20 \super TM
+\fs24 \nosupersub , ("CUPS
+\fs20 \super TM
+\fs24 \nosupersub "), is provided under the GNU General Public License ("GPL") and GNU Library General Public License ("LGPL"), Version 2, with exceptions for Apple operating systems and the OpenSSL toolkit. A copy of the exceptions and licenses follow this introduction.\
+The GNU LGPL applies to the CUPS API library, located in the "cups" subdirectory of the CUPS source distribution and in the "cups" include directory and library files in the binary distributions. The GNU GPL applies to the remainder of the CUPS distribution, including the "pdftops" filter which is based upon Xpdf and the CUPS imaging library.\
+For those not familiar with the GNU GPL, the license basically allows you to:\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
+\ls1\ilvl0\cf0 {\listtext	\'a5	}Use the CUPS software at no charge.\
+{\listtext	\'a5	}Distribute verbatim copies of the software in source or binary form.\
+{\listtext	\'a5	}Sell verbatim copies of the software for a media fee, or sell support for the software.\
+{\listtext	\'a5	}Distribute or sell printer drivers and filters that use CUPS so long as source code is made available under the GPL.\
+\pard\pardeftab720\sa240\ql\qnatural
+\cf0 What this license 
+\f0\b does not
+\f1\b0  allow you to do is make changes or add features to CUPS and then sell a binary distribution without source code. You must provide source for any new drivers, changes, or additions to the software, and all code must be provided under the GPL or LGPL as appropriate. The only exceptions to this are the portions of the CUPS software covered by the Apple operating system license exceptions outlined later in this license agreement.\
+The GNU LGPL relaxes the "link-to" restriction, allowing you to develop applications that use the CUPS API library under other licenses and/or conditions as appropriate for your application.\
+\pard\pardeftab720\sa280\ql\qnatural
+
+\f0\b\fs28 \cf0 License Exceptions\
+\pard\pardeftab720\sa240\ql\qnatural
+
+\f1\b0\fs24 \cf0 In addition, as the copyright holder of CUPS, Easy Software Products grants the following special exceptions:\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
+\ls2\ilvl0
+\f0\b \cf0 {\listtext	1.	}Apple Operating System Development License Exception
+\f1\b0 ;\
+\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\ql\qnatural
+\ls2\ilvl1\cf0 {\listtext	1.	}Software that is developed by any person or entity for an Apple Operating System ("Apple OS-Developed Software"), including but not limited to Apple and third party printer drivers, filters, and backends for an Apple Operating System, that is linked to the CUPS imaging library or based on any sample filters or backends provided with CUPS shall not be considered to be a derivative work or collective work based on the CUPS program and is exempt from the mandatory source code release clauses of the GNU GPL. You may therefore distribute linked combinations of the CUPS imaging library with Apple OS-Developed Software without releasing the source code of the Apple OS-Developed Software. You may also use sample filters and backends provided with CUPS to develop Apple OS-Developed Software without releasing the source code of the Apple OS-Developed Software.\
+{\listtext	2.	}An Apple Operating System means any operating system software developed and/or marketed by Apple Computer, Inc., including but not limited to all existing releases and versions of Apple's Darwin, Mac OS X, and Mac OS X Server products and all follow-on releases and future versions thereof.\
+{\listtext	3.	}This exception is only available for Apple OS-Developed Software and does not apply to software that is distributed for use on other operating systems.\
+{\listtext	4.	}All CUPS software that falls under this license exception have the following text at the top of each source file:\
+{\listtext	5.	}This file is subject to the Apple OS-Developed Software exception.\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
+\ls2\ilvl0
+\f0\b \cf0 {\listtext	2.	}OpenSSL Toolkit License Exception
+\f1\b0 ;\
+\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\ql\qnatural
+\ls2\ilvl1\cf0 {\listtext	1.	}Easy Software Products explicitly allows the compilation and distribution of the CUPS software with the OpenSSL Toolkit.\
+\pard\pardeftab720\sa240\ql\qnatural
+\cf0 No developer is required to provide these exceptions in a derived work.\
+\pard\pardeftab720\sa280\ql\qnatural
+
+\f0\b\fs28 \cf0 Trademarks\
+\pard\pardeftab720\sa240\ql\qnatural
+
+\f1\b0\fs24 \cf0 Easy Software Products has trademarked the Common UNIX Printing System, CUPS, and CUPS logo. You may use these names and logos in any direct port or binary distribution of CUPS. Please contact Easy Software Products for written permission to use them in derivative products. Our intention is to protect the value of these trademarks and ensure that any derivative product meets the same high-quality standards as the original.\
+\pard\pardeftab720\sa280\ql\qnatural
+
+\f0\b\fs28 \cf0 Binary Distribution Rights\
+\pard\pardeftab720\sa240\ql\qnatural
+
+\f1\b0\fs24 \cf0 Easy Software Products also sells rights to the CUPS source code under a binary distribution license for vendors that are unable to release source code for their drivers, additions, and modifications to CUPS under the GNU GPL and LGPL. For information please contact us at the address shown above.\
+The Common UNIX Printing System provides a "pdftops" filter that is based on the Xpdf software. For binary distribution licensing of this software, please contact:\
+\pard\pardeftab720\ql\qnatural
+\cf0 Derek B. Noonburg\
+Email: {\field{\*\fldinst{HYPERLINK "mailto:derekn@foolabs.com"}}{\fldrslt \cf2 \ul \ulc2 derekn@foolabs.com}}\
+WWW: {\field{\*\fldinst{HYPERLINK "http://www.foolabs.com/xpdf/"}}{\fldrslt \cf2 \ul \ulc2 http://www.foolabs.com/xpdf/}}\
+\pard\pardeftab720\sa280\ql\qnatural
+
+\f0\b\fs28 \cf0 Support\
+\pard\pardeftab720\sa240\ql\qnatural
+
+\f1\b0\fs24 \cf0 Easy Software Products sells software support for CUPS as well as a commercial printing product based on CUPS called ESP Print Pro. You can find out more at our web site:\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
+\ls3\ilvl0{\field{\*\fldinst{HYPERLINK "http://www.easysw.com/"}}{\fldrslt 
+\f3 \cf2 \ul \ulc2 {\listtext	\'a5	}http://www.easysw.com/}}
+\f3 \
+\pard\pardeftab720\sa280\ql\qnatural
+
+\f0\b\fs36 \cf0 GNU GENERAL PUBLIC LICENSE\
+\pard\pardeftab720\sa240\ql\qnatural
+
+\f1\b0\fs24 \cf0 Version 2, June 1991\
+\pard\pardeftab720\ql\qnatural
+
+\f3 \cf0 Copyright 1989, 1991 Free Software Foundation, Inc.\
+59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\
+\
+Everyone is permitted to copy and distribute verbatim\
+copies of this license document, but changing it is not allowed.\
+\pard\pardeftab720\sa300\ql\qnatural
+
+\f0\b \cf0 Preamble\
+\pard\pardeftab720\sa240\ql\qnatural
+
+\f1\b0 \cf0 The licenses for most software are designed to take away your freedom to share and change it. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change free software--to make sure the software is free for all its users. This General Public License applies to most of the Free Software Foundation's software and to any other program whose authors commit to using it. (Some other Free Software Foundation software is covered by the GNU Library General Public License instead.) You can apply it to your programs, too.\
+When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for this service if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs; and that you know you can do these things.\
+To protect your rights, we need to make restrictions that forbid anyone to deny you these rights or to ask you to surrender the rights. These restrictions translate to certain responsibilities for you if you distribute copies of the software, or if you modify it.\
+For example, if you distribute copies of such a program, whether gratis or for a fee, you must give the recipients all the rights that you have. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights.\
+We protect your rights with two steps: (1) copyright the software, and (2) offer you this license which gives you legal permission to copy, distribute and/or modify the software.\
+Also, for each author's protection and ours, we want to make certain that everyone understands that there is no warranty for this free software. If the software is modified by someone else and passed on, we want its recipients to know that what they have is not the original, so that any problems introduced by others will not reflect on the original authors' reputations.\
+Finally, any free program is threatened constantly by software patents. We wish to avoid the danger that redistributors of a free program will individually obtain patent licenses, in effect making the program proprietary. To prevent this, we have made it clear that any patent must be licensed for everyone's free use or not licensed at all.\
+The precise terms and conditions for copying, distribution and modification follow.\
+\pard\pardeftab720\sa300\ql\qnatural
+
+\f0\b \cf0 GNU GENERAL PUBLIC LICENSE
+\f4 \uc0\u8232 
+\f0 TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
+\ls4\ilvl0
+\f1\b0 \cf0 {\listtext	1.	}This License applies to any program or other work which contains a notice placed by the copyright holder saying it may be distributed under the terms of this General Public License. The "Program", below, refers to any such program or work, and a "work based on the Program" means either the Program or any derivative work under copyright law: that is to say, a work containing the Program or a portion of it, either verbatim or with modifications and/or translated into another language. (Hereinafter, translation is included without limitation in the term "modification".) Each licensee is addressed as "you".\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\ql\qnatural
+\ls4\ilvl0\cf0 {\listtext	2.	}Activities other than copying, distribution and modification are not covered by this License; they are outside its scope. The act of running the Program is not restricted, and the output from the Program is covered only if its contents constitute a work based on the Program (independent of having been made by running the Program). Whether that is true depends on what the Program does.\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
+\ls4\ilvl0\cf0 {\listtext	3.	}You may copy and distribute verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty; keep intact all the notices that refer to this License and to the absence of any warranty; and give any other recipients of the Program a copy of this License along with the Program.\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\ql\qnatural
+\ls4\ilvl0\cf0 {\listtext	4.	}You may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee.\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
+\ls4\ilvl0\cf0 {\listtext	5.	}You may modify your copy or copies of the Program or any portion of it, thus forming a work based on the Program, and copy and distribute such modifications or work under the terms of Section 1 above, provided that you also meet all of these conditions:\
+\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\ql\qnatural
+\ls4\ilvl1\cf0 {\listtext	1.	}You must cause the modified files to carry prominent notices stating that you changed the files and the date of any change.\
+{\listtext	2.	}You must cause any work that you distribute or publish, that in whole or in part contains or is derived from the Program or any part thereof, to be licensed as a whole at no charge to all third parties under the terms of this License.\
+{\listtext	3.	}if the modified program normally reads commands interactively when run, you must cause it, when started running for such interactive use in the most ordinary way, to print or display an announcement including an appropriate copyright notice and a notice that there is no warranty (or else, saying that you provide a warranty) and that users may redistribute the program under these conditions, and telling the user how to view a copy of this License. (Exception: if the Program itself is interactive but does not normally print such an announcement, your work based on the Program is not required to print an announcement.)\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\ql\qnatural
+\ls4\ilvl0\cf0 {\listtext	6.	}These requirements apply to the modified work as a whole. If identifiable sections of that work are not derived from the Program, and can be reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you distribute them as separate works. But when you distribute the same sections as part of a whole which is a work based on the Program, the distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to each and every part regardless of who wrote it.\
+{\listtext	7.	}Thus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you; rather, the intent is to exercise the right to control the distribution of derivative or collective works based on the Program.\
+{\listtext	8.	}In addition, mere aggregation of another work not based on the Program with the Program (or with a work based on the Program) on a volume of a storage or distribution medium does not bring the other work under the scope of this License.\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
+\ls4\ilvl0\cf0 {\listtext	9.	}You may copy and distribute the Program (or a work based on it, under Section 2) in object code or executable form under the terms of Sections 1 and 2 above provided that you also do one of the following:\
+\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\ql\qnatural
+\ls4\ilvl1\cf0 {\listtext	1.	}Accompany it with the complete corresponding machine-readable source code, which must be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange; or,\
+{\listtext	2.	}Accompany it with a written offer, valid for at least three years, to give any third party, for a charge no more than your cost of physically performing source distribution, a complete machine-readable copy of the corresponding source code, to be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange; or,\
+{\listtext	3.	}Accompany it with the information you received as to the offer to distribute corresponding source code. (This alternative is allowed only for noncommercial distribution and only if you received the program in object code or executable form with such an offer, in accord with Subsection b above.)\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\ql\qnatural
+\ls4\ilvl0\cf0 {\listtext	10.	}The source code for a work means the preferred form of the work for making modifications to it. For an executable work, complete source code means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control compilation and installation of the executable. However, as a special exception, the source code distributed need not include anything that is normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on which the executable runs, unless that component itself accompanies the executable.\
+{\listtext	11.	}If distribution of executable or object code is made by offering access to copy from a designated place, then offering equivalent access to copy the source code from the same place counts as distribution of the source code, even though third parties are not compelled to copy the source along with the object code.\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
+\ls4\ilvl0\cf0 {\listtext	12.	}You may not copy, modify, sublicense, or distribute the Program except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense or distribute the Program is void, and will automatically terminate your rights under this License. However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance.\
+{\listtext	13.	}You are not required to accept this License, since you have not signed it. However, nothing else grants you permission to modify or distribute the Program or its derivative works. These actions are prohibited by law if you do not accept this License. Therefore, by modifying or distributing the Program (or any work based on the Program), you indicate your acceptance of this License to do so, and all its terms and conditions for copying, distributing or modifying the Program or works based on it.\
+{\listtext	14.	}Each time you redistribute the Program (or any work based on the Program), the recipient automatically receives a license from the original licensor to copy, distribute or modify the Program subject to these terms and conditions. You may not impose any further restrictions on the recipients' exercise of the rights granted herein. You are not responsible for enforcing compliance by third parties to this License.\
+{\listtext	15.	}If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot distribute so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not distribute the Program at all. For example, if a patent license would not permit royalty-free redistribution of the Program by all those who receive copies directly or indirectly through you, then the only way you could satisfy both it and this License would be to refrain entirely from distribution of the Program.\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\ql\qnatural
+\ls4\ilvl0\cf0 {\listtext	16.	}If any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to apply and the section as a whole is intended to apply in other circumstances.\
+{\listtext	17.	}It is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such claims; this section has the sole purpose of protecting the integrity of the free software distribution system, which is implemented by public license practices. Many people have made generous contributions to the wide range of software distributed through that system in reliance on consistent application of that system; it is up to the author/donor to decide if he or she is willing to distribute software through any other system and a licensee cannot impose that choice.\
+{\listtext	18.	}This section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License.\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
+\ls4\ilvl0\cf0 {\listtext	19.	}If the distribution and/or use of the Program is restricted in certain countries either by patents or by copyrighted interfaces, the original copyright holder who places the Program under this License may add an explicit geographical distribution limitation excluding those countries, so that distribution is permitted only in or among countries not thus excluded. In such case, this License incorporates the limitation as if written in the body of this License.\
+{\listtext	20.	}The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\ql\qnatural
+\ls4\ilvl0\cf0 {\listtext	21.	}Each version is given a distinguishing version number. If the Program specifies a version number of this License which applies to it and "any later version", you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of this License, you may choose any version ever published by the Free Software Foundation.\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
+\ls4\ilvl0\cf0 {\listtext	22.	}If you wish to incorporate parts of the Program into other free programs whose distribution conditions are different, write to the author to ask for permission. For software which is copyrighted by the Free Software Foundation, write to the Free Software Foundation; we sometimes make exceptions for this. Our decision will be guided by the two goals of preserving the free status of all derivatives of our free software and of promoting the sharing and reuse of software generally.\
+\pard\pardeftab720\sa300\ql\qnatural
+
+\f0\b \cf0 NO WARRANTY\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
+\ls5\ilvl0
+\f1\b0 \cf0 {\listtext	1.	}BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\
+{\listtext	2.	}IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\
+\pard\pardeftab720\sa300\ql\qnatural
+
+\f0\b \cf0 END OF TERMS AND CONDITIONS\
+How to Apply These Terms to Your New Programs\
+\pard\pardeftab720\sa240\ql\qnatural
+
+\f1\b0 \cf0 If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms.\
+To do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively convey the exclusion of warranty; and each file should have at least the "copyright" line and a pointer to where the full notice is found.\
+\pard\pardeftab720\ql\qnatural
+
+\f5\i \cf0 one line to give the program's name and an idea of what it does.
+\f3\i0 \
+Copyright (C) 
+\f5\i yyyy
+\f3\i0   
+\f5\i name of author
+\f3\i0 \
+\
+This program is free software; you can redistribute it and/or\
+modify it under the terms of the GNU General Public License\
+as published by the Free Software Foundation; either version 2\
+of the License, or (at your option) any later version.\
+\
+This program is distributed in the hope that it will be useful,\
+but WITHOUT ANY WARRANTY; without even the implied warranty of\
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\
+GNU General Public License for more details.\
+\
+You should have received a copy of the GNU General Public License\
+along with this program; if not, write to the Free Software\
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\
+\pard\pardeftab720\sa240\ql\qnatural
+
+\f1 \cf0 Also add information on how to contact you by electronic and paper mail.\
+If the program is interactive, make it output a short notice like this when it starts in an interactive mode:\
+\pard\pardeftab720\ql\qnatural
+
+\f3 \cf0 Gnomovision version 69, Copyright (C) 
+\f5\i year
+\f3\i0  
+\f5\i name of author
+\f3\i0 \
+Gnomovision comes with ABSOLUTELY NO WARRANTY; for details\
+type `show w'.  This is free software, and you are welcome\
+to redistribute it under certain conditions; type `show c' \
+for details.\
+\pard\pardeftab720\sa240\ql\qnatural
+
+\f1 \cf0 The hypothetical commands 
+\f3 `show w'
+\f1  and 
+\f3 `show c'
+\f1  should show the appropriate parts of the General Public License. Of course, the commands you use may be called something other than 
+\f3 `show w'
+\f1  and 
+\f3 `show c'
+\f1 ; they could even be mouse-clicks or menu items--whatever suits your program.\
+You should also get your employer (if you work as a programmer) or your school, if any, to sign a "copyright disclaimer" for the program, if necessary. Here is a sample; alter the names:\
+\pard\pardeftab720\ql\qnatural
+
+\f3 \cf0 Yoyodyne, Inc., hereby disclaims all copyright\
+interest in the program `Gnomovision'\
+(which makes passes at compilers) written \
+by James Hacker.\
+\
+\pard\pardeftab720\ql\qnatural
+
+\f5\i \cf0 signature of Ty Coon
+\f3\i0 , 1 April 1989\
+Ty Coon, President of Vice\
+\pard\pardeftab720\sa280\ql\qnatural
+
+\f0\b\fs36 \cf0 GNU LIBRARY GENERAL PUBLIC LICENSE\
+\pard\pardeftab720\sa240\ql\qnatural
+
+\f1\b0\fs24 \cf0 Version 2, June 1991\
+\pard\pardeftab720\ql\qnatural
+
+\f3 \cf0 Copyright (C) 1991 Free Software Foundation, Inc.\
+59 Temple Place - Suite 330, Boston, MA  02111-1307, USA\
+Everyone is permitted to copy and distribute verbatim copies\
+of this license document, but changing it is not allowed.\
+\
+[This is the first released version of the library GPL.  It is\
+ numbered 2 because it goes with version 2 of the ordinary GPL.]\
+\pard\pardeftab720\sa300\ql\qnatural
+
+\f0\b \cf0 Preamble\
+\pard\pardeftab720\sa240\ql\qnatural
+
+\f1\b0 \cf0 The licenses for most software are designed to take away your freedom to share and change it. By contrast, the GNU General Public Licenses are intended to guarantee your freedom to share and change free software--to make sure the software is free for all its users.\
+This license, the Library General Public License, applies to some specially designated Free Software Foundation software, and to any other libraries whose authors decide to use it. You can use it for your libraries, too.\
+When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for this service if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs; and that you know you can do these things.\
+To protect your rights, we need to make restrictions that forbid anyone to deny you these rights or to ask you to surrender the rights. These restrictions translate to certain responsibilities for you if you distribute copies of the library, or if you modify it.\
+For example, if you distribute copies of the library, whether gratis or for a fee, you must give the recipients all the rights that we gave you. You must make sure that they, too, receive or can get the source code. If you link a program with the library, you must provide complete object files to the recipients so that they can relink them with the library, after making changes to the library and recompiling it. And you must show them these terms so they know their rights.\
+Our method of protecting your rights has two steps: (1) copyright the library, and (2) offer you this license which gives you legal permission to copy, distribute and/or modify the library.\
+Also, for each distributor's protection, we want to make certain that everyone understands that there is no warranty for this free library. If the library is modified by someone else and passed on, we want its recipients to know that what they have is not the original version, so that any problems introduced by others will not reflect on the original authors' reputations.\
+Finally, any free program is threatened constantly by software patents. We wish to avoid the danger that companies distributing free software will individually obtain patent licenses, thus in effect transforming the program into proprietary software. To prevent this, we have made it clear that any patent must be licensed for everyone's free use or not licensed at all.\
+Most GNU software, including some libraries, is covered by the ordinary GNU General Public License, which was designed for utility programs. This license, the GNU Library General Public License, applies to certain designated libraries. This license is quite different from the ordinary one; be sure to read it in full, and don't assume that anything in it is the same as in the ordinary license.\
+The reason we have a separate public license for some libraries is that they blur the distinction we usually make between modifying or adding to a program and simply using it. Linking a program with a library, without changing the library, is in some sense simply using the library, and is analogous to running a utility program or application program. However, in a textual and legal sense, the linked executable is a combined work, a derivative of the original library, and the ordinary General Public License treats it as such.\
+Because of this blurred distinction, using the ordinary General Public License for libraries did not effectively promote software sharing, because most developers did not use the libraries. We concluded that weaker conditions might promote sharing better.\
+However, unrestricted linking of non-free programs would deprive the users of those programs of all benefit from the free status of the libraries themselves. This Library General Public License is intended to permit developers of non-free programs to use free libraries, while preserving your freedom as a user of such programs to change the free libraries that are incorporated in them. (We have not seen how to achieve this as regards changes in header files, but we have achieved it as regards changes in the actual functions of the Library.) The hope is that this will lead to faster development of free libraries.\
+The precise terms and conditions for copying, distribution and modification follow. Pay close attention to the difference between a "work based on the library" and a "work that uses the library". The former contains code derived from the library, while the latter only works together with the library.\
+Note that it is possible for a library to be covered by the ordinary General Public License rather than by this special one.\
+\pard\pardeftab720\sa300\ql\qnatural
+
+\f0\b \cf0 TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\
+\pard\pardeftab720\sa240\ql\qnatural
+\cf0 0.
+\f1\b0  This License Agreement applies to any software library which contains a notice placed by the copyright holder or other authorized party saying it may be distributed under the terms of this Library General Public License (also called "this License"). Each licensee is addressed as "you".\
+A "library" means a collection of software functions and/or data prepared so as to be conveniently linked with application programs (which use some of those functions and data) to form executables.\
+The "Library", below, refers to any such software library or work which has been distributed under these terms. A "work based on the Library" means either the Library or any derivative work under copyright law: that is to say, a work containing the Library or a portion of it, either verbatim or with modifications and/or translated straightforwardly into another language. (Hereinafter, translation is included without limitation in the term "modification".)\
+"Source code" for a work means the preferred form of the work for making modifications to it. For a library, complete source code means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control compilation and installation of the library.\
+Activities other than copying, distribution and modification are not covered by this License; they are outside its scope. The act of running a program using the Library is not restricted, and output from such a program is covered only if its contents constitute a work based on the Library (independent of the use of the Library in a tool for writing it). Whether that is true depends on what the Library does and what the program that uses the Library does.\
+
+\f0\b 1.
+\f1\b0  You may copy and distribute verbatim copies of the Library's complete source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty; keep intact all the notices that refer to this License and to the absence of any warranty; and distribute a copy of this License along with the Library.\
+You may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee.\
+
+\f0\b 2.
+\f1\b0  You may modify your copy or copies of the Library or any portion of it, thus forming a work based on the Library, and copy and distribute such modifications or work under the terms of Section 1 above, provided that you also meet all of these conditions:\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
+\ls6\ilvl0\cf0 {\listtext	1.	}The modified work must itself be a software library.\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\ql\qnatural
+\ls6\ilvl0\cf0 {\listtext	2.	}\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
+\ls6\ilvl0\cf0 {\listtext	3.	}You must cause the files modified to carry prominent notices stating that you changed the files and the date of any change.\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\ql\qnatural
+\ls6\ilvl0\cf0 {\listtext	4.	}\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
+\ls6\ilvl0\cf0 {\listtext	5.	}You must cause the whole of the work to be licensed at no charge to all third parties under the terms of this License.\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\ql\qnatural
+\ls6\ilvl0\cf0 {\listtext	6.	}\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
+\ls6\ilvl0\cf0 {\listtext	7.	}If a facility in the modified Library refers to a function or a table of data to be supplied by an application program that uses the facility, other than as an argument passed when the facility is invoked, then you must make a good faith effort to ensure that, in the event an application does not supply such function or table, the facility still operates, and performs whatever part of its purpose remains meaningful.\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\ql\qnatural
+\ls6\ilvl0\cf0 {\listtext	8.	}(For example, a function in a library to compute square roots has a purpose that is entirely well-defined independent of the application. Therefore, Subsection 2d requires that any application-supplied function or table used by this function must be optional: if the application does not supply it, the square root function must still compute square roots.)\
+\pard\pardeftab720\sa240\ql\qnatural
+\cf0 These requirements apply to the modified work as a whole. If identifiable sections of that work are not derived from the Library, and can be reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you distribute them as separate works. But when you distribute the same sections as part of a whole which is a work based on the Library, the distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to each and every part regardless of who wrote it.\
+Thus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you; rather, the intent is to exercise the right to control the distribution of derivative or collective works based on the Library.\
+In addition, mere aggregation of another work not based on the Library with the Library (or with a work based on the Library) on a volume of a storage or distribution medium does not bring the other work under the scope of this License.\
+\pard\pardeftab720\sa240\ql\qnatural
+
+\f0\b \cf0 3.
+\f1\b0  You may opt to apply the terms of the ordinary GNU General Public License instead of this License to a given copy of the Library. To do this, you must alter all the notices that refer to this License, so that they refer to the ordinary GNU General Public License, version 2, instead of to this License. (If a newer version than version 2 of the ordinary GNU General Public License has appeared, then you can specify that version instead if you wish.) Do not make any other change in these notices.\
+Once this change is made in a given copy, it is irreversible for that copy, so the ordinary GNU General Public License applies to all subsequent copies and derivative works made from that copy.\
+This option is useful when you wish to copy part of the code of the Library into a program that is not a library.\
+
+\f0\b 4.
+\f1\b0  You may copy and distribute the Library (or a portion or derivative of it, under Section 2) in object code or executable form under the terms of Sections 1 and 2 above provided that you accompany it with the complete corresponding machine-readable source code, which must be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange.\
+If distribution of object code is made by offering access to copy from a designated place, then offering equivalent access to copy the source code from the same place satisfies the requirement to distribute the source code, even though third parties are not compelled to copy the source along with the object code.\
+
+\f0\b 5.
+\f1\b0  A program that contains no derivative of any portion of the Library, but is designed to work with the Library by being compiled or linked with it, is called a "work that uses the Library". Such a work, in isolation, is not a derivative work of the Library, and therefore falls outside the scope of this License.\
+However, linking a "work that uses the Library" with the Library creates an executable that is a derivative of the Library (because it contains portions of the Library), rather than a "work that uses the library". The executable is therefore covered by this License. Section 6 states terms for distribution of such executables.\
+When a "work that uses the Library" uses material from a header file that is part of the Library, the object code for the work may be a derivative work of the Library even though the source code is not. Whether this is true is especially significant if the work can be linked without the Library, or if the work is itself a library. The threshold for this to be true is not precisely defined by law.\
+If such an object file uses only numerical parameters, data structure layouts and accessors, and small macros and small inline functions (ten lines or less in length), then the use of the object file is unrestricted, regardless of whether it is legally a derivative work. (Executables containing this object code plus portions of the Library will still fall under Section 6.)\
+Otherwise, if the work is a derivative of the Library, you may distribute the object code for the work under the terms of Section 6. Any executables containing that work also fall under Section 6, whether or not they are linked directly with the Library itself.\
+
+\f0\b 6.
+\f1\b0  As an exception to the Sections above, you may also compile or link a "work that uses the Library" with the Library to produce a work containing portions of the Library, and distribute that work under terms of your choice, provided that the terms permit modification of the work for the customer's own use and reverse engineering for debugging such modifications.\
+You must give prominent notice with each copy of the work that the Library is used in it and that the Library and its use are covered by this License. You must supply a copy of this License. If the work during execution displays copyright notices, you must include the copyright notice for the Library among them, as well as a reference directing the user to the copy of this License. Also, you must do one of these things:\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
+\ls7\ilvl0\cf0 {\listtext	1.	}Accompany the work with the complete corresponding machine-readable source code for the Library including whatever changes were used in the work (which must be distributed under Sections 1 and 2 above); and, if the work is an executable linked with the Library, with the complete machine-readable "work that uses the Library", as object code and/or source code, so that the user can modify the Library and then relink to produce a modified executable containing the modified Library. (It is understood that the user who changes the contents of definitions files in the Library will not necessarily be able to recompile the application to use the modified definitions.)\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\ql\qnatural
+\ls7\ilvl0\cf0 {\listtext	2.	}\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
+\ls7\ilvl0\cf0 {\listtext	3.	}Accompany the work with a written offer, valid for at least three years, to give the same user the materials specified in Subsection 6a, above, for a charge no more than the cost of performing this distribution.\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\ql\qnatural
+\ls7\ilvl0\cf0 {\listtext	4.	}\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
+\ls7\ilvl0\cf0 {\listtext	5.	}If distribution of the work is made by offering access to copy from a designated place, offer equivalent access to copy the above specified materials from the same place.\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\ql\qnatural
+\ls7\ilvl0\cf0 {\listtext	6.	}\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
+\ls7\ilvl0\cf0 {\listtext	7.	}Verify that the user has already received a copy of these materials or that you have already sent this user a copy.\
+\pard\pardeftab720\sa240\ql\qnatural
+\cf0 For an executable, the required form of the "work that uses the Library" must include any data and utility programs needed for reproducing the executable from it. However, as a special exception, the source code distributed need not include anything that is normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on which the executable runs, unless that component itself accompanies the executable.\
+It may happen that this requirement contradicts the license restrictions of other proprietary libraries that do not normally accompany the operating system. Such a contradiction means you cannot use both them and the Library together in an executable that you distribute.\
+\pard\pardeftab720\sa240\ql\qnatural
+
+\f0\b \cf0 7.
+\f1\b0  You may place library facilities that are a work based on the Library side-by-side in a single library together with other library facilities not covered by this License, and distribute such a combined library, provided that the separate distribution of the work based on the Library and of the other library facilities is otherwise permitted, and provided that you do these two things:\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
+\ls8\ilvl0\cf0 {\listtext	1.	}Accompany the combined library with a copy of the same work based on the Library, uncombined with any other library facilities. This must be distributed under the terms of the Sections above.\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\ql\qnatural
+\ls8\ilvl0\cf0 {\listtext	2.	}\
+\pard\tx220\tx720\pardeftab720\li720\fi-720\ql\qnatural
+\ls8\ilvl0\cf0 {\listtext	3.	}Give prominent notice with the combined library of the fact that part of it is a work based on the Library, and explaining where to find the accompanying uncombined form of the same work.\
+\pard\pardeftab720\sa240\ql\qnatural
+
+\f0\b \cf0 8.
+\f1\b0  You may not copy, modify, sublicense, link with, or distribute the Library except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, link with, or distribute the Library is void, and will automatically terminate your rights under this License. However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance.\
+
+\f0\b 9.
+\f1\b0  You are not required to accept this License, since you have not signed it. However, nothing else grants you permission to modify or distribute the Library or its derivative works. These actions are prohibited by law if you do not accept this License. Therefore, by modifying or distributing the Library (or any work based on the Library), you indicate your acceptance of this License to do so, and all its terms and conditions for copying, distributing or modifying the Library or works based on it.\
+
+\f0\b 10.
+\f1\b0  Each time you redistribute the Library (or any work based on the Library), the recipient automatically receives a license from the original licensor to copy, distribute, link with or modify the Library subject to these terms and conditions. You may not impose any further restrictions on the recipients' exercise of the rights granted herein. You are not responsible for enforcing compliance by third parties to this License.\
+
+\f0\b 11.
+\f1\b0  If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot distribute so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not distribute the Library at all. For example, if a patent license would not permit royalty-free redistribution of the Library by all those who receive copies directly or indirectly through you, then the only way you could satisfy both it and this License would be to refrain entirely from distribution of the Library.\
+If any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to apply, and the section as a whole is intended to apply in other circumstances.\
+It is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such claims; this section has the sole purpose of protecting the integrity of the free software distribution system which is implemented by public license practices. Many people have made generous contributions to the wide range of software distributed through that system in reliance on consistent application of that system; it is up to the author/donor to decide if he or she is willing to distribute software through any other system and a licensee cannot impose that choice.\
+This section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License.\
+
+\f0\b 12.
+\f1\b0  If the distribution and/or use of the Library is restricted in certain countries either by patents or by copyrighted interfaces, the original copyright holder who places the Library under this License may add an explicit geographical distribution limitation excluding those countries, so that distribution is permitted only in or among countries not thus excluded. In such case, this License incorporates the limitation as if written in the body of this License.\
+
+\f0\b 13.
+\f1\b0  The Free Software Foundation may publish revised and/or new versions of the Library General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.\
+Each version is given a distinguishing version number. If the Library specifies a version number of this License which applies to it and "any later version", you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation. If the Library does not specify a license version number, you may choose any version ever published by the Free Software Foundation.\
+
+\f0\b 14.
+\f1\b0  If you wish to incorporate parts of the Library into other free programs whose distribution conditions are incompatible with these, write to the author to ask for permission. For software which is copyrighted by the Free Software Foundation, write to the Free Software Foundation; we sometimes make exceptions for this. Our decision will be guided by the two goals of preserving the free status of all derivatives of our free software and of promoting the sharing and reuse of software generally.\
+
+\f0\b NO WARRANTY
+\f1\b0 \
+
+\f0\b 15.
+\f1\b0  BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE LIBRARY IS WITH YOU. SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\
+
+\f0\b 16.
+\f1\b0  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\
+\pard\pardeftab720\sa300\ql\qnatural
+
+\f0\b \cf0 END OF TERMS AND CONDITIONS\
+How to Apply These Terms to Your New Libraries\
+\pard\pardeftab720\sa240\ql\qnatural
+
+\f1\b0 \cf0 If you develop a new library, and you want it to be of the greatest possible use to the public, we recommend making it free software that everyone can redistribute and change. You can do so by permitting redistribution under these terms (or, alternatively, under the terms of the ordinary General Public License).\
+To apply these terms, attach the following notices to the library. It is safest to attach them to the start of each source file to most effectively convey the exclusion of warranty; and each file should have at least the "copyright" line and a pointer to where the full notice is found.\
+\pard\pardeftab720\ql\qnatural
+
+\f5\i \cf0 one line to give the library's name and an idea of what it does.
+\f3\i0 \
+Copyright (C) 
+\f5\i year
+\f3\i0   
+\f5\i name of author
+\f3\i0 \
+\
+This library is free software; you can redistribute it and/or\
+modify it under the terms of the GNU Lesser General Public\
+License as published by the Free Software Foundation; either\
+version 2.1 of the License, or (at your option) any later version.\
+\
+This library is distributed in the hope that it will be useful,\
+but WITHOUT ANY WARRANTY; without even the implied warranty of\
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\
+Lesser General Public License for more details.\
+\
+You should have received a copy of the GNU Lesser General Public\
+License along with this library; if not, write to the Free Software\
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\
+\pard\pardeftab720\sa240\ql\qnatural
+
+\f1 \cf0 Also add information on how to contact you by electronic and paper mail.\
+You should also get your employer (if you work as a programmer) or your school, if any, to sign a "copyright disclaimer" for the library, if necessary. Here is a sample; alter the names:\
+\pard\pardeftab720\ql\qnatural
+
+\f3 \cf0 Yoyodyne, Inc., hereby disclaims all copyright interest in\
+the library `Frob' (a library for tweaking knobs) written\
+by James Random Hacker.\
+\
+\pard\pardeftab720\ql\qnatural
+
+\f5\i \cf0 signature of Ty Coon
+\f3\i0 , 1 April 1990\
+Ty Coon, President of Vice\
+\pard\pardeftab720\sa240\ql\qnatural
+
+\f1 \cf0 That's all there is to it!\
+}
\ 
diff -urNad cupsys-1.1.99.b1.r4748~/packaging/WELCOME.rtf cupsys-1.1.99.b1.r4748/packaging/WELCOME.rtf
--- cupsys-1.1.99.b1.r4748~/packaging/WELCOME.rtf	1970-01-01 09:00:00.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/packaging/WELCOME.rtf	2005-11-13 03:48:19.114041000 +0900
@@ -0,0 +1,24 @@
+{\rtf1\mac\ansicpg10000\cocoartf824\cocoasubrtf110
+{\fonttbl\f0\fswiss\fcharset77 Helvetica;\f1\fswiss\fcharset77 Helvetica-Bold;}
+{\colortbl;\red255\green255\blue255;}
+\margl1440\margr1440\vieww9000\viewh8400\viewkind0
+\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural
+
+\f0\fs24 \cf0 This program installs a pre-release version of CUPS 1.2 and replaces the CUPS 1.1.x software that is included with MacOS X.\
+\
+
+\f1\b WARNING\
+
+\f0\b0 \
+This is pre-release software and should not be used in production environments. Because MacOS X packages cannot be uninstalled, you will need to reinstall MacOS X to revert to the original CUPS 1.1.x software.\
+\
+Please report all problems using the Bugs & Features page on the CUPS home page:\
+\
+	http://www.cups.org/str.php\
+\
+
+\f1\b NO WARRANTY\
+
+\f0\b0 \
+CUPS is provided under the terms of the GNU General Public License and GNU Library General Public License. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\
+}
\ 
diff -urNad cupsys-1.1.99.b1.r4748~/packaging/cups-desc.plist.in cupsys-1.1.99.b1.r4748/packaging/cups-desc.plist.in
--- cupsys-1.1.99.b1.r4748~/packaging/cups-desc.plist.in	1970-01-01 09:00:00.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/packaging/cups-desc.plist.in	2005-11-13 03:48:19.114041000 +0900
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+        <key>IFPkgDescriptionDeleteWarning</key>
+        <string></string>
+        <key>IFPkgDescriptionDescription</key>
+        <string>The Common UNIX Printing System provides a portable printing layer for UNIX(r) operating systems.
+</string>
+        <key>IFPkgDescriptionTitle</key>
+        <string>Common UNIX Printing System</string>
+        <key>IFPkgDescriptionVersion</key>
+        <string>@CUPS_RELEASE@</string>
+</dict>
+</plist>
diff -urNad cupsys-1.1.99.b1.r4748~/packaging/cups-info.plist.in cupsys-1.1.99.b1.r4748/packaging/cups-info.plist.in
--- cupsys-1.1.99.b1.r4748~/packaging/cups-info.plist.in	1970-01-01 09:00:00.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/packaging/cups-info.plist.in	2005-11-13 03:48:19.114041000 +0900
@@ -0,0 +1,24 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+        <key>IFPkgFlagAuthorizationAction</key>
+        <string>RootAuthorization</string>
+	<key>IFPkgFlagBackgroundAlignment</key>
+	<string>bottomleft</string>
+	<key>IFPkgFlagBackgroundScaling</key>
+	<string>none</string>
+        <key>IFPkgFormatVersion</key>
+        <real>0.1</real>
+	<key>CFBundleIdentifier</key>
+	<string>org.cups.cups</string>
+        <key>CFBundleName</key>
+        <string>Common UNIX Printing System</string>
+        <key>CFBundleGetInfoString</key>
+        <string>Common UNIX Printing System, @CUPS_VERSION@</string>
+        <key>CFBundleShortVersionString</key>
+        <string>@CUPS_RELEASE@</string>
+	<key>IFPkgFlagAllowBackRev</key>
+	<true/>
+</dict>
+</plist>
diff -urNad cupsys-1.1.99.b1.r4748~/packaging/cups.list.in cupsys-1.1.99.b1.r4748/packaging/cups.list.in
--- cupsys-1.1.99.b1.r4748~/packaging/cups.list.in	1970-01-01 09:00:00.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/packaging/cups.list.in	2005-11-13 06:55:57.819980000 +0900
@@ -0,0 +1,453 @@
+#
+# "$Id: cups.list.in 4834 2005-11-12 21:55:57Z mike $"
+#
+#   ESP Package Manager (EPM) file list for the Common UNIX Printing
+#   System (CUPS).
+#
+#   Copyright 1997-2005 by Easy Software Products, all rights reserved.
+#
+#   These coded instructions, statements, and computer programs are the
+#   property of Easy Software Products and are protected by Federal
+#   copyright law.  Distribution and use rights are outlined in the file
+#   "LICENSE.txt" which should have been included with this file.  If this
+#   file is missing or damaged please contact Easy Software Products
+#   at:
+#
+#       Attn: CUPS Licensing Information
+#       Easy Software Products
+#       44141 Airport View Drive, Suite 204
+#       Hollywood, Maryland 20636 USA
+#
+#       Voice: (301) 373-9600
+#       EMail: cups-info@cups.org
+#         WWW: http://www.cups.org
+#
+
+# Product information
+%product Common UNIX Printing System
+%copyright 1993-2005 by Easy Software Products, All Rights Reserved.
+%vendor Easy Software Products
+%license LICENSE.txt
+%readme README.txt
+%version @CUPS_VERSION@
+%description The Common UNIX Printing System provides a portable printing
+%description layer for UNIX(r) operating systems.  It has been developed by
+%description Easy Software Products to promote a standard printing solution
+%description for all UNIX vendors and users.  CUPS provides the System V and
+%description Berkeley command-line interfaces. 
+
+%format rpm
+%provides cups 1:@CUPS_VERSION@
+%provides lpd, lpr, LPRng
+%replaces lpd, lpr, LPRng
+
+%format deb
+%provides cupsys
+%provides cupsys-client
+%provides cupsys-bsd
+
+%format pkg
+%replaces SUNWlpmsg LP Alerts
+%replaces SUNWlpr LP Print Service, (Root)
+%replaces SUNWlps LP Print Service - Server, (Usr)
+%replaces SUNWlpu LP Print Service - Client, (Usr)
+%replaces SUNWpsu LP Print Server, (Usr)
+%replaces SUNWpsr LP Print Server, (Root)
+%replaces SUNWpcu LP Print Client, (Usr)
+%replaces SUNWpcr LP Print Client, (Root)
+%replaces SUNWppm
+%replaces SUNWmp
+%replaces SUNWscplp SunOS Print Compatibility
+
+%format inst
+%replaces patch*.print_*.* 0 0 1289999999 1289999999
+%replaces maint*.print_*.* 0 0 1289999999 1289999999
+%replaces print 0 0 1289999999 1289999999
+%replaces fw_cups 0 0 1289999999 1289999999
+%incompat patch*.print_*.* 0 0 1289999999 1289999999
+%incompat maint*.print_*.* 0 0 1289999999 1289999999
+%incompat print 0 0 1289999999 1289999999
+%incompat fw_cups 0 0 1289999999 1289999999
+
+%format all
+
+%subpackage libs
+%description Common UNIX Printing System - shared libraries
+%format rpm
+%provides cups-libs 1:@CUPS_VERSION@
+%format deb
+%provides libcups1
+%provides libcupsys2
+%provides libcupsys2-gnutls10
+%provides libcupsimage2
+%format all
+
+%subpackage devel
+%description Common UNIX Printing System - development environment
+%format rpm
+%provides cups-devel 1:@CUPS_VERSION@
+%format deb
+%provides libcupsys2-dev
+%provides libcupsimage2-dev
+%format all
+
+%subpackage lpd
+%description Common UNIX Printing System - LPD support
+%format rpm
+%provides cups-lpd 1:@CUPS_VERSION@
+%format all
+
+%subpackage
+
+
+#
+# GNU variables...
+#
+
+$prefix=@prefix@
+$exec_prefix=@exec_prefix@
+$bindir=@bindir@
+$datadir=@datadir@
+$includedir=@includedir@
+$infodir=@infodir@
+$libdir=@libdir@
+$libexecdir=@libexecdir@
+$localstatedir=@localstatedir@
+$mandir=@mandir@
+$oldincludedir=@oldincludedir@
+$sbindir=@sbindir@
+$sharedstatedir=@sharedstatedir@
+$srcdir=@srcdir@
+$sysconfdir=@sysconfdir@
+$top_srcdir=@top_srcdir@
+
+#
+# ESP variables...
+#
+
+$AMANDIR=@AMANDIR@
+$BINDIR=@bindir@
+$CACHEDIR=@CUPS_CACHEDIR@
+$DATADIR=@CUPS_DATADIR@
+$DOCDIR=@CUPS_DOCROOT@
+$INCLUDEDIR=${includedir}
+$INITDIR=@INITDIR@
+$INITDDIR=@INITDDIR@
+$LIBDIR=${libdir}
+$LOCALEDIR=@CUPS_LOCALEDIR@
+$LOGDIR=@CUPS_LOGDIR@
+$MANDIR=@mandir@
+$PAMDIR=@PAMDIR@
+$PMANDIR=@PMANDIR@
+$REQUESTS=@CUPS_REQUESTS@
+$SBINDIR=@sbindir@
+$SERVERBIN=@CUPS_SERVERBIN@
+$SERVERROOT=@CUPS_SERVERROOT@
+$STATEDIR=@CUPS_STATEDIR@
+
+$CUPS_USER=@CUPS_USER@
+$CUPS_GROUP=@CUPS_GROUP@
+
+$MAN1EXT=@MAN1EXT@
+$MAN5EXT=@MAN5EXT@
+$MAN8EXT=@MAN8EXT@
+$MAN8DIR=@MAN8DIR@
+
+$DSOLIBS=@DSOLIBS@
+
+# Make sure the MD5 password file is now owned by CUPS_USER...
+%postinstall if test -f $SERVERROOT/passwd.md5; then
+%postinstall chown $CUPS_USER $SERVERROOT/passwd.md5
+%postinstall fi
+
+# Make sure the shared libraries are refreshed...
+%subpackage libs
+%system linux
+%postinstall ldconfig
+%system all
+%subpackage
+
+# Server programs
+%system all
+# Server files
+f 0755 root sys $SBINDIR/cupsd scheduler/cupsd
+
+d 0755 root sys $SERVERBIN -
+d 0755 root sys $SERVERBIN/backend -
+f 0755 root sys $SERVERBIN/backend/ipp backend/ipp
+l 0755 root sys $SERVERBIN/backend/http ipp
+f 0755 root sys $SERVERBIN/backend/lpd backend/lpd
+f 0755 root sys $SERVERBIN/backend/parallel backend/parallel
+f 0755 root sys $SERVERBIN/backend/scsi backend/scsi
+f 0755 root sys $SERVERBIN/backend/serial backend/serial
+f 0755 root sys $SERVERBIN/backend/socket backend/socket
+f 0755 root sys $SERVERBIN/backend/usb backend/usb
+d 0755 root sys $SERVERBIN/cgi-bin -
+f 0755 root sys $SERVERBIN/cgi-bin/admin.cgi cgi-bin/admin.cgi
+f 0755 root sys $SERVERBIN/cgi-bin/classes.cgi cgi-bin/classes.cgi
+f 0755 root sys $SERVERBIN/cgi-bin/help.cgi cgi-bin/help.cgi
+f 0755 root sys $SERVERBIN/cgi-bin/jobs.cgi cgi-bin/jobs.cgi
+f 0755 root sys $SERVERBIN/cgi-bin/printers.cgi cgi-bin/printers.cgi
+d 0755 root sys $SERVERBIN/daemon -
+f 0755 root sys $SERVERBIN/daemon/cups-deviced scheduler/cups-deviced
+f 0755 root sys $SERVERBIN/daemon/cups-driverd scheduler/cups-driverd
+f 0755 root sys $SERVERBIN/daemon/cups-polld scheduler/cups-polld
+d 0755 root sys $SERVERBIN/driver -
+d 0755 root sys $SERVERBIN/filter -
+f 0755 root sys $SERVERBIN/filter/gziptoany filter/gziptoany
+f 0755 root sys $SERVERBIN/filter/hpgltops filter/hpgltops
+f 0755 root sys $SERVERBIN/filter/imagetops filter/imagetops
+f 0755 root sys $SERVERBIN/filter/imagetoraster filter/imagetoraster
+f 0755 root sys $SERVERBIN/filter/pdftops pdftops/pdftops
+f 0755 root sys $SERVERBIN/filter/pstops filter/pstops
+f 0755 root sys $SERVERBIN/filter/rastertolabel filter/rastertolabel
+l 0755 root sys $SERVERBIN/filter/rastertodymo rastertolabel
+f 0755 root sys $SERVERBIN/filter/rastertoepson filter/rastertoepson
+f 0755 root sys $SERVERBIN/filter/rastertohp filter/rastertohp
+f 0755 root sys $SERVERBIN/filter/texttops filter/texttops
+d 0755 root sys $SERVERBIN/notifier -
+f 0755 root sys $SERVERBIN/notifier/mailto notifier/mailto
+
+%subpackage lpd
+d 0755 root sys $SERVERBIN/daemon -
+f 0755 root sys $SERVERBIN/daemon/cups-lpd scheduler/cups-lpd
+%subpackage
+
+# Admin commands
+d 0755 root sys $BINDIR -
+l 0755 root sys $BINDIR/enable $SBINDIR/accept
+l 0755 root sys $LIBDIR/accept $SBINDIR/accept
+d 0755 root sys $SBINDIR -
+l 0755 root sys $SBINDIR/cupsdisable accept
+l 0755 root sys $SBINDIR/cupsenable accept
+l 0755 root sys $BINDIR/disable $SBINDIR/accept
+d 0755 root sys $LIBDIR -
+l 0755 root sys $LIBDIR/lpadmin $SBINDIR/lpadmin
+l 0755 root sys $LIBDIR/reject accept
+f 0755 root sys $SBINDIR/accept systemv/accept
+f 0755 root sys $SBINDIR/cupsaddsmb systemv/cupsaddsmb
+f 0755 root sys $SBINDIR/lpadmin systemv/lpadmin
+f 0755 root sys $SBINDIR/lpc berkeley/lpc
+f 0755 root sys $SBINDIR/lpinfo systemv/lpinfo
+f 0755 root sys $SBINDIR/lpmove systemv/lpmove
+l 0755 root sys $SBINDIR/reject accept
+
+%system irix
+l 0755 root sys /usr/etc/lpc $SBINDIR/lpc
+%system all
+
+# User commands
+d 0755 root sys $BINDIR -
+f 0755 root sys $BINDIR/cancel systemv/cancel
+f 0755 root sys $BINDIR/cupstestppd systemv/cupstestppd
+f 0755 root sys $BINDIR/lp systemv/lp
+f 0755 root sys $BINDIR/lpoptions systemv/lpoptions
+f 4755 $CUPS_USER sys $BINDIR/lppasswd systemv/lppasswd
+f 0755 root sys $BINDIR/lpq berkeley/lpq
+f 0755 root sys $BINDIR/lpr berkeley/lpr
+f 0755 root sys $BINDIR/lprm berkeley/lprm
+f 0755 root sys $BINDIR/lpstat systemv/lpstat
+
+%system irix
+l 0755 root sys /usr/bsd/lpq $BINDIR/lpq
+l 0755 root sys /usr/bsd/lpr $BINDIR/lpr
+l 0755 root sys /usr/bsd/lprm $BINDIR/lprm
+%system all
+
+# DSOs
+%if DSOLIBS
+%subpackage libs
+%system hpux
+f 0755 root sys $LIBDIR/libcups.sl.2 cups/libcups.sl.2
+l 0755 root sys $LIBDIR/libcups.sl libcups.sl.2
+f 0755 root sys $LIBDIR/libcupsimage.sl.2 filter/libcupsimage.sl.2
+l 0755 root sys $LIBDIR/libcupsimage.sl libcupsimage.sl.2
+%system aix
+f 0755 root sys $LIBDIR/libcups_s.a cups/libcups_s.a
+f 0755 root sys $LIBDIR/libcupsimage_s.a filter/libcupsimage_s.a
+%system darwin
+f 0755 root sys $LIBDIR/libcups.2.dylib cups/libcups.2.dylib
+l 0755 root sys $LIBDIR/libcups.dylib libcups.2.dylib
+f 0755 root sys $LIBDIR/libcupsimage.2.dylib filter/libcupsimage.2.dylib
+l 0755 root sys $LIBDIR/libcupsimage.dylib libcupsimage.2.dylib
+%system !hpux !aix !darwin
+f 0755 root sys $LIBDIR/libcups.so.2 cups/libcups.so.2
+l 0755 root sys $LIBDIR/libcups.so libcups.so.2
+f 0755 root sys $LIBDIR/libcupsimage.so.2 filter/libcupsimage.so.2
+l 0755 root sys $LIBDIR/libcupsimage.so libcupsimage.so.2
+%system all
+%subpackage
+%endif
+
+# Directories
+d 0755 root sys $LOGDIR -
+d 0755 root sys $REQUESTS -
+d 0755 root sys $REQUESTS/tmp -
+d 0755 root sys $CACHEDIR -
+d 0755 root sys $CACHEDIR/ppd -
+d 0755 root sys $STATEDIR -
+d 0755 root sys $STATEDIR/certs -
+
+# Data files
+f 0644 root sys $LOCALEDIR/C/cups_C locale/C/cups_C
+f 0644 root sys $LOCALEDIR/be/cups_be locale/be/cups_be
+f 0644 root sys $LOCALEDIR/cs/cups_cs locale/cs/cups_cs
+f 0644 root sys $LOCALEDIR/de/cups_de locale/de/cups_de
+f 0644 root sys $LOCALEDIR/en/cups_en locale/en/cups_en
+f 0644 root sys $LOCALEDIR/en_US/cups_en_US locale/en_US/cups_en_US
+f 0644 root sys $LOCALEDIR/es/cups_es locale/es/cups_es
+f 0644 root sys $LOCALEDIR/fr/cups_fr locale/fr/cups_fr
+f 0644 root sys $LOCALEDIR/it/cups_it locale/it/cups_it
+f 0644 root sys $LOCALEDIR/ru_RU/cups_ru_RU locale/ru_RU/cups_ru_RU
+f 0644 root sys $LOCALEDIR/sv/cups_sv locale/sv/cups_sv
+f 0644 root sys $LOCALEDIR/uk/cups_uk locale/uk/cups_uk
+f 0644 root sys $LOCALEDIR/uk_UA/cups_uk_UA locale/uk_UA/cups_uk_UA
+f 0644 root sys $LOCALEDIR/zh_CN/cups_zh_CN locale/zh_CN/cups_zh_CN
+
+d 0755 root sys $DATADIR -
+
+d 0755 root sys $DATADIR/banners -
+f 0644 root sys $DATADIR/banners/classified data/classified
+f 0644 root sys $DATADIR/banners/confidential data/confidential
+f 0644 root sys $DATADIR/banners/secret data/secret
+f 0644 root sys $DATADIR/banners/standard data/standard
+f 0644 root sys $DATADIR/banners/topsecret data/topsecret
+f 0644 root sys $DATADIR/banners/unclassified data/unclassified
+
+d 0755 root sys $DATADIR/charsets -
+f 0644 root sys $DATADIR/charsets/windows-874 data/windows-874
+f 0644 root sys $DATADIR/charsets/windows-1250 data/windows-1250
+f 0644 root sys $DATADIR/charsets/windows-1251 data/windows-1251
+f 0644 root sys $DATADIR/charsets/windows-1252 data/windows-1252
+f 0644 root sys $DATADIR/charsets/windows-1253 data/windows-1253
+f 0644 root sys $DATADIR/charsets/windows-1254 data/windows-1254
+f 0644 root sys $DATADIR/charsets/windows-1255 data/windows-1255
+f 0644 root sys $DATADIR/charsets/windows-1256 data/windows-1256
+f 0644 root sys $DATADIR/charsets/windows-1257 data/windows-1257
+f 0644 root sys $DATADIR/charsets/windows-1258 data/windows-1258
+f 0644 root sys $DATADIR/charsets/iso-8859-1 data/iso-8859-1
+f 0644 root sys $DATADIR/charsets/iso-8859-2 data/iso-8859-2
+f 0644 root sys $DATADIR/charsets/iso-8859-3 data/iso-8859-3
+f 0644 root sys $DATADIR/charsets/iso-8859-4 data/iso-8859-4
+f 0644 root sys $DATADIR/charsets/iso-8859-5 data/iso-8859-5
+f 0644 root sys $DATADIR/charsets/iso-8859-6 data/iso-8859-6
+f 0644 root sys $DATADIR/charsets/iso-8859-7 data/iso-8859-7
+f 0644 root sys $DATADIR/charsets/iso-8859-8 data/iso-8859-8
+f 0644 root sys $DATADIR/charsets/iso-8859-9 data/iso-8859-9
+f 0644 root sys $DATADIR/charsets/iso-8859-10 data/iso-8859-10
+f 0644 root sys $DATADIR/charsets/iso-8859-13 data/iso-8859-13
+f 0644 root sys $DATADIR/charsets/iso-8859-14 data/iso-8859-14
+f 0644 root sys $DATADIR/charsets/iso-8859-15 data/iso-8859-15
+f 0644 root sys $DATADIR/charsets/utf-8 data/utf-8
+
+d 0755 root sys $DATADIR/data -
+f 0644 root sys $DATADIR/data/HPGLprolog data/HPGLprolog
+f 0644 root sys $DATADIR/data/psglyphs data/psglyphs
+f 0644 root sys $DATADIR/data/testprint.ps data/testprint.ps
+
+d 0755 root sys $DATADIR/fonts -
+f 0644 root sys $DATADIR/fonts fonts/Courier*
+f 0644 root sys $DATADIR/fonts/Symbol fonts/Symbol
+
+d 0755 root sys $DATADIR/model -
+f 0644 root sys $DATADIR/model ppd/*.ppd
+
+d 0755 root sys $DATADIR/templates -
+c 0644 root sys $DATADIR/templates templates/*.tmpl
+
+# Config files
+d 0755 root sys $SERVERROOT -
+d 0711 $CUPS_USER $CUPS_GROUP $SERVERROOT/certs -
+d 0755 root sys $SERVERROOT/interfaces -
+d 0755 root sys $SERVERROOT/ppd -
+c 0600 root sys $SERVERROOT conf/*.conf
+c 0600 root sys $SERVERROOT/mime.convs conf/mime.convs
+c 0600 root sys $SERVERROOT/mime.types conf/mime.types
+
+%if PAMDIR
+d 0755 root sys $PAMDIR -
+c 0644 root sys $PAMDIR/cups conf/@PAMFILE@
+%endif
+
+%subpackage devel
+# Developer files
+f 0755 root sys $BINDIR/cups-config cups-config
+d 0755 root sys $INCLUDEDIR/cups -
+f 0644 root sys $INCLUDEDIR/cups/cups.h cups/cups.h
+f 0644 root sys $INCLUDEDIR/cups/http.h cups/http.h
+f 0644 root sys $INCLUDEDIR/cups/image.h filter/image.h
+f 0644 root sys $INCLUDEDIR/cups/ipp.h cups/ipp.h
+f 0644 root sys $INCLUDEDIR/cups/language.h cups/language.h
+f 0644 root sys $INCLUDEDIR/cups/md5.h cups/md5.h
+f 0644 root sys $INCLUDEDIR/cups/ppd.h cups/ppd.h
+f 0644 root sys $INCLUDEDIR/cups/raster.h filter/raster.h
+
+f 0644 root sys $LIBDIR/libcups.a cups/libcups.a
+f 0644 root sys $LIBDIR/libcupsimage.a filter/libcupsimage.a
+
+d 0755 root sys $DOCDIR/help -
+f 0644 root sys $DOCDIR/help doc/help/api*.html
+%subpackage
+
+# Documentation files
+d 0755 root sys $DOCDIR -
+f 0644 root sys $DOCDIR doc/*.css
+f 0644 root sys $DOCDIR doc/*.html
+d 0755 root sys $DOCDIR/help -
+f 0644 root sys $DOCDIR/help doc/*-reference.html
+d 0755 root sys $DOCDIR/images -
+f 0644 root sys $DOCDIR/images doc/images/*.gif
+f 0644 root sys $DOCDIR/robots.txt doc/robots.txt
+
+# Man pages
+d 0755 root sys $AMANDIR -
+d 0755 root sys $AMANDIR/man$MAN8DIR -
+d 0755 root sys $MANDIR -
+d 0755 root sys $MANDIR/man1 -
+d 0755 root sys $MANDIR/man5 -
+
+f 0644 root sys $MANDIR/man1/backend.$MAN1EXT man/backend.$MAN1EXT
+f 0644 root sys $MANDIR/man1/cupstestppd.$MAN1EXT man/cupstestppd.$MAN1EXT
+f 0644 root sys $MANDIR/man1/filter.$MAN1EXT man/filter.$MAN1EXT
+f 0644 root sys $MANDIR/man1/lpoptions.$MAN1EXT man/lpoptions.$MAN1EXT
+f 0644 root sys $MANDIR/man1/lppasswd.$MAN1EXT man/lppasswd.$MAN1EXT
+f 0644 root sys $MANDIR/man1/lpq.$MAN1EXT man/lpq.$MAN1EXT
+f 0644 root sys $MANDIR/man1/lprm.$MAN1EXT man/lprm.$MAN1EXT
+f 0644 root sys $MANDIR/man1/lpr.$MAN1EXT man/lpr.$MAN1EXT
+f 0644 root sys $MANDIR/man1/lpstat.$MAN1EXT man/lpstat.$MAN1EXT
+f 0644 root sys $MANDIR/man1/lp.$MAN1EXT man/lp.$MAN1EXT
+l 0644 root sys $MANDIR/man1/cancel.$MAN1EXT lp.$MAN1EXT
+
+f 0644 root sys $MANDIR/man5/classes.conf.$MAN5EXT man/classes.conf.$MAN5EXT
+f 0644 root sys $MANDIR/man5/cupsd.conf.$MAN5EXT man/cupsd.conf.$MAN5EXT
+f 0644 root sys $MANDIR/man5/mime.convs.$MAN5EXT man/mime.convs.$MAN5EXT
+f 0644 root sys $MANDIR/man5/mime.types.$MAN5EXT man/mime.types.$MAN5EXT
+f 0644 root sys $MANDIR/man5/printers.conf.$MAN5EXT man/printers.conf.$MAN5EXT
+
+f 0644 root sys $AMANDIR/man$MAN8DIR/accept.$MAN8EXT man/accept.$MAN8EXT
+l 0644 root sys $AMANDIR/man$MAN8DIR/reject.$MAN8EXT accept.$MAN8EXT
+f 0644 root sys $AMANDIR/man$MAN8DIR/cupsaddsmb.$MAN8EXT man/cupsaddsmb.$MAN8EXT
+f 0644 root sys $AMANDIR/man$MAN8DIR/cups-polld.$MAN8EXT man/cups-polld.$MAN8EXT
+f 0644 root sys $AMANDIR/man$MAN8DIR/cupsd.$MAN8EXT man/cupsd.$MAN8EXT
+f 0644 root sys $AMANDIR/man$MAN8DIR/cupsenable.$MAN8EXT man/cupsenable.$MAN8EXT
+l 0644 root sys $AMANDIR/man$MAN8DIR/cupsdisable.$MAN8EXT cupsenable.$MAN8EXT
+f 0644 root sys $AMANDIR/man$MAN8DIR/lpadmin.$MAN8EXT man/lpadmin.$MAN8EXT
+f 0644 root sys $AMANDIR/man$MAN8DIR/lpc.$MAN8EXT man/lpc.$MAN8EXT
+f 0644 root sys $AMANDIR/man$MAN8DIR/lpinfo.$MAN8EXT man/lpinfo.$MAN8EXT
+f 0644 root sys $AMANDIR/man$MAN8DIR/lpmove.$MAN8EXT man/lpmove.$MAN8EXT
+
+%subpackage devel
+f 0644 root sys $MANDIR/man1/cups-config.$MAN1EXT man/cups-config.$MAN1EXT
+
+%subpackage lpd
+d 0755 root sys $AMANDIR/man$MAN8DIR -
+f 0644 root sys $AMANDIR/man$MAN8DIR/cups-lpd.$MAN8EXT man/cups-lpd.$MAN8EXT
+%subpackage
+
+# Startup script
+%system all
+i 0755 root sys cups cups.sh
+
+#
+# End of "$Id: cups.list.in 4834 2005-11-12 21:55:57Z mike $".
+#
diff -urNad cupsys-1.1.99.b1.r4748~/packaging/cups.spec.in cupsys-1.1.99.b1.r4748/packaging/cups.spec.in
--- cupsys-1.1.99.b1.r4748~/packaging/cups.spec.in	1970-01-01 09:00:00.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/packaging/cups.spec.in	2005-11-13 07:00:16.644476000 +0900
@@ -0,0 +1,277 @@
+#
+# "$Id: cups.spec 4787 2005-10-13 20:13:21Z mike $"
+#
+#   RPM "spec" file for the Common UNIX Printing System (CUPS).
+#
+#   Original version by Jason McMullan <jmcc@ontv.com>.
+#
+#   Copyright 1999-2005 by Easy Software Products, all rights reserved.
+#
+#   These coded instructions, statements, and computer programs are the
+#   property of Easy Software Products and are protected by Federal
+#   copyright law.  Distribution and use rights are outlined in the file
+#   "LICENSE.txt" which should have been included with this file.  If this
+#   file is missing or damaged please contact Easy Software Products
+#   at:
+#
+#       Attn: CUPS Licensing Information
+#       Easy Software Products
+#       44141 Airport View Drive, Suite 204
+#       Hollywood, Maryland 20636 USA
+#
+#       Voice: (301) 373-9600
+#       EMail: cups-info@cups.org
+#         WWW: http://www.cups.org
+#
+
+Summary: Common Unix Printing System
+Name: cups
+Version: @CUPS_VERSION@
+Release: 0
+Epoch: 1
+License: GPL
+Group: System Environment/Daemons
+Source: ftp://ftp.easysw.com/pub/cups/%{version}/cups-%{version}-source.tar.gz
+Url: http://www.cups.org
+Packager: Anonymous <anonymous@foo.com>
+Vendor: Easy Software Products
+
+# Use buildroot so as not to disturb the version already installed
+BuildRoot: /tmp/%{name}-root
+
+# Dependencies...
+Requires: %{name}-libs = %{epoch}:%{version}
+Obsoletes: lpd, lpr, LPRng
+Provides: lpd, lpr, LPRng
+
+%package devel
+Summary: Common Unix Printing System - development environment
+Group: Development/Libraries
+Requires: %{name}-libs = %{epoch}:%{version}
+
+%package libs
+Summary: Common Unix Printing System - shared libraries
+Group: System Environment/Libraries
+Provides: libcups1
+
+%package lpd
+Summary: Common Unix Printing System - LPD support
+Group: System Environment/Daemons
+Requires: %{name} = %{epoch}:%{version} xinetd
+
+%description
+The Common UNIX Printing System provides a portable printing layer for 
+UNIX operating systems. It has been developed by Easy Software Products 
+to promote a standard printing solution for all UNIX vendors and users. 
+CUPS provides the System V and Berkeley command-line interfaces. 
+
+%description devel
+The Common UNIX Printing System provides a portable printing layer for 
+UNIX operating systems. This is the development package for creating
+additional printer drivers and other CUPS services.
+
+%description libs
+The Common UNIX Printing System provides a portable printing layer for 
+UNIX operating systems. This package contains the CUPS shared libraries.
+
+%description lpd
+The Common UNIX Printing System provides a portable printing layer for 
+UNIX operating systems. This package provides LPD client support.
+
+%prep
+%setup
+
+%build
+CFLAGS="$RPM_OPT_FLAGS" CXXFLAGS="$RPM_OPT_FLAGS" LDFLAGS="$RPM_OPT_FLAGS" ./configure
+
+# If we got this far, all prerequisite libraries must be here.
+make
+
+%install
+# Make sure the RPM_BUILD_ROOT directory exists.
+rm -rf $RPM_BUILD_ROOT
+
+make BUILDROOT=$RPM_BUILD_ROOT install
+
+%post
+ldconfig
+
+if test -x /sbin/chkconfig; then
+	/sbin/chkconfig --add cups
+	/sbin/chkconfig cups on
+fi
+
+# these lines automatically start cupsd after installation; commented out
+# by request...
+#if test -f /sbin/init.d/cups; then
+#	/sbin/init.d/cups start
+#fi
+#if test -f /etc/rc.d/init.d/cups; then
+#	/etc/rc.d/init.d/cups start
+#fi
+#if test -f /etc/init.d/cups; then
+#	/etc/init.d/cups start
+#fi
+
+%preun
+if test -f /sbin/init.d/cups; then
+	/sbin/init.d/cups stop
+fi
+if test -f /etc/rc.d/init.d/cups; then
+	/etc/rc.d/init.d/cups stop
+fi
+if test -f /etc/init.d/cups; then
+	/etc/init.d/cups stop
+fi
+
+if test -x /sbin/chkconfig; then
+	/sbin/chkconfig --del cups
+fi
+
+%clean
+rm -rf $RPM_BUILD_ROOT
+
+%files
+%defattr(-,root,root)
+%dir /etc/cups
+%config(noreplace) /etc/cups/*.conf
+%dir /etc/cups/interfaces
+/etc/cups/mime.types
+/etc/cups/mime.convs
+%dir /etc/cups/ppd
+%dir /etc/pam.d
+/etc/pam.d/*
+
+# RC dirs are a pain under Linux...  Uncomment the appropriate ones if you
+# don't use Red Hat or Mandrake...
+
+/etc/init.d/*
+/etc/rc0.d/*
+/etc/rc2.d/*
+/etc/rc3.d/*
+/etc/rc5.d/*
+
+# OLD RedHat/Mandrake
+#/etc/rc.d/init.d/*
+#/etc/rc.d/rc0.d/*
+#/etc/rc.d/rc2.d/*
+#/etc/rc.d/rc3.d/*
+#/etc/rc.d/rc5.d/*
+
+#/sbin/rc.d/*
+#/sbin/rc.d/rc0.d/*
+#/sbin/rc.d/rc2.d/*
+#/sbin/rc.d/rc3.d/*
+#/sbin/rc.d/rc5.d/*
+
+/usr/bin/cancel
+/usr/bin/cupstestppd
+/usr/bin/lp*
+%dir /usr/lib/cups
+%dir /usr/lib/cups/backend
+/usr/lib/cups/backend/*
+%dir /usr/lib/cups/cgi-bin
+/usr/lib/cups/cgi-bin/*
+%dir /usr/lib/cups/daemon
+/usr/lib/cups/daemon/cups-deviced
+/usr/lib/cups/daemon/cups-driverd
+/usr/lib/cups/daemon/cups-polld
+%dir /usr/lib/cups/driver
+%dir /usr/lib/cups/filter
+/usr/lib/cups/filter/*
+%dir /usr/lib/cups/notifier
+/usr/lib/cups/notifier/*
+
+/usr/sbin/*
+%dir /usr/share/cups
+/usr/share/cups/*
+%dir /usr/share/doc/cups
+/usr/share/doc/cups/*.*
+%dir /usr/share/doc/cups/help
+/usr/share/doc/cups/help/*-reference.html
+%dir /usr/share/doc/cups/images
+/usr/share/doc/cups/images/*
+%dir /usr/share/locale
+/usr/share/locale/*
+
+%dir /usr/share/man/cat1
+/usr/share/man/cat1/cancel.1
+/usr/share/man/cat1/cupstestppd.1
+/usr/share/man/cat1/lp.1
+/usr/share/man/cat1/lpoptions.1
+/usr/share/man/cat1/lppasswd.1
+/usr/share/man/cat1/lpq.1
+/usr/share/man/cat1/lpr.1
+/usr/share/man/cat1/lprm.1
+/usr/share/man/cat1/lpstat.1
+%dir /usr/share/man/cat5
+/usr/share/man/cat5/*
+%dir /usr/share/man/cat8
+/usr/share/man/cat8/*
+%dir /usr/share/man/man1
+/usr/share/man/man1/cancel.1.gz
+/usr/share/man/man1/cupstestppd.1.gz
+/usr/share/man/man1/lp.1.gz
+/usr/share/man/man1/lpoptions.1.gz
+/usr/share/man/man1/lppasswd.1.gz
+/usr/share/man/man1/lpq.1.gz
+/usr/share/man/man1/lpr.1.gz
+/usr/share/man/man1/lprm.1.gz
+/usr/share/man/man1/lpstat.1.gz
+%dir /usr/share/man/man5
+/usr/share/man/man5/*
+%dir /usr/share/man/man8
+/usr/share/man/man8/accept.8.gz
+/usr/share/man/man8/cupsaddsmb.8.gz
+/usr/share/man/man8/cupsd.8.gz
+/usr/share/man/man8/cupsenable.8.gz
+/usr/share/man/man8/cups-polld.8.gz
+/usr/share/man/man8/lpadmin.8.gz
+/usr/share/man/man8/lpc.8.gz
+/usr/share/man/man8/lpinfo.8.gz
+/usr/share/man/man8/lpmove.8.gz
+
+%dir /var/cache/cups
+%dir /var/cache/cups/ppd
+%dir /var/log/cups
+%dir /var/run/cups
+%attr(0711,lp,root) %dir /var/run/cups/certs
+%attr(0700,lp,root) %dir /var/spool/cups
+%attr(1700,lp,root) %dir /var/spool/cups/tmp
+
+%files devel
+%defattr(-,root,root)
+%dir /usr/share/man/cat1
+/usr/share/man/cat1/backend.1
+/usr/share/man/cat1/cups-config.1
+/usr/share/man/cat1/filter.1
+%dir /usr/share/man/man1
+/usr/share/man/man1/backend.1.gz
+/usr/share/man/man1/cups-config.1.gz
+/usr/share/man/man1/filter.1.gz
+
+/usr/bin/cups-config
+%dir /usr/include/cups
+/usr/include/cups/*
+/usr/lib/*.a
+/usr/lib/*.so
+
+%dir /usr/share/doc/cups/help
+/usr/share/doc/cups/help/api*.html
+
+%files libs
+%defattr(-,root,root)
+/usr/lib/*.so.*
+
+%files lpd
+%defattr(-,root,root)
+#/etc/xinetd.d/cups-lpd
+%dir /usr/lib/cups
+%dir /usr/lib/cups/daemon
+/usr/lib/cups/daemon/cups-lpd
+%dir /usr/share/man/man8
+/usr/share/man/man8/cups-lpd.8.gz
+
+#
+# End of "$Id: cups.spec 4787 2005-10-13 20:13:21Z mike $".
+#
diff -urNad cupsys-1.1.99.b1.r4748~/packaging/installer.tif cupsys-1.1.99.b1.r4748/packaging/installer.tif
--- cupsys-1.1.99.b1.r4748~/packaging/installer.tif	1970-01-01 09:00:00.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/packaging/installer.tif	2005-11-13 03:48:19.114041000 +0900
@@ -0,0 +1,22 @@
+II* d  xu0E) 
+ (} \ @8G ?ft 	Hz3oFl6  9N)\.: x>#gKnxmebnnTIAxpu55~j-}RM+.C^^'2o&kGtg|f|=:3s	jH?G7v:YrZuCNr{?'z&'hWAMWL9	Gs,{/~9# &ZwaF7{kAka~5{Z9	-iV?n[zZ{t{{-,Gz^5Ak|=VeV!TY q1j`bw\+VtrU_i%iJK5z<+-l(e+R+D/(kN}(]ZMUOd k;_jNP>HqAE8	ZWRZC(4NPZq=f%)'~>"A)OiR|6Y}m'Wo{5,[xf\S6.igh.<[okR
+GIz|)%zk"8R>-08'mr9.7
+}!T^["Dx6f5i\)j>7
+bJ|Ea]kRG2Lqu.x]y$!R@R@@
+H
+HI ({vtmkX<??oob9(uPUu{}c~wrauyOOOW:g[i Fe\!?j6Qpm_Z^o2[w:C
+B_nO
+quQ2+& [&|IqH/x&|?Rq]qc)O$r'>n(%8M!PMHW>CL9 Eo7#2u})OhGc9LYV9r:mG-]0 q6-=7Nb0q9>;5~8&avk5&p})s@m*[)+uo;}_Wksl1lM}3NpS,c/%AWX|+i?b~aJm8k/>}dc*7{e<&X8q+f|ato\ 11^B%G}lqK} Y	" /c%+mX2 <fka~NI+m+;PS6*|yz1F3jJk Kr}xe=86PsmM7D&aJS0V|6(q62DISM"SAzM,'l&d,+02 2e%52=h},~SY>Xou7A#V?'mcTpZwUSM"S
+yr%4\w0Xf(q!g}
+|8K?Z_qr]d""#M\3osMC&k0MK\ Dn|sLr '3Dt)59~oal|aXs~g=o2m$Ia9sL&)6l^@9I\0~\s%y{zf0EiOr_i. o n`7 W&Okm n(wap7LN|[o0+<swoe[-M {o|{+qe4mn\8wap7 W&	&}\0[L)ioo}tgQnL;8E9p]U@@`o8qmZ@,|!|;+(G=[w 6,zWjZ'(|kbaerMdutJv{o[B:/cYn3,hokoAtlltjx]fE~-m7~ljB(3*ZFIVFx.PQn"tl ff],ggfo|9s9{h)=nuW/oym5q7my,}O{N7|Dk^z\SYv<6+Q]jX?CB]?*[<(|M|4BB\XmrOovz{'lPkXZZq:Qu.|wkc_$[z(bu~>/,,alHK5_OA_o|o>T>WDc|k6>5^'jy0qPU!|[S[bWMT6}X	i/e,|4|pP+Fs&K37}Np\J%uM1|iF%_
+ouN9t1!)g=|go
+(.S|r:|go[e2UkLEok1QQ\& >Dz{b|V:EB1'L&eZK1f7TNoW=8xlG~1oC<sF:|govo]|f:|go>Ms'G<x'_AL8|goTfPtC|j/aAAo,(
+9
+X.(HyF[AAt\AA$,5yA|+9yA5,P(|+{eG%GYr&}{QQr&}2&&*9FIA/g9RpC.93)b!~+&*n,aeX~r7XlvoX(!u}fDv`9+=+zon:v_|{	z'!vZ?;=9H]\bu\(,xOR
+O=;Hu;#pVH6o!Rm_`0c,OT9=;H{Ibt2z_|Wsu5H~uX|SEdr"_%t}aD,d,RmZGXW>i|7aw.2,7Rl,Z0OoZ/c9\{N^}`NcD='y J$!\1Y^Gf-I}>\buo%+:\rgcm/Ymqch},g-pn!B/:y|kBJ&' 3X=Q{|YTm:O2?D~O9}bs}!Bg$^K& Ma9@9/$`#wQ,c#Uby_L}eJ}BGs@d26Xn%c?|M$O>15x@G81M,G}	s]xM6J>eL:2Kz,kL|vmCni2h|3y{1 *:N3\b>e,F+\_xb	[X}a`%wmO>q><9;!72IlNv!D@dM1sx1imH[i?|Cdlyoacm,s:),S}8>dv%W<cgc#Fd,Lm@P2Kj(kSm`>q-#kPb1tt=d4dk{<} OTdlC-;0F^!'2Z7uj
+!O(s?LrF26JK>{-ka-q6V7{w?^O&Eu9<w-O=s}g?8S")rX9#_e&{n`?3lhCFhmPh4x!g8M,_}#\?.|+o`6nh	rHi-G&SQ;SIm+YFZ_ msBsw?~]?`~_d*%IkSNy9s[#SC=GU]F7T3S(/A.k}uqz[xQ@q`
+pP 4 
+2(8/~fL4wz{-Uj~ p<[_u{n3C
+v1\AJ{]iBu\c@_YJZ_Jcb=j=T=bSZXSTpu(GZ~Ob/g8g//*-@|(fMORqAm}Tl{Gu[TZb?0E4EN+ciQ_\5%g'eJ5kq=VHq'5#l2DdC8qZ=C_upXwK_us2nKz*]+5-9G.qDKMKU;Zs,TZr\E~v|cRqvzC7s.>gs_y@U>Yz~$^"ck8sRK:94/d[MMPry27C3S)dgnKh!sy-~nA.Gp!WoXY9z|Z*!k^Z(ocOu}AZW5M3GMCC;QRGiE>6x.5bsZ HW=#9T}V?!{!c73|	MW}%dMsVO}\,0|                              B                9   J                          @                            (       =       R               /home/mike/c/printpro/cups/doc/images/cups-installer.tif       ~
+        
+  ]     H      H   
\ 
diff -urNad cupsys-1.1.99.b1.r4748~/packaging/installer.xcf.gz cupsys-1.1.99.b1.r4748/packaging/installer.xcf.gz
--- cupsys-1.1.99.b1.r4748~/packaging/installer.xcf.gz	1970-01-01 09:00:00.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/packaging/installer.xcf.gz	2005-11-13 03:48:19.114041000 +0900
@@ -0,0 +1,30 @@
+      \ydGycwv>z;F,b!zz=5F!BR8NB bG$cKQFj	H!@8v+U~}&;^_U}_W}z}KZrf M!_0oB!0h'(vq/c^|frSW[W>u-^8}o@b%!.2'}'O;][%yy?r?u2k}|._stS%cF.%Vz-&5%_9I+h*]ue~~6EK9d/._x~k{i8~_?s'.r-:]w3{!<2'xvU9ykO./rAv lW/k),Ys+Qg?0$c:!/]}mSfYim~z\ZmmeonbC|QM+Aqui;y/Q G>[p'QPY|+UniS?B>>vi#Ip52rk6o[f~abq%WA-Gui#=MM+ ?"/ufx5m4.!UT/`
+:m={+,K3LLO	+'l{g+"w@8j~Oo8:/8rm`ME_5?2z>c55
+,_,_tG7?Sas=9<>ky7Lk";s_!Y?W_im\?|:4Syz}}+zu`WuB^Nkm[|;A'1 *<s1@h7V
+#5
+4}w Prv)Mp,O0Q#=NO>}'xP(W!/=Wq
+X)f)?Az/?7m}]~F]_y>?G:mfoGCjzSJ<%=`! wB6cA;vC.=SG+AlDc?GxD^od4;d{{2i:$L\/ sa|_0f|5c^ac^cUjPsfcic1}P{l^[{7bL", Q#oQ4Z2KU3O	IWSfm7&qb$f3hem3;m770lgf2gFs"Dy!N]"D6Ic6Qh;&Yks2Z>0CUP8sL
+dund/ cPC#9xZCBCK!$JH(a[P*R1T\T9=84&oo1{lCvL.	`&<zci/zl:o7szv':FtF`Q1d3lLC6}6@B6aZ{y}z-"Q%w2
+bXvUm@8
+iDi455q2yB&Sd"
+kaZ	GQ.^DPz\o4 "`v,v7^K4y4"*&4F<Fx}f9G1	2uL_HZhEeJAbPSK19%
+QY!|.NQ&@,
+*!l8fcvTu
+u{G6cNpvXs]a)b8df|v[cq|VmnW Rm~|p*x9A/ vt B<I,HP6j$QrjJ@)3"s$[(z~J86Z`MQP+vX"6j>pvqc{WStX-2.gHuKP-8@*8*{4fQvA,jq:&EDxo73pGv* sCF!Ci0?[DS B)r c	V0<f%GrK
+Ch; 0xh3vN87%*Pp9=sGwD;VWILZ	z6&Q4h\E2f4h`1!G~#Y9(l\au7!$_(n@1`O1S8L6YRTRfV3k'>Tf!)A[L:N	!~er
+R!=(HM[8(Y4gN;&=5}.Y9S:.@^EPt(9aF)cruMIlo(k6_ '!$hBE!Cc%gE_hUb9b([kFL+}OY7\JoESY2f}ZFAfX9rzg\2>2JS$\L>CtB5gihFJ=$$}d2f3+i  6JoJ7ZJu'tmUqa0C
+P?X#+xTaKvj*.",`d*?>'ElWzQBMtgax c5X"SP{zP3vzH2@)3"=9vBH_Q,y+Abi aCR@FY !3]2mL@F!5`*k.R`Z]P]ryi@/B4{$d*>ZK6.ppl|r/u/j66/rz~<)G$wAp*n=8,.Z[+f;PwlwmqOV0omt
+e!#l
+4%;0vBV;4n)Y>.V_VSJry)J3);.:(N8~WLuN)4*1"t	+|nfKitc b/RPPWK|2c2,bL9IQpT)i"Uq8W/zsK	;eaa[5@cR?\Kp.~R?\
+z/X>Qr.6p\~x:{r4)$)3_rOI+#p93t\*
+nU)fU\,=N5W4q91q8..J9YZ3pK	Y%D6O:jK` 'kd/FPJ>UR`	vT?B= =G;#_:|a\^D8,(yF9.]s2jNZ50.R"9'k	]	W.P"s-r.pUv^]@!ZVfeyr.~B}TP!GU?ckqsjF:V?\?-2LEK|snI;JNnt6GK.5v4GJfqt]7yR0zH$ftD'!H5SVWTn2)NC!*8v-|uRT20n6vj"Ei:yR'pnpnpnOg|-pg$L&rvyy/Pn>">9KxM>':2To@$
+^$ur-$pyghqq~='r `6%.dUztL<0*{L< 'N't;G.wYV/W9PG9B=5Y61w/xHm6RW!u?2*/K022;t,dZ1fQjErd'd>gExdZ%+/Vuf(CiJPI&una-x: Ss?FeK9[F+yw~#&%>9/#yF32oya|y-7Z,-N%glH?{&Q8F=p^^IR-cSN\JSiI]	W2>+.:S.W*c;Mw |^t=yG~eZ?U/aO.oU
+5cg|:/w-%`]tO=t;|{$"`%i}%`C,r*u;jd8Md8Md8M$yoH:mKo_$/z_Nu{tZmWPI<&>=nZ.zaza|+cNnMhqu6s)#/DZX+n|rJKk9r$]RR@+/zA"5"_+hmh2)94LwnB|(/h8v_#q&
+YO`OF;^-`PM*Xm`(K%4s"(?ZVO[;en(s?2:s	+sNT/+g&;j;">#G`2[\{t"qYNW,k7` F~%zz]
+fYNWj'=fQQtExmUe]p^zLS(ZvB[UK<uRZ%/7}^#^At3PVT/WKX{%Z@DH,kq7G!s::/@_R:n9bB|*ofEFFDe]H#uaf!]%]+O
+!ACEW{gIv!|$88@[ZZE%sH.|C f993*$h;+Yvwfgg9?0PU,tV;jv-hsAl xj4-HoAz[q`59=QWDY&~sJk[iFfOt;wZ&QyO^_zd.2%AtA_PmDE?7ww&}W'}W#dr?ZHa1#wac2b|O\OuVhM=O?{Bw
+ -Aebx.yHu$Vc~GhW%64cfVvu[# mW.hc]wmAVTo( lK(%P zkptXbPvUUvq+q+`>^^^r`ldb:i&Rax62x^`}pk0}w{ZJj)o4L-~I.RW0!&(mN,1\%Y9#Da%I|o |W340M1e3f^[<t~q+Lw>Tl3Nst`%LROLf@BG})]Xp#m+w0lP
+A@8,jR7p60|J>1:t| RjHey7;r/w.E}@5uk+l;<|)w.=Z[|
+*=+S_drp2Sd)7TGJN:Z8saTl`*?96_2:r2P%<0Wp
+ aL*N^hpF
+".v97n2b;jOR5jNQ>>nbk.Yt`lqp.v`2=kiEX \<@QA9T',KqmVFb	:|*rUTfOJ^X~T-##mwK	jl(o"5s>edw",K=<}-QY{JAHr;sqGm`Ot	M2Q'}HVEfDrYsQ+x/qTtQeV$oD~/U7Ls"*[>Jk"|/3.7j~+((  
\ 
diff -urNad cupsys-1.1.99.b1.r4748~/pdftops/Dependencies cupsys-1.1.99.b1.r4748/pdftops/Dependencies
--- cupsys-1.1.99.b1.r4748~/pdftops/Dependencies	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/pdftops/Dependencies	2005-10-19 06:09:12.681329000 +0900
@@ -86,7 +86,7 @@
 PSOutputDev.o: CharTypes.h Object.h gmem.h Array.h Dict.h Stream.h Error.h
 PSOutputDev.o: Function.h Gfx.h GfxState.h GfxFont.h UnicodeMap.h
 PSOutputDev.o: FoFiType1C.h FoFiBase.h FoFiTrueType.h Catalog.h Page.h
-PSOutputDev.o: Annot.h PSOutputDev.h OutputDev.h
+PSOutputDev.o: Annot.h XRef.h PSOutputDev.h OutputDev.h
 PSTokenizer.o: ../config.h PSTokenizer.h gtypes.h
 SecurityHandler.o: ../config.h GString.h PDFDoc.h XRef.h gtypes.h Object.h
 SecurityHandler.o: gmem.h Array.h Dict.h Stream.h Catalog.h Page.h Decrypt.h
diff -urNad cupsys-1.1.99.b1.r4748~/pdftops/Function.cxx cupsys-1.1.99.b1.r4748/pdftops/Function.cxx
--- cupsys-1.1.99.b1.r4748~/pdftops/Function.cxx	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/pdftops/Function.cxx	2005-10-11 04:23:23.958633000 +0900
@@ -1150,6 +1150,7 @@
       a = -1;
       b = nPSOps;
       // invariant: psOpNames[a] < tok < psOpNames[b]
+      cmp = 1;
       while (b - a > 1) {
 	mid = (a + b) / 2;
 	cmp = tok->cmp(psOpNames[mid]);
diff -urNad cupsys-1.1.99.b1.r4748~/pdftops/Gfx.cxx cupsys-1.1.99.b1.r4748/pdftops/Gfx.cxx
--- cupsys-1.1.99.b1.r4748~/pdftops/Gfx.cxx	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/pdftops/Gfx.cxx	2005-10-11 04:23:23.958633000 +0900
@@ -688,6 +688,7 @@
   a = -1;
   b = numOps;
   // invariant: opTab[a] < name < opTab[b]
+  cmp = 1;
   while (b - a > 1) {
     m = (a + b) / 2;
     cmp = strcmp(opTab[m].name, name);
diff -urNad cupsys-1.1.99.b1.r4748~/pdftops/JPXStream.cxx cupsys-1.1.99.b1.r4748/pdftops/JPXStream.cxx
--- cupsys-1.1.99.b1.r4748~/pdftops/JPXStream.cxx	2005-09-17 23:52:15.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/pdftops/JPXStream.cxx	2005-11-05 04:02:40.635849000 +0900
@@ -783,7 +783,7 @@
   int segType;
   GBool haveSIZ, haveCOD, haveQCD, haveSOT;
   Guint precinctSize, style;
-  Guint segLen, capabilities, comp, i, j, r;
+  Guint segLen, capabilities, nTiles, comp, i, j, r;
 
   //----- main header
   haveSIZ = haveCOD = haveQCD = haveSOT = gFalse;
@@ -818,8 +818,13 @@
 	            / img.xTileSize;
       img.nYTiles = (img.ySize - img.yTileOffset + img.yTileSize - 1)
 	            / img.yTileSize;
-      img.tiles = (JPXTile *)gmallocn(img.nXTiles * img.nYTiles,
-				      sizeof(JPXTile));
+      nTiles = img.nXTiles * img.nYTiles;
+      // check for overflow before allocating memory
+      if (nTiles == 0 || nTiles / img.nXTiles != img.nYTiles) {
+	error(getPos(), "Bad tile count in JPX SIZ marker segment");
+	return gFalse;
+      }
+      img.tiles = (JPXTile *)gmallocn(nTiles, sizeof(JPXTile));
       for (i = 0; i < img.nXTiles * img.nYTiles; ++i) {
 	img.tiles[i].tileComps = (JPXTileComp *)gmallocn(img.nComps,
 							 sizeof(JPXTileComp));
diff -urNad cupsys-1.1.99.b1.r4748~/pdftops/Stream.cxx cupsys-1.1.99.b1.r4748/pdftops/Stream.cxx
--- cupsys-1.1.99.b1.r4748~/pdftops/Stream.cxx	2005-09-17 23:52:15.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/pdftops/Stream.cxx	2005-11-05 04:02:40.635849000 +0900
@@ -401,18 +401,33 @@
 
 StreamPredictor::StreamPredictor(Stream *strA, int predictorA,
 				 int widthA, int nCompsA, int nBitsA) {
+  int totalBits;
+
   str = strA;
   predictor = predictorA;
   width = widthA;
   nComps = nCompsA;
   nBits = nBitsA;
+  predLine = NULL;
+  ok = gFalse;
 
   nVals = width * nComps;
+  totalBits = nVals * nBits;
+  if (totalBits == 0 ||
+      (totalBits / nBits) / nComps != width ||
+      totalBits + 7 < 0) {
+    return;
+  }
   pixBytes = (nComps * nBits + 7) >> 3;
-  rowBytes = ((nVals * nBits + 7) >> 3) + pixBytes;
+  rowBytes = ((totalBits + 7) >> 3) + pixBytes;
+  if (rowBytes < 0) {
+    return;
+  }
   predLine = (Guchar *)gmalloc(rowBytes);
   memset(predLine, 0, rowBytes);
   predIdx = rowBytes;
+
+  ok = gTrue;
 }
 
 StreamPredictor::~StreamPredictor() {
@@ -1004,6 +1019,10 @@
     FilterStream(strA) {
   if (predictor != 1) {
     pred = new StreamPredictor(this, predictor, columns, colors, bits);
+    if (!pred->isOk()) {
+      delete pred;
+      pred = NULL;
+    }
   } else {
     pred = NULL;
   }
@@ -2899,6 +2918,14 @@
   height = read16();
   width = read16();
   numComps = str->getChar();
+  if (numComps <= 0 || numComps > 4) {
+    error(getPos(), "Bad number of components in DCT stream", prec);
+    return gFalse;
+  }
+  if (numComps <= 0 || numComps > 4) {
+    error(getPos(), "Bad number of components in DCT stream", prec);
+    return gFalse;
+  }
   if (prec != 8) {
     error(getPos(), "Bad DCT precision %d", prec);
     return gFalse;
@@ -3827,6 +3854,10 @@
     FilterStream(strA) {
   if (predictor != 1) {
     pred = new StreamPredictor(this, predictor, columns, colors, bits);
+    if (!pred->isOk()) {
+      delete pred;
+      pred = NULL;
+    }
   } else {
     pred = NULL;
   }
diff -urNad cupsys-1.1.99.b1.r4748~/pdftops/Stream.h cupsys-1.1.99.b1.r4748/pdftops/Stream.h
--- cupsys-1.1.99.b1.r4748~/pdftops/Stream.h	2005-09-17 23:52:15.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/pdftops/Stream.h	2005-11-05 04:02:40.635849000 +0900
@@ -232,6 +232,8 @@
 
   ~StreamPredictor();
 
+  GBool isOk() { return ok; }
+
   int lookChar();
   int getChar();
 
@@ -249,6 +251,7 @@
   int rowBytes;			// bytes per line
   Guchar *predLine;		// line buffer
   int predIdx;			// current index in predLine
+  GBool ok;
 };
 
 //------------------------------------------------------------------------
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/Dependencies cupsys-1.1.99.b1.r4748/scheduler/Dependencies
--- cupsys-1.1.99.b1.r4748~/scheduler/Dependencies	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/Dependencies	2005-10-19 06:09:12.681329000 +0900
@@ -146,6 +146,8 @@
 cups-polld.o: ../cups/http-private.h ../config.h ../cups/http.h ../cups/md5.h
 cups-polld.o: ../cups/cups.h ../cups/ipp.h ../cups/ppd.h ../cups/file.h
 cups-polld.o: ../cups/language.h ../cups/string.h
+testdirsvc.o: ../cups/cups.h ../cups/ipp.h ../cups/http.h ../cups/md5.h
+testdirsvc.o: ../cups/ppd.h ../cups/file.h ../cups/string.h ../config.h
 testmime.o: ../cups/string.h ../config.h mime.h ../cups/ipp.h ../cups/file.h
 testspeed.o: ../cups/cups.h ../cups/ipp.h ../cups/http.h ../cups/md5.h
 testspeed.o: ../cups/ppd.h ../cups/file.h ../cups/language.h ../cups/debug.h
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/Makefile cupsys-1.1.99.b1.r4748/scheduler/Makefile
--- cupsys-1.1.99.b1.r4748~/scheduler/Makefile	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/Makefile	2005-10-19 06:09:12.681329000 +0900
@@ -1,5 +1,5 @@
 #
-# "$Id: Makefile 4691 2005-09-22 20:56:46Z mike $"
+# "$Id: Makefile 4801 2005-10-18 21:09:12Z mike $"
 #
 #   Scheduler Makefile for the Common UNIX Printing System (CUPS).
 #
@@ -57,6 +57,7 @@
 		cups-driverd.o \
 		cups-lpd.o \
 		cups-polld.o \
+		testdirsvc.o \
 		testmime.o \
 		testspeed.o \
 		util.o
@@ -67,6 +68,7 @@
 		cups-lpd \
 		cups-polld \
 		libmime.a \
+		testdirsvc \
 		testmime \
 		testspeed
 
@@ -124,13 +126,13 @@
 	echo Creating $(STATEDIR)...
 	$(INSTALL_DIR) $(STATEDIR)
 	echo Creating $(STATEDIR)/certs...
-	-$(INSTALL_DIR) -m 711 -o $(CUPS_USER) -g $(CUPS_GROUP) $(STATEDIR)/certs
+	$(INSTALL_DIR) $(STATEDIR)/certs
 	echo Creating $(LOGDIR)...
 	$(INSTALL_DIR) $(LOGDIR)
 	echo Creating $(REQUESTS)...
-	$(INSTALL_DIR) -m 710 $(REQUESTS)
+	$(INSTALL_DIR) $(REQUESTS)
 	echo Creating $(REQUESTS)/tmp...
-	$(INSTALL_DIR) -m 1770 $(REQUESTS)/tmp
+	$(INSTALL_DIR) $(REQUESTS)/tmp
 	echo Creating $(CACHEDIR)...
 	$(INSTALL_DIR) $(CACHEDIR)
 	echo Creating $(CACHEDIR)/ppd...
@@ -147,6 +149,12 @@
 		$(LIBZ) $(SSLLIBS) $(LIBSLP) $(PAMLIBS) $(LIBS) \
 		$(LIBPAPER) $(LIBMALLOC)
 
+cupsd-static:	$(CUPSDOBJS) libmime.a ../cups/libcups.a
+	echo Linking $@...
+	$(CC) $(LDFLAGS) -o cupsd-static $(CUPSDOBJS) libmime.a \
+		$(LIBZ) $(SSLLIBS) $(LIBSLP) $(PAMLIBS) ../cups/libcups.a \
+		$(COMMONLIBS) $(LIBZ) $(LIBPAPER) $(LIBMALLOC)
+
 
 #
 # Make the device daemon, "cups-deviced".
@@ -196,12 +204,22 @@
 
 
 #
+# Make the test program, "testdirsvc".
+#
+
+testdirsvc:	testdirsvc.o
+	echo Linking $@...
+	$(CC) $(LDFLAGS) -o testdirsvc testdirsvc.o $(COMMONLIBS) $(NETLIBS)
+
+
+#
 # testmime
 #
 
 testmime:	testmime.o libmime.a
 	echo Linking $@...
-	$(CC) $(LDFLAGS) -o $@ testmime.o libmime.a ../cups/libcups.a $(COMMONLIBS) $(LIBZ)
+	$(CC) $(LDFLAGS) -o $@ testmime.o libmime.a ../cups/libcups.a \
+		$(COMMONLIBS) $(LIBZ)
 
 
 #
@@ -221,5 +239,5 @@
 
 
 #
-# End of "$Id: Makefile 4691 2005-09-22 20:56:46Z mike $".
+# End of "$Id: Makefile 4801 2005-10-18 21:09:12Z mike $".
 #
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/auth.c cupsys-1.1.99.b1.r4748/scheduler/auth.c
--- cupsys-1.1.99.b1.r4748~/scheduler/auth.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/auth.c	2005-10-26 04:00:12.142678000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: auth.c 4719 2005-09-28 21:12:44Z mike $"
+ * "$Id: auth.c 4813 2005-10-25 19:00:12Z mike $"
  *
  *   Authorization routines for the Common UNIX Printing System (CUPS).
  *
@@ -93,11 +93,24 @@
 
 
 /*
+ * Local structures...
+ */
+
+#if HAVE_LIBPAM
+typedef struct cupsd_authdata_s		/**** Authentication data ****/
+{
+  char	username[33],			/* Username string */
+	password[33];			/* Password string */
+} cupsd_authdata_t;
+#endif /* HAVE_LIBPAM */
+
+
+/*
  * Local globals...
  */
 
 #if defined(__hpux) && defined(HAVE_LIBPAM)
-static cupsd_client_t	*auth_client;	/* Current client being authenticated */
+static cupsd_authdata_t	*auth_datat;	/* Current client being authenticated */
 #endif /* __hpux && HAVE_LIBPAM */
 
 
@@ -277,6 +290,471 @@
 
 
 /*
+ * 'cupsdAuthorize()' - Validate any authorization credentials.
+ */
+
+void
+cupsdAuthorize(cupsd_client_t *con)	/* I - Client connection */
+{
+  int		type;			/* Authentication type */
+  char		*authorization,		/* Pointer into Authorization string */
+		*ptr,			/* Pointer into string */
+		username[65],		/* Username string */
+		password[33];		/* Password string */
+  const char	*localuser;		/* Certificate username */
+  char		nonce[HTTP_MAX_VALUE],	/* Nonce value from client */
+		md5[33],		/* MD5 password */
+		basicmd5[33];		/* MD5 of Basic password */
+  static const char * const states[] =	/* HTTP client states... */
+		{
+		  "WAITING",
+		  "OPTIONS",
+		  "GET",
+		  "GET",
+		  "HEAD",
+		  "POST",
+		  "POST",
+		  "POST",
+		  "PUT",
+		  "PUT",
+		  "DELETE",
+		  "TRACE",
+		  "CLOSE",
+		  "STATUS"
+		};
+
+
+ /*
+  * Locate the best matching location so we know what kind of
+  * authentication to expect...
+  */
+
+  con->best = cupsdFindBest(con->uri, con->http.state);
+
+  cupsdLogMessage(CUPSD_LOG_DEBUG2,
+                  "cupsdAuthorize: con->uri=\"%s\", con->best=%p(%s)",
+                  con->uri, con->best, con->best ? con->best->location : "");
+
+  if (con->best && con->best->type != AUTH_NONE)
+    type = con->best->type;
+  else
+    type = DefaultAuthType;
+
+ /*
+  * Decode the Authorization string...
+  */
+
+  authorization = con->http.fields[HTTP_FIELD_AUTHORIZATION];
+
+  cupsdLogMessage(CUPSD_LOG_DEBUG2, "cupsdAuthorize: Authorization=\"%s\"",
+                  authorization);
+
+  username[0] = '\0';
+  password[0] = '\0';
+
+  if (type == AUTH_NONE)
+  {
+   /*
+    * No authorization required, return early...
+    */
+
+    cupsdLogMessage(CUPSD_LOG_DEBUG,
+                    "cupsdAuthorize: No authentication required.");
+    return;
+  }
+  else if (!*authorization)
+  {
+   /*
+    * No authorization data provided, return early...
+    */
+
+    cupsdLogMessage(CUPSD_LOG_DEBUG,
+                    "cupsdAuthorize: No authentication data provided.");
+    return;
+  }
+  else if (!strncmp(authorization, "Local", 5) &&
+           !strcasecmp(con->http.hostname, "localhost"))
+  {
+   /*
+    * Get Local certificate authentication data...
+    */
+
+    authorization += 5;
+    while (isspace(*authorization))
+      authorization ++;
+
+    if ((localuser = cupsdFindCert(authorization)) != NULL)
+      strlcpy(username, localuser, sizeof(username));
+    else
+    {
+      cupsdLogMessage(CUPSD_LOG_ERROR,
+                      "cupsdAuthorize: Local authentication certificate not "
+		      "found!");
+      return;
+    }
+  }
+  else if (!strncmp(authorization, "Basic", 5) &&
+           (type == AUTH_BASIC || type == AUTH_BASICDIGEST))
+  {
+   /*
+    * Get the Basic authentication data...
+    */
+
+    authorization += 5;
+    while (isspace(*authorization))
+      authorization ++;
+
+    httpDecode64(username, authorization);
+
+   /*
+    * Pull the username and password out...
+    */
+
+    if ((ptr = strchr(username, ':')) == NULL)
+    {
+      cupsdLogMessage(CUPSD_LOG_ERROR,
+                      "cupsdAuthorize: Missing Basic password!");
+      return;
+    }
+
+    *ptr++ = '\0';
+
+    if (!username[0])
+    {
+     /*
+      * Username must not be empty...
+      */
+
+      cupsdLogMessage(CUPSD_LOG_ERROR,
+                      "cupsdAuthorize: Empty Basic username!");
+      return;
+    }
+
+    if (!*ptr)
+    {
+     /*
+      * Password must not be empty...
+      */
+
+      cupsdLogMessage(CUPSD_LOG_ERROR,
+                      "cupsdAuthorize: Empty Basic password!");
+      return;
+    }
+
+    strlcpy(password, ptr, sizeof(password));
+
+   /*
+    * Validate the username and password...
+    */
+
+    switch (type)
+    {
+      case AUTH_BASIC :
+          {
+#if HAVE_LIBPAM
+	   /*
+	    * Only use PAM to do authentication.  This supports MD5
+	    * passwords, among other things...
+	    */
+
+	    pam_handle_t	*pamh;	/* PAM authentication handle */
+	    int			pamerr;	/* PAM error code */
+	    struct pam_conv	pamdata;/* PAM conversation data */
+	    cupsd_authdata_t	data;	/* Authentication data */
+
+
+            strlcpy(data.username, username, sizeof(data.username));
+	    strlcpy(data.password, password, sizeof(data.password));
+
+	    pamdata.conv        = pam_func;
+	    pamdata.appdata_ptr = &data;
+
+#  ifdef __hpux
+	   /*
+	    * Workaround for HP-UX bug in pam_unix; see pam_func() below for
+	    * more info...
+	    */
+
+	    auth_data = &data;
+#  endif /* __hpux */
+
+	    pamerr = pam_start("cups", username, &pamdata, &pamh);
+	    if (pamerr != PAM_SUCCESS)
+	    {
+	      cupsdLogMessage(CUPSD_LOG_ERROR,
+	                      "cupsdAuthorize: pam_start() returned %d (%s)!\n",
+        	              pamerr, pam_strerror(pamh, pamerr));
+	      pam_end(pamh, 0);
+	      return;
+	    }
+
+	    pamerr = pam_authenticate(pamh, PAM_SILENT);
+	    if (pamerr != PAM_SUCCESS)
+	    {
+	      cupsdLogMessage(CUPSD_LOG_ERROR,
+	                      "cupsdAuthorize: pam_authenticate() returned %d "
+			      "(%s)!\n",
+        	              pamerr, pam_strerror(pamh, pamerr));
+	      pam_end(pamh, 0);
+	      return;
+	    }
+
+	    pamerr = pam_acct_mgmt(pamh, PAM_SILENT);
+	    if (pamerr != PAM_SUCCESS)
+	    {
+	      cupsdLogMessage(CUPSD_LOG_ERROR,
+	                      "cupsdAuthorize: pam_acct_mgmt() returned %d "
+			      "(%s)!\n",
+        	              pamerr, pam_strerror(pamh, pamerr));
+	      pam_end(pamh, 0);
+	      return;
+	    }
+
+	    pam_end(pamh, PAM_SUCCESS);
+
+#elif defined(HAVE_USERSEC_H)
+	   /*
+	    * Use AIX authentication interface...
+	    */
+
+	    char	*authmsg;	/* Authentication message */
+	    char	*loginmsg;	/* Login message */
+	    int		reenter;	/* ??? */
+
+
+	    cupsdLogMessage(CUPSD_LOG_DEBUG,
+	                    "cupsdAuthorize: AIX authenticate of username \"%s\"",
+                            username);
+
+	    reenter = 1;
+	    if (authenticate(username, password, &reenter, &authmsg) != 0)
+	    {
+	      cupsdLogMessage(CUPSD_LOG_DEBUG,
+	                      "cupsdAuthorize: Unable to authenticate username "
+			      "\"%s\": %s",
+	                      username, strerror(errno));
+	      return;
+	    }
+
+#else
+           /*
+	    * Use normal UNIX password file-based authentication...
+	    */
+
+            char		*pass;	/* Encrypted password */
+            struct passwd	*pw;	/* User password data */
+#  ifdef HAVE_SHADOW_H
+            struct spwd		*spw;	/* Shadow password data */
+#  endif /* HAVE_SHADOW_H */
+
+
+	    pw = getpwnam(username);	/* Get the current password */
+	    endpwent();			/* Close the password file */
+
+	    if (!pw)
+	    {
+	     /*
+	      * No such user...
+	      */
+
+	      cupsdLogMessage(CUPSD_LOG_ERROR,
+	                      "cupsdAuthorize: Unknown username \"%s\"!",
+        	              username);
+	      return (HTTP_UNAUTHORIZED);
+	    }
+
+#  ifdef HAVE_SHADOW_H
+	    spw = getspnam(username);
+	    endspent();
+
+	    if (!spw && !strcmp(pw->pw_passwd, "x"))
+	    {
+	     /*
+	      * Don't allow blank passwords!
+	      */
+
+	      cupsdLogMessage(CUPSD_LOG_ERROR,
+	                      "cupsdAuthorize: Username \"%s\" has no shadow "
+			      "password!", username);
+	      return;
+	    }
+
+	    if (spw && !spw->sp_pwdp[0] && !pw->pw_passwd[0])
+#  else
+	    if (!pw->pw_passwd[0])
+#  endif /* HAVE_SHADOW_H */
+	    {
+	     /*
+	      * Don't allow blank passwords!
+	      */
+
+	      cupsdLogMessage(CUPSD_LOG_ERROR,
+	                      "cupsdAuthorize: Username \"%s\" has no password!",
+        	              username);
+	      return;
+	    }
+
+	   /*
+	    * OK, the password isn't blank, so compare with what came from the
+	    * client...
+	    */
+
+	    pass = cups_crypt(password, pw->pw_passwd);
+
+	    cupsdLogMessage(CUPSD_LOG_DEBUG2,
+	                    "cupsdAuthorize: pw_passwd=\"%s\", crypt=\"%s\"",
+		            pw->pw_passwd, pass);
+
+	    if (!pass || strcmp(pw->pw_passwd, pass))
+	    {
+#  ifdef HAVE_SHADOW_H
+	      if (spw)
+	      {
+		pass = cups_crypt(password, spw->sp_pwdp);
+
+		cupsdLogMessage(CUPSD_LOG_DEBUG2,
+	                	"cupsdAuthorize: sp_pwdp=\"%s\", crypt=\"%s\"",
+				spw->sp_pwdp, pass);
+
+		if (pass == NULL || strcmp(spw->sp_pwdp, pass))
+		{
+	          cupsdLogMessage(CUPSD_LOG_ERROR,
+		                  "cupsdAuthorize: Authentication failed for "
+				  "user \"%s\"!",
+				  username);
+		  return;
+        	}
+	      }
+	      else
+#  endif /* HAVE_SHADOW_H */
+	      {
+		cupsdLogMessage(CUPSD_LOG_ERROR,
+		        	"cupsdAuthorize: Authentication failed for "
+				"user \"%s\"!",
+				username);
+		return;
+              }
+	    }
+#endif /* HAVE_LIBPAM */
+          }
+          break;
+
+      case AUTH_BASICDIGEST :
+         /*
+	  * Do Basic authentication with the Digest password file...
+	  */
+
+	  if (!cupsdGetMD5Passwd(username, NULL, md5))
+	  {
+            cupsdLogMessage(CUPSD_LOG_ERROR,
+	                    "cupsdAuthorize: Unknown MD5 username \"%s\"!",
+	                    username);
+            return;
+	  }
+
+	  httpMD5(username, "CUPS", password, basicmd5);
+
+	  if (strcmp(md5, basicmd5))
+	  {
+            cupsdLogMessage(CUPSD_LOG_ERROR,
+	                    "cupsdAuthorize: Authentication failed for \"%s\"!",
+	                    username);
+            return;
+	  }
+	  break;
+    }
+  }
+  else if (!strncmp(authorization, "Digest", 6) && type == AUTH_DIGEST)
+  {
+   /*
+    * Get the username, password, and nonce from the Digest attributes...
+    */
+
+    if (!httpGetSubField2(&(con->http), HTTP_FIELD_AUTHORIZATION, "username",
+                          username, sizeof(username)) || !username[0])
+    {
+     /*
+      * Username must not be empty...
+      */
+
+      cupsdLogMessage(CUPSD_LOG_ERROR,
+                      "cupsdAuthorize: Empty or missing Digest username!");
+      return;
+    }
+
+    if (!httpGetSubField2(&(con->http), HTTP_FIELD_AUTHORIZATION, "response",
+                          password, sizeof(password)) || !password[0])
+    {
+     /*
+      * Password must not be empty...
+      */
+
+      cupsdLogMessage(CUPSD_LOG_ERROR,
+                      "cupsdAuthorize: Empty or missing Digest password!");
+      return;
+    }
+
+    if (!httpGetSubField(&(con->http), HTTP_FIELD_AUTHORIZATION, "nonce",
+                         nonce))
+    {
+      cupsdLogMessage(CUPSD_LOG_ERROR,
+	              "cupsdAuthorize: No nonce value for Digest "
+		      "authentication!");
+      return;
+    }
+
+    if (strcmp(con->http.hostname, nonce))
+    {
+      cupsdLogMessage(CUPSD_LOG_ERROR,
+	              "cupsdAuthorize: Bad nonce value, expected \"%s\", "
+		      "got \"%s\"!", con->http.hostname, nonce);
+      return;
+    }
+
+   /*
+    * Validate the username and password...
+    */
+
+    if (!cupsdGetMD5Passwd(username, NULL, md5))
+    {
+      cupsdLogMessage(CUPSD_LOG_ERROR,
+	              "cupsdAuthorize: Unknown MD5 username \"%s\"!",
+	              username);
+      return;
+    }
+
+    httpMD5Final(nonce, states[con->http.state], con->uri, md5);
+
+    if (strcmp(md5, password))
+    {
+      cupsdLogMessage(CUPSD_LOG_ERROR,
+	              "cupsdAuthorize: Authentication failed for \"%s\"!",
+	              username);
+      return;
+    }
+  }
+  else
+  {
+    cupsdLogMessage(CUPSD_LOG_DEBUG,
+                    "cupsdAuthorize: Bad authentication data.");
+    return;
+  }
+
+ /*
+  * If we get here, then we were able to validate the username and
+  * password - copy the validated username and password to the client
+  * data and return...
+  */
+
+  strlcpy(con->username, username, sizeof(con->username));
+  strlcpy(con->password, password, sizeof(con->password));
+
+  cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdAuthorize: username=\"%s\"",
+                  con->username);
+}
+
+
+/*
  * 'cupsdCheckAuth()' - Check authorization masks.
  */
 
@@ -366,7 +844,9 @@
 	    * Check the named interface...
 	    */
 
-            if ((iface = cupsdNetIFFind(masks->mask.name.name)) != NULL)
+            for (iface = cupsdNetIFFind(masks->mask.name.name);
+	         iface && !strcasecmp(masks->mask.name.name, iface->name);
+		 iface = iface->next)
 	    {
               if (iface->address.addr.sa_family == AF_INET)
 	      {
@@ -977,8 +1457,10 @@
   snprintf(filename, sizeof(filename), "%s/passwd.md5", ServerRoot);
   if ((fp = cupsFileOpen(filename, "r")) == NULL)
   {
-    cupsdLogMessage(CUPSD_LOG_ERROR, "Unable to open %s - %s", filename,
-                    strerror(errno));
+    if (errno != ENOENT)
+      cupsdLogMessage(CUPSD_LOG_ERROR, "Unable to open %s - %s", filename,
+                      strerror(errno));
+
     return (NULL);
   }
 
@@ -1028,41 +1510,6 @@
   cupsd_location_t	*best;		/* Best match for location so far */
   int			hostlen;	/* Length of hostname */
   struct passwd		*pw;		/* User password data */
-  char			nonce[HTTP_MAX_VALUE],
-					/* Nonce value from client */
-			md5[33],	/* MD5 password */
-			basicmd5[33];	/* MD5 of Basic password */
-#if HAVE_LIBPAM
-  pam_handle_t		*pamh;		/* PAM authentication handle */
-  int			pamerr;		/* PAM error code */
-  struct pam_conv	pamdata;	/* PAM conversation data */
-#elif defined(HAVE_USERSEC_H)
-  char			*authmsg;	/* Authentication message */
-  char			*loginmsg;	/* Login message */
-  int			reenter;	/* ??? */
-#else
-  char			*pass;		/* Encrypted password */
-#  ifdef HAVE_SHADOW_H
-  struct spwd		*spw;		/* Shadow password data */
-#  endif /* HAVE_SHADOW_H */
-#endif /* HAVE_LIBPAM */
-  static const char * const states[] =	/* HTTP client states... */
-		{
-		  "WAITING",
-		  "OPTIONS",
-		  "GET",
-		  "GET",
-		  "HEAD",
-		  "POST",
-		  "POST",
-		  "POST",
-		  "PUT",
-		  "PUT",
-		  "DELETE",
-		  "TRACE",
-		  "CLOSE",
-		  "STATUS"
-		};
   static const char * const levels[] =	/* Auth levels */
 		{
 		  "ANON",
@@ -1113,20 +1560,20 @@
   */
 
 #ifdef AF_INET6
-  if (con->http.hostaddr.addr.sa_family == AF_INET6)
+  if (con->http.hostaddr->addr.sa_family == AF_INET6)
   {
    /*
     * Copy IPv6 address...
     */
 
-    address[0] = ntohl(con->http.hostaddr.ipv6.sin6_addr.s6_addr32[0]);
-    address[1] = ntohl(con->http.hostaddr.ipv6.sin6_addr.s6_addr32[1]);
-    address[2] = ntohl(con->http.hostaddr.ipv6.sin6_addr.s6_addr32[2]);
-    address[3] = ntohl(con->http.hostaddr.ipv6.sin6_addr.s6_addr32[3]);
+    address[0] = ntohl(con->http.hostaddr->ipv6.sin6_addr.s6_addr32[0]);
+    address[1] = ntohl(con->http.hostaddr->ipv6.sin6_addr.s6_addr32[1]);
+    address[2] = ntohl(con->http.hostaddr->ipv6.sin6_addr.s6_addr32[2]);
+    address[3] = ntohl(con->http.hostaddr->ipv6.sin6_addr.s6_addr32[3]);
   }
   else
 #endif /* AF_INET6 */
-  if (con->http.hostaddr.addr.sa_family == AF_INET)
+  if (con->http.hostaddr->addr.sa_family == AF_INET)
   {
    /*
     * Copy IPv4 address...
@@ -1135,7 +1582,7 @@
     address[0] = 0;
     address[1] = 0;
     address[2] = 0;
-    address[3] = ntohl(con->http.hostaddr.ipv4.sin_addr.s_addr);
+    address[3] = ntohl(con->http.hostaddr->ipv4.sin_addr.s_addr);
   }
   else
     memset(address, 0, sizeof(address));
@@ -1234,11 +1681,8 @@
     }
   }
 
-  cupsdLogMessage(CUPSD_LOG_DEBUG2,
-                  "cupsdIsAuthorized: username=\"%s\" password=%d chars",
-	          con->username, (int)strlen(con->password));
-  DEBUG_printf(("cupsdIsAuthorized: username=\"%s\", password=\"%s\"\n",
-		con->username, con->password));
+  cupsdLogMessage(CUPSD_LOG_DEBUG2, "cupsdIsAuthorized: username=\"%s\"",
+	          con->username);
 
   if (!con->username[0])
   {
@@ -1249,318 +1693,6 @@
   }
 
  /*
-  * Check the user's password...
-  */
-
-  cupsdLogMessage(CUPSD_LOG_DEBUG2,
-                  "cupsdIsAuthorized: Checking \"%s\", address = %x:%x:%x:%x, hostname = \"%s\"",
-	          con->username, address[0], address[1], address[2],
-	          address[3], con->http.hostname);
-
-  pw = NULL;
-
-  if (strcasecmp(con->http.hostname, "localhost") ||
-      strncmp(con->http.fields[HTTP_FIELD_AUTHORIZATION], "Local", 5))
-  {
-   /*
-    * Not doing local certificate-based authentication; check the password...
-    */
-
-    if (!con->password[0])
-      return (HTTP_UNAUTHORIZED);
-
-   /*
-    * See what kind of authentication we are doing...
-    */
-
-    switch (best->type != AUTH_NONE ? best->type : DefaultAuthType)
-    {
-      case AUTH_BASIC :
-	 /*
-	  * Get the user info...
-	  */
-
-	  pw = getpwnam(con->username);		/* Get the current password */
-	  endpwent();				/* Close the password file */
-
-#if HAVE_LIBPAM
-	 /*
-	  * Only use PAM to do authentication.  This allows MD5 passwords, among
-	  * other things...
-	  */
-
-	  pamdata.conv        = pam_func;
-	  pamdata.appdata_ptr = con;
-
-#  ifdef __hpux
-	 /*
-	  * Workaround for HP-UX bug in pam_unix; see pam_conv() below for
-	  * more info...
-	  */
-
-	  auth_client = con;
-#  endif /* __hpux */
-
-	  DEBUG_printf(("cupsdIsAuthorized: Setting appdata_ptr = %p\n", con));
-
-	  pamerr = pam_start("cups", con->username, &pamdata, &pamh);
-	  if (pamerr != PAM_SUCCESS)
-	  {
-	    cupsdLogMessage(CUPSD_LOG_ERROR,
-	                    "cupsdIsAuthorized: pam_start() returned %d (%s)!\n",
-        	            pamerr, pam_strerror(pamh, pamerr));
-	    pam_end(pamh, 0);
-	    return (HTTP_UNAUTHORIZED);
-	  }
-
-	  pamerr = pam_authenticate(pamh, PAM_SILENT);
-	  if (pamerr != PAM_SUCCESS)
-	  {
-	    cupsdLogMessage(CUPSD_LOG_ERROR,
-	                    "cupsdIsAuthorized: pam_authenticate() returned %d (%s)!\n",
-        	            pamerr, pam_strerror(pamh, pamerr));
-	    pam_end(pamh, 0);
-	    return (HTTP_UNAUTHORIZED);
-	  }
-
-	  pamerr = pam_acct_mgmt(pamh, PAM_SILENT);
-	  if (pamerr != PAM_SUCCESS)
-	  {
-	    cupsdLogMessage(CUPSD_LOG_ERROR,
-	                    "cupsdIsAuthorized: pam_acct_mgmt() returned %d (%s)!\n",
-        	            pamerr, pam_strerror(pamh, pamerr));
-	    pam_end(pamh, 0);
-	    return (HTTP_UNAUTHORIZED);
-	  }
-
-	  pam_end(pamh, PAM_SUCCESS);
-#elif defined(HAVE_USERSEC_H)
-	 /*
-	  * Use AIX authentication interface...
-	  */
-
-	  cupsdLogMessage(CUPSD_LOG_DEBUG,
-	                  "cupsdIsAuthorized: AIX authenticate of username \"%s\"",
-                          con->username);
-
-	  reenter = 1;
-	  if (authenticate(con->username, con->password, &reenter, &authmsg) != 0)
-	  {
-	    cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdIsAuthorized: Unable to authenticate username \"%s\": %s",
-	               con->username, strerror(errno));
-	    return (HTTP_UNAUTHORIZED);
-	  }
-#else
-         /*
-	  * Use normal UNIX password file-based authentication...
-	  */
-
-	  if (pw == NULL)			/* No such user... */
-	  {
-	    cupsdLogMessage(CUPSD_LOG_WARN,
-	                    "cupsdIsAuthorized: Unknown username \"%s\"; access denied.",
-        	            con->username);
-	    return (HTTP_UNAUTHORIZED);
-	  }
-
-#  ifdef HAVE_SHADOW_H
-	  spw = getspnam(con->username);
-	  endspent();
-
-	  if (spw == NULL && strcmp(pw->pw_passwd, "x") == 0)
-	  {					/* Don't allow blank passwords! */
-	    cupsdLogMessage(CUPSD_LOG_WARN,
-	                    "cupsdIsAuthorized: Username \"%s\" has no shadow password; access denied.",
-        	            con->username);
-	    return (HTTP_UNAUTHORIZED);	/* No such user or bad shadow file */
-	  }
-
-#    ifdef DEBUG
-	  if (spw != NULL)
-	    printf("spw->sp_pwdp = \"%s\"\n", spw->sp_pwdp);
-	  else
-	    puts("spw = NULL");
-#    endif /* DEBUG */
-
-	  if (spw != NULL && spw->sp_pwdp[0] == '\0' && pw->pw_passwd[0] == '\0')
-#  else
-	  if (pw->pw_passwd[0] == '\0')
-#  endif /* HAVE_SHADOW_H */
-	  {					/* Don't allow blank passwords! */
-	    cupsdLogMessage(CUPSD_LOG_WARN,
-	                    "cupsdIsAuthorized: Username \"%s\" has no password; access denied.",
-        	            con->username);
-	    return (HTTP_UNAUTHORIZED);
-	  }
-
-	 /*
-	  * OK, the password isn't blank, so compare with what came from the client...
-	  */
-
-	  pass = cups_crypt(con->password, pw->pw_passwd);
-
-	  cupsdLogMessage(CUPSD_LOG_DEBUG2,
-	                  "cupsdIsAuthorized: pw_passwd = %s, crypt = %s",
-		          pw->pw_passwd, pass);
-
-	  if (pass == NULL || strcmp(pw->pw_passwd, pass) != 0)
-	  {
-#  ifdef HAVE_SHADOW_H
-	    if (spw != NULL)
-	    {
-	      pass = cups_crypt(con->password, spw->sp_pwdp);
-
-	      cupsdLogMessage(CUPSD_LOG_DEBUG2,
-	                      "cupsdIsAuthorized: sp_pwdp = %s, crypt = %s",
-			      spw->sp_pwdp, pass);
-
-	      if (pass == NULL || strcmp(spw->sp_pwdp, pass) != 0)
-		return (HTTP_UNAUTHORIZED);
-	    }
-	    else
-#  endif /* HAVE_SHADOW_H */
-	      return (HTTP_UNAUTHORIZED);
-	  }
-#endif /* HAVE_LIBPAM */
-          break;
-
-      case AUTH_DIGEST :
-	 /*
-	  * Do Digest authentication...
-	  */
-
-	  if (!httpGetSubField(&(con->http), HTTP_FIELD_AUTHORIZATION, "nonce",
-                               nonce))
-	  {
-            cupsdLogMessage(CUPSD_LOG_ERROR,
-	                    "cupsdIsAuthorized: No nonce value for Digest authentication!");
-            return (HTTP_UNAUTHORIZED);
-	  }
-
-	  if (strcmp(con->http.hostname, nonce) != 0)
-	  {
-            cupsdLogMessage(CUPSD_LOG_ERROR,
-	                    "cupsdIsAuthorized: Nonce value error!");
-            cupsdLogMessage(CUPSD_LOG_ERROR,
-	                    "cupsdIsAuthorized: Expected \"%s\",",
-	                    con->http.hostname);
-            cupsdLogMessage(CUPSD_LOG_ERROR,
-	                    "cupsdIsAuthorized: Got \"%s\"!", nonce);
-            return (HTTP_UNAUTHORIZED);
-	  }
-
-	  cupsdLogMessage(CUPSD_LOG_DEBUG2, "cupsdIsAuthorized: nonce = \"%s\"",
-	                  nonce);
-
-	  if (best->num_names && best->level == AUTH_GROUP)
-	  {
-	    cupsdLogMessage(CUPSD_LOG_DEBUG2,
-	                    "cupsdIsAuthorized: num_names = %d",
-			    best->num_names);
-
-            for (i = 0; i < best->num_names; i ++)
-	    {
-	      if (!strcasecmp(best->names[i], "@SYSTEM"))
-	      {
-	        for (j = 0; j < NumSystemGroups; j ++)
-		  if (cupsdGetMD5Passwd(con->username, SystemGroups[j], md5))
-		    break;
-
-                if (j < NumSystemGroups)
-		  break;
-	      }
-	      else if (cupsdGetMD5Passwd(con->username, best->names[i], md5))
-		break;
-            }
-
-            if (i >= best->num_names)
-	      md5[0] = '\0';
-	  }
-	  else if (!cupsdGetMD5Passwd(con->username, NULL, md5))
-	    md5[0] = '\0';
-
-	  if (!md5[0])
-	  {
-            cupsdLogMessage(CUPSD_LOG_DEBUG2,
-	                    "cupsdIsAuthorized: No matching user:group for \"%s\" in passwd.md5!",
-	                    con->username);
-            return (HTTP_UNAUTHORIZED);
-	  }
-
-	  httpMD5Final(nonce, states[con->http.state], con->uri, md5);
-
-	  if (strcmp(md5, con->password) != 0)
-	  {
-            cupsdLogMessage(CUPSD_LOG_DEBUG2,
-	                    "cupsdIsAuthorized: MD5s \"%s\" and \"%s\" don't match!",
-	                    md5, con->password);
-            return (HTTP_UNAUTHORIZED);
-	  }
-          break;
-
-      case AUTH_BASICDIGEST :
-         /*
-	  * Do Basic authentication with the Digest password file...
-	  */
-
-	  if (best->num_names && best->level == AUTH_GROUP)
-	  {
-	    cupsdLogMessage(CUPSD_LOG_DEBUG2,
-	                    "cupsdIsAuthorized: num_names = %d",
-			    best->num_names);
-
-            for (i = 0; i < best->num_names; i ++)
-	    {
-	      if (!strcasecmp(best->names[i], "@SYSTEM"))
-	      {
-	        for (j = 0; j < NumSystemGroups; j ++)
-		  if (cupsdGetMD5Passwd(con->username, SystemGroups[j], md5))
-		    break;
-
-                if (j < NumSystemGroups)
-		  break;
-	      }
-	      else if (cupsdGetMD5Passwd(con->username, best->names[i], md5))
-		break;
-            }
-
-            if (i >= best->num_names)
-	      md5[0] = '\0';
-	  }
-	  else if (!cupsdGetMD5Passwd(con->username, NULL, md5))
-	    md5[0] = '\0';
-
-	  if (!md5[0])
-	  {
-            cupsdLogMessage(CUPSD_LOG_DEBUG2,
-	                    "cupsdIsAuthorized: No matching user:group for \"%s\" in passwd.md5!",
-	                    con->username);
-            return (HTTP_UNAUTHORIZED);
-	  }
-
-	  httpMD5(con->username, "CUPS", con->password, basicmd5);
-
-	  if (strcmp(md5, basicmd5) != 0)
-	  {
-            cupsdLogMessage(CUPSD_LOG_DEBUG2,
-	                    "cupsdIsAuthorized: MD5s \"%s\" and \"%s\" don't match!",
-	                    md5, basicmd5);
-            return (HTTP_UNAUTHORIZED);
-	  }
-	  break;
-    }
-  }
-  else
-  {
-   /*
-    * Get password entry for certificate-based auth...
-    */
-
-    pw = getpwnam(con->username);	/* Get the current password */
-    endpwent();				/* Close the password file */
-  }
-
- /*
   * OK, the password is good.  See if we need normal user access, or group
   * access... (root always matches)
   */
@@ -1568,6 +1700,13 @@
   if (!strcmp(con->username, "root"))
     return (HTTP_OK);
 
+ /*
+  * Get the user info...
+  */
+
+  pw = getpwnam(con->username);
+  endpwent();
+
   if (best->level == AUTH_USER)
   {
    /*
@@ -1616,43 +1755,34 @@
   cupsdLogMessage(CUPSD_LOG_DEBUG2,
                   "cupsdIsAuthorized: Checking group membership...");
 
-  if (best->type == AUTH_BASIC)
+ /*
+  * Check to see if this user is in any of the named groups...
+  */
+
+  for (i = 0; i < best->num_names; i ++)
   {
-   /*
-    * Check to see if this user is in any of the named groups...
-    */
+    cupsdLogMessage(CUPSD_LOG_DEBUG2,
+                    "cupsdIsAuthorized: Checking group \"%s\" membership...",
+                    best->names[i]);
 
-    for (i = 0; i < best->num_names; i ++)
+    if (!strcasecmp(best->names[i], "@SYSTEM"))
     {
-      cupsdLogMessage(CUPSD_LOG_DEBUG2,
-                      "cupsdIsAuthorized: Checking group \"%s\" membership...",
-                      best->names[i]);
-
-      if (!strcasecmp(best->names[i], "@SYSTEM"))
-      {
-        for (j = 0; j < NumSystemGroups; j ++)
-	  if (cupsdCheckGroup(con->username, pw, SystemGroups[j]))
-	    return (HTTP_OK);
-      }
-      else if (cupsdCheckGroup(con->username, pw, best->names[i]))
-        return (HTTP_OK);
+      for (j = 0; j < NumSystemGroups; j ++)
+	if (cupsdCheckGroup(con->username, pw, SystemGroups[j]))
+	  return (HTTP_OK);
     }
-
-   /*
-    * The user isn't part of the specified group, so deny access...
-    */
-
-    cupsdLogMessage(CUPSD_LOG_DEBUG2,
-                    "cupsdIsAuthorized: User not in group(s)!");
-
-    return (HTTP_UNAUTHORIZED);
+    else if (cupsdCheckGroup(con->username, pw, best->names[i]))
+      return (HTTP_OK);
   }
 
  /*
-  * All checks passed...
+  * The user isn't part of the specified group, so deny access...
   */
 
-  return (HTTP_OK);
+  cupsdLogMessage(CUPSD_LOG_DEBUG2,
+                  "cupsdIsAuthorized: User not in group(s)!");
+
+  return (HTTP_UNAUTHORIZED);
 }
 
 
@@ -1878,7 +2008,7 @@
 {
   int			i;		/* Looping var */
   struct pam_response	*replies;	/* Replies */
-  cupsd_client_t	*client;	/* Pointer client connection */
+  cupsd_authdata_t	*data;		/* Pointer to auth data */
 
 
  /*
@@ -1900,10 +2030,10 @@
   * module.  This is a workaround...
   */
 
-  client = auth_client;
+  data = auth_data;
   (void)appdata_ptr;
 #else
-  client = (cupsd_client_t *)appdata_ptr;
+  data = (cupsd_authdata_t *)appdata_ptr;
 #endif /* __hpux */
 
   for (i = 0; i < num_msg; i ++)
@@ -1914,16 +2044,16 @@
     {
       case PAM_PROMPT_ECHO_ON:
           DEBUG_printf(("pam_func: PAM_PROMPT_ECHO_ON, returning \"%s\"...\n",
-	                client->username));
+	                data->username));
           replies[i].resp_retcode = PAM_SUCCESS;
-          replies[i].resp         = strdup(client->username);
+          replies[i].resp         = strdup(data->username);
           break;
 
       case PAM_PROMPT_ECHO_OFF:
           DEBUG_printf(("pam_func: PAM_PROMPT_ECHO_OFF, returning \"%s\"...\n",
-	                client->password));
+	                data->password));
           replies[i].resp_retcode = PAM_SUCCESS;
-          replies[i].resp         = strdup(client->password);
+          replies[i].resp         = strdup(data->password);
           break;
 
       case PAM_TEXT_INFO:
@@ -1978,5 +2108,5 @@
 
 
 /*
- * End of "$Id: auth.c 4719 2005-09-28 21:12:44Z mike $".
+ * End of "$Id: auth.c 4813 2005-10-25 19:00:12Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/auth.h cupsys-1.1.99.b1.r4748/scheduler/auth.h
--- cupsys-1.1.99.b1.r4748~/scheduler/auth.h	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/auth.h	2005-10-26 03:23:10.577577000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: auth.h 4719 2005-09-28 21:12:44Z mike $"
+ * "$Id: auth.h 4812 2005-10-25 18:23:10Z mike $"
  *
  *   Authorization definitions for the Common UNIX Printing System (CUPS)
  *   scheduler.
@@ -139,6 +139,7 @@
 extern void		cupsdAllowHost(cupsd_location_t *loc, char *name);
 extern void		cupsdAllowIP(cupsd_location_t *loc, unsigned address[4],
 			             unsigned netmask[4]);
+extern void		cupsdAuthorize(cupsd_client_t *con);
 extern int		cupsdCheckAuth(unsigned ip[4], char *name, int namelen,
 				       int num_masks, cupsd_authmask_t *masks);
 extern int		cupsdCheckGroup(const char *username,
@@ -158,5 +159,5 @@
 
 
 /*
- * End of "$Id: auth.h 4719 2005-09-28 21:12:44Z mike $".
+ * End of "$Id: auth.h 4812 2005-10-25 18:23:10Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/classes.c cupsys-1.1.99.b1.r4748/scheduler/classes.c
--- cupsys-1.1.99.b1.r4748~/scheduler/classes.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/classes.c	2005-11-12 12:27:16.422457000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: classes.c 4719 2005-09-28 21:12:44Z mike $"
+ * "$Id: classes.c 4830 2005-11-12 03:27:16Z mike $"
  *
  *   Printer class routines for the Common UNIX Printing System (CUPS).
  *
@@ -133,7 +133,8 @@
     cupsd_printer_t *p)			/* I - Printer to delete */
 {
   int		i;			/* Looping var */
-  cups_ptype_t	type;			/* Class type */
+  cups_ptype_t	type,			/* Class type */
+		oldtype;		/* Old class type */
 
 
  /*
@@ -168,6 +169,7 @@
 
   if (c->num_printers > 0)
   {
+    oldtype = c->type;
     type    = c->type & (CUPS_PRINTER_CLASS | CUPS_PRINTER_IMPLICIT);
     c->type = ~CUPS_PRINTER_REMOTE;
 
@@ -180,7 +182,8 @@
     * Update the IPP attributes...
     */
 
-    cupsdSetPrinterAttrs(c);
+    if (c->type != oldtype)
+      cupsdSetPrinterAttrs(c);
   }
 }
 
@@ -211,11 +214,14 @@
   * Then clean out any empty implicit classes...
   */
 
-  for (c = (cupsd_printer_t *)cupsArrayFirst(Printers);
+  for (c = (cupsd_printer_t *)cupsArrayFirst(ImplicitPrinters);
        c;
-       c = (cupsd_printer_t *)cupsArrayNext(Printers))
-    if ((c->type & CUPS_PRINTER_IMPLICIT) && c->num_printers == 0)
+       c = (cupsd_printer_t *)cupsArrayNext(ImplicitPrinters))
+    if (c->num_printers == 0)
+    {
+      cupsArrayRemove(ImplicitPrinters, c);
       cupsdDeletePrinter(c, 0);
+    }
 }
 
 
@@ -299,10 +305,11 @@
   cupsd_printer_t	*c;		/* Current class/printer */
 
 
-  if ((c = cupsdFindDest(name)) != NULL && !(c->type & CUPS_PRINTER_CLASS))
-    return (NULL);
-  else
+  if ((c = cupsdFindDest(name)) != NULL &&
+      (c->type & (CUPS_PRINTER_CLASS | CUPS_PRINTER_IMPLICIT)))
     return (c);
+  else
+    return (NULL);
 }
 
 
@@ -678,8 +685,11 @@
   snprintf(backup, sizeof(backup), "%s/classes.conf.O", ServerRoot);
 
   if (rename(temp, backup))
-    cupsdLogMessage(CUPSD_LOG_ERROR, "Unable to backup classes.conf - %s",
-                    strerror(errno));
+  {
+    if (errno != ENOENT)
+      cupsdLogMessage(CUPSD_LOG_ERROR, "Unable to backup classes.conf - %s",
+                      strerror(errno));
+  }
 
   if ((fp = cupsFileOpen(temp, "w")) == NULL)
   {
@@ -707,7 +717,7 @@
 
   curtime = time(NULL);
   curdate = localtime(&curtime);
-  strftime(temp, sizeof(temp) - 1, "%c", curdate);
+  strftime(temp, sizeof(temp) - 1, "%Y-%m-%d %H:%M", curdate);
 
   cupsFilePuts(fp, "# Class configuration file for " CUPS_SVERSION "\n");
   cupsFilePrintf(fp, "# Written by cupsd on %s\n", temp);
@@ -801,25 +811,23 @@
   int			accepting;	/* printer-is-accepting-jobs value */
 
 
-  for (pclass = (cupsd_printer_t *)cupsArrayFirst(Printers);
+  for (pclass = (cupsd_printer_t *)cupsArrayFirst(ImplicitPrinters);
        pclass;
-       pclass = (cupsd_printer_t *)cupsArrayNext(Printers))
-    if (pclass->type & CUPS_PRINTER_IMPLICIT)
-    {
-     /*
-      * Implicit class, loop through the printers to come up with a
-      * composite state...
-      */
+       pclass = (cupsd_printer_t *)cupsArrayNext(ImplicitPrinters))
+  {
+   /*
+    * Loop through the printers to come up with a composite state...
+    */
 
-      for (i = 0, accepting = 0; i < pclass->num_printers; i ++)
-        if ((accepting |= pclass->printers[i]->accepting) != 0)
-	  break;
+    for (i = 0, accepting = 0; i < pclass->num_printers; i ++)
+      if ((accepting = pclass->printers[i]->accepting) != 0)
+	break;
 
-      pclass->accepting = accepting;
-    }
+    pclass->accepting = accepting;
+  }
 }
 
 
 /*
- * End of "$Id: classes.c 4719 2005-09-28 21:12:44Z mike $".
+ * End of "$Id: classes.c 4830 2005-11-12 03:27:16Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/client.c cupsys-1.1.99.b1.r4748/scheduler/client.c
--- cupsys-1.1.99.b1.r4748~/scheduler/client.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/client.c	2005-10-26 03:23:10.577577000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: client.c 4734 2005-10-01 01:03:34Z mike $"
+ * "$Id: client.c 4812 2005-10-25 18:23:10Z mike $"
  *
  *   Client routines for the Common UNIX Printing System (CUPS) scheduler.
  *
@@ -23,26 +23,25 @@
  *
  * Contents:
  *
- *   cupsdAcceptClient()    - Accept a new client.
- *   cupsdCloseAllClients() - Close all remote clients immediately.
- *   cupsdCloseClient()     - Close a remote client.
- *   cupsdEncryptClient()   - Enable encryption for the client...
- *   cupsdIsCGI()           - Is the resource a CGI script/program?
- *   cupsdReadClient()      - Read data from a client.
- *   cupsdSendCommand()     - Send output from a command via HTTP.
- *   cupsdSendError()       - Send an error message via HTTP.
- *   cupsdSendFile()        - Send a file via HTTP.
- *   cupsdSendHeader()      - Send an HTTP request.
- *   cupsdUpdateCGI()       - Read status messages from CGI scripts and programs.
- *   cupsdWriteClient()     - Write data to a client as needed.
- *   check_if_modified()    - Decode an "If-Modified-Since" line.
- *   decode_auth()          - Decode an authorization string.
- *   get_file()             - Get a filename and state info.
- *   install_conf_file()    - Install a configuration file.
- *   is_path_absolute()     - Is a path absolute and free of relative elements.
- *   pipe_command()         - Pipe the output of a command to the remote client.
- *   CDSAReadFunc()         - Read function for CDSA decryption code.
- *   CDSAWriteFunc()        - Write function for CDSA encryption code.
+ *   cupsdAcceptClient()     - Accept a new client.
+ *   cupsdCloseAllClients()  - Close all remote clients immediately.
+ *   cupsdCloseClient()      - Close a remote client.
+ *   cupsdEncryptClient()    - Enable encryption for the client...
+ *   cupsdIsCGI()            - Is the resource a CGI script/program?
+ *   cupsdReadClient()       - Read data from a client.
+ *   cupsdSendCommand()      - Send output from a command via HTTP.
+ *   cupsdSendError()        - Send an error message via HTTP.
+ *   cupsdSendFile()         - Send a file via HTTP.
+ *   cupsdSendHeader()       - Send an HTTP request.
+ *   cupsdUpdateCGI()        - Read status messages from CGI scripts and programs.
+ *   cupsdWriteClient()      - Write data to a client as needed.
+ *   check_if_modified()     - Decode an "If-Modified-Since" line.
+ *   get_cdsa_server_certs() - Convert a keychain name into the CFArrayRef
+ *			       required by SSLSetCertificate.
+ *   get_file()              - Get a filename and state info.
+ *   install_conf_file()     - Install a configuration file.
+ *   is_path_absolute()      - Is a path absolute and free of relative elements.
+ *   pipe_command()          - Pipe the output of a command to the remote client.
  */
 
 /*
@@ -52,6 +51,10 @@
 #include <cups/http-private.h>
 #include "cupsd.h"
 
+#ifdef HAVE_CDSASSL
+#  include <Security/Security.h>
+#endif /* HAVE_CDSASSL */
+
 
 /*
  * Local functions...
@@ -59,7 +62,9 @@
 
 static int		check_if_modified(cupsd_client_t *con,
 			                  struct stat *filestats);
-static void		decode_auth(cupsd_client_t *con);
+#ifdef HAVE_CDSASSL
+static CFArrayRef	get_cdsa_server_certs(void);
+#endif /* HAVE_CDSASSL */
 static char		*get_file(cupsd_client_t *con, struct stat *filestats, 
 			          char *filename, int len);
 static http_status_t	install_conf_file(cupsd_client_t *con);
@@ -67,13 +72,6 @@
 static int		pipe_command(cupsd_client_t *con, int infile, int *outfile,
 			             char *command, char *options, int root);
 
-#ifdef HAVE_CDSASSL
-static OSStatus		CDSAReadFunc(SSLConnectionRef connection, void *data,
-			             size_t *dataLength);
-static OSStatus		CDSAWriteFunc(SSLConnectionRef connection,
-			              const void *data, size_t *dataLength);
-#endif /* HAVE_CDSASSL */
-
 
 /*
  * 'cupsdAcceptClient()' - Accept a new client.
@@ -86,7 +84,9 @@
   int			count;		/* Count of connections on a host */
   int			val;		/* Parameter value */
   cupsd_client_t	*con;		/* New client pointer */
-  const struct hostent	*host;		/* Host entry for address */
+  http_addrlist_t	*addrlist,	/* List of adddresses for host */
+			*addr;		/* Current address */
+  socklen_t		addrlen;	/* Length of address */
   char			*hostname;	/* Hostname for address */
   http_addr_t		temp;		/* Temporary address variable */
   static time_t		last_dos = 0;	/* Time of last DoS attack */
@@ -112,15 +112,16 @@
   memset(con, 0, sizeof(cupsd_client_t));
   con->http.activity = time(NULL);
   con->file          = -1;
+  con->http.hostaddr = &(con->clientaddr);
 
  /*
   * Accept the client and get the remote address...
   */
 
-  val = sizeof(struct sockaddr_in);
+  addrlen = sizeof(http_addr_t);
 
-  if ((con->http.fd = accept(lis->fd, (struct sockaddr *)&(con->http.hostaddr),
-                             &val)) < 0)
+  if ((con->http.fd = accept(lis->fd, (struct sockaddr *)con->http.hostaddr,
+                             &addrlen)) < 0)
   {
     cupsdLogMessage(CUPSD_LOG_ERROR, "Unable to accept client connection - %s.",
                     strerror(errno));
@@ -129,18 +130,34 @@
 
 #ifdef AF_INET6
   if (lis->address.addr.sa_family == AF_INET6)
-    con->http.hostaddr.ipv6.sin6_port = lis->address.ipv6.sin6_port;
+  {
+   /*
+    * Save the connected port number...
+    */
+
+    con->http.hostaddr->ipv6.sin6_port = lis->address.ipv6.sin6_port;
+
+   /*
+    * Convert IPv4 over IPv6 addresses (::ffff:n.n.n.n) to IPv4 forms we
+    * can more easily use...
+    */
+
+    if (con->http.hostaddr->ipv6.sin6_addr.s6_addr32[0] == 0 &&
+        con->http.hostaddr->ipv6.sin6_addr.s6_addr32[1] == 0 &&
+        ntohl(con->http.hostaddr->ipv6.sin6_addr.s6_addr32[2]) == 0xffff)
+      con->http.hostaddr->ipv6.sin6_addr.s6_addr32[2] = 0;
+  }
   else
 #endif /* AF_INET6 */
   if (lis->address.addr.sa_family == AF_INET)
-    con->http.hostaddr.ipv4.sin_port = lis->address.ipv4.sin_port;
+    con->http.hostaddr->ipv4.sin_port = lis->address.ipv4.sin_port;
 
  /*
   * Check the number of clients on the same address...
   */
 
   for (i = 0, count = 0; i < NumClients; i ++)
-    if (httpAddrEqual(&(Clients[i].http.hostaddr), &(con->http.hostaddr)))
+    if (httpAddrEqual(Clients[i].http.hostaddr, con->http.hostaddr))
     {
       count ++;
       if (count >= MaxClientsPerHost)
@@ -170,7 +187,7 @@
   * Get the hostname or format the IP address as needed...
   */
 
-  if (httpAddrLocalhost(&(con->http.hostaddr)))
+  if (httpAddrLocalhost(con->http.hostaddr))
   {
    /*
     * Map accesses from the loopback interface to "localhost"...
@@ -179,23 +196,30 @@
     strlcpy(con->http.hostname, "localhost", sizeof(con->http.hostname));
     hostname = con->http.hostname;
   }
-  else if (httpAddrEqual(&(con->http.hostaddr), &ServerAddr))
+  else
   {
    /*
     * Map accesses from the same host to the server name.
     */
 
-    strlcpy(con->http.hostname, ServerName, sizeof(con->http.hostname));
-    hostname = con->http.hostname;
-  }
-  else if (HostNameLookups)
-    hostname = httpAddrLookup(&(con->http.hostaddr), con->http.hostname,
-                              sizeof(con->http.hostname));
-  else
-  {
-    hostname = NULL;
-    httpAddrString(&(con->http.hostaddr), con->http.hostname,
-                   sizeof(con->http.hostname));
+    for (addr = ServerAddrs; addr; addr = addr->next)
+      if (httpAddrEqual(con->http.hostaddr, &(addr->addr)))
+        break;
+
+    if (addr)
+    {
+      strlcpy(con->http.hostname, ServerName, sizeof(con->http.hostname));
+      hostname = con->http.hostname;
+    }
+    else if (HostNameLookups)
+      hostname = httpAddrLookup(con->http.hostaddr, con->http.hostname,
+                                sizeof(con->http.hostname));
+    else
+    {
+      hostname = NULL;
+      httpAddrString(con->http.hostaddr, con->http.hostname,
+                     sizeof(con->http.hostname));
+    }
   }
 
   if (hostname == NULL && HostNameLookups == 2)
@@ -226,40 +250,22 @@
     * Do double lookups as needed...
     */
 
-    if ((host = httpGetHostByName(con->http.hostname)) != NULL)
+    if ((addrlist = httpAddrGetList(con->http.hostname, AF_UNSPEC, NULL)) != NULL)
     {
      /*
       * See if the hostname maps to the same IP address...
       */
 
-      if (host->h_addrtype != con->http.hostaddr.addr.sa_family)
-      {
-       /*
-        * Not the right type of address...
-	*/
-
-	host = NULL;
-      }
-      else
-      {
-       /*
-        * Compare all of the addresses against this one...
-	*/
-
-	for (i = 0; host->h_addr_list[i]; i ++)
-	{
-	  httpAddrLoad(host, 0, i, &temp);
-
-          if (httpAddrEqual(&(con->http.hostaddr), &temp))
-	    break;
-        }
-
-        if (!host->h_addr_list[i])
-	  host = NULL;
-      }
+      for (addr = addrlist; addr; addr = addr->next)
+        if (httpAddrEqual(con->http.hostaddr, &(addr->addr)))
+          break;
     }
+    else
+      addr = NULL;
 
-    if (host == NULL)
+    httpAddrFreeList(addrlist);
+
+    if (!addr)
     {
      /*
       * Can't have a hostname that doesn't resolve to the same IP address
@@ -284,28 +290,28 @@
   }
 
 #ifdef AF_INET6
-  if (con->http.hostaddr.addr.sa_family == AF_INET6)
+  if (con->http.hostaddr->addr.sa_family == AF_INET6)
     cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdAcceptClient: %d from %s:%d (IPv6)",
                     con->http.fd, con->http.hostname,
-		    ntohs(con->http.hostaddr.ipv6.sin6_port));
+		    ntohs(con->http.hostaddr->ipv6.sin6_port));
   else
 #endif /* AF_INET6 */
 #ifdef AF_LOCAL
-  if (con->http.hostaddr.addr.sa_family == AF_LOCAL)
+  if (con->http.hostaddr->addr.sa_family == AF_LOCAL)
     cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdAcceptClient: %d from %s (Domain)",
                     con->http.fd, con->http.hostname);
   else
 #endif /* AF_LOCAL */
   cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdAcceptClient: %d from %s:%d (IPv4)",
                   con->http.fd, con->http.hostname,
-		  ntohs(con->http.hostaddr.ipv4.sin_port));
+		  ntohs(con->http.hostaddr->ipv4.sin_port));
 
  /*
   * Get the local address the client connected to...
   */
 
-  i = sizeof(temp);
-  if (getsockname(con->http.fd, (struct sockaddr *)&temp, &i))
+  addrlen = sizeof(temp);
+  if (getsockname(con->http.fd, (struct sockaddr *)&temp, &addrlen))
   {
     cupsdLogMessage(CUPSD_LOG_ERROR, "Unable to get local address - %s",
                     strerror(errno));
@@ -414,7 +420,7 @@
 cupsdCloseClient(cupsd_client_t *con)	/* I - Client to close */
 {
   int		partial;		/* Do partial close for SSL? */
-#if defined(HAVE_LIBSSL)
+#ifdef HAVE_LIBSSL
   SSL_CTX	*context;		/* Context for encryption */
   SSL		*conn;			/* Connection for encryption */
   unsigned long	error;			/* Error code */
@@ -423,8 +429,6 @@
   int            error;			/* Error code */
   gnutls_certificate_server_credentials *credentials;
 					/* TLS credentials */
-#elif defined(HAVE_CDSASSL)
-  int		status;			/* Error status */
 #endif /* HAVE_LIBSSL */
 
 
@@ -493,7 +497,7 @@
     free(conn);
 
 #  elif defined(HAVE_CDSASSL)
-    status = SSLClose((SSLContextRef)con->http.tls);
+    SSLClose((SSLContextRef)con->http.tls);
     SSLDisposeContext((SSLContextRef)con->http.tls);
 #  endif /* HAVE_LIBSSL */
 
@@ -511,6 +515,7 @@
                     "cupsdCloseClient: %d Killing process ID %d...",
                     con->http.fd, con->pipe_pid);
     cupsdEndProcess(con->pipe_pid, 1);
+    con->pipe_pid = 0;
   }
 
   if (con->file >= 0)
@@ -627,7 +632,7 @@
 int					/* O - 1 on success, 0 on error */
 cupsdEncryptClient(cupsd_client_t *con)	/* I - Client to encrypt */
 {
-#if defined HAVE_LIBSSL
+#ifdef HAVE_LIBSSL
   SSL_CTX	*context;		/* Context for encryption */
   SSL		*conn;			/* Connection for encryption */
   unsigned long	error;			/* Error code */
@@ -731,15 +736,10 @@
   return (1);
 
 #elif defined(HAVE_CDSASSL)
-  OSStatus		error;		/* Error info */
-  SSLContextRef		conn;		/* New connection */
-  SSLProtocol		tryVersion;	/* Protocol version */
-  const char		*hostName;	/* Local hostname */
-  int			allowExpired;	/* Allow expired certificates? */
-  int			allowAnyRoot;	/* Allow any root certificate? */
-  SSLProtocol		*negVersion;	/* Negotiated protocol version */
-  SSLCipherSuite	*negCipher;	/* Negotiated cypher */
-  CFArrayRef		*peerCerts;	/* Certificates */
+  OSStatus	error;			/* Error info */
+  SSLContextRef	conn;			/* New connection */
+  int		allowExpired;		/* Allow expired certificates? */
+  int		allowAnyRoot;		/* Allow any root certificate? */
 
 
   conn         = NULL;
@@ -747,8 +747,19 @@
   allowExpired = 1;
   allowAnyRoot = 1;
 
+  if (!ServerCertificatesArray)
+    ServerCertificatesArray = get_cdsa_server_certs();
+
+  if (!ServerCertificatesArray)
+  {
+    cupsdLogMessage(CUPSD_LOG_ERROR,
+        	    "EncryptClient: Could not find signing key in keychain "
+		    "\"%s\"", ServerCertificate);
+    error = errSSLBadConfiguration;
+  }
+
   if (!error)
-    error = SSLSetIOFuncs(conn, CDSAReadFunc, CDSAWriteFunc);
+    error = SSLSetIOFuncs(conn, _httpReadCDSA, _httpWriteCDSA);
 
   if (!error)
     error = SSLSetProtocolVersion(conn, kSSLProtocol3);
@@ -757,19 +768,16 @@
     error = SSLSetConnection(conn, (SSLConnectionRef)con->http.fd);
 
   if (!error)
-  {
-    hostName = ServerName;	/* MRS: ??? */
-    error    = SSLSetPeerDomainName(conn, hostName, strlen(hostName) + 1);
-  }
+    error = SSLSetPeerDomainName(conn, ServerName, strlen(ServerName) + 1);
 
-  /* have to do these options befor setting server certs */
+  /* have to do these options before setting server certs */
   if (!error && allowExpired)
     error = SSLSetAllowsExpiredCerts(conn, true);
 
   if (!error && allowAnyRoot)
     error = SSLSetAllowsAnyRoot(conn, true);
 
-  if (!error && ServerCertificatesArray != NULL)
+  if (!error && ServerCertificatesArray)
     error = SSLSetCertificate(conn, ServerCertificatesArray);
 
  /*
@@ -789,7 +797,7 @@
                     con->http.hostname);
 
     cupsdLogMessage(CUPSD_LOG_ERROR,
-                    "cupsdEncryptClient: CDSA error code is %d", error);
+                    "cupsdEncryptClient: CDSA error code is %d", (int)error);
 
     con->http.error  = error;
     con->http.status = HTTP_ERROR;
@@ -809,7 +817,7 @@
 
 #else
   return (0);
-#endif /* HAVE_GNUTLS */
+#endif /* HAVE_LIBSSL */
 }
 
 
@@ -1259,7 +1267,7 @@
     else
       con->language = cupsLangGet(DefaultLocale);
 
-    decode_auth(con);
+    cupsdAuthorize(con);
 
     if (!strncmp(con->http.fields[HTTP_FIELD_CONNECTION], "Keep-Alive", 10) &&
         KeepAlive)
@@ -1281,8 +1289,7 @@
       * Do OPTIONS command...
       */
 
-      if ((con->best = cupsdFindBest(con->uri, con->http.state)) != NULL &&
-          con->best->type != AUTH_NONE)
+      if (con->best && con->best->type != AUTH_NONE)
       {
 	if (!cupsdSendHeader(con, HTTP_UNAUTHORIZED, NULL))
 	  return (cupsdCloseClient(con));
@@ -1357,8 +1364,6 @@
 #endif /* HAVE_SSL */
       }
 
-      con->best = cupsdFindBest(con->uri, con->http.state);
-
       if ((status = cupsdIsAuthorized(con, NULL)) != HTTP_OK)
       {
         cupsdLogMessage(CUPSD_LOG_DEBUG2,
@@ -2400,7 +2405,7 @@
     if (!strchr(CGIStatusBuffer->buffer, '\n'))
       break;
 
-  if (ptr == NULL)
+  if (ptr == NULL && errno)
   {
    /*
     * Fatal error on pipe - should never happen!
@@ -2709,79 +2714,94 @@
 }
 
 
+#ifdef HAVE_CDSASSL
 /*
- * 'decode_auth()' - Decode an authorization string.
+ * 'get_cdsa_server_certs()' - Convert a keychain name into the CFArrayRef
+ *			       required by SSLSetCertificate.
+ *
+ * For now we assumes that there is exactly one SecIdentity in the
+ * keychain - i.e. there is exactly one matching cert/private key pair.
+ * In the future we will search a keychain for a SecIdentity matching a
+ * specific criteria.  We also skip the operation of adding additional
+ * non-signing certs from the keychain to the CFArrayRef.
+ *
+ * To create a self-signed certificate for testing use the certtool.
+ * Executing the following as root will do it:
+ *
+ *     certtool c c v k=CUPS
  */
 
-static void
-decode_auth(cupsd_client_t *con)	/* I - Client to decode to */
+static CFArrayRef			/* O - Array of certificates */
+get_cdsa_server_certs(void)
 {
-  char		*s,			/* Authorization string */
-		value[1024];		/* Value string */
-  const char	*username;		/* Certificate username */
-
-
- /*
-  * Decode the string...
-  */
+  OSStatus		err;		/* Error info */
+  SecKeychainRef	kcRef;		/* Keychain reference */
+  SecIdentitySearchRef	srchRef;	/* Search reference */
+  SecIdentityRef	identity;	/* Identity */
+  CFArrayRef		ca;		/* Certificate array */
 
-  s = con->http.fields[HTTP_FIELD_AUTHORIZATION];
 
-  cupsdLogMessage(CUPSD_LOG_DEBUG2,
-                  "decode_auth(%p): Authorization string = \"%s\"", con, s);
+  kcRef    = NULL;
+  srchRef  = NULL;
+  identity = NULL;
+  ca	   = NULL;
+  err      = SecKeychainOpen(ServerCertificate, &kcRef);
 
-  if (!strncmp(s, "Basic", 5))
+  if (err)
+    cupsdLogMessage(CUPSD_LOG_ERROR, "Cannot open keychain \"%s\", error %d.",
+	            ServerCertificate, (int)err);
+  else
   {
-    s += 5;
-    while (isspace(*s))
-      s ++;
-
-    httpDecode64(value, s);
-
    /*
-    * Pull the username and password out...
+    * Search for "any" identity matching specified key use; 
+    * in this app, we expect there to be exactly one. 
     */
 
-    if ((s = strchr(value, ':')) == NULL)
+    err = SecIdentitySearchCreate(kcRef, CSSM_KEYUSE_SIGN, &srchRef);
+
+    if (err)
+      cupsdLogMessage(CUPSD_LOG_DEBUG2,
+		      "Cannot find signing key in keychain \"%s\", error %d",
+		      ServerCertificate, (int)err);
+    else
     {
-      cupsdLogMessage(CUPSD_LOG_DEBUG,
-                      "decode_auth: %d no colon in auth string \"%s\"",
-        	      con->http.fd, value);
-      return;
-    }
+      err = SecIdentitySearchCopyNext(srchRef, &identity);
 
-    *s++ = '\0';
+      if (err)
+	cupsdLogMessage(CUPSD_LOG_DEBUG2,
+			"Cannot find signing key in keychain \"%s\", error %d",
+			ServerCertificate, (int)err);
+      else
+      {
+	if (CFGetTypeID(identity) != SecIdentityGetTypeID())
+	  cupsdLogMessage(CUPSD_LOG_ERROR,
+	                  "SecIdentitySearchCopyNext CFTypeID failure!");
+	else
+	{
+	 /* 
+	  * Found one. Place it in a CFArray. 
+	  * TBD: snag other (non-identity) certs from keychain and add them
+	  * to array as well.
+	  */
 
-    strlcpy(con->username, value, sizeof(con->username));
-    strlcpy(con->password, s, sizeof(con->password));
-  }
-  else if (!strncmp(s, "Local", 5))
-  {
-    s += 5;
-    while (isspace(*s))
-      s ++;
+	  ca = CFArrayCreate(NULL, (const void **)&identity, 1, NULL);
 
-    if ((username = cupsdFindCert(s)) != NULL)
-      strlcpy(con->username, username, sizeof(con->username));
-  }
-  else if (!strncmp(s, "Digest", 6))
-  {
-   /*
-    * Get the username and password from the Digest attributes...
-    */
+	  if (ca == nil)
+	    cupsdLogMessage(CUPSD_LOG_ERROR, "CFArrayCreate error");
+	}
 
-    if (httpGetSubField(&(con->http), HTTP_FIELD_AUTHORIZATION, "username",
-                        value))
-      strlcpy(con->username, value, sizeof(con->username));
+	/*CFRelease(identity);*/
+      }
 
-    if (httpGetSubField(&(con->http), HTTP_FIELD_AUTHORIZATION, "response",
-                        value))
-      strlcpy(con->password, value, sizeof(con->password));
+      /*CFRelease(srchRef);*/
+    }
+
+    /*CFRelease(kcRef);*/
   }
 
-  cupsdLogMessage(CUPSD_LOG_DEBUG2, "decode_auth: %d username=\"%s\"",
-                  con->http.fd, con->username);
+  return (ca);
 }
+#endif /* HAVE_CDSASSL */
 
 
 /*
@@ -3264,7 +3284,7 @@
     strcpy(lang, "LANG=C");
 
   strcpy(remote_addr, "REMOTE_ADDR=");
-  httpAddrString(&(con->http.hostaddr), remote_addr + 12,
+  httpAddrString(con->http.hostaddr, remote_addr + 12,
                  sizeof(remote_addr) - 12);
 
   snprintf(remote_host, sizeof(remote_host), "REMOTE_HOST=%s",
@@ -3418,56 +3438,6 @@
 }
 
 
-#if defined(HAVE_CDSASSL)
-/*
- * 'CDSAReadFunc()' - Read function for CDSA decryption code.
- */
-
-static OSStatus				/* O  - -1 on error, 0 on success */
-CDSAReadFunc(
-    SSLConnectionRef connection,	/* I  - SSL/TLS connection */
-    void             *data,		/* I  - Data buffer */
-    size_t           *dataLength)	/* IO - Number of bytes */
-{
-  ssize_t	bytes;			/* Number of bytes read */
-
-
-  bytes = recv((int)connection, data, *dataLength, 0);
-  if (bytes >= 0)
-  {
-    *dataLength = bytes;
-    return (0);
-  }
-  else
-    return (-1);
-}
-
-
-/*
- * 'CDSAWriteFunc()' - Write function for CDSA encryption code.
- */
-
-static OSStatus				/* O  - -1 on error, 0 on success */
-CDSAWriteFunc(
-    SSLConnectionRef connection,	/* I  - SSL/TLS connection */
-    const void       *data,		/* I  - Data buffer */
-    size_t           *dataLength)	/* IO - Number of bytes */
-{
-  ssize_t bytes;
-
-
-  bytes = write((int)connection, data, *dataLength);
-  if (bytes >= 0)
-  {
-    *dataLength = bytes;
-    return (0);
-  }
-  else
-    return (-1);
-}
-#endif /* HAVE_CDSASSL */
-
-
 /*
- * End of "$Id: client.c 4734 2005-10-01 01:03:34Z mike $".
+ * End of "$Id: client.c 4812 2005-10-25 18:23:10Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/client.h cupsys-1.1.99.b1.r4748/scheduler/client.h
--- cupsys-1.1.99.b1.r4748~/scheduler/client.h	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/client.h	2005-10-08 19:10:46.040473000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: client.h 4730 2005-09-30 21:45:34Z mike $"
+ * "$Id: client.h 4757 2005-10-08 10:10:46Z mike $"
  *
  *   Client definitions for the Common UNIX Printing System (CUPS) scheduler.
  *
@@ -52,6 +52,7 @@
 #ifdef HAVE_SSL
   int			auto_ssl;	/* Automatic test for SSL/TLS */
 #endif /* HAVE_SSL */
+  http_addr_t		clientaddr;	/* Client address */
   char			servername[256];/* Server name for connection */
   int			serverport;	/* Server port for connection */
 };
@@ -83,13 +84,14 @@
 					/* Local port encryption to use */
 VAR int			NumListeners	VALUE(0);
 					/* Number of listening sockets */
-VAR cupsd_listener_t		*Listeners	VALUE(NULL);
+VAR cupsd_listener_t	*Listeners	VALUE(NULL);
 					/* Listening sockets */
 VAR int			NumClients	VALUE(0);
 					/* Number of HTTP clients */
-VAR cupsd_client_t		*Clients	VALUE(NULL);
+VAR cupsd_client_t	*Clients	VALUE(NULL);
 					/* HTTP clients */
-VAR http_addr_t		ServerAddr;	/* Server address */
+VAR http_addrlist_t	*ServerAddrs	VALUE(NULL);
+					/* Server address(es) */
 VAR char		*ServerHeader	VALUE(NULL);
 					/* Server header in requests */
 VAR int			CGIPipes[2]	VALUE2(-1,-1);
@@ -128,5 +130,5 @@
 
 
 /*
- * End of "$Id: client.h 4730 2005-09-30 21:45:34Z mike $".
+ * End of "$Id: client.h 4757 2005-10-08 10:10:46Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/conf.c cupsys-1.1.99.b1.r4748/scheduler/conf.c
--- cupsys-1.1.99.b1.r4748~/scheduler/conf.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/conf.c	2005-11-12 12:27:16.422457000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: conf.c 4733 2005-10-01 00:34:49Z mike $"
+ * "$Id: conf.c 4830 2005-11-12 03:27:16Z mike $"
  *
  *   Configuration routines for the Common UNIX Printing System (CUPS).
  *
@@ -31,8 +31,6 @@
  *   read_configuration()     - Read a configuration file.
  *   read_location()          - Read a <Location path> definition.
  *   read_policy()            - Read a <Policy name> definition.
- *   CDSAGetServerCerts()     - Convert a keychain name into the CFArrayRef
- *                              required by SSLSetCertificate.
  */
 
 /*
@@ -45,11 +43,6 @@
 #include <sys/utsname.h>
 #include <cups/dir.h>
 
-#ifdef HAVE_CDSASSL
-#  include <Security/SecureTransport.h>
-#  include <Security/SecIdentitySearch.h>
-#endif /* HAVE_CDSASSL */
-
 #ifdef HAVE_VSYSLOG
 #  include <syslog.h>
 #endif /* HAVE_VSYSLOG */
@@ -108,8 +101,6 @@
   { "DefaultPolicy",		&DefaultPolicy,		CUPSD_VARTYPE_STRING },
   { "DocumentRoot",		&DocumentRoot,		CUPSD_VARTYPE_STRING },
   { "ErrorLog",			&ErrorLog,		CUPSD_VARTYPE_STRING },
-  { "FaxRetryLimit",		&FaxRetryLimit,		CUPSD_VARTYPE_INTEGER },
-  { "FaxRetryInterval",		&FaxRetryInterval,	CUPSD_VARTYPE_INTEGER },
   { "FileDevice",		&FileDevice,		CUPSD_VARTYPE_BOOLEAN },
   { "FilterLimit",		&FilterLimit,		CUPSD_VARTYPE_INTEGER },
   { "FilterNice",		&FilterNice,		CUPSD_VARTYPE_INTEGER },
@@ -117,6 +108,8 @@
   { "HideImplicitMembers",	&HideImplicitMembers,	CUPSD_VARTYPE_BOOLEAN },
   { "ImplicitClasses",		&ImplicitClasses,	CUPSD_VARTYPE_BOOLEAN },
   { "ImplicitAnyClasses",	&ImplicitAnyClasses,	CUPSD_VARTYPE_BOOLEAN },
+  { "JobRetryLimit",		&JobRetryLimit,		CUPSD_VARTYPE_INTEGER },
+  { "JobRetryInterval",		&JobRetryInterval,	CUPSD_VARTYPE_INTEGER },
   { "KeepAliveTimeout",		&KeepAliveTimeout,	CUPSD_VARTYPE_INTEGER },
   { "KeepAlive",		&KeepAlive,		CUPSD_VARTYPE_BOOLEAN },
   { "LimitRequestBody",		&MaxRequestSize,	CUPSD_VARTYPE_INTEGER },
@@ -169,23 +162,19 @@
 			  0x00000000, 0x00000000, 0x00000000, 0x00000000
 			};
 
-#ifdef HAVE_CDSASSL
-CFArrayRef CDSAGetServerCerts();
-#endif /* HAVE_CDSASSL */
-
 
 /*
  * Local functions...
  */
 
-static int	get_address(const char *value, unsigned defaddress, int defport,
-		            int deffamily, http_addr_t *address);
-static int	get_addr_and_mask(const char *value, unsigned *ip,
-		                  unsigned *mask);
-static int	parse_aaa(cupsd_location_t *loc, char *line, char *value, int linenum);
-static int	read_configuration(cups_file_t *fp);
-static int	read_location(cups_file_t *fp, char *name, int linenum);
-static int	read_policy(cups_file_t *fp, char *name, int linenum);
+static http_addrlist_t	*get_address(const char *value, int defport);
+static int		get_addr_and_mask(const char *value, unsigned *ip,
+			                  unsigned *mask);
+static int		parse_aaa(cupsd_location_t *loc, char *line,
+			          char *value, int linenum);
+static int		read_configuration(cups_file_t *fp);
+static int		read_location(cups_file_t *fp, char *name, int linenum);
+static int		read_policy(cups_file_t *fp, char *name, int linenum);
 
 
 /*
@@ -256,17 +245,7 @@
 
   if (NumListeners > 0)
   {
-#ifdef HAVE_DOMAINSOCKETS
-    int			i;		/* Looping var */
-    cupsd_listener_t	*lis;		/* Current listening socket */
-
-    for (i = NumListeners, lis = Listeners; i > 0; i --, lis ++)
-      if (lis->address.sin_family == AF_LOCAL)
-	cupsdClearString((char **)&lis->address.sin_addr);
-#endif /* HAVE_DOMAINSOCKETS */
-
     free(Listeners);
-
     NumListeners = 0;
   }
 
@@ -404,8 +383,8 @@
 
   ConfigFilePerm      = 0640;
   DefaultAuthType     = AUTH_BASIC;
-  FaxRetryLimit       = 5;
-  FaxRetryInterval    = 300;
+  JobRetryLimit       = 5;
+  JobRetryInterval    = 300;
   FileDevice          = FALSE;
   FilterLevel         = 0;
   FilterLimit         = 0;
@@ -449,6 +428,7 @@
   MaxJobsPerPrinter   = 0;
   MaxCopies           = 100;
 
+  cupsdDeleteAllPolicies();
   cupsdClearString(&DefaultPolicy);
 
  /*
@@ -590,15 +570,21 @@
   if (ServerCertificate[0] != '/')
     cupsdSetStringf(&ServerCertificate, "%s/%s", ServerRoot, ServerCertificate);
 
-#  if defined(HAVE_LIBSSL) || defined(HAVE_GNUTLS)
-  chown(ServerCertificate, RunUser, Group);
-  chmod(ServerCertificate, ConfigFilePerm);
+  if (!strncmp(ServerRoot, ServerCertificate, strlen(ServerRoot)))
+  {
+    chown(ServerCertificate, RunUser, Group);
+    chmod(ServerCertificate, ConfigFilePerm);
+  }
 
+#  if defined(HAVE_LIBSSL) || defined(HAVE_GNUTLS)
   if (ServerKey[0] != '/')
     cupsdSetStringf(&ServerKey, "%s/%s", ServerRoot, ServerKey);
 
-  chown(ServerKey, RunUser, Group);
-  chmod(ServerKey, ConfigFilePerm);
+  if (!strncmp(ServerRoot, ServerKey, strlen(ServerRoot)))
+  {
+    chown(ServerKey, RunUser, Group);
+    chmod(ServerKey, ConfigFilePerm);
+  }
 #  endif /* HAVE_LIBSSL || HAVE_GNUTLS */
 #endif /* HAVE_SSL */
 
@@ -901,6 +887,11 @@
     }
   }
 
+  cupsdLogMessage(CUPSD_LOG_DEBUG,"NumPolicies=%d", NumPolicies);
+  for (i = 0; i < NumPolicies; i ++)
+    cupsdLogMessage(CUPSD_LOG_DEBUG, "Policies[%d]=\"%s\"", i,
+                    Policies[i]->name);
+
  /*
   * If we are doing a full reload or the server root has changed, flush
   * the jobs, printers, etc. and start from scratch...
@@ -916,6 +907,7 @@
     * Free all memory...
     */
 
+    cupsdDeleteAllSubscriptions();
     cupsdFreeAllJobs();
     cupsdDeleteAllClasses();
     cupsdDeleteAllPrinters();
@@ -987,6 +979,7 @@
 
     cupsdLoadAllPrinters();
     cupsdLoadAllClasses();
+    cupsdLoadRemoteCache();
 
     cupsdCreateCommonData();
 
@@ -996,12 +989,28 @@
 
     cupsdLoadAllJobs();
 
+   /*
+    * Load subscriptions...
+    */
+
+    cupsdLoadAllSubscriptions();
+
     cupsdLogMessage(CUPSD_LOG_INFO, "Full reload complete.");
   }
   else
   {
+   /*
+    * Not a full reload, so recreate the common printer attributes...
+    */
+
     cupsdCreateCommonData();
 
+   /*
+    * Update all printers as needed...
+    */
+
+    cupsdUpdatePrinters();
+
     cupsdLogMessage(CUPSD_LOG_INFO, "Partial reload complete.");
   }
 
@@ -1028,18 +1037,15 @@
  * 'get_address()' - Get an address + port number from a line.
  */
 
-static int				/* O - 1 if address good, 0 if bad */
+static http_addrlist_t *		/* O - Pointer to list if address good, NULL if bad */
 get_address(const char  *value,		/* I - Value string */
-            unsigned    defaddress,	/* I - Default address */
-	    int         defport,	/* I - Default port */
-	    int         deffamily,	/* I - Default family */
-            http_addr_t *address)	/* O - Socket address */
+	    int         defport)	/* I - Default port */
 {
-  char			hostname[256],	/* Hostname or IP */
-			portname[256],	/* Port number or name */
-			*ptr;		/* Pointer into hostname string */
-  struct hostent	*host;		/* Host address */
-  struct servent	*port;		/* Port number */  
+  char			buffer[1024],	/* Hostname + port number buffer */
+			defpname[255],	/* Default port name */
+			*hostname,	/* Hostname or IP */
+			*portname;	/* Port number or name */
+  http_addrlist_t	*addrlist;	/* Address list */
 
 
  /*
@@ -1049,136 +1055,58 @@
   if (!*value)
   {
     cupsdLogMessage(CUPSD_LOG_ERROR, "Bad (empty) address!");
-    return (0);
+    return (NULL);
   }
 
  /*
-  * Initialize the socket address to the defaults...
+  * Grab a hostname and port number; if there is no colon and the port name
+  * is only digits, then we have a port number by itself...
   */
 
-  memset(address, 0, sizeof(http_addr_t));
+  strlcpy(buffer, value, sizeof(buffer));
 
-#ifdef AF_INET6
-  if (deffamily == AF_INET6)
+  if ((portname = strrchr(buffer, ':')) != NULL && !strchr(portname, ']'))
   {
-    address->ipv6.sin6_family            = AF_INET6;
-    address->ipv6.sin6_addr.s6_addr32[0] = htonl(defaddress);
-    address->ipv6.sin6_addr.s6_addr32[1] = htonl(defaddress);
-    address->ipv6.sin6_addr.s6_addr32[2] = htonl(defaddress);
-    address->ipv6.sin6_addr.s6_addr32[3] = htonl(defaddress);
-    address->ipv6.sin6_port              = htons(defport);
+    *portname++ = '\0';
+    hostname = buffer;
   }
   else
-#endif /* AF_INET6 */
   {
-    address->ipv4.sin_family      = AF_INET;
-    address->ipv4.sin_addr.s_addr = htonl(defaddress);
-    address->ipv4.sin_port        = htons(defport);
-  }
-
-#ifdef AF_LOCAL
- /*
-  * If the address starts with a "/", it is a domain socket...
-  */
+    for (portname = buffer; isdigit(*portname & 255); portname ++);
 
-  if (*value == '/')
-  {
-    if (strlen(value) >= sizeof(address->un.sun_path))
+    if (*portname)
     {
-      cupsdLogMessage(CUPSD_LOG_ERROR, "Domain socket name \"%s\" too long!",
-                      value);
-      return (0);
-    }
-
-    address->un.sun_family = AF_LOCAL;
-    strcpy(address->un.sun_path, value);
-
-    return (1);
-  }
-#endif /* AF_LOCAL */
-
- /*
-  * Try to grab a hostname and port number...
-  */
-
-  strlcpy(hostname, value, sizeof(hostname));
-
-  if ((ptr = strrchr(hostname, ':')) != NULL)
-  {
-   /*
-    * Copy hostname and port separately...
-    */
-
-    *ptr++ = '\0';
+     /*
+      * Use the default port...
+      */
 
-    strlcpy(portname, ptr, sizeof(portname));
-  }
-  else if (isdigit(value[0] & 255))
-  {
-   /*
-    * Port number...
-    */
+      sprintf(defpname, "%d", defport);
+      portname = defpname;
+      hostname = buffer;
+    }
+    else
+    {
+     /*
+      * The buffer contains just a port number...
+      */
 
-    hostname[0] = '\0';
-    strlcpy(portname, value, sizeof(portname));
+      portname = buffer;
+      hostname = NULL;
+    }
   }
-  else
-  {
-   /*
-    * Hostname by itself...
-    */
 
-    portname[0] = '\0';
-  }
+  if (hostname && !strcmp(hostname, "*"))
+    hostname = NULL;
 
  /*
-  * Decode the hostname and port number as needed...
+  * Now lookup the address using httpAddrGetList()...
   */
 
-  if (hostname[0] && strcmp(hostname, "*"))
-  {
-    if ((host = httpGetHostByName(hostname)) == NULL)
-    {
-      cupsdLogMessage(CUPSD_LOG_ERROR, "httpGetHostByName(\"%s\") failed - %s!",
-                      hostname, hstrerror(h_errno));
-      return (0);
-    }
-
-    httpAddrLoad(host, defport, 0, address);
-  }
-
-  if (portname[0] != '\0')
-  {
-    if (isdigit(portname[0] & 255))
-    {
-#ifdef AF_INET6
-      if (address->addr.sa_family == AF_INET6)
-        address->ipv6.sin6_port = htons(atoi(portname));
-      else
-#endif /* AF_INET6 */
-      address->ipv4.sin_port = htons(atoi(portname));
-    }
-    else
-    {
-      if ((port = getservbyname(portname, NULL)) == NULL)
-      {
-        cupsdLogMessage(CUPSD_LOG_ERROR, "getservbyname(\"%s\") failed - %s!",
-	                portname, strerror(errno));
-        return (0);
-      }
-      else
-      {
-#ifdef AF_INET6
-	if (address->addr.sa_family == AF_INET6)
-          address->ipv6.sin6_port = htons(port->s_port);
-	else
-#endif /* AF_INET6 */
-	address->ipv4.sin_port = htons(port->s_port);
-      }
-    }
-  }
+  if ((addrlist = httpAddrGetList(hostname, AF_UNSPEC, portname)) == NULL)
+    cupsdLogMessage(CUPSD_LOG_ERROR, "Hostname lookup for \"%s\" failed!",
+                    hostname ? hostname : "(nil)");
 
-  return (1);
+  return (addrlist);
 }
 
 
@@ -1191,18 +1119,33 @@
                   unsigned   *ip,	/* O - Address value */
 		  unsigned   *mask)	/* O - Mask value */
 {
-  int		i,			/* Looping var */
+  int		i, j,			/* Looping vars */
 		family,			/* Address family */
 		ipcount;		/* Count of fields in address */
+  unsigned	ipval;			/* Value */
   const char	*maskval,		/* Pointer to start of mask value */
-		*ptr;			/* Pointer into value */
-  static unsigned netmasks[4][4] =	/* Standard netmasks... */
+		*ptr,			/* Pointer into value */
+		*ptr2;			/* ... */
+  static unsigned netmasks[4][4] =	/* Standard IPv4 netmasks... */
   {
+    { 0xffffffff, 0xffffffff, 0xffffffff, 0xff000000 },
+    { 0xffffffff, 0xffffffff, 0xffffffff, 0xffff0000 },
+    { 0xffffffff, 0xffffffff, 0xffffffff, 0xffffff00 },
+    { 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff }
+  };
+#ifdef AF_INET6
+  static unsigned netmasks6[8][4] =	/* Standard IPv6 netmasks... */
+  {
+    { 0xffff0000, 0x00000000, 0x00000000, 0x00000000 },
     { 0xffffffff, 0x00000000, 0x00000000, 0x00000000 },
+    { 0xffffffff, 0xffff0000, 0x00000000, 0x00000000 },
     { 0xffffffff, 0xffffffff, 0x00000000, 0x00000000 },
+    { 0xffffffff, 0xffffffff, 0xffff0000, 0x00000000 },
     { 0xffffffff, 0xffffffff, 0xffffffff, 0x00000000 },
+    { 0xffffffff, 0xffffffff, 0xffffffff, 0xffff0000 },
     { 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff }
   };
+#endif /* AF_INET6 */
 
 
  /*
@@ -1229,16 +1172,34 @@
 
     family  = AF_INET6;
 
-    for (i = 0, ptr = value + 1; *ptr && i < 4; i ++)
+    for (i = 0, ptr = value + 1; *ptr && i < 8; i ++)
     {
       if (*ptr == ']')
         break;
-      else if (*ptr == ':')
-        ip[i] = 0;
+      else if (!strncmp(ptr, "::", 2))
+      {
+        for (ptr2 = strchr(ptr + 2, ':'), j = 0;
+	     ptr2;
+	     ptr2 = strchr(ptr2 + 1, ':'), j ++);
+
+        i = 7 - j;
+      }
+      else if (isxdigit(*ptr & 255))
+      {
+        ipval = strtoul(ptr, (char **)&ptr, 16);
+
+	if (ipval > 0xffff)
+	  return (0);
+
+        if (i & 1)
+          ip[i] |= ipval;
+	else
+          ip[i] |= ipval << 16;
+      }
       else
-        ip[i] = strtoul(ptr, (char **)&ptr, 16);
+        return (0);
 
-      if (*ptr == ':' || *ptr == ']')
+      while (*ptr == ':')
         ptr ++;
     }
 
@@ -1270,22 +1231,40 @@
     memset(mask, 0, sizeof(unsigned) * 4);
 
 #ifdef AF_INET6
-    if (maskval[1] == '[')
+    if (*maskval == '[')
     {
      /*
       * Get hexadecimal mask value...
       */
 
-      for (i = 0, ptr = maskval + 1; *ptr && i < 4; i ++)
+      for (i = 0, ptr = maskval + 1; *ptr && i < 8; i ++)
       {
 	if (*ptr == ']')
 	  break;
-	else if (*ptr == ':')
-          mask[i] = 0;
+	else if (!strncmp(ptr, "::", 2))
+	{
+          for (ptr2 = strchr(ptr + 2, ':'), j = 0;
+	       ptr2;
+	       ptr2 = strchr(ptr2 + 1, ':'), j ++);
+
+          i = 7 - j;
+	}
+	else if (isxdigit(*ptr & 255))
+	{
+          ipval = strtoul(ptr, (char **)&ptr, 16);
+
+	  if (ipval > 0xffff)
+	    return (0);
+
+          if (i & 1)
+            mask[i] |= ipval;
+	  else
+            mask[i] |= ipval << 16;
+	}
 	else
-          mask[i] = strtoul(ptr, (char **)&ptr, 16);
+          return (0);
 
-	if (*ptr == ':' || *ptr == ']')
+        while (*ptr == ':')
           ptr ++;
       }
 
@@ -1361,6 +1340,10 @@
       }
     }
   }
+#ifdef AF_INET6
+  else if (family == AF_INET6)
+    memcpy(mask, netmasks6[ipcount - 1], sizeof(unsigned) * 4);
+#endif /* AF_INET6 */
   else
     memcpy(mask, netmasks[ipcount - 1], sizeof(unsigned) * 4);
 
@@ -1583,16 +1566,40 @@
     {
       loc->type  = AUTH_NONE;
       loc->level = AUTH_ANON;
+
+      cupsdLogMessage(CUPSD_LOG_WARN,
+                      "\"AuthClass %s\" is deprecated; consider removing "
+		      "it from line %d.",
+	              value, linenum);
     }
     else if (!strcasecmp(value, "user"))
+    {
       loc->level = AUTH_USER;
+
+      cupsdLogMessage(CUPSD_LOG_WARN,
+                      "\"AuthClass %s\" is deprecated; consider using "
+		      "\"Require valid-user\" on line %d.",
+	              value, linenum);
+    }
     else if (!strcasecmp(value, "group"))
+    {
       loc->level = AUTH_GROUP;
+
+      cupsdLogMessage(CUPSD_LOG_WARN,
+                      "\"AuthClass %s\" is deprecated; consider using "
+		      "\"Require @groupname\" on line %d.",
+	              value, linenum);
+    }
     else if (!strcasecmp(value, "system"))
     {
       loc->level = AUTH_GROUP;
 
       cupsdAddName(loc, "@SYSTEM");
+
+      cupsdLogMessage(CUPSD_LOG_WARN,
+                      "\"AuthClass %s\" is deprecated; consider using "
+		      "\"Require @SYSTEM\" on line %d.",
+	              value, linenum);
     }
     else
     {
@@ -1603,7 +1610,14 @@
     }
   }
   else if (!strcasecmp(line, "AuthGroupName"))
+  {
     cupsdAddName(loc, value);
+
+    cupsdLogMessage(CUPSD_LOG_WARN,
+                    "\"AuthGroupName %s\" directive is deprecated; consider "
+		    "using \"Require @%s\" on line %d.",
+		    value, value, linenum);
+  }
   else if (!strcasecmp(line, "Require"))
   {
    /*
@@ -1710,11 +1724,12 @@
 			quote;		/* Quote character */
   int			valuelen;	/* Length of value */
   cupsd_var_t		*var;		/* Current variable */
+  http_addrlist_t	*addrlist,	/* Address list */
+			*addr;		/* Current address */
   unsigned		ip[4],		/* Address value */
 			mask[4];	/* Netmask value */
   cupsd_dirsvc_relay_t	*relay;		/* Relay data */
-  cupsd_dirsvc_poll_t	*poll;		/* Polling data */
-  http_addr_t		polladdr;	/* Polling address */
+  cupsd_dirsvc_poll_t	*pollp;		/* Polling data */
   cupsd_location_t	*location;	/* Browse location */
   cups_file_t		*incfile;	/* Include file */
   char			incname[1024];	/* Include filename */
@@ -1791,90 +1806,99 @@
         return (0);
       }
     }
-    else if (!strcasecmp(line, "Port") || !strcasecmp(line, "Listen"))
+    else if (!strcasecmp(line, "FaxRetryInterval"))
     {
-     /*
-      * Add a listening address to the list...
-      */
-
-      cupsd_listener_t	*lis;		/* New listeners array */
-
-
-      if (NumListeners == 0)
-        lis = malloc(sizeof(cupsd_listener_t));
+      if (value)
+      {
+        JobRetryInterval = atoi(value);
+	cupsdLogMessage(CUPSD_LOG_WARN,
+	                "FaxRetryInterval is deprecated; use "
+			"JobRetryInterval on line %d.", linenum);
+      }
       else
-        lis = realloc(Listeners, (NumListeners + 1) * sizeof(cupsd_listener_t));
-
-      if (!lis)
       {
-        cupsdLogMessage(CUPSD_LOG_ERROR,
-	                "Unable to allocate %s at line %d - %s.",
-	                line, linenum, strerror(errno));
-        continue;
+        cupsdLogMessage(CUPSD_LOG_ERROR, "Syntax error on line %d.", linenum);
+        return (0);
       }
-
-      Listeners = lis;
-      lis      += NumListeners;
-
-      memset(lis, 0, sizeof(cupsd_listener_t));
-
-#if defined(AF_INET6) && !defined(__OpenBSD__)
-      if (get_address(value, INADDR_ANY, IPP_PORT, AF_INET6, &(lis->address)))
-#else
-      if (get_address(value, INADDR_ANY, IPP_PORT, AF_INET, &(lis->address)))
-#endif /* AF_INET6  && !__OpenBSD__ */
+    }
+    else if (!strcasecmp(line, "FaxRetryLimit"))
+    {
+      if (value)
       {
-        httpAddrString(&(lis->address), temp, sizeof(temp));
-
-#ifdef AF_INET6
-        if (lis->address.addr.sa_family == AF_INET6)
-          cupsdLogMessage(CUPSD_LOG_INFO, "Listening to %s:%d (IPv6)", temp,
-                          ntohs(lis->address.ipv6.sin6_port));
-	else
-#endif /* AF_INET6 */
-#ifdef AF_LOCAL
-        if (lis->address.addr.sa_family == AF_LOCAL)
-          cupsdLogMessage(CUPSD_LOG_INFO, "Listening to %s (Domain)", temp);
-	else
-#endif /* AF_LOCAL */
-	  cupsdLogMessage(CUPSD_LOG_INFO, "Listening to %s:%d (IPv4)", temp,
-                          ntohs(lis->address.ipv4.sin_port));
-
-	NumListeners ++;
+        JobRetryLimit = atoi(value);
+	cupsdLogMessage(CUPSD_LOG_WARN,
+	                "FaxRetryLimit is deprecated; use "
+			"JobRetryLimit on line %d.", linenum);
       }
       else
-        cupsdLogMessage(CUPSD_LOG_ERROR, "Bad %s address %s at line %d.", line,
-	                value, linenum);
+      {
+        cupsdLogMessage(CUPSD_LOG_ERROR, "Syntax error on line %d.", linenum);
+        return (0);
+      }
     }
+    else if (!strcasecmp(line, "Port") || !strcasecmp(line, "Listen")
 #ifdef HAVE_SSL
-    else if (!strcasecmp(line, "SSLPort") || !strcasecmp(line, "SSLListen"))
+             || !strcasecmp(line, "SSLPort") || !strcasecmp(line, "SSLListen")
+#endif /* HAVE_SSL */
+	     )
     {
      /*
-      * Add a listening address to the list...
+      * Add listening address(es) to the list...
       */
 
       cupsd_listener_t	*lis;		/* New listeners array */
 
 
-      if (NumListeners == 0)
-        lis = malloc(sizeof(cupsd_listener_t));
-      else
-        lis = realloc(Listeners, (NumListeners + 1) * sizeof(cupsd_listener_t));
+     /*
+      * Get the address list...
+      */
 
-      if (!lis)
+      addrlist = get_address(value, IPP_PORT);
+
+      if (!addrlist)
       {
-        cupsdLogMessage(CUPSD_LOG_ERROR,
-	                "Unable to allocate %s at line %d - %s.",
-	                line, linenum, strerror(errno));
+        cupsdLogMessage(CUPSD_LOG_ERROR, "Bad %s address %s at line %d.", line,
+	                value, linenum);
         continue;
       }
 
-      Listeners = lis;
-      lis      += NumListeners;
+     /*
+      * Add each address...
+      */
 
-      if (get_address(value, INADDR_ANY, IPP_PORT, AF_INET, &(lis->address)))
+      for (addr = addrlist; addr; addr = addr->next)
       {
-        httpAddrString(&(lis->address), temp, sizeof(temp));
+       /*
+        * Allocate another listener...
+	*/
+
+	if (NumListeners == 0)
+          lis = malloc(sizeof(cupsd_listener_t));
+	else
+          lis = realloc(Listeners, (NumListeners + 1) * sizeof(cupsd_listener_t));
+
+	if (!lis)
+	{
+          cupsdLogMessage(CUPSD_LOG_ERROR,
+	                  "Unable to allocate %s at line %d - %s.",
+	                  line, linenum, strerror(errno));
+          break;
+	}
+
+	Listeners = lis;
+	lis      += NumListeners;
+
+       /*
+        * Copy the current address and log it...
+	*/
+
+	memset(lis, 0, sizeof(cupsd_listener_t));
+	memcpy(&(lis->address), &(addr->addr), sizeof(lis->address));
+
+#ifdef HAVE_SSL
+        if (!strcasecmp(line, "SSLPort") || !strcasecmp(line, "SSLListen"))
+          lis->encryption = HTTP_ENCRYPT_ALWAYS;
+#endif /* HAVE_SSL */
 
 #ifdef AF_INET6
         if (lis->address.addr.sa_family == AF_INET6)
@@ -1887,16 +1911,18 @@
           cupsdLogMessage(CUPSD_LOG_INFO, "Listening to %s (Domain)", temp);
 	else
 #endif /* AF_LOCAL */
-        cupsdLogMessage(CUPSD_LOG_INFO, "Listening to %s:%d (IPv4)", temp,
+	cupsdLogMessage(CUPSD_LOG_INFO, "Listening to %s:%d (IPv4)", temp,
                         ntohs(lis->address.ipv4.sin_port));
-        lis->encryption = HTTP_ENCRYPT_ALWAYS;
+
 	NumListeners ++;
       }
-      else
-        cupsdLogMessage(CUPSD_LOG_ERROR, "Bad %s address %s at line %d.", line,
-	                value, linenum);
+
+     /*
+      * Free the list...
+      */
+
+      httpAddrFreeList(addrlist);
     }
-#endif /* HAVE_SSL */
     else if (!strcasecmp(line, "BrowseAddress"))
     {
      /*
@@ -1947,21 +1973,32 @@
 
 	NumBrowsers ++;
       }
-      else if (get_address(value, INADDR_NONE, BrowsePort, AF_INET, &(dira->to)))
+      else if ((addrlist = get_address(value, BrowsePort)) != NULL)
       {
-        httpAddrString(&(dira->to), temp, sizeof(temp));
+       /*
+        * Only IPv4 addresses are supported...
+        */
 
-#ifdef AF_INET6
-        if (dira->to.addr.sa_family == AF_INET6)
-          cupsdLogMessage(CUPSD_LOG_INFO,
-	                  "Sending browsing info to %s:%d (IPv6)", temp,
-                          ntohs(dira->to.ipv6.sin6_port));
+	for (addr = addrlist; addr; addr = addr->next)
+	  if (addr->addr.addr.sa_family == AF_INET)
+	    break;	    
+
+	if (addr)
+	{
+	  memcpy(&(dira->to), &(addrlist->addr), sizeof(dira->to));
+	  httpAddrString(&(dira->to), temp, sizeof(temp));
+
+	  cupsdLogMessage(CUPSD_LOG_INFO,
+	                  "Sending browsing info to %s:%d (IPv4)",
+			  temp, ntohs(dira->to.ipv4.sin_port));
+  
+	  NumBrowsers ++;
+	}
 	else
-#endif /* AF_INET6 */
-        cupsdLogMessage(CUPSD_LOG_INFO, "Sending browsing info to %s:%d (IPv4)",
-	                temp, ntohs(dira->to.ipv4.sin_port));
+	  cupsdLogMessage(CUPSD_LOG_ERROR, "Bad BrowseAddress %s at line %d.",
+			  value, linenum);
 
-	NumBrowsers ++;
+	httpAddrFreeList(addrlist);
       }
       else
         cupsdLogMessage(CUPSD_LOG_ERROR, "Bad BrowseAddress %s at line %d.",
@@ -2268,33 +2305,45 @@
       * Get "to" address and port...
       */
 
-      if (get_address(value, INADDR_BROADCAST, BrowsePort, AF_INET, &(relay->to)))
+      if ((addrlist = get_address(value, BrowsePort)) != NULL)
       {
-        httpAddrString(&(relay->to), temp, sizeof(temp));
+       /*
+        * Only IPv4 addresses are supported...
+        */
 
-        if (relay->from.type == AUTH_IP)
-	  snprintf(temp2, sizeof(temp2), "%u.%u.%u.%u/%u.%u.%u.%u",
-		   relay->from.mask.ip.address[0],
-		   relay->from.mask.ip.address[1],
-		   relay->from.mask.ip.address[2],
-		   relay->from.mask.ip.address[3],
-		   relay->from.mask.ip.netmask[0],
-		   relay->from.mask.ip.netmask[1],
-		   relay->from.mask.ip.netmask[2],
-		   relay->from.mask.ip.netmask[3]);
-	else
-	  strlcpy(temp2, relay->from.mask.name.name, sizeof(temp2));
+	for (addr = addrlist; addr; addr = addr->next)
+	  if (addr->addr.addr.sa_family == AF_INET)
+	    break;	    
 
-#ifdef AF_INET6
-        if (relay->to.addr.sa_family == AF_INET6)
-          cupsdLogMessage(CUPSD_LOG_INFO, "Relaying from %s to %s:%d (IPv6)",
-	                  temp, temp2, ntohs(relay->to.ipv6.sin6_port));
+	if (addr)
+	{
+	  memcpy(&(relay->to), &(addrlist->addr), sizeof(relay->to));
+  
+	  httpAddrString(&(relay->to), temp, sizeof(temp));
+  
+	  if (relay->from.type == AUTH_IP)
+	    snprintf(temp2, sizeof(temp2), "%u.%u.%u.%u/%u.%u.%u.%u",
+		     relay->from.mask.ip.address[0],
+		     relay->from.mask.ip.address[1],
+		     relay->from.mask.ip.address[2],
+		     relay->from.mask.ip.address[3],
+		     relay->from.mask.ip.netmask[0],
+		     relay->from.mask.ip.netmask[1],
+		     relay->from.mask.ip.netmask[2],
+		     relay->from.mask.ip.netmask[3]);
+	  else
+	    strlcpy(temp2, relay->from.mask.name.name, sizeof(temp2));
+  
+	  cupsdLogMessage(CUPSD_LOG_INFO, "Relaying from %s to %s:%d (IPv4)",
+			  temp, temp2, ntohs(relay->to.ipv4.sin_port));
+  
+	  NumRelays ++;
+	}
 	else
-#endif /* AF_INET6 */
-        cupsdLogMessage(CUPSD_LOG_INFO, "Relaying from %s to %s:%d (IPv4)",
-	                temp, temp2, ntohs(relay->to.ipv4.sin_port));
+	  cupsdLogMessage(CUPSD_LOG_ERROR, "Bad relay address %s at line %d.",
+	                  value, linenum);
 
-	NumRelays ++;
+	httpAddrFreeList(addrlist);
       }
       else
       {
@@ -2311,12 +2360,43 @@
       * BrowsePoll address[:port]
       */
 
+      char		*portname;	/* Port name */
+      int		portnum;	/* Port number */
+      struct servent	*service;	/* Service */
+
+
+     /*
+      * Extract the port name from the address...
+      */
+
+      if ((portname = strrchr(value, ':')) != NULL && !strchr(portname, ']'))
+      {
+        *portname++ = '\0';
+
+        if (isdigit(*portname & 255))
+	  portnum = atoi(portname);
+	else if ((service = getservbyname(portname, NULL)) != NULL)
+	  portnum = ntohs(service->s_port);
+	else
+	{
+	  cupsdLogMessage(CUPSD_LOG_ERROR, "Lookup of service \"%s\" failed!",
+	                  portname);
+          continue;
+	}
+      }
+      else
+        portnum = ippPort();
+
+     /*
+      * Add the poll entry...
+      */
+
       if (NumPolled == 0)
-        poll = malloc(sizeof(cupsd_dirsvc_poll_t));
+        pollp = malloc(sizeof(cupsd_dirsvc_poll_t));
       else
-        poll = realloc(Polled, (NumPolled + 1) * sizeof(cupsd_dirsvc_poll_t));
+        pollp = realloc(Polled, (NumPolled + 1) * sizeof(cupsd_dirsvc_poll_t));
 
-      if (!poll)
+      if (!pollp)
       {
         cupsdLogMessage(CUPSD_LOG_ERROR,
 	                "Unable to allocate BrowsePoll at line %d - %s.",
@@ -2324,33 +2404,17 @@
         continue;
       }
 
-      Polled = poll;
-      poll   += NumPolled;
-
-     /*
-      * Get poll address and port...
-      */
-
-      if (get_address(value, INADDR_NONE, ippPort(), AF_INET, &polladdr))
-      {
-	NumPolled ++;
-	memset(poll, 0, sizeof(cupsd_dirsvc_poll_t));
+      Polled = pollp;
+      pollp   += NumPolled;
 
-        httpAddrString(&polladdr, poll->hostname, sizeof(poll->hostname));
+      NumPolled ++;
+      memset(pollp, 0, sizeof(cupsd_dirsvc_poll_t));
 
-#ifdef AF_INET6
-        if (polladdr.addr.sa_family == AF_INET6)
-          poll->port = ntohs(polladdr.ipv6.sin6_port);
-	else
-#endif /* AF_INET6 */
-        poll->port = ntohs(polladdr.ipv4.sin_port);
+      strlcpy(pollp->hostname, value, sizeof(pollp->hostname));
+      pollp->port = portnum;
 
-        cupsdLogMessage(CUPSD_LOG_INFO, "Polling %s:%d", poll->hostname,
-	                poll->port);
-      }
-      else
-        cupsdLogMessage(CUPSD_LOG_ERROR, "Bad poll address %s at line %d.",
-	                value, linenum);
+      cupsdLogMessage(CUPSD_LOG_INFO, "Polling %s:%d", pollp->hostname,
+	              pollp->port);
     }
     else if (!strcasecmp(line, "DefaultAuthType"))
     {
@@ -2378,22 +2442,46 @@
       * User ID to run as...
       */
 
-      if (isdigit(value[0]))
-        User = atoi(value);
-      else
+      if (value && isdigit(value[0] & 255))
+      {
+        int uid = atoi(value);
+
+	if (!uid)
+	  cupsdLogMessage(CUPSD_LOG_ERROR,
+	                  "Will not use User 0 as specified on line %d "
+			  "for security reasons.  You must use a non-"
+			  "privileged account instead.",
+	                  linenum);
+        else
+	  User = atoi(value);
+      }
+      else if (value)
       {
         struct passwd *p;	/* Password information */
 
         endpwent();
 	p = getpwnam(value);
 
-	if (p != NULL)
-	  User = p->pw_uid;
+	if (p)
+	{
+	  if (!p->pw_uid)
+	    cupsdLogMessage(CUPSD_LOG_ERROR,
+	                    "Will not use User %s (UID=0) as specified on line "
+			    "%d for security reasons.  You must use a non-"
+			    "privileged account instead.",
+	                    value, linenum);
+	  else
+	    User = p->pw_uid;
+	}
 	else
 	  cupsdLogMessage(CUPSD_LOG_ERROR,
 	                  "Unknown User \"%s\" on line %d, ignoring!",
 	                  value, linenum);
       }
+      else
+	cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "User directive on line %d missing the username!",
+	                linenum);
     }
     else if (!strcasecmp(line, "Group"))
     {
@@ -2939,96 +3027,6 @@
 }
 
 
-#ifdef HAVE_CDSASSL
 /*
- * 'CDSAGetServerCerts()' - Convert a keychain name into the CFArrayRef
- *                          required by SSLSetCertificate.
- *
- * For now we assumes that there is exactly one SecIdentity in the
- * keychain - i.e. there is exactly one matching cert/private key pair.
- * In the future we will search a keychain for a SecIdentity matching a
- * specific criteria.  We also skip the operation of adding additional
- * non-signing certs from the keychain to the CFArrayRef.
- *
- * To create a self-signed certificate for testing use the certtool.
- * Executing the following as root will do it:
- *
- *     certtool c c v k=CUPS
- */
-
-CFArrayRef
-CDSAGetServerCerts(void)
-{
-  OSStatus		err;		/* Error info */
-  SecKeychainRef 	kcRef;		/* Keychain reference */
-  SecIdentitySearchRef	srchRef;	/* Search reference */
-  SecIdentityRef	identity;	/* Identity */
-  CFArrayRef		ca;		/* Certificate array */
-
-
-  kcRef    = NULL;
-  srchRef  = NULL;
-  identity = NULL;
-  ca       = NULL;
-  err      = SecKeychainOpen(ServerCertificate, &kcRef);
-
-  if (err)
-    cupsdLogMessage(CUPSD_LOG_ERROR, "Cannot open keychain \"%s\", error %d.",
-                    ServerCertificate, err);
-  else
-  {
-   /*
-    * Search for "any" identity matching specified key use; 
-    * in this app, we expect there to be exactly one. 
-    */
-
-    err = SecIdentitySearchCreate(kcRef, CSSM_KEYUSE_SIGN, &srchRef);
-
-    if (err)
-      cupsdLogMessage(CUPSD_LOG_ERROR,
-                      "Cannot find signing key in keychain \"%s\", error %d",
-                      ServerCertificate, err);
-    else
-    {
-      err = SecIdentitySearchCopyNext(srchRef, &identity);
-
-      if (err)
-	cupsdLogMessage(CUPSD_LOG_ERROR,
-	                "Cannot find signing key in keychain \"%s\", error %d",
-	                ServerCertificate, err);
-      else
-      {
-	if (CFGetTypeID(identity) != SecIdentityGetTypeID())
-	  cupsdLogMessage(CUPSD_LOG_ERROR,
-	                  "SecIdentitySearchCopyNext CFTypeID failure!");
-	else
-	{
-	 /* 
-	  * Found one. Place it in a CFArray. 
-	  * TBD: snag other (non-identity) certs from keychain and add them
-	  * to array as well.
-	  */
-
-	  ca = CFArrayCreate(NULL, (const void **)&identity, 1, NULL);
-
-	  if (ca == nil)
-	    cupsdLogMessage(CUPSD_LOG_ERROR, "CFArrayCreate error");
-	}
-
-	/*CFRelease(identity);*/
-      }
-
-      /*CFRelease(srchRef);*/
-    }
-
-    /*CFRelease(kcRef);*/
-  }
-
-  return ca;
-}
-#endif /* HAVE_CDSASSL */
-
-
-/*
- * End of "$Id: conf.c 4733 2005-10-01 00:34:49Z mike $".
+ * End of "$Id: conf.c 4830 2005-11-12 03:27:16Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/cups-driverd.c cupsys-1.1.99.b1.r4748/scheduler/cups-driverd.c
--- cupsys-1.1.99.b1.r4748~/scheduler/cups-driverd.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/cups-driverd.c	2005-10-26 03:23:10.577577000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: cups-driverd.c 4690 2005-09-22 19:05:31Z mike $"
+ * "$Id: cups-driverd.c 4812 2005-10-25 18:23:10Z mike $"
  *
  *   PPD/driver support for the Common UNIX Printing System (CUPS).
  *
@@ -997,7 +997,8 @@
 
   if ((dir = cupsDirOpen(drivers)) == NULL)
   {
-    fprintf(stderr, "ERROR: [cups-driverd] Unable to open driver directory \"%s\": %s",
+    fprintf(stderr, "ERROR: [cups-driverd] Unable to open driver directory "
+                    "\"%s\": %s\n",
             drivers, strerror(errno));
     return (0);
   }
@@ -1075,5 +1076,5 @@
 
 
 /*
- * End of "$Id: cups-driverd.c 4690 2005-09-22 19:05:31Z mike $".
+ * End of "$Id: cups-driverd.c 4812 2005-10-25 18:23:10Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/cups-lpd.c cupsys-1.1.99.b1.r4748/scheduler/cups-lpd.c
--- cupsys-1.1.99.b1.r4748~/scheduler/cups-lpd.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/cups-lpd.c	2005-10-22 04:17:52.778582000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: cups-lpd.c 4730 2005-09-30 21:45:34Z mike $"
+ * "$Id: cups-lpd.c 4807 2005-10-21 19:17:52Z mike $"
  *
  *   Line Printer Daemon interface for the Common UNIX Printing System (CUPS).
  *
@@ -103,7 +103,7 @@
 		*list,			/* Pointer to list */
 		*agent,			/* Pointer to user */
 		status;			/* Status for client */
-  int		hostlen;		/* Size of client address */
+  socklen_t	hostlen;		/* Size of client address */
   http_addr_t	hostaddr;		/* Address of client */
   char		hostname[256],		/* Name of client */
 		hostip[256],		/* IP address */
@@ -324,7 +324,8 @@
   request->request.op.operation_id = IPP_GET_PRINTER_ATTRIBUTES;
   request->request.op.request_id   = 1;
 
-  snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", name);
+  httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                   "/printers/%s", name);
 
   language = cupsLangDefault();
 
@@ -427,7 +428,8 @@
   request->request.op.operation_id = IPP_PRINT_JOB;
   request->request.op.request_id   = 1;
 
-  snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", name);
+  httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                   "/printers/%s", name);
 
   language = cupsLangDefault();
 
@@ -1137,7 +1139,8 @@
   ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
                "attributes-natural-language", NULL, language->language);
 
-  snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", queue);
+  httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                   "/printers/%s", queue);
   ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI,
                "printer-uri", NULL, uri);
 
@@ -1211,7 +1214,8 @@
   ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
                "attributes-natural-language", NULL, language->language);
 
-  snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", queue);
+  httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                   "/printers/%s", queue);
 
   ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri",
                NULL, uri);
@@ -1433,5 +1437,5 @@
 
 
 /*
- * End of "$Id: cups-lpd.c 4730 2005-09-30 21:45:34Z mike $".
+ * End of "$Id: cups-lpd.c 4807 2005-10-21 19:17:52Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/cupsd.dsp cupsys-1.1.99.b1.r4748/scheduler/cupsd.dsp
--- cupsys-1.1.99.b1.r4748~/scheduler/cupsd.dsp	2001-05-14 03:38:42.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/cupsd.dsp	1970-01-01 09:00:00.000000000 +0900
@@ -1,173 +0,0 @@
-# Microsoft Developer Studio Project File - Name="cupsd" - Package Owner=<4>
-# Microsoft Developer Studio Generated Build File, Format Version 6.00
-# ** DO NOT EDIT **
-
-# TARGTYPE "Win32 (x86) Application" 0x0101
-
-CFG=cupsd - Win32 Debug
-!MESSAGE This is not a valid makefile. To build this project using NMAKE,
-!MESSAGE use the Export Makefile command and run
-!MESSAGE 
-!MESSAGE NMAKE /f "cupsd.mak".
-!MESSAGE 
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f "cupsd.mak" CFG="cupsd - Win32 Debug"
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE "cupsd - Win32 Release" (based on "Win32 (x86) Application")
-!MESSAGE "cupsd - Win32 Debug" (based on "Win32 (x86) Application")
-!MESSAGE 
-
-# Begin Project
-# PROP AllowPerConfigDependencies 0
-# PROP Scc_ProjName ""
-# PROP Scc_LocalPath ""
-CPP=cl.exe
-MTL=midl.exe
-RSC=rc.exe
-
-!IF  "$(CFG)" == "cupsd - Win32 Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "Release"
-# PROP BASE Intermediate_Dir "Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Release"
-# PROP Intermediate_Dir "Release"
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /YX /FD /c
-# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /YX /FD /c
-# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
-# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
-# ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /machine:I386
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /machine:I386
-
-!ELSEIF  "$(CFG)" == "cupsd - Win32 Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "Debug"
-# PROP BASE Intermediate_Dir "Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Debug"
-# PROP Intermediate_Dir "Debug"
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /YX /FD /GZ /c
-# ADD CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /I "../visualc" /I ".." /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /YX /FD /GZ /c
-# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
-# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
-# ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /debug /machine:I386 /pdbtype:sept
-
-!ENDIF 
-
-# Begin Target
-
-# Name "cupsd - Win32 Release"
-# Name "cupsd - Win32 Debug"
-# Begin Group "Source Files"
-
-# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-# Begin Source File
-
-SOURCE=.\auth.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\classes.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\client.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\conf.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\dirsvc.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\ipp.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\job.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\listen.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\log.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\main.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\printers.c
-# End Source File
-# End Group
-# Begin Group "Header Files"
-
-# PROP Default_Filter "h;hpp;hxx;hm;inl"
-# Begin Source File
-
-SOURCE=.\auth.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\classes.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\client.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\conf.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\cupsd.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\dirsvc.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\job.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\printers.h
-# End Source File
-# End Group
-# End Target
-# End Project
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/dirsvc.c cupsys-1.1.99.b1.r4748/scheduler/dirsvc.c
--- cupsys-1.1.99.b1.r4748~/scheduler/dirsvc.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/dirsvc.c	2005-11-08 11:05:59.483675000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: dirsvc.c 4744 2005-10-03 01:32:35Z mike $"
+ * "$Id: dirsvc.c 4825 2005-11-08 02:05:59Z mike $"
  *
  *   Directory services routines for the Common UNIX Printing System (CUPS).
  *
@@ -23,23 +23,31 @@
  *
  * Contents:
  *
- *   cupsdProcessBrowseData() - Process new browse data.
- *   cupsdSendBrowseDelete()  - Send a "browse delete" message for a printer.
- *   cupsdSendBrowseList()    - Send new browsing information as necessary.
- *   cupsdSendCUPSBrowse()    - Send new browsing information using the CUPS protocol.
- *   cupsdStartBrowsing()     - Start sending and receiving broadcast information.
- *   cupsdStartPolling()      - Start polling servers as needed.
- *   cupsdStopBrowsing()      - Stop sending and receiving broadcast information.
- *   cupsdStopPolling()       - Stop polling servers as needed.
- *   cupsdUpdateCUPSBrowse()  - Update the browse lists using the CUPS protocol.
- *   cupsdUpdatePolling()     - Read status messages from the poll daemons.
- *   slp_reg_callback()       - Empty SLPRegReport.
- *   cupsdSendSLPBrowse()     - Register the specified printer with SLP.
- *   slp_dereg_printer()      - SLPDereg() the specified printer
- *   slp_get_attr()           - Get an attribute from an SLP registration.
- *   slp_attr_callback()      - SLP attribute callback 
- *   slp_url_callback()       - SLP service url callback
- *   cupsdUpdateSLPBrowse()   - Get browsing information via SLP.
+ *   cupsdLoadRemoteCache()        - Load the remote printer cache.
+ *   cupsdProcessBrowseData()      - Process new browse data.
+ *   cupsdProcessImplicitClasses() - Create/update implicit classes as needed.
+ *   cupsdSaveRemoteCache()        - Save the remote printer cache.
+ *   cupsdSendBrowseDelete()       - Send a "browse delete" message for a
+ *                                   printer.
+ *   cupsdSendBrowseList()         - Send new browsing information as necessary.
+ *   cupsdSendCUPSBrowse()         - Send new browsing information using the
+ *                                   CUPS protocol.
+ *   cupsdSendSLPBrowse()          - Register the specified printer with SLP.
+ *   cupsdStartBrowsing()          - Start sending and receiving broadcast
+ *                                   information.
+ *   cupsdStartPolling()           - Start polling servers as needed.
+ *   cupsdStopBrowsing()           - Stop sending and receiving broadcast
+ *                                   information.
+ *   cupsdStopPolling()            - Stop polling servers as needed.
+ *   cupsdUpdateCUPSBrowse()       - Update the browse lists using the CUPS
+ *                                   protocol.
+ *   cupsdUpdatePolling()          - Read status messages from the poll daemons.
+ *   cupsdUpdateSLPBrowse()        - Get browsing information via SLP.
+ *   slp_attr_callback()           - SLP attribute callback 
+ *   slp_dereg_printer()           - SLPDereg() the specified printer
+ *   slp_get_attr()                - Get an attribute from an SLP registration.
+ *   slp_reg_callback()            - Empty SLPRegReport.
+ *   slp_url_callback()            - SLP service url callback
  */
 
 /*
@@ -50,25 +58,386 @@
 #include <grp.h>
 
 
-#ifdef HAVE_LIBSLP
-static void	slp_dereg_printer(cupsd_printer_t *p);
+/*
+ * SLP definitions...
+ */
+
+#ifdef HAVE_LIBSLP 
+/*
+ * SLP service name for CUPS...
+ */
+
+#  define SLP_CUPS_SRVTYPE	"service:printer"
+#  define SLP_CUPS_SRVLEN	15
+
+
+/* 
+ * Printer service URL structure
+ */
+
+typedef struct _slpsrvurl_s		/**** SLP URL list ****/
+{
+  struct _slpsrvurl_s	*next;		/* Next URL in list */
+  char			url[HTTP_MAX_URI];
+					/* URL */
+} slpsrvurl_t;
+
+
+/*
+ * Local functions...
+ */
+
+static SLPBoolean	slp_attr_callback(SLPHandle hslp, const char *attrlist,
+			                  SLPError errcode, void *cookie);
+static void		slp_dereg_printer(cupsd_printer_t *p);
+static int 		slp_get_attr(const char *attrlist, const char *tag,
+			             char **valbuf);
+static void		slp_reg_callback(SLPHandle hslp, SLPError errcode,
+					 void *cookie);
+static SLPBoolean	slp_url_callback(SLPHandle hslp, const char *srvurl,
+			                 unsigned short lifetime,
+			                 SLPError errcode, void *cookie);
 #endif /* HAVE_LIBSLP */
 
 
 /*
+ * 'cupsdLoadRemoteCache()' - Load the remote printer cache.
+ */
+
+void
+cupsdLoadRemoteCache(void)
+{
+  cups_file_t		*fp;		/* remote.cache file */
+  int			linenum;	/* Current line number */
+  char			line[1024],	/* Line from file */
+			*value,		/* Pointer to value */
+			*valueptr;	/* Pointer into value */
+  cupsd_printer_t	*p;		/* Current printer */
+  time_t		now;		/* Current time */
+
+
+ /*
+  * Open the remote.cache file...
+  */
+
+  snprintf(line, sizeof(line), "%s/remote.cache", CacheDir);
+  if ((fp = cupsFileOpen(line, "r")) == NULL)
+    return;
+
+ /*
+  * Read printer configurations until we hit EOF...
+  */
+
+  linenum = 0;
+  p       = NULL;
+  now     = time(NULL);
+
+  while (cupsFileGetConf(fp, line, sizeof(line), &value, &linenum))
+  {
+   /*
+    * Decode the directive...
+    */
+
+    if (!strcasecmp(line, "<Printer") ||
+        !strcasecmp(line, "<DefaultPrinter"))
+    {
+     /*
+      * <Printer name> or <DefaultPrinter name>
+      */
+
+      if (p == NULL && value)
+      {
+       /*
+        * Add the printer and a base file type...
+	*/
+
+        cupsdLogMessage(CUPSD_LOG_DEBUG,
+	                "cupsdLoadRemoteCache: Loading printer %s...", value);
+
+        p = cupsdAddPrinter(value);
+	p->accepting   = 1;
+	p->state       = IPP_PRINTER_IDLE;
+	p->type        |= CUPS_PRINTER_REMOTE;
+	p->browse_time = now + BrowseTimeout;
+
+       /*
+        * Set the default printer as needed...
+	*/
+
+        if (!strcasecmp(line, "<DefaultPrinter"))
+	  DefaultPrinter = p;
+      }
+      else
+      {
+        cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
+        return;
+      }
+    }
+    else if (!strcasecmp(line, "<Class") ||
+             !strcasecmp(line, "<DefaultClass"))
+    {
+     /*
+      * <Class name> or <DefaultClass name>
+      */
+
+      if (p == NULL && value)
+      {
+       /*
+        * Add the printer and a base file type...
+	*/
+
+        cupsdLogMessage(CUPSD_LOG_DEBUG,
+	                "cupsdLoadRemoteCache: Loading class %s...", value);
+
+        p = cupsdAddClass(value);
+	p->accepting   = 1;
+	p->state       = IPP_PRINTER_IDLE;
+	p->type        |= CUPS_PRINTER_REMOTE;
+	p->browse_time = now + BrowseTimeout;
+
+       /*
+        * Set the default printer as needed...
+	*/
+
+        if (!strcasecmp(line, "<DefaultClass"))
+	  DefaultPrinter = p;
+      }
+      else
+      {
+        cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
+        return;
+      }
+    }
+    else if (!strcasecmp(line, "</Printer>") ||
+             !strcasecmp(line, "</Class>"))
+    {
+      if (p != NULL)
+      {
+       /*
+        * Close out the current printer...
+	*/
+
+        cupsdSetPrinterAttrs(p);
+
+        p = NULL;
+      }
+      else
+      {
+        cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
+        return;
+      }
+    }
+    else if (!p)
+    {
+      cupsdLogMessage(CUPSD_LOG_ERROR,
+                      "Syntax error on line %d of remote.cache.", linenum);
+      return;
+    }
+    else if (!strcasecmp(line, "Info"))
+    {
+      if (value)
+	cupsdSetString(&p->info, value);
+    }
+    else if (!strcasecmp(line, "MakeModel"))
+    {
+      if (value)
+	cupsdSetString(&p->make_model, value);
+    }
+    else if (!strcasecmp(line, "Location"))
+    {
+      if (value)
+	cupsdSetString(&p->location, value);
+    }
+    else if (!strcasecmp(line, "DeviceURI"))
+    {
+      if (value)
+	cupsdSetString(&p->device_uri, value);
+      else
+      {
+	cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
+	return;
+      }
+    }
+    else if (!strcasecmp(line, "State"))
+    {
+     /*
+      * Set the initial queue state...
+      */
+
+      if (value && !strcasecmp(value, "idle"))
+        p->state = IPP_PRINTER_IDLE;
+      else if (value && !strcasecmp(value, "stopped"))
+        p->state = IPP_PRINTER_STOPPED;
+      else
+      {
+	cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
+	return;
+      }
+    }
+    else if (!strcasecmp(line, "StateMessage"))
+    {
+     /*
+      * Set the initial queue state message...
+      */
+
+      if (value)
+	strlcpy(p->state_message, value, sizeof(p->state_message));
+    }
+    else if (!strcasecmp(line, "Accepting"))
+    {
+     /*
+      * Set the initial accepting state...
+      */
+
+      if (value &&
+          (!strcasecmp(value, "yes") ||
+           !strcasecmp(value, "on") ||
+           !strcasecmp(value, "true")))
+        p->accepting = 1;
+      else if (value &&
+               (!strcasecmp(value, "no") ||
+        	!strcasecmp(value, "off") ||
+        	!strcasecmp(value, "false")))
+        p->accepting = 0;
+      else
+      {
+	cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
+	return;
+      }
+    }
+    else if (!strcasecmp(line, "Type"))
+    {
+      if (value)
+        p->type = atoi(value);
+      else
+      {
+	cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
+	return;
+      }
+    }
+    else if (!strcasecmp(line, "BrowseTime"))
+    {
+      if (value)
+      {
+        time_t t = atoi(value);
+
+	if (t > (now + BrowseInterval))
+          p->browse_time = t;
+      }
+      else
+      {
+	cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
+	return;
+      }
+    }
+    else if (!strcasecmp(line, "JobSheets"))
+    {
+     /*
+      * Set the initial job sheets...
+      */
+
+      if (value)
+      {
+	for (valueptr = value; *valueptr && !isspace(*valueptr & 255); valueptr ++);
+
+	if (*valueptr)
+          *valueptr++ = '\0';
+
+	cupsdSetString(&p->job_sheets[0], value);
+
+	while (isspace(*valueptr & 255))
+          valueptr ++;
+
+	if (*valueptr)
+	{
+          for (value = valueptr; *valueptr && !isspace(*valueptr & 255); valueptr ++);
+
+	  if (*valueptr)
+            *valueptr++ = '\0';
+
+	  cupsdSetString(&p->job_sheets[1], value);
+	}
+      }
+      else
+      {
+	cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
+	return;
+      }
+    }
+    else if (!strcasecmp(line, "AllowUser"))
+    {
+      if (value)
+      {
+        p->deny_users = 0;
+        cupsdAddPrinterUser(p, value);
+      }
+      else
+      {
+	cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
+	return;
+      }
+    }
+    else if (!strcasecmp(line, "DenyUser"))
+    {
+      if (value)
+      {
+        p->deny_users = 1;
+        cupsdAddPrinterUser(p, value);
+      }
+      else
+      {
+	cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Syntax error on line %d of remote.cache.", linenum);
+	return;
+      }
+    }
+    else
+    {
+     /*
+      * Something else we don't understand...
+      */
+
+      cupsdLogMessage(CUPSD_LOG_ERROR,
+                      "Unknown configuration directive %s on line %d of remote.cache.",
+	              line, linenum);
+    }
+  }
+
+  cupsFileClose(fp);
+
+ /*
+  * Do auto-classing if needed...
+  */
+
+  cupsdProcessImplicitClasses();
+}
+
+
+/*
  * 'cupsdProcessBrowseData()' - Process new browse data.
  */
 
 void
 cupsdProcessBrowseData(
-    const char   *uri,			/* I - URI of printer/class */
-    cups_ptype_t type,			/* I - Printer type */
-    ipp_pstate_t state,			/* I - Printer state */
-    const char   *location,		/* I - Printer location */
-    const char   *info,			/* I - Printer information */
-    const char   *make_model)		/* I - Printer make and model */
+    const char    *uri,			/* I - URI of printer/class */
+    cups_ptype_t  type,			/* I - Printer type */
+    ipp_pstate_t  state,		/* I - Printer state */
+    const char    *location,		/* I - Printer location */
+    const char    *info,		/* I - Printer information */
+    const char    *make_model,		/* I - Printer make and model */
+    int		  num_attrs,		/* I - Number of attributes */
+    cups_option_t *attrs)		/* I - Attributes */
 {
-  int		i;			/* Looping var */
   int		update;			/* Update printer attributes? */
   char		finaluri[HTTP_MAX_URI],	/* Final URI for printer */
 		method[HTTP_MAX_URI],	/* Method portion of URI */
@@ -81,11 +450,8 @@
 		*sptr;			/* Pointer into ServerName */
   char		local_make_model[IPP_MAX_NAME];
 					/* Local make and model */
-  cupsd_printer_t *p,			/* Printer information */
-		*pclass,		/* Printer class */
-		*first;			/* First printer in class */
-  int		offset,			/* Offset of name */
-		len;			/* Length of name */
+  cupsd_printer_t *p;			/* Printer information */
+  const char	*ipp_options;		/* ipp-options value */
 
 
  /*
@@ -122,44 +488,45 @@
   * OK, this isn't a local printer; add any remote options...
   */
 
+  ipp_options = cupsGetOption("ipp-options", num_attrs, attrs);
+
   if (BrowseRemoteOptions)
   {
     if (BrowseRemoteOptions[0] == '?')
     {
      /*
-      * Override server-supplied URI...
+      * Override server-supplied options...
       */
 
-      char	tempuri[HTTP_MAX_URI];	/* Temporary URI */
-
-
-      if (strchr(uri, '?'))
-      {
-       /*
-        * Drop everything after ?...
-	*/
-
-        strlcpy(tempuri, uri, sizeof(tempuri));
-	*strchr(tempuri, '?') = '\0';
-
-        uri = tempuri;
-      }
-
+      snprintf(finaluri, sizeof(finaluri), "%s%s", uri, BrowseRemoteOptions);
+    }
+    else if (ipp_options)
+    {
      /*
-      * Combine stripped URI and remote options...
+      * Combine the server and local options...
       */
 
-      snprintf(finaluri, sizeof(finaluri), "%s%s", uri, BrowseRemoteOptions);
+      snprintf(finaluri, sizeof(finaluri), "%s?%s+%s", uri, ipp_options,
+               BrowseRemoteOptions);
     }
-    else if (strchr(uri, '?'))
-      snprintf(finaluri, sizeof(finaluri), "%s+%s", uri, BrowseRemoteOptions);
     else
+    {
+     /*
+      * Just use the local options...
+      */
+
       snprintf(finaluri, sizeof(finaluri), "%s?%s", uri, BrowseRemoteOptions);
+    }
 
+    uri = finaluri;
+  }
+  else if (ipp_options)
+  {
    /*
-    * Use the new URI instead of the old one...
+    * Just use the server-supplied options...
     */
 
+    snprintf(finaluri, sizeof(finaluri), "%s?%s", uri, ipp_options);
     uri = finaluri;
   }
 
@@ -495,156 +862,307 @@
   * Do auto-classing if needed...
   */
 
-  if (ImplicitClasses && Printers)
+  cupsdProcessImplicitClasses();
+}
+
+
+/*
+ * 'cupsdProcessImplicitClasses()' - Create/update implicit classes as needed.
+ */
+
+void
+cupsdProcessImplicitClasses(void)
+{
+  int		i;			/* Looping var */
+  int		update;			/* Update printer attributes? */
+  char		name[IPP_MAX_NAME],	/* Name of printer */
+		*hptr;			/* Pointer into hostname */
+  cupsd_printer_t *p,			/* Printer information */
+		*pclass,		/* Printer class */
+		*first;			/* First printer in class */
+  int		offset,			/* Offset of name */
+		len;			/* Length of name */
+
+
+  if (!ImplicitClasses || !Printers)
+    return;
+
+ /*
+  * Loop through all available printers and create classes as needed...
+  */
+
+  for (p = (cupsd_printer_t *)cupsArrayFirst(Printers), len = 0, offset = 0,
+           update = 0, pclass = NULL, first = NULL;
+       p != NULL;
+       p = (cupsd_printer_t *)cupsArrayNext(Printers))
   {
    /*
-    * Loop through all available printers and create classes as needed...
+    * Skip implicit classes...
     */
 
-    for (p = (cupsd_printer_t *)cupsArrayFirst(Printers), len = 0, offset = 0,
-             update = 0, pclass = NULL, first = NULL;
-         p != NULL;
-	 p = (cupsd_printer_t *)cupsArrayNext(Printers))
+    if (p->type & CUPS_PRINTER_IMPLICIT)
+    {
+      len = 0;
+      continue;
+    }
+
+   /*
+    * If len == 0, get the length of this printer name up to the "@"
+    * sign (if any).
+    */
+
+    cupsArraySave(Printers);
+
+    if (len > 0 &&
+	strncasecmp(p->name, name + offset, len) == 0 &&
+	(p->name[len] == '\0' || p->name[len] == '@'))
     {
      /*
-      * Skip implicit classes...
+      * We have more than one printer with the same name; see if
+      * we have a class, and if this printer is a member...
       */
 
-      if (p->type & CUPS_PRINTER_IMPLICIT)
+      if (pclass && strcasecmp(pclass->name, name))
       {
-        len = 0;
-        continue;
+	if (update)
+	  cupsdSetPrinterAttrs(pclass);
+
+	update = 0;
+	pclass = NULL;
+      }
+
+      if (!pclass && (pclass = cupsdFindDest(name)) == NULL)
+      {
+       /*
+	* Need to add the class...
+	*/
+
+	pclass = cupsdAddPrinter(name);
+	cupsArrayAdd(ImplicitPrinters, pclass);
+
+	pclass->type      |= CUPS_PRINTER_IMPLICIT;
+	pclass->accepting = 1;
+	pclass->state     = IPP_PRINTER_IDLE;
+
+        cupsdSetString(&pclass->location, p->location);
+        cupsdSetString(&pclass->info, p->info);
+
+        update = 1;
+
+        cupsdLogMessage(CUPSD_LOG_INFO, "Added implicit class \"%s\"...",
+	                name);
+      }
+
+      if (first != NULL)
+      {
+        for (i = 0; i < pclass->num_printers; i ++)
+	  if (pclass->printers[i] == first)
+	    break;
+
+        if (i >= pclass->num_printers)
+	{
+	  first->in_implicit_class = 1;
+	  cupsdAddPrinterToClass(pclass, first);
+        }
+
+	first = NULL;
       }
 
+      for (i = 0; i < pclass->num_printers; i ++)
+	if (pclass->printers[i] == p)
+	  break;
+
+      if (i >= pclass->num_printers)
+      {
+	p->in_implicit_class = 1;
+	cupsdAddPrinterToClass(pclass, p);
+	update = 1;
+      }
+    }
+    else
+    {
      /*
-      * If len == 0, get the length of this printer name up to the "@"
-      * sign (if any).
+      * First time around; just get name length and mark it as first
+      * in the list...
       */
 
-      cupsArraySave(Printers);
+      if ((hptr = strchr(p->name, '@')) != NULL)
+	len = hptr - p->name;
+      else
+	len = strlen(p->name);
 
-      if (len > 0 &&
-	  strncasecmp(p->name, name + offset, len) == 0 &&
-	  (p->name[len] == '\0' || p->name[len] == '@'))
+      strncpy(name, p->name, len);
+      name[len] = '\0';
+      offset    = 0;
+
+      if ((first = (hptr ? cupsdFindDest(name) : p)) != NULL &&
+	  !(first->type & CUPS_PRINTER_IMPLICIT))
       {
        /*
-	* We have more than one printer with the same name; see if
-	* we have a class, and if this printer is a member...
+	* Can't use same name as a local printer; add "Any" to the
+	* front of the name, unless we have explicitly disabled
+	* the "ImplicitAnyClasses"...
 	*/
 
-        if (pclass && strcasecmp(pclass->name, name))
+        if (ImplicitAnyClasses && len < (sizeof(name) - 4))
 	{
-	  if (update)
-	    cupsdSetPrinterAttrs(pclass);
+	 /*
+	  * Add "Any" to the class name...
+	  */
 
-	  update = 0;
-	  pclass = NULL;
+          strcpy(name, "Any");
+          strncpy(name + 3, p->name, len);
+	  name[len + 3] = '\0';
+	  offset        = 3;
 	}
-
-        if (!pclass && (pclass = cupsdFindDest(name)) == NULL)
+	else
 	{
 	 /*
-	  * Need to add the class...
+	  * Don't create an implicit class if we have a local printer
+	  * with the same name...
 	  */
 
-	  pclass = cupsdAddPrinter(name);
-	  pclass->type      |= CUPS_PRINTER_IMPLICIT;
-	  pclass->accepting = 1;
-	  pclass->state     = IPP_PRINTER_IDLE;
+	  len = 0;
+          cupsArrayRestore(Printers);
+	  continue;
+	}
+      }
 
-          cupsdSetString(&pclass->location, p->location);
-          cupsdSetString(&pclass->info, p->info);
+      first = p;
+    }
 
-          update = 1;
+    cupsArrayRestore(Printers);
+  }
 
-          cupsdLogMessage(CUPSD_LOG_INFO, "Added implicit class \"%s\"...",
-	                  name);
-	}
+ /*
+  * Update the last printer class as needed...
+  */
 
-        if (first != NULL)
-	{
-          for (i = 0; i < pclass->num_printers; i ++)
-	    if (pclass->printers[i] == first)
-	      break;
+  if (pclass && update)
+    cupsdSetPrinterAttrs(pclass);
+}
 
-          if (i >= pclass->num_printers)
-	    cupsdAddPrinterToClass(pclass, first);
 
-	  first = NULL;
-	}
+/*
+ * 'cupsdSaveRemoteCache()' - Save the remote printer cache.
+ */
 
-        for (i = 0; i < pclass->num_printers; i ++)
-	  if (pclass->printers[i] == p)
-	    break;
+void
+cupsdSaveRemoteCache(void)
+{
+  int			i;		/* Looping var */
+  cups_file_t		*fp;		/* printers.conf file */
+  char			temp[1024];	/* Temporary string */
+  cupsd_printer_t	*printer;	/* Current printer class */
+  time_t		curtime;	/* Current time */
+  struct tm		*curdate;	/* Current date */
 
-        if (i >= pclass->num_printers)
-	{
-	  cupsdAddPrinterToClass(pclass, p);
-	  update = 1;
-	}
-      }
-      else
-      {
-       /*
-        * First time around; just get name length and mark it as first
-	* in the list...
-	*/
 
-	if ((hptr = strchr(p->name, '@')) != NULL)
-	  len = hptr - p->name;
-	else
-	  len = strlen(p->name);
+ /*
+  * Create the remote.cache file...
+  */
 
-        strncpy(name, p->name, len);
-	name[len] = '\0';
-	offset    = 0;
+  snprintf(temp, sizeof(temp), "%s/remote.cache", CacheDir);
 
-	if ((first = (hptr ? cupsdFindDest(name) : p)) != NULL &&
-	    !(first->type & CUPS_PRINTER_IMPLICIT))
-	{
-	 /*
-	  * Can't use same name as a local printer; add "Any" to the
-	  * front of the name, unless we have explicitly disabled
-	  * the "ImplicitAnyClasses"...
-	  */
+  if ((fp = cupsFileOpen(temp, "w")) == NULL)
+  {
+    cupsdLogMessage(CUPSD_LOG_ERROR,
+                    "Unable to save remote.cache - %s", strerror(errno));
+    return;
+  }
+  else
+    cupsdLogMessage(CUPSD_LOG_INFO, "Saving remote.cache...");
 
-          if (ImplicitAnyClasses && len < (sizeof(name) - 4))
-	  {
-	   /*
-	    * Add "Any" to the class name...
-	    */
+ /*
+  * Restrict access to the file...
+  */
 
-            strcpy(name, "Any");
-            strncpy(name + 3, p->name, len);
-	    name[len + 3] = '\0';
-	    offset        = 3;
-	  }
-	  else
-	  {
-	   /*
-	    * Don't create an implicit class if we have a local printer
-	    * with the same name...
-	    */
+  fchown(cupsFileNumber(fp), getuid(), Group);
+  fchmod(cupsFileNumber(fp), ConfigFilePerm);
 
-	    len = 0;
-            cupsArrayRestore(Printers);
-	    continue;
-	  }
-	}
+ /*
+  * Write a small header to the file...
+  */
 
-	first = p;
-      }
+  curtime = time(NULL);
+  curdate = localtime(&curtime);
+  strftime(temp, sizeof(temp) - 1, "%Y-%m-%d %H:%M", curdate);
 
-      cupsArrayRestore(Printers);
-    }
+  cupsFilePuts(fp, "# Remote cache file for " CUPS_SVERSION "\n");
+  cupsFilePrintf(fp, "# Written by cupsd on %s\n", temp);
+
+ /*
+  * Write each local printer known to the system...
+  */
+
+  for (printer = (cupsd_printer_t *)cupsArrayFirst(Printers);
+       printer;
+       printer = (cupsd_printer_t *)cupsArrayNext(Printers))
+  {
+   /*
+    * Skip local destinations...
+    */
+
+    if (!(printer->type & CUPS_PRINTER_REMOTE))
+      continue;
 
    /*
-    * Update the last printer class as needed...
+    * Write printers as needed...
     */
 
-    if (pclass && update)
-      cupsdSetPrinterAttrs(pclass);
+    if (printer == DefaultPrinter)
+      cupsFilePuts(fp, "<Default");
+    else
+      cupsFilePutChar(fp, '<');
+
+    if (printer->type & CUPS_PRINTER_CLASS)
+      cupsFilePrintf(fp, "Class %s>\n", printer->name);
+    else
+      cupsFilePrintf(fp, "Printer %s>\n", printer->name);
+
+    cupsFilePrintf(fp, "Type %d\n", printer->type);
+
+    cupsFilePrintf(fp, "BrowseTime %d\n", (int)printer->browse_time);
+
+    if (printer->info)
+      cupsFilePrintf(fp, "Info %s\n", printer->info);
+
+    if (printer->make_model)
+      cupsFilePrintf(fp, "MakeModel %s\n", printer->make_model);
+
+    if (printer->location)
+      cupsFilePrintf(fp, "Location %s\n", printer->location);
+
+    if (printer->device_uri)
+      cupsFilePrintf(fp, "DeviceURI %s\n", printer->device_uri);
+
+    if (printer->state == IPP_PRINTER_STOPPED)
+    {
+      cupsFilePuts(fp, "State Stopped\n");
+      cupsFilePrintf(fp, "StateMessage %s\n", printer->state_message);
+    }
+    else
+      cupsFilePuts(fp, "State Idle\n");
+
+    if (printer->accepting)
+      cupsFilePuts(fp, "Accepting Yes\n");
+    else
+      cupsFilePuts(fp, "Accepting No\n");
+
+    cupsFilePrintf(fp, "JobSheets %s %s\n", printer->job_sheets[0],
+            printer->job_sheets[1]);
+
+    for (i = 0; i < printer->num_users; i ++)
+      cupsFilePrintf(fp, "%sUser %s\n", printer->deny_users ? "Deny" : "Allow",
+              printer->users[i]);
+
+    if (printer->type & CUPS_PRINTER_CLASS)
+      cupsFilePuts(fp, "</Class>\n");
+    else
+      cupsFilePuts(fp, "</Printer>\n");
   }
+
+  cupsFileClose(fp);
 }
 
 
@@ -806,7 +1324,9 @@
 	                "Remote destination \"%s\" has timed out; deleting it...",
 	                p->name);
 
+        cupsArraySave(Printers);
         cupsdDeletePrinter(p, 1);
+        cupsArrayRestore(Printers);
       }
     }
   }
@@ -825,6 +1345,7 @@
   cupsd_dirsvc_addr_t	*b;		/* Browse address */
   int			bytes;		/* Length of packet */
   char			packet[1453];	/* Browse data packet */
+  char			uri[1024];	/* Printer URI */
   char			options[1024];	/* Browse local options */
   cupsd_netif_t		*iface;		/* Network interface */
 
@@ -843,12 +1364,7 @@
   */
 
   if (BrowseLocalOptions)
-  {
-    if (BrowseLocalOptions[0] == '?')
-      strlcpy(options, BrowseLocalOptions, sizeof(options));
-    else
-      snprintf(options, sizeof(options), "?%s", BrowseLocalOptions);
-  }
+    snprintf(options, sizeof(options), " ipp-options=%s", BrowseLocalOptions);
   else
     options[0] = '\0';
 
@@ -874,18 +1390,22 @@
         for (iface = NetIFList; iface != NULL; iface = iface->next)
 	{
 	 /*
-	  * Only send to local interfaces...
+	  * Only send to local, IPv4 interfaces...
 	  */
 
-	  if (!iface->is_local || !iface->port)
+	  if (!iface->is_local || !iface->port ||
+	      iface->address.addr.sa_family != AF_INET)
 	    continue;
 
-	  snprintf(packet, sizeof(packet), "%x %x ipp://%s:%d/%s/%s%s \"%s\" \"%s\" \"%s\"\n",
-        	   type, p->state, iface->hostname, iface->port,
-		   (p->type & CUPS_PRINTER_CLASS) ? "classes" : "printers",
-		   p->name, options, p->location ? p->location : "",
+	  httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, iface->hostname,
+	                   iface->port,
+			   (p->type & CUPS_PRINTER_CLASS) ? "/classes/%s%s" :
+			                                    "/printers/%s",
+			   p->name);
+	  snprintf(packet, sizeof(packet), "%x %x %s \"%s\" \"%s\" \"%s\"%s\n",
+        	   type, p->state, uri, p->location ? p->location : "",
 		   p->info ? p->info : "",
-		   p->make_model ? p->make_model : "Unknown");
+		   p->make_model ? p->make_model : "Unknown", options);
 
 	  bytes = strlen(packet);
 
@@ -893,66 +1413,54 @@
 	                  "cupsdSendBrowseList: (%d bytes to \"%s\") %s", bytes,
         	          iface->name, packet);
 
-          if (iface->broadcast.addr.sa_family == AF_INET)
-	  {
-            iface->broadcast.ipv4.sin_port = htons(BrowsePort);
-
-	    sendto(BrowseSocket, packet, bytes, 0,
-		   (struct sockaddr *)&(iface->broadcast),
-		   sizeof(struct sockaddr_in));
-          }
-#ifdef AF_INET6
-	  else
-	  {
-            iface->broadcast.ipv6.sin6_port = htons(BrowsePort);
+          iface->broadcast.ipv4.sin_port = htons(BrowsePort);
 
-	    sendto(BrowseSocket, packet, bytes, 0,
-		   (struct sockaddr *)&(iface->broadcast),
-		   sizeof(struct sockaddr_in6));
-          }
-#endif /* AF_INET6 */
+	  sendto(BrowseSocket, packet, bytes, 0,
+		 (struct sockaddr *)&(iface->broadcast),
+		 sizeof(struct sockaddr_in));
         }
       }
       else if ((iface = cupsdNetIFFind(b->iface)) != NULL)
       {
        /*
-        * Send to the named interface...
+        * Send to the named interface using the IPv4 address...
 	*/
 
-        if (!iface->port)
-	  continue;
+        while (iface)
+	  if (strcasecmp(b->iface, iface->name))
+	  {
+	    iface = NULL;
+	    break;
+	  }
+	  else if (iface->address.addr.sa_family == AF_INET && iface->port)
+	    break;
+	  else
+	    iface = iface->next;
 
-	snprintf(packet, sizeof(packet), "%x %x ipp://%s:%d/%s/%s%s \"%s\" \"%s\" \"%s\"\n",
-        	 type, p->state, iface->hostname, iface->port,
-		 (p->type & CUPS_PRINTER_CLASS) ? "classes" : "printers",
-		 p->name, options, p->location ? p->location : "",
-		 p->info ? p->info : "",
-		 p->make_model ? p->make_model : "Unknown");
+        if (iface)
+	{
+	  httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, iface->hostname,
+	                   iface->port,
+			   (p->type & CUPS_PRINTER_CLASS) ? "/classes/%s%s" :
+			                                    "/printers/%s",
+			   p->name);
+	  snprintf(packet, sizeof(packet), "%x %x %s \"%s\" \"%s\" \"%s\"%s\n",
+        	   type, p->state, uri, p->location ? p->location : "",
+		   p->info ? p->info : "",
+		   p->make_model ? p->make_model : "Unknown", options);
 
-	bytes = strlen(packet);
+	  bytes = strlen(packet);
 
-	cupsdLogMessage(CUPSD_LOG_DEBUG2,
-	                "cupsdSendBrowseList: (%d bytes to \"%s\") %s", bytes,
-        	        iface->name, packet);
+	  cupsdLogMessage(CUPSD_LOG_DEBUG2,
+	                  "cupsdSendBrowseList: (%d bytes to \"%s\") %s", bytes,
+        	          iface->name, packet);
 
-        if (iface->broadcast.addr.sa_family == AF_INET)
-	{
           iface->broadcast.ipv4.sin_port = htons(BrowsePort);
 
 	  sendto(BrowseSocket, packet, bytes, 0,
 		 (struct sockaddr *)&(iface->broadcast),
 		 sizeof(struct sockaddr_in));
         }
-#ifdef AF_INET6
-	else
-	{
-          iface->broadcast.ipv6.sin6_port = htons(BrowsePort);
-
-	  sendto(BrowseSocket, packet, bytes, 0,
-		 (struct sockaddr *)&(iface->broadcast),
-		 sizeof(struct sockaddr_in6));
-        }
-#endif /* AF_INET6 */
       }
     }
     else
@@ -962,27 +1470,19 @@
       * the default server name...
       */
 
-      snprintf(packet, sizeof(packet), "%x %x %s%s \"%s\" \"%s\" \"%s\"\n",
-       	       type, p->state, p->uri, options,
+      snprintf(packet, sizeof(packet), "%x %x %s \"%s\" \"%s\" \"%s\"%s\n",
+       	       type, p->state, p->uri,
 	       p->location ? p->location : "",
 	       p->info ? p->info : "",
-	       p->make_model ? p->make_model : "Unknown");
+	       p->make_model ? p->make_model : "Unknown", options);
 
       bytes = strlen(packet);
       cupsdLogMessage(CUPSD_LOG_DEBUG2,
                       "cupsdSendBrowseList: (%d bytes) %s", bytes, packet);
 
-#ifdef AF_INET6
-      if (sendto(BrowseSocket, packet, bytes, 0,
-		 (struct sockaddr *)&(b->to),
-		 b->to.addr.sa_family == AF_INET ?
-		     sizeof(struct sockaddr_in) :
-		     sizeof(struct sockaddr_in6)) <= 0)
-#else
       if (sendto(BrowseSocket, packet, bytes, 0,
 		 (struct sockaddr *)&(b->to),
 		 sizeof(struct sockaddr_in)) <= 0)
-#endif /* AF_INET6 */
       {
        /*
         * Unable to send browse packet, so remove this address from the
@@ -1003,6 +1503,186 @@
 }
 
 
+#ifdef HAVE_LIBSLP
+/*
+ * 'cupsdSendSLPBrowse()' - Register the specified printer with SLP.
+ */
+
+void 
+cupsdSendSLPBrowse(cupsd_printer_t *p)	/* I - Printer to register */
+{
+  char		srvurl[HTTP_MAX_URI],	/* Printer service URI */
+		attrs[8192],		/* Printer attributes */
+		finishings[1024],	/* Finishings to support */
+		make_model[IPP_MAX_NAME * 2],
+					/* Make and model, quoted */
+		location[IPP_MAX_NAME * 2],
+					/* Location, quoted */
+		info[IPP_MAX_NAME * 2],	/* Info, quoted */
+		*src,			/* Pointer to original string */
+		*dst;			/* Pointer to destination string */
+  ipp_attribute_t *authentication;	/* uri-authentication-supported value */
+  SLPError	error;			/* SLP error, if any */
+
+
+  cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdSendSLPBrowse(%p = \"%s\")", p,
+                  p->name);
+
+ /*
+  * Make the SLP service URL that conforms to the IANA 
+  * 'printer:' template.
+  */
+
+  snprintf(srvurl, sizeof(srvurl), SLP_CUPS_SRVTYPE ":%s", p->uri);
+
+  cupsdLogMessage(CUPSD_LOG_DEBUG2, "Service URL = \"%s\"", srvurl);
+
+ /*
+  * Figure out the finishings string...
+  */
+
+  if (p->type & CUPS_PRINTER_STAPLE)
+    strcpy(finishings, "staple");
+  else
+    finishings[0] = '\0';
+
+  if (p->type & CUPS_PRINTER_BIND)
+  {
+    if (finishings[0])
+      strlcat(finishings, ",bind", sizeof(finishings));
+    else
+      strcpy(finishings, "bind");
+  }
+
+  if (p->type & CUPS_PRINTER_PUNCH)
+  {
+    if (finishings[0])
+      strlcat(finishings, ",punch", sizeof(finishings));
+    else
+      strcpy(finishings, "punch");
+  }
+
+  if (p->type & CUPS_PRINTER_COVER)
+  {
+    if (finishings[0])
+      strlcat(finishings, ",cover", sizeof(finishings));
+    else
+      strcpy(finishings, "cover");
+  }
+
+  if (p->type & CUPS_PRINTER_SORT)
+  {
+    if (finishings[0])
+      strlcat(finishings, ",sort", sizeof(finishings));
+    else
+      strcpy(finishings, "sort");
+  }
+
+  if (!finishings[0])
+    strcpy(finishings, "none");
+
+ /*
+  * Quote any commas in the make and model, location, and info strings...
+  */
+
+  for (src = p->make_model, dst = make_model;
+       src && *src && dst < (make_model + sizeof(make_model) - 2);)
+  {
+    if (*src == ',' || *src == '\\' || *src == ')')
+      *dst++ = '\\';
+
+    *dst++ = *src++;
+  }
+
+  *dst = '\0';
+
+  if (!make_model[0])
+    strcpy(make_model, "Unknown");
+
+  for (src = p->location, dst = location;
+       src && *src && dst < (location + sizeof(location) - 2);)
+  {
+    if (*src == ',' || *src == '\\' || *src == ')')
+      *dst++ = '\\';
+
+    *dst++ = *src++;
+  }
+
+  *dst = '\0';
+
+  if (!location[0])
+    strcpy(location, "Unknown");
+
+  for (src = p->info, dst = info;
+       src && *src && dst < (info + sizeof(info) - 2);)
+  {
+    if (*src == ',' || *src == '\\' || *src == ')')
+      *dst++ = '\\';
+
+    *dst++ = *src++;
+  }
+
+  *dst = '\0';
+
+  if (!info[0])
+    strcpy(info, "Unknown");
+
+ /*
+  * Get the authentication value...
+  */
+
+  authentication = ippFindAttribute(p->attrs, "uri-authentication-supported",
+                                    IPP_TAG_KEYWORD);
+
+ /*
+  * Make the SLP attribute string list that conforms to
+  * the IANA 'printer:' template.
+  */
+
+  snprintf(attrs, sizeof(attrs),
+           "(printer-uri-supported=%s),"
+           "(uri-authentication-supported=%s>),"
+#ifdef HAVE_SSL
+           "(uri-security-supported=tls>),"
+#else
+           "(uri-security-supported=none>),"
+#endif /* HAVE_SSL */
+           "(printer-name=%s),"
+           "(printer-location=%s),"
+           "(printer-info=%s),"
+           "(printer-more-info=%s),"
+           "(printer-make-and-model=%s),"
+	   "(charset-supported=utf-8),"
+	   "(natural-language-configured=%s),"
+	   "(natural-language-supported=de,en,es,fr,it),"
+           "(color-supported=%s),"
+           "(finishings-supported=%s),"
+           "(sides-supported=one-sided%s),"
+	   "(multiple-document-jobs-supported=true)"
+	   "(ipp-versions-supported=1.0,1.1)",
+	   p->uri, authentication->values[0].string.text, p->name, location,
+	   info, p->uri, make_model, DefaultLanguage,
+           p->type & CUPS_PRINTER_COLOR ? "true" : "false",
+           finishings,
+           p->type & CUPS_PRINTER_DUPLEX ?
+	       ",two-sided-long-edge,two-sided-short-edge" : "");
+
+  cupsdLogMessage(CUPSD_LOG_DEBUG2, "Attributes = \"%s\"", attrs);
+
+ /*
+  * Register the printer with the SLP server...
+  */
+
+  error = SLPReg(BrowseSLPHandle, srvurl, BrowseTimeout,
+	         SLP_CUPS_SRVTYPE, attrs, SLP_TRUE, slp_reg_callback, 0);
+
+  if (error != SLP_OK)
+    cupsdLogMessage(CUPSD_LOG_ERROR, "SLPReg of \"%s\" failed with status %d!", p->name,
+                    error);
+}
+#endif /* HAVE_LIBSLP */
+
+
 /*
  * 'cupsdStartBrowsing()' - Start sending and receiving broadcast information.
  */
@@ -1133,7 +1813,7 @@
 cupsdStartPolling(void)
 {
   int			i;		/* Looping var */
-  cupsd_dirsvc_poll_t	*poll;		/* Current polling server */
+  cupsd_dirsvc_poll_t	*pollp;		/* Current polling server */
   char			polld[1024];	/* Poll daemon path */
   char			sport[10];	/* Server port */
   char			bport[10];	/* Browser port */
@@ -1197,25 +1877,25 @@
   * Run each polling daemon, redirecting stderr to the polling pipe...
   */
 
-  for (i = 0, poll = Polled; i < NumPolled; i ++, poll ++)
+  for (i = 0, pollp = Polled; i < NumPolled; i ++, pollp ++)
   {
-    sprintf(sport, "%d", poll->port);
+    sprintf(sport, "%d", pollp->port);
 
-    argv[1] = poll->hostname;
+    argv[1] = pollp->hostname;
 
     if (cupsdStartProcess(polld, argv, envp, -1, -1, statusfds[1], -1,
-                          0, &(poll->pid)) < 0)
+                          0, &(pollp->pid)) < 0)
     {
       cupsdLogMessage(CUPSD_LOG_ERROR,
                       "cupsdStartPolling: Unable to fork polling daemon - %s",
                       strerror(errno));
-      poll->pid = 0;
+      pollp->pid = 0;
       break;
     }
     else
       cupsdLogMessage(CUPSD_LOG_DEBUG,
                       "cupsdStartPolling: Started polling daemon for %s:%d, pid = %d",
-                      poll->hostname, poll->port, poll->pid);
+                      pollp->hostname, pollp->port, pollp->pid);
   }
 
   close(statusfds[1]);
@@ -1285,7 +1965,7 @@
 cupsdStopPolling(void)
 {
   int			i;		/* Looping var */
-  cupsd_dirsvc_poll_t	*poll;		/* Current polling server */
+  cupsd_dirsvc_poll_t	*pollp;		/* Current polling server */
 
 
   if (PollPipe >= 0)
@@ -1301,9 +1981,9 @@
     PollStatusBuffer = NULL;
   }
 
-  for (i = 0, poll = Polled; i < NumPolled; i ++, poll ++)
-    if (poll->pid)
-      cupsdEndProcess(poll->pid, 0);
+  for (i = 0, pollp = Polled; i < NumPolled; i ++, pollp ++)
+    if (pollp->pid)
+      cupsdEndProcess(pollp->pid, 0);
 }
 
 
@@ -1320,6 +2000,7 @@
   int		bytes;			/* Number of bytes left */
   char		packet[1541],		/* Broadcast packet */
 		*pptr;			/* Pointer into packet */
+  socklen_t	srclen;			/* Length of source address */
   http_addr_t	srcaddr;		/* Source address */
   char		srcname[1024];		/* Source hostname */
   unsigned	address[4];		/* Source address */
@@ -1335,15 +2016,17 @@
 		make_model[IPP_MAX_NAME];/* Make and model string */
   int		port;			/* Port portion of URI */
   cupsd_netif_t	*iface;			/* Network interface */
+  int		num_attrs;		/* Number of attributes */
+  cups_option_t	*attrs;			/* Attributes */
 
 
  /*
   * Read a packet from the browse socket...
   */
 
-  len = sizeof(srcaddr);
+  srclen = sizeof(srcaddr);
   if ((bytes = recvfrom(BrowseSocket, packet, sizeof(packet) - 1, 0, 
-                        (struct sockaddr *)&srcaddr, &len)) < 0)
+                        (struct sockaddr *)&srcaddr, &srclen)) < 0)
   {
    /*
     * "Connection refused" is returned under Linux if the destination port
@@ -1475,6 +2158,8 @@
   strcpy(location, "Location Unknown");
   strcpy(info, "No Information Available");
   make_model[0] = '\0';
+  num_attrs     = 0;
+  attrs         = NULL;
 
   if ((pptr = strchr(packet, '\"')) != NULL)
   {
@@ -1504,8 +2189,7 @@
            i ++, pptr ++)
 	info[i] = *pptr;
 
-      if (i)
-	info[i] = '\0';
+      info[i] = '\0';
 
       if (*pptr == '\"')
 	pptr ++;
@@ -1520,8 +2204,13 @@
              i ++, pptr ++)
 	  make_model[i] = *pptr;
 
-	if (i)
-	  make_model[i] = '\0';
+	if (*pptr == '\"')
+	  pptr ++;
+
+	make_model[i] = '\0';
+
+        if (*pptr)
+	  num_attrs = cupsParseOptions(pptr, num_attrs, &attrs);
       }
     }
   }
@@ -1544,13 +2233,19 @@
   */
 
   if (!strcasecmp(host, ServerName) && port == LocalPort)
+  {
+    cupsFreeOptions(num_attrs, attrs);
     return;
+  }
 
   cupsdNetIFUpdate();
 
   for (iface = NetIFList; iface != NULL; iface = iface->next)
-    if (!strcasecmp(host, iface->hostname) && port == LocalPort)
+    if (!strcasecmp(host, iface->hostname) && port == iface->port)
+    {
+      cupsFreeOptions(num_attrs, attrs);
       return;
+    }
 
  /*
   * Do relaying...
@@ -1565,6 +2260,7 @@
 	cupsdLogMessage(CUPSD_LOG_ERROR,
 	                "cupsdUpdateCUPSBrowse: sendto failed for relay %d - %s.",
 	                i + 1, strerror(errno));
+	cupsFreeOptions(num_attrs, attrs);
 	return;
       }
 
@@ -1573,7 +2269,8 @@
   */
 
   cupsdProcessBrowseData(uri, (cups_ptype_t)type, (ipp_pstate_t)state, location,
-                         info, make_model);
+                         info, make_model, num_attrs, attrs);
+  cupsFreeOptions(num_attrs, attrs);
 }
 
 
@@ -1607,222 +2304,170 @@
 }
 
 
-/***********************************************************************
- **** SLP Support Code *************************************************
- ***********************************************************************/
-
 #ifdef HAVE_LIBSLP 
 /*
- * SLP service name for CUPS...
- */
-
-#  define SLP_CUPS_SRVTYPE	"service:printer"
-#  define SLP_CUPS_SRVLEN	15
-
-
-/* 
- * Printer service URL structure
- */
-
-typedef struct _slpsrvurl
-{
-  struct _slpsrvurl	*next;
-  char			url[HTTP_MAX_URI];
-} slpsrvurl_t;
-
-
-/*
- * 'slp_reg_callback()' - Empty SLPRegReport.
+ * 'cupsdUpdateSLPBrowse()' - Get browsing information via SLP.
  */
 
-static void
-slp_reg_callback(SLPHandle hslp,
-                  SLPError  errcode,
-		  void      *cookie)
+void
+cupsdUpdateSLPBrowse(void)
 {
-  (void)hslp;
-  (void)errcode;
-  (void)cookie;
-
-  return;
-}
-
+  slpsrvurl_t		*s,		/* Temporary list of service URLs */
+			*next;		/* Next service in list */
+  cupsd_printer_t	p;		/* Printer information */
+  const char		*uri;		/* Pointer to printer URI */
+  char			method[HTTP_MAX_URI],
+					/* Method portion of URI */
+			username[HTTP_MAX_URI],
+					/* Username portion of URI */
+			host[HTTP_MAX_URI],
+					/* Host portion of URI */
+			resource[HTTP_MAX_URI];
+					/* Resource portion of URI */
+  int			port;		/* Port portion of URI */
 
-/*
- * 'cupsdSendSLPBrowse()' - Register the specified printer with SLP.
- */
 
-void 
-cupsdSendSLPBrowse(cupsd_printer_t *p)	/* I - Printer to register */
-{
-  char		srvurl[HTTP_MAX_URI],	/* Printer service URI */
-		attrs[8192],		/* Printer attributes */
-		finishings[1024],	/* Finishings to support */
-		make_model[IPP_MAX_NAME * 2],
-					/* Make and model, quoted */
-		location[IPP_MAX_NAME * 2],
-					/* Location, quoted */
-		info[IPP_MAX_NAME * 2],	/* Info, quoted */
-		*src,			/* Pointer to original string */
-		*dst;			/* Pointer to destination string */
-  ipp_attribute_t *authentication;	/* uri-authentication-supported value */
-  SLPError	error;			/* SLP error, if any */
+  cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdUpdateSLPBrowse() Start...");
 
+ /*
+  * Reset the refresh time...
+  */
 
-  cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdSendSLPBrowse(%p = \"%s\")", p,
-                  p->name);
+  BrowseSLPRefresh = time(NULL) + BrowseInterval;
 
- /*
-  * Make the SLP service URL that conforms to the IANA 
-  * 'printer:' template.
+ /* 
+  * Poll for remote printers using SLP...
   */
 
-  snprintf(srvurl, sizeof(srvurl), SLP_CUPS_SRVTYPE ":%s", p->uri);
+  s = NULL;
 
-  cupsdLogMessage(CUPSD_LOG_DEBUG2, "Service URL = \"%s\"", srvurl);
+  SLPFindSrvs(BrowseSLPHandle, SLP_CUPS_SRVTYPE, "", "",
+	      slp_url_callback, &s);
 
  /*
-  * Figure out the finishings string...
+  * Loop through the list of available printers...
   */
 
-  if (p->type & CUPS_PRINTER_STAPLE)
-    strcpy(finishings, "staple");
-  else
-    finishings[0] = '\0';
-
-  if (p->type & CUPS_PRINTER_BIND)
+  for (; s; s = next)
   {
-    if (finishings[0])
-      strlcat(finishings, ",bind", sizeof(finishings));
-    else
-      strcpy(finishings, "bind");
-  }
+   /*
+    * Save the "next" pointer...
+    */
 
-  if (p->type & CUPS_PRINTER_PUNCH)
-  {
-    if (finishings[0])
-      strlcat(finishings, ",punch", sizeof(finishings));
-    else
-      strcpy(finishings, "punch");
-  }
+    next = s->next;
 
-  if (p->type & CUPS_PRINTER_COVER)
-  {
-    if (finishings[0])
-      strlcat(finishings, ",cover", sizeof(finishings));
-    else
-      strcpy(finishings, "cover");
-  }
+   /* 
+    * Load a cupsd_printer_t structure with the SLP service attributes...
+    */
 
-  if (p->type & CUPS_PRINTER_SORT)
-  {
-    if (finishings[0])
-      strlcat(finishings, ",sort", sizeof(finishings));
-    else
-      strcpy(finishings, "sort");
-  }
+    SLPFindAttrs(BrowseSLPHandle, s->url, "", "", slp_attr_callback, &p);
 
-  if (!finishings[0])
-    strcpy(finishings, "none");
+   /*
+    * Process this printer entry...
+    */
 
- /*
-  * Quote any commas in the make and model, location, and info strings...
-  */
+    uri = s->url + SLP_CUPS_SRVLEN + 1;
 
-  for (src = p->make_model, dst = make_model;
-       src && *src && dst < (make_model + sizeof(make_model) - 2);)
-  {
-    if (*src == ',' || *src == '\\' || *src == ')')
-      *dst++ = '\\';
+    if (!strncmp(uri, "http://", 7) || !strncmp(uri, "ipp://", 6))
+    {
+     /*
+      * Pull the URI apart to see if this is a local or remote printer...
+      */
 
-    *dst++ = *src++;
-  }
+      httpSeparate(uri, method, username, host, &port, resource);
 
-  *dst = '\0';
+      if (strcasecmp(host, ServerName) == 0)
+	continue;
 
-  if (!make_model[0])
-    strcpy(make_model, "Unknown");
+     /*
+      * OK, at least an IPP printer, see if it is a CUPS printer or
+      * class...
+      */
 
-  for (src = p->location, dst = location;
-       src && *src && dst < (location + sizeof(location) - 2);)
-  {
-    if (*src == ',' || *src == '\\' || *src == ')')
-      *dst++ = '\\';
+      if (strstr(uri, "/printers/") != NULL)
+        cupsdProcessBrowseData(uri, p.type, IPP_PRINTER_IDLE, p.location,
+	                  p.info, p.make_model, 0, NULL);
+      else if (strstr(uri, "/classes/") != NULL)
+        cupsdProcessBrowseData(uri, p.type | CUPS_PRINTER_CLASS, IPP_PRINTER_IDLE,
+	                  p.location, p.info, p.make_model, 0, NULL);
+    }
 
-    *dst++ = *src++;
-  }
+   /*
+    * Free this listing...
+    */
 
-  *dst = '\0';
+    free(s);
+  }       
 
-  if (!location[0])
-    strcpy(location, "Unknown");
+  cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdUpdateSLPBrowse() End...");
+}
 
-  for (src = p->info, dst = info;
-       src && *src && dst < (info + sizeof(info) - 2);)
-  {
-    if (*src == ',' || *src == '\\' || *src == ')')
-      *dst++ = '\\';
 
-    *dst++ = *src++;
-  }
+/*
+ * 'slp_attr_callback()' - SLP attribute callback 
+ */
 
-  *dst = '\0';
+static SLPBoolean			/* O - SLP_TRUE for success */
+slp_attr_callback(
+    SLPHandle  hslp,			/* I - SLP handle */
+    const char *attrlist,		/* I - Attribute list */
+    SLPError   errcode,			/* I - Parsing status for this attr */
+    void       *cookie)			/* I - Current printer */
+{
+  char			*tmp = 0;
+  cupsd_printer_t	*p = (cupsd_printer_t*)cookie;
 
-  if (!info[0])
-    strcpy(info, "Unknown");
 
  /*
-  * Get the authentication value...
+  * Let the compiler know we won't be using these...
   */
 
-  authentication = ippFindAttribute(p->attrs, "uri-authentication-supported",
-                                    IPP_TAG_KEYWORD);
+  (void)hslp;
 
  /*
-  * Make the SLP attribute string list that conforms to
-  * the IANA 'printer:' template.
+  * Bail if there was an error
   */
 
-  snprintf(attrs, sizeof(attrs),
-           "(printer-uri-supported=%s),"
-           "(uri-authentication-supported=%s>),"
-#ifdef HAVE_SSL
-           "(uri-security-supported=tls>),"
-#else
-           "(uri-security-supported=none>),"
-#endif /* HAVE_SSL */
-           "(printer-name=%s),"
-           "(printer-location=%s),"
-           "(printer-info=%s),"
-           "(printer-more-info=%s),"
-           "(printer-make-and-model=%s),"
-	   "(charset-supported=utf-8),"
-	   "(natural-language-configured=%s),"
-	   "(natural-language-supported=de,en,es,fr,it),"
-           "(color-supported=%s),"
-           "(finishings-supported=%s),"
-           "(sides-supported=one-sided%s),"
-	   "(multiple-document-jobs-supported=true)"
-	   "(ipp-versions-supported=1.0,1.1)",
-	   p->uri, authentication->values[0].string.text, p->name, location,
-	   info, p->uri, make_model, DefaultLanguage,
-           p->type & CUPS_PRINTER_COLOR ? "true" : "false",
-           finishings,
-           p->type & CUPS_PRINTER_DUPLEX ?
-	       ",two-sided-long-edge,two-sided-short-edge" : "");
-
-  cupsdLogMessage(CUPSD_LOG_DEBUG2, "Attributes = \"%s\"", attrs);
+  if (errcode != SLP_OK)
+    return (SLP_TRUE);
 
  /*
-  * Register the printer with the SLP server...
+  * Parse the attrlist to obtain things needed to build CUPS browse packet
   */
 
-  error = SLPReg(BrowseSLPHandle, srvurl, BrowseTimeout,
-	         SLP_CUPS_SRVTYPE, attrs, SLP_TRUE, slp_reg_callback, 0);
+  memset(p, 0, sizeof(cupsd_printer_t));
 
-  if (error != SLP_OK)
-    cupsdLogMessage(CUPSD_LOG_ERROR, "SLPReg of \"%s\" failed with status %d!", p->name,
-                    error);
+  p->type = CUPS_PRINTER_REMOTE;
+
+  if (slp_get_attr(attrlist, "(printer-location=", &(p->location)))
+    return (SLP_FALSE);
+  if (slp_get_attr(attrlist, "(printer-info=", &(p->info)))
+    return (SLP_FALSE);
+  if (slp_get_attr(attrlist, "(printer-make-and-model=", &(p->make_model)))
+    return (SLP_FALSE);
+
+  if (slp_get_attr(attrlist, "(color-supported=", &tmp))
+    return (SLP_FALSE);
+  if (strcasecmp(tmp, "true") == 0)
+    p->type |= CUPS_PRINTER_COLOR;
+
+  if (slp_get_attr(attrlist, "(finishings-supported=", &tmp))
+    return (SLP_FALSE);
+  if (strstr(tmp, "staple"))
+    p->type |= CUPS_PRINTER_STAPLE;
+  if (strstr(tmp, "bind"))
+    p->type |= CUPS_PRINTER_BIND;
+  if (strstr(tmp, "punch"))
+    p->type |= CUPS_PRINTER_PUNCH;
+
+  if (slp_get_attr(attrlist, "(sides-supported=", &tmp))
+    return (SLP_FALSE);
+  if (strstr(tmp,"two-sided"))
+    p->type |= CUPS_PRINTER_DUPLEX;
+
+  cupsdClearString(&tmp);
+
+  return (SLP_TRUE);
 }
 
 
@@ -1831,9 +2476,9 @@
  */
 
 static void 
-slp_dereg_printer(cupsd_printer_t *p)
+slp_dereg_printer(cupsd_printer_t *p)	/* I - Printer */
 {
-  char	srvurl[HTTP_MAX_URI];	/* Printer service URI */
+  char	srvurl[HTTP_MAX_URI];		/* Printer service URI */
 
 
   cupsdLogMessage(CUPSD_LOG_DEBUG, "slp_dereg_printer: printer=\"%s\"", p->name);
@@ -1901,70 +2546,19 @@
 
 
 /*
- * 'slp_attr_callback()' - SLP attribute callback 
+ * 'slp_reg_callback()' - Empty SLPRegReport.
  */
 
-static SLPBoolean			/* O - SLP_TRUE for success */
-slp_attr_callback(
-    SLPHandle  hslp,			/* I - SLP handle */
-    const char *attrlist,		/* I - Attribute list */
-    SLPError   errcode,			/* I - Parsing status for this attr */
-    void       *cookie)			/* I - Current printer */
+static void
+slp_reg_callback(SLPHandle hslp,	/* I - SLP handle */
+                 SLPError  errcode,	/* I - Error code, if any */
+		 void      *cookie)	/* I - App data */
 {
-  char			*tmp = 0;
-  cupsd_printer_t	*p = (cupsd_printer_t*)cookie;
-
-
- /*
-  * Let the compiler know we won't be using these...
-  */
-
   (void)hslp;
+  (void)errcode;
+  (void)cookie;
 
- /*
-  * Bail if there was an error
-  */
-
-  if (errcode != SLP_OK)
-    return (SLP_TRUE);
-
- /*
-  * Parse the attrlist to obtain things needed to build CUPS browse packet
-  */
-
-  memset(p, 0, sizeof(cupsd_printer_t));
-
-  p->type = CUPS_PRINTER_REMOTE;
-
-  if (slp_get_attr(attrlist, "(printer-location=", &(p->location)))
-    return (SLP_FALSE);
-  if (slp_get_attr(attrlist, "(printer-info=", &(p->info)))
-    return (SLP_FALSE);
-  if (slp_get_attr(attrlist, "(printer-make-and-model=", &(p->make_model)))
-    return (SLP_FALSE);
-
-  if (slp_get_attr(attrlist, "(color-supported=", &tmp))
-    return (SLP_FALSE);
-  if (strcasecmp(tmp, "true") == 0)
-    p->type |= CUPS_PRINTER_COLOR;
-
-  if (slp_get_attr(attrlist, "(finishings-supported=", &tmp))
-    return (SLP_FALSE);
-  if (strstr(tmp, "staple"))
-    p->type |= CUPS_PRINTER_STAPLE;
-  if (strstr(tmp, "bind"))
-    p->type |= CUPS_PRINTER_BIND;
-  if (strstr(tmp, "punch"))
-    p->type |= CUPS_PRINTER_PUNCH;
-
-  if (slp_get_attr(attrlist, "(sides-supported=", &tmp))
-    return (SLP_FALSE);
-  if (strstr(tmp,"two-sided"))
-    p->type |= CUPS_PRINTER_DUPLEX;
-
-  cupsdClearString(&tmp);
-
-  return (SLP_TRUE);
+  return;
 }
 
 
@@ -2028,104 +2622,9 @@
 
   return (SLP_TRUE);
 }
-
-
-/*
- * 'cupsdUpdateSLPBrowse()' - Get browsing information via SLP.
- */
-
-void
-cupsdUpdateSLPBrowse(void)
-{
-  slpsrvurl_t	*s,			/* Temporary list of service URLs */
-		*next;			/* Next service in list */
-  cupsd_printer_t	p;			/* Printer information */
-  const char	*uri;			/* Pointer to printer URI */
-  char		method[HTTP_MAX_URI],	/* Method portion of URI */
-		username[HTTP_MAX_URI],	/* Username portion of URI */
-		host[HTTP_MAX_URI],	/* Host portion of URI */
-		resource[HTTP_MAX_URI];	/* Resource portion of URI */
-  int		port;			/* Port portion of URI */
-
-
-  cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdUpdateSLPBrowse() Start...");
-
- /*
-  * Reset the refresh time...
-  */
-
-  BrowseSLPRefresh = time(NULL) + BrowseInterval;
-
- /* 
-  * Poll for remote printers using SLP...
-  */
-
-  s = NULL;
-
-  SLPFindSrvs(BrowseSLPHandle, SLP_CUPS_SRVTYPE, "", "",
-	      slp_url_callback, &s);
-
- /*
-  * Loop through the list of available printers...
-  */
-
-  for (; s; s = next)
-  {
-   /*
-    * Save the "next" pointer...
-    */
-
-    next = s->next;
-
-   /* 
-    * Load a cupsd_printer_t structure with the SLP service attributes...
-    */
-
-    SLPFindAttrs(BrowseSLPHandle, s->url, "", "", slp_attr_callback, &p);
-
-   /*
-    * Process this printer entry...
-    */
-
-    uri = s->url + SLP_CUPS_SRVLEN + 1;
-
-    if (strncmp(uri, "http://", 7) == 0 ||
-        strncmp(uri, "ipp://", 6) == 0)
-    {
-     /*
-      * Pull the URI apart to see if this is a local or remote printer...
-      */
-
-      httpSeparate(uri, method, username, host, &port, resource);
-
-      if (strcasecmp(host, ServerName) == 0)
-	continue;
-
-     /*
-      * OK, at least an IPP printer, see if it is a CUPS printer or
-      * class...
-      */
-
-      if (strstr(uri, "/printers/") != NULL)
-        cupsdProcessBrowseData(uri, p.type, IPP_PRINTER_IDLE, p.location,
-	                  p.info, p.make_model);
-      else if (strstr(uri, "/classes/") != NULL)
-        cupsdProcessBrowseData(uri, p.type | CUPS_PRINTER_CLASS, IPP_PRINTER_IDLE,
-	                  p.location, p.info, p.make_model);
-    }
-
-   /*
-    * Free this listing...
-    */
-
-    free(s);
-  }       
-
-  cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdUpdateSLPBrowse() End...");
-}
 #endif /* HAVE_LIBSLP */
 
 
 /*
- * End of "$Id: dirsvc.c 4744 2005-10-03 01:32:35Z mike $".
+ * End of "$Id: dirsvc.c 4825 2005-11-08 02:05:59Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/dirsvc.h cupsys-1.1.99.b1.r4748/scheduler/dirsvc.h
--- cupsys-1.1.99.b1.r4748~/scheduler/dirsvc.h	2005-09-29 06:12:44.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/dirsvc.h	2005-11-05 06:13:20.192531000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: dirsvc.h 4719 2005-09-28 21:12:44Z mike $"
+ * "$Id: dirsvc.h 4822 2005-11-04 21:13:20Z mike $"
  *
  *   Directory services definitions for the Common UNIX Printing System
  *   (CUPS) scheduler.
@@ -137,9 +137,13 @@
  * Prototypes...
  */
 
+extern void	cupsdLoadRemoteCache(void);
 extern void	cupsdProcessBrowseData(const char *uri, cups_ptype_t type,
 		                       ipp_pstate_t state, const char *location,
-				       const char *info, const char *make_model);
+				       const char *info, const char *make_model,
+				       int num_attrs, cups_option_t *attrs);
+extern void	cupsdProcessImplicitClasses(void);
+extern void	cupsdSaveRemoteCache(void);
 extern void	cupsdSendBrowseDelete(cupsd_printer_t *p);
 extern void	cupsdSendBrowseList(void);
 extern void	cupsdSendCUPSBrowse(cupsd_printer_t *p);
@@ -154,5 +158,5 @@
 
 
 /*
- * End of "$Id: dirsvc.h 4719 2005-09-28 21:12:44Z mike $".
+ * End of "$Id: dirsvc.h 4822 2005-11-04 21:13:20Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/filter.c cupsys-1.1.99.b1.r4748/scheduler/filter.c
--- cupsys-1.1.99.b1.r4748~/scheduler/filter.c	2005-11-13 13:59:11.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/filter.c	2005-11-13 06:46:52.687523000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: filter.c 4613 2005-08-30 12:41:48Z mike $"
+ * "$Id: filter.c 4833 2005-11-12 21:46:52Z mike $"
  *
  *   File type conversion routines for the Common UNIX Printing System (CUPS).
  *
@@ -222,7 +222,7 @@
       * any...)
       */
 
-      for (j = 0, cost = 0; j < num_temp; j ++)
+      for (j = 0, cost = current->cost; j < num_temp; j ++)
         cost += temp[j].cost;
 
       if (cost < mincost)
@@ -322,5 +322,5 @@
 
 
 /*
- * End of "$Id: filter.c 4613 2005-08-30 12:41:48Z mike $".
+ * End of "$Id: filter.c 4833 2005-11-12 21:46:52Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/ipp.c cupsys-1.1.99.b1.r4748/scheduler/ipp.c
--- cupsys-1.1.99.b1.r4748~/scheduler/ipp.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/ipp.c	2005-10-22 04:17:52.778582000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: ipp.c 4744 2005-10-03 01:32:35Z mike $"
+ * "$Id: ipp.c 4807 2005-10-21 19:17:52Z mike $"
  *
  *   IPP routines for the Common UNIX Printing System (CUPS) scheduler.
  *
@@ -896,6 +896,9 @@
 
   if ((attr = ippFindAttribute(con->request, "printer-is-shared", IPP_TAG_BOOLEAN)) != NULL)
   {
+    if (pclass->shared && !attr->values[0].boolean)
+      cupsdSendBrowseDelete(pclass);
+
     cupsdLogMessage(CUPSD_LOG_INFO,
                     "Setting %s printer-is-shared to %d (was %d.)",
                     pclass->name, attr->values[0].boolean, pclass->shared);
@@ -986,7 +989,8 @@
     cupsdFreeQuotas(pclass);
     pclass->page_limit = attr->values[0].integer;
   }
-  if ((attr = ippFindAttribute(con->request, "printer-op-policy", IPP_TAG_TEXT)) != NULL)
+  if ((attr = ippFindAttribute(con->request, "printer-op-policy",
+                               IPP_TAG_NAME)) != NULL)
   {
     cupsd_policy_t *p;			/* Policy */
 
@@ -1008,7 +1012,8 @@
       return;
     }
   }
-  if ((attr = ippFindAttribute(con->request, "printer-error-policy", IPP_TAG_TEXT)) != NULL)
+  if ((attr = ippFindAttribute(con->request, "printer-error-policy",
+                               IPP_TAG_NAME)) != NULL)
   {
     if (strcmp(attr->values[0].string.text, "abort-job") &&
         strcmp(attr->values[0].string.text, "retry-job") &&
@@ -1656,6 +1661,9 @@
 
   if ((attr = ippFindAttribute(con->request, "printer-is-shared", IPP_TAG_BOOLEAN)) != NULL)
   {
+    if (printer->shared && !attr->values[0].boolean)
+      cupsdSendBrowseDelete(printer);
+
     cupsdLogMessage(CUPSD_LOG_INFO,
                     "Setting %s printer-is-shared to %d (was %d.)",
                     printer->name, attr->values[0].boolean, printer->shared);
@@ -1743,7 +1751,8 @@
     cupsdFreeQuotas(printer);
     printer->page_limit = attr->values[0].integer;
   }
-  if ((attr = ippFindAttribute(con->request, "printer-op-policy", IPP_TAG_TEXT)) != NULL)
+  if ((attr = ippFindAttribute(con->request, "printer-op-policy",
+                               IPP_TAG_NAME)) != NULL)
   {
     cupsd_policy_t *p;			/* Policy */
 
@@ -1765,7 +1774,8 @@
       return;
     }
   }
-  if ((attr = ippFindAttribute(con->request, "printer-error-policy", IPP_TAG_TEXT)) != NULL)
+  if ((attr = ippFindAttribute(con->request, "printer-error-policy",
+                               IPP_TAG_NAME)) != NULL)
   {
     if (strcmp(attr->values[0].string.text, "abort-job") &&
         strcmp(attr->values[0].string.text, "retry-job") &&
@@ -4290,8 +4300,9 @@
     if (!ippFindAttribute(DefaultPrinter->attrs, "printer-uri-supported",
                           IPP_TAG_URI))
     {
-      snprintf(printer_uri, sizeof(printer_uri), "ipp://%s:%d/printers/%s",
-               con->servername, con->serverport, DefaultPrinter->name);
+      httpAssembleURIf(printer_uri, sizeof(printer_uri), "ipp", NULL,
+                       con->servername, con->serverport, "/printers/%s",
+        	       DefaultPrinter->name);
       ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_URI,
         	   "printer-uri-supported", NULL, printer_uri);
       cupsdLogMessage(CUPSD_LOG_DEBUG2, "printer-uri-supported=\"%s\"",
@@ -4320,7 +4331,7 @@
                ippTimeToDate(curtime));
 
     ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_NAME,
-        	 "printer-error-policy", NULL, DefaultPrinter->op_policy);
+        	 "printer-error-policy", NULL, DefaultPrinter->error_policy);
     ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_NAME,
         	 "printer-op-policy", NULL, DefaultPrinter->op_policy);
 
@@ -4486,7 +4497,7 @@
 		resource[HTTP_MAX_URI];	/* Resource portion of URI */
   int		port;			/* Port portion of URI */
   int		completed;		/* Completed jobs? */
-  int		first;			/* First job ID */
+  int		first_job_id;		/* First job ID */
   int		limit;			/* Maximum number of jobs to return */
   int		count;			/* Number of jobs that match */
   cupsd_job_t	*job;			/* Current job pointer */
@@ -4590,10 +4601,11 @@
   else
     limit = 1000000;
 
-  if ((attr = ippFindAttribute(con->request, "first", IPP_TAG_INTEGER)) != NULL)
-    first = attr->values[0].integer;
+  if ((attr = ippFindAttribute(con->request, "first-job-id",
+                               IPP_TAG_INTEGER)) != NULL)
+    first_job_id = attr->values[0].integer;
   else
-    first = 1;
+    first_job_id = 1;
 
  /*
   * See if we only want to see jobs for a specific user...
@@ -4642,7 +4654,7 @@
     if (completed && job->state->values[0].integer <= IPP_JOB_STOPPED)
       continue;
 
-    if (job->id < first)
+    if (job->id < first_job_id)
       continue;
 
     count ++;
@@ -5007,8 +5019,9 @@
   if (!ippFindAttribute(printer->attrs, "printer-uri-supported",
                         IPP_TAG_URI))
   {
-    snprintf(printer_uri, sizeof(printer_uri), "ipp://%s:%d/printers/%s",
-             con->servername, con->serverport, printer->name);
+    httpAssembleURIf(printer_uri, sizeof(printer_uri), "ipp", NULL,
+                     con->servername, con->serverport, "/printers/%s",
+        	     printer->name);
     ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_URI,
         	 "printer-uri-supported", NULL, printer_uri);
     cupsdLogMessage(CUPSD_LOG_DEBUG2, "printer-uri-supported=\"%s\"",
@@ -5036,7 +5049,7 @@
              ippTimeToDate(curtime));
 
   ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_NAME,
-               "printer-error-policy", NULL, printer->op_policy);
+               "printer-error-policy", NULL, printer->error_policy);
   ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_NAME,
                "printer-op-policy", NULL, printer->op_policy);
 
@@ -5096,10 +5109,8 @@
   int		printer_type,		/* printer-type attribute */
 		printer_mask;		/* printer-type-mask attribute */
   char		*location;		/* Location string */
-  char		name[IPP_MAX_NAME],	/* Printer name */
-		*nameptr;		/* Pointer into name */
-  cupsd_printer_t *iclass;		/* Implicit class */
   const char	*username;		/* Current user */
+  char		*first_printer_name;	/* first-printer-name attribute */
   char		printer_uri[HTTP_MAX_URI];
 					/* Printer URI */
 
@@ -5133,28 +5144,38 @@
   else
     limit = 10000000;
 
+  if ((attr = ippFindAttribute(con->request, "first-printer-name",
+                               IPP_TAG_NAME)) != NULL)
+    first_printer_name = attr->values[0].string.text;
+  else
+    first_printer_name = NULL;
+
  /*
   * Support filtering...
   */
 
-  if ((attr = ippFindAttribute(con->request, "printer-type", IPP_TAG_ENUM)) != NULL)
+  if ((attr = ippFindAttribute(con->request, "printer-type",
+                               IPP_TAG_ENUM)) != NULL)
     printer_type = attr->values[0].integer;
   else
     printer_type = 0;
 
-  if ((attr = ippFindAttribute(con->request, "printer-type-mask", IPP_TAG_ENUM)) != NULL)
+  if ((attr = ippFindAttribute(con->request, "printer-type-mask",
+                               IPP_TAG_ENUM)) != NULL)
     printer_mask = attr->values[0].integer;
   else
     printer_mask = 0;
 
-  if ((attr = ippFindAttribute(con->request, "printer-location", IPP_TAG_TEXT)) != NULL)
+  if ((attr = ippFindAttribute(con->request, "printer-location",
+                               IPP_TAG_TEXT)) != NULL)
     location = attr->values[0].string.text;
   else
     location = NULL;
 
   if (con->username[0])
     username = con->username;
-  else if ((attr = ippFindAttribute(con->request, "requesting-user-name", IPP_TAG_NAME)) != NULL)
+  else if ((attr = ippFindAttribute(con->request, "requesting-user-name",
+                                    IPP_TAG_NAME)) != NULL)
     username = attr->values[0].string.text;
   else
     username = NULL;
@@ -5181,7 +5202,15 @@
 
   curtime = time(NULL);
 
-  for (count = 0, printer = (cupsd_printer_t *)cupsArrayFirst(Printers);
+  if (first_printer_name)
+  {
+    if ((printer = cupsdFindDest(first_printer_name)) == NULL)
+      printer = (cupsd_printer_t *)cupsArrayFirst(Printers);
+  }
+  else
+    printer = (cupsd_printer_t *)cupsArrayFirst(Printers);
+
+  for (count = 0;
        count < limit && printer != NULL;
        printer = (cupsd_printer_t *)cupsArrayNext(Printers))
     if ((!type || (printer->type & CUPS_PRINTER_CLASS) == type) &&
@@ -5189,44 +5218,14 @@
 	(location == NULL || printer->location == NULL ||
 	 !strcasecmp(printer->location, location)))
     {
-      cupsArraySave(Printers);
-
      /*
       * If HideImplicitMembers is enabled, see if this printer or class
       * is a member of an implicit class...
       */
 
       if (ImplicitClasses && HideImplicitMembers &&
-          (printer->type & CUPS_PRINTER_REMOTE))
-      {
-       /*
-        * Make a copy of the printer name...
-	*/
-
-        strlcpy(name, printer->name, sizeof(name));
-
-	if ((nameptr = strchr(name, '@')) != NULL)
-	{
-	 /*
-	  * Strip trailing @server...
-	  */
-
-	  *nameptr = '\0';
-
-         /*
-	  * Find the core printer, if any...
-	  */
-
-          if ((iclass = cupsdFindPrinter(name)) != NULL &&
-	      (iclass->type & CUPS_PRINTER_IMPLICIT))
-	  {
-            cupsArrayRestore(Printers);
-	    continue;
-	  }
-	}
-      }
-
-      cupsArrayRestore(Printers);
+          printer->in_implicit_class)
+        continue;
 
      /*
       * If a username is specified, see if it is allowed or denied
@@ -5260,8 +5259,9 @@
       if (!ippFindAttribute(printer->attrs, "printer-uri-supported",
                             IPP_TAG_URI))
       {
-	snprintf(printer_uri, sizeof(printer_uri), "ipp://%s:%d/printers/%s",
-        	 con->servername, con->serverport, printer->name);
+	httpAssembleURIf(printer_uri, sizeof(printer_uri), "ipp", NULL,
+                	 con->servername, con->serverport, "/printers/%s",
+        		 printer->name);
 	ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_URI,
         	     "printer-uri-supported", NULL, printer_uri);
         cupsdLogMessage(CUPSD_LOG_DEBUG2, "printer-uri-supported=\"%s\"", printer_uri);
@@ -5288,7 +5288,7 @@
         	 ippTimeToDate(curtime));
 
       ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_NAME,
-                   "printer-error-policy", NULL, printer->op_policy);
+                   "printer-error-policy", NULL, printer->error_policy);
       ippAddString(con->response, IPP_TAG_PRINTER, IPP_TAG_NAME,
                    "printer-op-policy", NULL, printer->op_policy);
 
@@ -8471,5 +8471,5 @@
 
 
 /*
- * End of "$Id: ipp.c 4744 2005-10-03 01:32:35Z mike $".
+ * End of "$Id: ipp.c 4807 2005-10-21 19:17:52Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/job.c cupsys-1.1.99.b1.r4748/scheduler/job.c
--- cupsys-1.1.99.b1.r4748~/scheduler/job.c	2005-10-01 13:18:14.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/job.c	2005-11-05 06:13:20.192531000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: job.c 4739 2005-10-01 04:18:14Z mike $"
+ * "$Id: job.c 4822 2005-11-04 21:13:20Z mike $"
  *
  *   Job management routines for the Common UNIX Printing System (CUPS).
  *
@@ -445,7 +445,7 @@
 
 	    job->tries ++;
 
-	    if (job->tries >= FaxRetryLimit)
+	    if (job->tries >= JobRetryLimit)
 	    {
 	     /*
 	      * Too many tries...
@@ -453,11 +453,11 @@
 
 	      cupsdLogMessage(CUPSD_LOG_ERROR,
 	                      "Canceling job %d since it could not be sent after %d tries.",
-	        	      job->id, FaxRetryLimit);
+	        	      job->id, JobRetryLimit);
 
 	      cupsdAddEvent(CUPSD_EVENT_JOB_COMPLETED, job->printer, job,
                 	    "Job cancelled since it could not be sent after %d tries.",
-			    FaxRetryLimit);
+			    JobRetryLimit);
 
 	      cupsdCancelJob(job, 0);
 	    }
@@ -467,7 +467,7 @@
 	      * Try again in N seconds...
 	      */
 
-	      set_hold_until(job, time(NULL) + FaxRetryInterval);
+	      set_hold_until(job, time(NULL) + JobRetryInterval);
 	    }
 	  }
 	  else if (!strcmp(printer->error_policy, "abort-job"))
@@ -721,7 +721,6 @@
 			resource[HTTP_MAX_URI];
 					/* Resource portion of URI */
   int			port;		/* Port portion of URI */
-  cupsd_printer_t	*p;		/* Printer or class */
   const char		*dest;		/* Destination */
   mime_type_t		**filetypes;	/* New filetypes array */
   int			*compressions;	/* New compressions array */
@@ -854,38 +853,8 @@
       httpSeparate(attr->values[0].string.text, method, username, host,
                    &port, resource);
 
-      if ((dest = cupsdValidateDest(host, resource, &(job->dtype), NULL)) == NULL &&
-          job->state != NULL &&
-	  job->state->values[0].integer <= IPP_JOB_PROCESSING)
-      {
-       /*
-	* Job queued on remote printer or class, so add it...
-	*/
-
-	if (strncmp(resource, "/classes/", 9) == 0)
-	{
-	  p = cupsdAddClass(resource + 9);
-	  cupsdSetString(&p->make_model, "Remote Class on unknown");
-	}
-	else
-	{
-	  p = cupsdAddPrinter(resource + 10);
-	  cupsdSetString(&p->make_model, "Remote Printer on unknown");
-	}
-
-        p->state       = IPP_PRINTER_STOPPED;
-	p->type        |= CUPS_PRINTER_REMOTE;
-	p->browse_time = 2147483647;
-
-	cupsdSetString(&p->location, "Location Unknown");
-	cupsdSetString(&p->info, "No Information Available");
-	p->hostname[0] = '\0';
-
-	cupsdSetPrinterAttrs(p);
-	dest = p->name;
-      }
-
-      if (dest == NULL)
+      if ((dest = cupsdValidateDest(host, resource, &(job->dtype),
+                                    NULL)) == NULL)
       {
         cupsdLogMessage(CUPSD_LOG_ERROR,
 	                "cupsdLoadAllJobs: Unable to queue job for destination \"%s\"!",
@@ -2726,5 +2695,5 @@
 
 
 /*
- * End of "$Id: job.c 4739 2005-10-01 04:18:14Z mike $".
+ * End of "$Id: job.c 4822 2005-11-04 21:13:20Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/job.h cupsys-1.1.99.b1.r4748/scheduler/job.h
--- cupsys-1.1.99.b1.r4748~/scheduler/job.h	2005-10-01 02:46:19.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/job.h	2005-11-05 03:39:32.279708000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: job.h 4729 2005-09-30 17:46:19Z mike $"
+ * "$Id: job.h 4819 2005-11-04 18:39:32Z mike $"
  *
  *   Print job definitions for the Common UNIX Printing System (CUPS) scheduler.
  *
@@ -79,9 +79,9 @@
 					/* List of active jobs */
 VAR int			NextJobId	VALUE(1);
 					/* Next job ID to use */
-VAR int			FaxRetryLimit	VALUE(5),
+VAR int			JobRetryLimit	VALUE(5),
 					/* Max number of tries */
-			FaxRetryInterval VALUE(300);
+			JobRetryInterval VALUE(300);
 					/* Seconds between retries */
 
 
@@ -116,5 +116,5 @@
 
 
 /*
- * End of "$Id: job.h 4729 2005-09-30 17:46:19Z mike $".
+ * End of "$Id: job.h 4819 2005-11-04 18:39:32Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/listen.c cupsys-1.1.99.b1.r4748/scheduler/listen.c
--- cupsys-1.1.99.b1.r4748~/scheduler/listen.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/listen.c	2005-10-13 09:38:28.365747000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: listen.c 4719 2005-09-28 21:12:44Z mike $"
+ * "$Id: listen.c 4780 2005-10-13 00:38:28Z mike $"
  *
  *   Server listening routines for the Common UNIX Printing System (CUPS)
  *   scheduler.
@@ -38,6 +38,16 @@
 
 
 /*
+ * Make sure the IPV6_V6ONLY is defined on Linux - older versions of
+ * glibc don't define it even if the kernel supports it...
+ */
+
+#if defined(__linux) && !defined(IPV6_V6ONLY)
+#  define IPV6_V6ONLY 26
+#endif /* __linux && !IPV6_V6ONLY */
+
+
+/*
  * 'cupsdPauseListening()' - Clear input polling on all listening sockets...
  */
 
@@ -48,7 +58,7 @@
   cupsd_listener_t	*lis;		/* Current listening socket */
 
 
-  if (NumListeners < 1 || !FD_ISSET(Listeners[0].fd, InputSet))
+  if (NumListeners < 1)
     return;
 
   if (NumClients == MaxClients)
@@ -58,13 +68,14 @@
   cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdPauseListening: Clearing input bits...");
 
   for (i = NumListeners, lis = Listeners; i > 0; i --, lis ++)
-  {
-    cupsdLogMessage(CUPSD_LOG_DEBUG2,
-                    "cupsdPauseListening: Removing fd %d from InputSet...",
-                    lis->fd);
+    if (lis->fd >= 0)
+    {
+      cupsdLogMessage(CUPSD_LOG_DEBUG2,
+                      "cupsdPauseListening: Removing fd %d from InputSet...",
+                      lis->fd);
 
-    FD_CLR(lis->fd, InputSet);
-  }
+      FD_CLR(lis->fd, InputSet);
+    }
 }
 
 
@@ -79,7 +90,7 @@
   cupsd_listener_t	*lis;		/* Current listening socket */
 
 
-  if (NumListeners < 1 || FD_ISSET(Listeners[0].fd, InputSet))
+  if (NumListeners < 1)
     return;
 
   if (NumClients >= (MaxClients - 1))
@@ -88,12 +99,13 @@
   cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdResumeListening: Setting input bits...");
 
   for (i = NumListeners, lis = Listeners; i > 0; i --, lis ++)
-  {
-    cupsdLogMessage(CUPSD_LOG_DEBUG2,
-                    "cupsdResumeListening: Adding fd %d to InputSet...",
-                    lis->fd);
-    FD_SET(lis->fd, InputSet);
-  }
+    if (lis->fd >= 0)
+    {
+      cupsdLogMessage(CUPSD_LOG_DEBUG2,
+                      "cupsdResumeListening: Adding fd %d to InputSet...",
+                      lis->fd);
+      FD_SET(lis->fd, InputSet);
+    }
 }
 
 
@@ -109,7 +121,6 @@
 			p,		/* Port number */
 			val;		/* Parameter value */
   cupsd_listener_t	*lis;		/* Current listening socket */
-  struct hostent	*host;		/* Host entry for server address */
   char			s[256];		/* String addresss */
   const char		*have_domain;	/* Have a domain socket? */
   static const char * const encryptions[] =
@@ -128,28 +139,13 @@
   * Get the server's IP address...
   */
 
-  memset(&ServerAddr, 0, sizeof(ServerAddr));
-
-  if ((host = httpGetHostByName(ServerName)) != NULL)
-  {
-   /*
-    * Found the server's address!
-    */
-
-    httpAddrLoad(host, 0, 0, &ServerAddr);
-  }
-  else
-  {
-   /*
-    * Didn't find it!  Use an address of 0...
-    */
+  if (ServerAddrs)
+    httpAddrFreeList(ServerAddrs);
 
+  if ((ServerAddrs = httpAddrGetList(ServerName, AF_UNSPEC, NULL)) == NULL)
     cupsdLogMessage(CUPSD_LOG_ERROR,
-                    "cupsdStartListening: Unable to find IP address for server name \"%s\" - %s\n",
-                    ServerName, hstrerror(h_errno));
-
-    ServerAddr.ipv4.sin_family = AF_INET;
-  }
+                    "cupsdStartListening: Unable to find IP address for "
+		    "server name \"%s\"!\n", ServerName);
 
  /*
   * Setup socket listeners...
@@ -167,64 +163,23 @@
 #endif /* AF_INET6 */
 #ifdef AF_LOCAL
     if (lis->address.addr.sa_family == AF_LOCAL)
-    {
-      have_domain = lis->address.un.sun_path;
-      p           = 0;
-    }
+      p = 0;
     else
 #endif /* AF_LOCAL */
     p = ntohs(lis->address.ipv4.sin_port);
 
    /*
-    * Save the first port that is bound to the local loopback or
-    * "any" address...
-    */
-
-    if (!LocalPort && p > 0 &&
-        (httpAddrLocalhost(&(lis->address)) ||
-         httpAddrAny(&(lis->address))))
-    {
-      LocalPort       = p;
-      LocalEncryption = lis->encryption;
-    }
-
-   /*
     * Create a socket for listening...
     */
 
     lis->fd = socket(lis->address.addr.sa_family, SOCK_STREAM, 0);
 
-#ifdef AF_INET6
-    if (lis->fd == -1 && lis->address.addr.sa_family == AF_INET6 &&
-        (httpAddrLocalhost(&(lis->address)) || httpAddrAny(&(lis->address))))
-    {
-     /*
-      * Try binding to an IPv4 address instead...
-      */
-
-      cupsdLogMessage(CUPSD_LOG_NOTICE,
-                      "cupsdStartListening: Unable to use IPv6 address, trying IPv4...");
-
-      p = ntohs(lis->address.ipv6.sin6_port);
-
-      if (httpAddrAny(&(lis->address)))
-	lis->address.ipv4.sin_addr.s_addr = htonl(0x00000000);
-      else
-	lis->address.ipv4.sin_addr.s_addr = htonl(0x7f000001);
-
-      lis->address.ipv4.sin_port  = htons(p);
-      lis->address.addr.sa_family = AF_INET;
-
-      lis->fd = socket(lis->address.addr.sa_family, SOCK_STREAM, 0);
-    }
-#endif /* AF_INET6 */
-
     if (lis->fd == -1)
     {
       cupsdLogMessage(CUPSD_LOG_ERROR,
                       "cupsdStartListening: Unable to open listen socket for address %s:%d - %s.",
                       s, p, strerror(errno));
-      exit(errno);
+      continue;
     }
 
     fcntl(lis->fd, F_SETFD, fcntl(lis->fd, F_GETFD) | FD_CLOEXEC);
@@ -247,30 +202,23 @@
 #ifdef AF_INET6
     if (lis->address.addr.sa_family == AF_INET6)
     {
-      status = bind(lis->fd, (struct sockaddr *)&(lis->address),
-	            httpAddrLength(&(lis->address)));
+#  ifdef IPV6_V6ONLY
+     /*
+      * Accept only IPv6 connections on this socket, to avoid
+      * potential security issues and to make all platforms behave
+      * the same.
+      */
 
-#ifdef IPV6_V6ONLY
-      if (status >= 0 &&
-          (httpAddrLocalhost(&(lis->address)) || httpAddrAny(&(lis->address))))
-      {
-       /*
-        * Make sure that wildcard and loopback addresses accept
-	* connections from both IPv6 and IPv4 clients.
-	*
-	* NOTE: This DOES NOT WORK for OpenBSD, since they adopted a
-	*       stricter behavior in the name of security.  For OpenBSD,
-	*       you must list IPv4 and IPv6 listen addresses separately.
-	*/
+      val = 1;
+#    ifdef __sun
+      setsockopt(lis->fd, IPPROTO_IPV6, IPV6_V6ONLY, (char *)&val, sizeof(val));
+#    else
+      setsockopt(lis->fd, IPPROTO_IPV6, IPV6_V6ONLY, &val, sizeof(val));
+#    endif /* __sun */
+#  endif /* IPV6_V6ONLY */
 
-        val = 0;
-#  ifdef __sun
-        setsockopt(lis->fd, IPPROTO_IPV6, IPV6_V6ONLY, (char *)&val, sizeof(val));
-#  else
-        setsockopt(lis->fd, IPPROTO_IPV6, IPV6_V6ONLY, &val, sizeof(val));
-#  endif /* __sun */
-      }
-#endif /* IPV6_V6ONLY */
+      status = bind(lis->fd, (struct sockaddr *)&(lis->address),
+	            httpAddrLength(&(lis->address)));
     }
     else
 #endif /* AF_INET6 */
@@ -315,7 +263,9 @@
       cupsdLogMessage(CUPSD_LOG_ERROR,
                       "cupsdStartListening: Unable to bind socket for address %s:%d - %s.",
                       s, p, strerror(errno));
-      exit(errno);
+      close(lis->fd);
+      lis->fd = -1;
+      continue;
     }
 
    /*
@@ -338,6 +288,24 @@
       cupsdLogMessage(CUPSD_LOG_INFO,
                       "cupsdStartListening: Listening to %s on fd %d...",
         	      s, lis->fd);
+
+   /*
+    * Save the first port that is bound to the local loopback or
+    * "any" address...
+    */
+
+    if (!LocalPort && p > 0 &&
+        (httpAddrLocalhost(&(lis->address)) ||
+         httpAddrAny(&(lis->address))))
+    {
+      LocalPort       = p;
+      LocalEncryption = lis->encryption;
+    }
+
+#ifdef AF_LOCAL
+    if (lis->address.addr.sa_family == AF_LOCAL && !have_domain)
+      have_domain = lis->address.un.sun_path;
+#endif /* AF_LOCAL */
   }
 
  /*
@@ -357,7 +325,8 @@
   }
 
  /*
-  * Set the CUPS_SERVER and IPP_PORT variables based on the listeners...
+  * Set the CUPS_SERVER, IPP_PORT, and CUPS_ENCRYPTION variables based on
+  * the listeners...
   */
 
   if (have_domain)
@@ -375,10 +344,11 @@
     */
 
     cupsdSetEnv("CUPS_SERVER", "localhost");
-    cupsdSetEnvf("IPP_PORT", "%d", LocalPort);
-    cupsdSetEnv("CUPS_ENCRYPTION", encryptions[LocalEncryption]);
   }
 
+  cupsdSetEnv("CUPS_ENCRYPTION", encryptions[LocalEncryption]);
+  cupsdSetEnvf("IPP_PORT", "%d", LocalPort);
+
  /*
   * Resume listening for connections...
   */
@@ -424,5 +394,5 @@
 
 
 /*
- * End of "$Id: listen.c 4719 2005-09-28 21:12:44Z mike $".
+ * End of "$Id: listen.c 4780 2005-10-13 00:38:28Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/log.c cupsys-1.1.99.b1.r4748/scheduler/log.c
--- cupsys-1.1.99.b1.r4748~/scheduler/log.c	2005-10-01 06:45:34.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/log.c	2005-11-05 06:13:20.192531000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: log.c 4730 2005-09-30 21:45:34Z mike $"
+ * "$Id: log.c 4822 2005-11-04 21:13:20Z mike $"
  *
  *   Log file routines for the Common UNIX Printing System (CUPS).
  *
@@ -157,7 +157,7 @@
   * See if we want to log this message...
   */
 
-  if (level > LogLevel)
+  if (level > LogLevel || !ErrorLog)
     return (1);
 
 #ifdef HAVE_VSYSLOG
@@ -533,5 +533,5 @@
 
 
 /*
- * End of "$Id: log.c 4730 2005-09-30 21:45:34Z mike $".
+ * End of "$Id: log.c 4822 2005-11-04 21:13:20Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/main.c cupsys-1.1.99.b1.r4748/scheduler/main.c
--- cupsys-1.1.99.b1.r4748~/scheduler/main.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/main.c	2005-11-12 12:15:10.305626000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: main.c 4719 2005-09-28 21:12:44Z mike $"
+ * "$Id: main.c 4829 2005-11-12 03:15:10Z mike $"
  *
  *   Scheduler main loop for the Common UNIX Printing System (CUPS).
  *
@@ -640,6 +640,13 @@
       cupsdUpdateCGI();
 
    /*
+    * Update notifier messages as needed...
+    */
+
+    if (NotifierPipes[0] >= 0 && FD_ISSET(NotifierPipes[0], input))
+      cupsdUpdateNotifierStatus();
+
+   /*
     * Update the browse list as needed...
     */
 
@@ -669,7 +676,7 @@
     */
 
     for (i = NumListeners, lis = Listeners; i > 0; i --, lis ++)
-      if (FD_ISSET(lis->fd, input))
+      if (lis->fd >= 0 && FD_ISSET(lis->fd, input))
       {
         FD_CLR(lis->fd, input);
         cupsdAcceptClient(lis);
@@ -1467,5 +1474,5 @@
 
 
 /*
- * End of "$Id: main.c 4719 2005-09-28 21:12:44Z mike $".
+ * End of "$Id: main.c 4829 2005-11-12 03:15:10Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/network.c cupsys-1.1.99.b1.r4748/scheduler/network.c
--- cupsys-1.1.99.b1.r4748~/scheduler/network.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/network.c	2005-10-13 04:44:42.560866000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: network.c 4719 2005-09-28 21:12:44Z mike $"
+ * "$Id: network.c 4779 2005-10-12 19:44:42Z mike $"
  *
  *   Network interface functions for the Common UNIX Printing System
  *   (CUPS) scheduler.
@@ -140,9 +140,12 @@
   int			i,		/* Looping var */
 			match;		/* Matching address? */
   cupsd_listener_t	*lis;		/* Listen address */
-  cupsd_netif_t		*temp;		/* Current interface */
+  cupsd_netif_t		*temp,		/* New interface */
+			*prev,		/* Previous interface */
+			*current;	/* Current interface */
   struct ifaddrs	*addrs,		/* Interface address list */
 			*addr;		/* Current interface address */
+  http_addrlist_t	*saddr;		/* Current server address */
 
 
  /*
@@ -190,8 +193,25 @@
     if ((temp = calloc(1, sizeof(cupsd_netif_t))) == NULL)
       break;
 
-    temp->next = NetIFList;
-    NetIFList  = temp;
+   /*
+    * Insert the node in sorted order; since we don't expect to
+    * have a lot of network interfaces, we just do a simple linear
+    * search...
+    */
+
+    for (current = NetIFList, prev = NULL;
+         current;
+	 prev = current, current = current->next)
+      if (strcasecmp(addr->ifa_name, current->name) <= 0)
+        break;
+
+    if (current)
+      temp->next = current;
+
+    if (prev)
+      prev->next = temp;
+    else
+      NetIFList = temp;
 
    /*
     * Then copy all of the information...
@@ -294,12 +314,22 @@
 
       if (httpAddrLocalhost(&(temp->address)))
         strcpy(temp->hostname, "localhost");
-      else if (httpAddrEqual(&(temp->address), &ServerAddr))
-        strlcpy(temp->hostname, ServerName, sizeof(temp->hostname));
       else
-        httpAddrString(&(temp->address), temp->hostname,
-	               sizeof(temp->hostname));
+      {
+        for (saddr = ServerAddrs; saddr; saddr = saddr->next)
+	  if (httpAddrEqual(&(temp->address), &(saddr->addr)))
+	    break;
+
+	if (saddr)
+          strlcpy(temp->hostname, ServerName, sizeof(temp->hostname));
+	else
+          httpAddrString(&(temp->address), temp->hostname,
+	        	 sizeof(temp->hostname));
+      }
     }
+
+    cupsdLogMessage(CUPSD_LOG_DEBUG, "cupsdNetIFUpdate: \"%s\" = %s...",
+                    temp->name, temp->hostname);
   }
 
   freeifaddrs(addrs);
@@ -542,5 +572,5 @@
 
 
 /*
- * End of "$Id: network.c 4719 2005-09-28 21:12:44Z mike $".
+ * End of "$Id: network.c 4779 2005-10-12 19:44:42Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/notify.h cupsys-1.1.99.b1.r4748/scheduler/notify.h
--- cupsys-1.1.99.b1.r4748~/scheduler/notify.h	2005-09-29 06:12:44.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/notify.h	1970-01-01 09:00:00.000000000 +0900
@@ -1,137 +0,0 @@
-/*
- * "$Id: notify.h 4719 2005-09-28 21:12:44Z mike $"
- *
- *   Notification definitions for the Common UNIX Printing System (CUPS)
- *   scheduler.
- *
- *   Copyright 1997-2005 by Easy Software Products, all rights reserved.
- *
- *   These coded instructions, statements, and computer programs are the
- *   property of Easy Software Products and are protected by Federal
- *   copyright law.  Distribution and use rights are outlined in the file
- *   "LICENSE.txt" which should have been included with this file.  If this
- *   file is missing or damaged please contact Easy Software Products
- *   at:
- *
- *       Attn: CUPS Licensing Information
- *       Easy Software Products
- *       44141 Airport View Drive, Suite 204
- *       Hollywood, Maryland 20636 USA
- *
- *       Voice: (301) 373-9600
- *       EMail: cups-info@cups.org
- *         WWW: http://www.cups.org
- */
-
-
-/*
- * Event mask constants...
- */
-
-enum
-{
-  /* Standard IPP notifications */
-  CUPSD_EVENT_IPP_PRINTER_STATE_CHANGED = 0x00000007,
-  CUPSD_EVENT_IPP_PRINTER_RESTARTED = 0x00000001,
-  CUPSD_EVENT_IPP_PRINTER_SHUTDOWN = 0x00000002,
-  CUPSD_EVENT_IPP_PRINTER_STOPPED = 0x00000004,
-  CUPSD_EVENT_IPP_PRINTER_CONFIG_CHANGED = 0x000000018,
-  CUPSD_EVENT_IPP_PRINTER_MEDIA_CHANGED = 0x00000008,
-  CUPSD_EVENT_IPP_PRINTER_FINISHINGS_CHANGED = 0x00000010,
-  CUPSD_EVENT_IPP_PRINTER_QUEUE_ORDER_CHANGED = 0x00000020,
-  CUPSD_EVENT_IPP_JOB_STATE_CHANGED = 0x000001c0,
-  CUPSD_EVENT_IPP_JOB_CREATED = 0x00000040,
-  CUPSD_EVENT_IPP_JOB_COMPLETED = 0x00000080,
-  CUPSD_EVENT_IPP_JOB_STOPPED = 0x00000100,
-  CUPSD_EVENT_IPP_JOB_CONFIG_CHANGED = 0x00000200,
-  CUPSD_EVENT_IPP_JOB_PROGRESS = 0x00000400,
-
-  /* CUPS event extensions */
-  CUPSD_EVENT_CUPS_QUEUE = 0x003f0000,
-  CUPSD_EVENT_CUPS_QUEUE_ADDED = 0x00030000,
-  CUPSD_EVENT_CUPS_PRINTER_ADDED = 0x00010000,
-  CUPSD_EVENT_CUPS_CLASS_ADDED = 0x00020000,
-  CUPSD_EVENT_CUPS_QUEUE_CHANGED = 0x000c0000,
-  CUPSD_EVENT_CUPS_PRINTER_CHANGED = 0x00040000,
-  CUPSD_EVENT_CUPS_CLASS_CHANGED = 0x00080000,
-  CUPSD_EVENT_CUPS_QUEUE_DELETED = 0x00300000,
-  CUPSD_EVENT_CUPS_PRINTER_DELETED = 0x00100000,
-  CUPSD_EVENT_CUPS_CLASS_DELETED = 0x00200000,
-  CUPSD_EVENT_CUPS_JOB_MOVED = 0x00400000,
-  CUPSD_EVENT_CUPS_DEVICE = 0x03800000,
-  CUPSD_EVENT_CUPS_DEVICE_ADDED = 0x00800000,
-  CUPSD_EVENT_CUPS_DEVICE_CHANGED = 0x01000000,
-  CUPSD_EVENT_CUPS_DEVICE_DELETED = 0x02000000,
-  CUPSD_EVENT_CUPS_OPERATION = 0x04000000
-};
-
-
-/*
- * Types and structures...
- */
-
-typedef struct cupsd_subscription_s	/**** Subscription object ****/
-{
-  struct cupsd_subscription_s *next;	/* Pointer to next subscription */
-  int		id;			/* subscription-id */
-  unsigned	mask;			/* Event mask */
-  ipp_t		*attrs;			/* Subscription attributes */
-  int		job_id;			/* Subscription Job ID */
-  char		*dest;			/* Subscription printer/class  */
-  cups_ptype_t	dtype;			/* Type of destination */
-  char		*recipient;		/* Recipient of subscription */
-  int		pid;			/* PID of notifier process */
-  int		notify_pipe;		/* Pipe to process */
-  int		status_pipe;		/* Pipe from process */
-  int		status;			/* Exit status of notifier */
-  char		*buffer;		/* Status buffer */
-  int		bufused;		/* Amount of buffer in use */
-  time_t	last_time;		/* Time of last notification */
-} cupsd_subscription_t;
-
-typedef struct cupsd_event_s		/**** Event object ****/
-{
-  struct cupsd_event_s *next;		/* Pointer to next event */
-  int		id;			/* event-id */
-  time_t	event_time;		/* event-time */
-  ipp_t		*attrs;			/* Event attributes */
-  unsigned	mask;			/* Event mask */
-  int		job_id;			/* Event job ID */
-  char		*dest;			/* Event printer/class */
-  cups_ptype_t	dtype;			/* Type of destination */
-} cupsd_event_t;
-
-
-/*
- * Globals...
- */
-
-
-VAR int			NumEvents	VALUE(0),
-					/* Number of active events */
-			MaxEvents	VALUE(100);
-					/* Maximum number of events to hold */
-VAR cupsd_event_t	*Events		VALUE(NULL),
-					/* List of events */
-			*LastEvent	VALUE(NULL);
-					/* Last event in list */
-
-VAR int			MaxSubscriptions VALUE(100),
-					/* Maximum number of subscriptions */
-			MaxSubscriptionsPerUser VALUE(0),
-					/* Maximum subscriptions per user */
-			MaxSubscriptionsPerPrinter VALUE(0),
-					/* Maximum subscriptions per printer */
-			MaxSubscriptionsPerJob VALUE(0),
-					/* Maximum subscriptions per job */
-			NumSubscriptions VALUE(0);
-					/* Number of subscriptions */
-VAR cupsd_subscription_t *Subscriptions	VALUE(NULL),
-					/* List of subscriptions */
-			*LastSubcription VALUE(NULL);
-					/* Last subscription in list */
-
-
-/*
- * End of "$Id: notify.h 4719 2005-09-28 21:12:44Z mike $".
- */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/printers.c cupsys-1.1.99.b1.r4748/scheduler/printers.c
--- cupsys-1.1.99.b1.r4748~/scheduler/printers.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/printers.c	2005-11-12 12:27:16.422457000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: printers.c 4729 2005-09-30 17:46:19Z mike $"
+ * "$Id: printers.c 4830 2005-11-12 03:27:16Z mike $"
  *
  *   Printer routines for the Common UNIX Printing System (CUPS).
  *
@@ -38,6 +38,7 @@
  *   cupsdSetPrinterReasons()    - Set/update the reasons strings.
  *   cupsdSetPrinterState()      - Update the current state of a printer.
  *   cupsdStopPrinter()          - Stop a printer from printing any jobs...
+ *   cupsdUpdatePrinters()       - Update printers after a partial reload.
  *   cupsdValidateDest()         - Validate a printer/class destination.
  *   cupsdWritePrintcap()        - Write a pseudo-printcap file for older
  *                                 applications that need it...
@@ -126,6 +127,9 @@
 
   cupsArrayAdd(Printers, p);
 
+  if (!ImplicitPrinters)
+    ImplicitPrinters = cupsArrayNew(compare_printers, NULL);
+
  /*
   * Write a new /etc/printcap or /var/spool/lp/pstatus file.
   */
@@ -537,6 +541,12 @@
   DEBUG_printf(("cupsdDeletePrinter(%08x): p->name = \"%s\"...\n", p, p->name));
 
  /*
+  * Stop printing on this printer...
+  */
+
+  cupsdStopPrinter(p, update);
+
+ /*
   * If this printer is the next for browsing, point to the next one...
   */
 
@@ -553,12 +563,6 @@
   cupsArrayRemove(Printers, p);
 
  /*
-  * Stop printing on this printer...
-  */
-
-  cupsdStopPrinter(p, update);
-
- /*
   * Remove the dummy interface/icon/option files under IRIX...
   */
 
@@ -1142,8 +1146,11 @@
   snprintf(backup, sizeof(backup), "%s/printers.conf.O", ServerRoot);
 
   if (rename(temp, backup))
-    cupsdLogMessage(CUPSD_LOG_ERROR,
-                    "Unable to backup printers.conf - %s", strerror(errno));
+  {
+    if (errno != ENOENT)
+      cupsdLogMessage(CUPSD_LOG_ERROR,
+                      "Unable to backup printers.conf - %s", strerror(errno));
+  }
 
   if ((fp = cupsFileOpen(temp, "w")) == NULL)
   {
@@ -1171,7 +1178,7 @@
 
   curtime = time(NULL);
   curdate = localtime(&curtime);
-  strftime(temp, sizeof(temp) - 1, "%c", curdate);
+  strftime(temp, sizeof(temp) - 1, "%Y-%m-%d %H:%M", curdate);
 
   cupsFilePuts(fp, "# Printer configuration file for " CUPS_SVERSION "\n");
   cupsFilePrintf(fp, "# Written by cupsd on %s\n", temp);
@@ -1419,8 +1426,10 @@
     ippAddString(p->attrs, IPP_TAG_PRINTER, IPP_TAG_URI,
 	         "printer-uri-supported", NULL, p->uri);
 
-    ippAddString(p->attrs, IPP_TAG_PRINTER, IPP_TAG_TEXT,
-                 "printer-make-and-model", NULL, p->make_model);
+    if (p->make_model)
+      ippAddString(p->attrs, IPP_TAG_PRINTER, IPP_TAG_TEXT,
+                   "printer-make-and-model", NULL, p->make_model);
+
     p->raw = 1;
   }
   else
@@ -1440,7 +1449,8 @@
       * Add class-specific attributes...
       */
 
-      if ((p->type & CUPS_PRINTER_IMPLICIT) && p->num_printers > 0)
+      if ((p->type & CUPS_PRINTER_IMPLICIT) && p->num_printers > 0 &&
+          p->printers[0]->make_model)
 	ippAddString(p->attrs, IPP_TAG_PRINTER, IPP_TAG_TEXT,
                      "printer-make-and-model", NULL, p->printers[0]->make_model);
       else
@@ -1544,8 +1554,9 @@
 	else
 	  cupsdSetString(&p->make_model, "Bad PPD File");
 
-	ippAddString(p->attrs, IPP_TAG_PRINTER, IPP_TAG_TEXT,
-                     "printer-make-and-model", NULL, p->make_model);
+        if (p->make_model)
+	  ippAddString(p->attrs, IPP_TAG_PRINTER, IPP_TAG_TEXT,
+                       "printer-make-and-model", NULL, p->make_model);
 
        /*
 	* Add media options from the PPD file...
@@ -2084,6 +2095,42 @@
 
 
 /*
+ * 'cupsdUpdatePrinters()' - Update printers after a partial reload.
+ */
+
+void
+cupsdUpdatePrinters(void)
+{
+  cupsd_printer_t	*p;		/* Current printer */
+
+
+ /*
+  * Loop through the printers and recreate the printer attributes
+  * for any local printers since the policy and/or access control
+  * stuff may have changed.  Also, if browsing is disabled, remove
+  * any remote printers...
+  */
+
+  for (p = (cupsd_printer_t *)cupsArrayFirst(Printers);
+       p;
+       p = (cupsd_printer_t *)cupsArrayNext(Printers))
+  {
+    if (!Browsing && (p->type & (CUPS_PRINTER_IMPLICIT | CUPS_PRINTER_REMOTE)))
+    {
+      if (p->type & CUPS_PRINTER_IMPLICIT)
+        cupsArrayRemove(ImplicitPrinters, p);
+
+      cupsArraySave(Printers);
+      cupsdDeletePrinter(p, 0);
+      cupsArrayRestore(Printers);
+    }
+    else if (!(p->type & CUPS_PRINTER_REMOTE))
+      cupsdSetPrinterAttrs(p);
+  }
+}
+
+
+/*
  * 'cupsdValidateDest()' - Validate a printer/class destination.
  */
 
@@ -2686,5 +2733,5 @@
 
 
 /*
- * End of "$Id: printers.c 4729 2005-09-30 17:46:19Z mike $".
+ * End of "$Id: printers.c 4830 2005-11-12 03:27:16Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/printers.h cupsys-1.1.99.b1.r4748/scheduler/printers.h
--- cupsys-1.1.99.b1.r4748~/scheduler/printers.h	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/printers.h	2005-10-12 23:27:37.676710000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: printers.h 4719 2005-09-28 21:12:44Z mike $"
+ * "$Id: printers.h 4775 2005-10-12 14:27:37Z mike $"
  *
  *   Printer definitions for the Common UNIX Printing System (CUPS) scheduler.
  *
@@ -52,6 +52,7 @@
   cupsd_policy_t *op_policy_ptr;	/* Pointer to operation policy */
   int		shared;			/* Shared? */
   int		accepting;		/* Accepting jobs? */
+  int		in_implicit_class;	/* In an implicit class? */
   ipp_pstate_t	state;			/* Printer state */
   char		state_message[1024];	/* Printer state message */
   int		num_reasons;		/* Number of printer-state-reasons */
@@ -89,8 +90,10 @@
 
 VAR ipp_t		*CommonData	VALUE(NULL);
 					/* Common printer object attrs */
-VAR cups_array_t	*Printers	VALUE(NULL);
+VAR cups_array_t	*Printers	VALUE(NULL),
 					/* Printer list */
+			*ImplicitPrinters VALUE(NULL);
+					/* Implicit class printers */
 VAR cupsd_printer_t	*DefaultPrinter	VALUE(NULL);
 					/* Default printer */
 VAR char		*DefaultPolicy	VALUE(NULL);
@@ -125,6 +128,7 @@
 extern void		cupsdSetPrinterState(cupsd_printer_t *p, ipp_pstate_t s, int update);
 #define			cupsdStartPrinter(p,u) cupsdSetPrinterState((p), IPP_PRINTER_IDLE, (u))
 extern void		cupsdStopPrinter(cupsd_printer_t *p, int update);
+extern void		cupsdUpdatePrinters(void);
 extern cupsd_quota_t	*cupsdUpdateQuota(cupsd_printer_t *p, const char *username,
 			                  int pages, int k);
 extern const char	*cupsdValidateDest(const char *hostname,
@@ -138,5 +142,5 @@
 
 
 /*
- * End of "$Id: printers.h 4719 2005-09-28 21:12:44Z mike $".
+ * End of "$Id: printers.h 4775 2005-10-12 14:27:37Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/server.c cupsys-1.1.99.b1.r4748/scheduler/server.c
--- cupsys-1.1.99.b1.r4748~/scheduler/server.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/server.c	2005-11-12 12:27:16.422457000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: server.c 4719 2005-09-28 21:12:44Z mike $"
+ * "$Id: server.c 4830 2005-11-12 03:27:16Z mike $"
  *
  *   Server start/stop routines for the Common UNIX Printing System (CUPS).
  *
@@ -33,11 +33,17 @@
 
 #include <cups/http-private.h>
 #include "cupsd.h"
-
 #include <grp.h>
 
 
 /*
+ * Local globals...
+ */
+
+static int	started = 0;
+
+
+/*
  * 'cupsdStartServer()' - Start the server.
  */
 
@@ -77,8 +83,6 @@
   */
 
   gnutls_global_init();
-#elif defined(HAVE_CDSASSL)
-  ServerCertificatesArray = CDSAGetServerCerts();
 #endif /* HAVE_LIBSSL */
 
  /*
@@ -105,6 +109,8 @@
 		    CGIPipes[0]);
     FD_SET(CGIPipes[0], InputSet);
   }
+
+  started = 1;
 }
 
 
@@ -115,6 +121,9 @@
 void
 cupsdStopServer(void)
 {
+  if (!started)
+    return;
+
  /*
   * Close all network clients and stop all jobs...
   */
@@ -123,6 +132,8 @@
   cupsdStopListening();
   cupsdStopPolling();
   cupsdStopBrowsing();
+  cupsdStopAllNotifiers();
+  cupsdSaveRemoteCache();
 
   if (Clients != NULL)
   {
@@ -185,9 +196,11 @@
 
     PageFile = NULL;
   }
+
+  started = 0;
 }
 
 
 /*
- * End of "$Id: server.c 4719 2005-09-28 21:12:44Z mike $".
+ * End of "$Id: server.c 4830 2005-11-12 03:27:16Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/subscriptions.c cupsys-1.1.99.b1.r4748/scheduler/subscriptions.c
--- cupsys-1.1.99.b1.r4748~/scheduler/subscriptions.c	2005-09-29 06:12:44.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/subscriptions.c	2005-11-12 12:27:16.422457000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: subscriptions.c 4719 2005-09-28 21:12:44Z mike $"
+ * "$Id: subscriptions.c 4830 2005-11-12 03:27:16Z mike $"
  *
  *   Subscription routines for the Common UNIX Printing System (CUPS) scheduler.
  *
@@ -36,6 +36,7 @@
  *   cupsdStopAllNotifiers()       - Stop all notifier processes.
  *   cupsdUpdateNotifierStatus()   - Read messages from notifiers.
  *   cupsd_delete_event()          - Delete a single event...
+ *   cupsd_start_notifier()        - Start a notifier subprocess...
  */
 
 /*
@@ -50,6 +51,7 @@
  */
 
 static void	cupsd_delete_event(cupsd_event_t *event);
+static void	cupsd_start_notifier(cupsd_subscription_t *sub);
 
 
 /*
@@ -366,8 +368,9 @@
 
   temp->id             = NextSubscriptionId;
   temp->mask           = mask;
-  temp->job            = job;
   temp->dest           = dest;
+  temp->job            = job;
+  temp->pipe           = -1;
   temp->first_event_id = 1;
   temp->next_event_id  = 1;
 
@@ -440,6 +443,13 @@
 
 
  /*
+  * Close the pipe to the notifier as needed...
+  */
+
+  if (sub->pipe >= 0)
+    close(sub->pipe);
+
+ /*
   * Free memory...
   */
 
@@ -1075,8 +1085,11 @@
   snprintf(backup, sizeof(backup), "%s/subscriptions.conf.O", ServerRoot);
 
   if (rename(temp, backup))
-    cupsdLogMessage(CUPSD_LOG_ERROR, "Unable to backup subscriptions.conf - %s",
-                    strerror(errno));
+  {
+    if (errno != ENOENT)
+      cupsdLogMessage(CUPSD_LOG_ERROR, "Unable to backup subscriptions.conf - %s",
+                      strerror(errno));
+  }
 
   if ((fp = cupsFileOpen(temp, "w")) == NULL)
   {
@@ -1105,7 +1118,7 @@
 
   curtime = time(NULL);
   curdate = localtime(&curtime);
-  strftime(temp, sizeof(temp) - 1, "%c", curdate);
+  strftime(temp, sizeof(temp) - 1, "%Y-%m-%d %H:%M", curdate);
 
   cupsFilePuts(fp, "# Subscription configuration file for " CUPS_SVERSION "\n");
   cupsFilePrintf(fp, "# Written by cupsd on %s\n", temp);
@@ -1209,6 +1222,9 @@
     cupsd_subscription_t *sub,		/* I - Subscription object */
     cupsd_event_t        *event)	/* I - Event to send */
 {
+  ipp_state_t	state;			/* IPP event state */
+
+
   cupsdLogMessage(CUPSD_LOG_DEBUG,
                   "cupsdSendNotification(sub=%p(%d), event=%p(%s))\n",
                   sub, sub->id, event, cupsdEventName(event->event));
@@ -1244,7 +1260,25 @@
   * Deliver the event...
   */
 
-  /**** TODO ****/
+  if (sub->recipient)
+  {
+    if (sub->pipe < 0)
+      cupsd_start_notifier(sub);
+
+    if (sub->pipe >= 0)
+    {
+      event->attrs->state = IPP_IDLE;
+
+      while ((state = ippWriteFile(sub->pipe, event->attrs)) != IPP_DATA)
+        if (state == IPP_ERROR)
+	  break;
+
+      if (state == IPP_ERROR)
+        cupsdLogMessage(CUPSD_LOG_ERROR,
+	                "Unable to send event for subscription %d (%s)!",
+			sub->id, sub->recipient);
+    }
+  }
 
  /*
   * Bump the event sequence number...
@@ -1293,19 +1327,22 @@
   * Close the status pipes...
   */
 
-  cupsdLogMessage(CUPSD_LOG_DEBUG2,
-                  "cupsdStopAllNotifiers: Removing fd %d from InputSet...",
-	          NotifierPipes[0]);
-  FD_CLR(NotifierPipes[0], InputSet);
+  if (NotifierPipes[0] >= 0)
+  {
+    cupsdLogMessage(CUPSD_LOG_DEBUG2,
+                    "cupsdStopAllNotifiers: Removing fd %d from InputSet...",
+	            NotifierPipes[0]);
+    FD_CLR(NotifierPipes[0], InputSet);
 
-  cupsdStatBufDelete(NotifierStatusBuffer);
+    cupsdStatBufDelete(NotifierStatusBuffer);
 
-  close(NotifierPipes[0]);
-  close(NotifierPipes[1]);
+    close(NotifierPipes[0]);
+    close(NotifierPipes[1]);
 
-  NotifierPipes[0] = -1;
-  NotifierPipes[1] = -1;
-  NotifierStatusBuffer = NULL;
+    NotifierPipes[0] = -1;
+    NotifierPipes[1] = -1;
+    NotifierStatusBuffer = NULL;
+  }
 }
 
 
@@ -1314,7 +1351,7 @@
  */
 
 void
-cupsdUpdateNotiferStatus(void)
+cupsdUpdateNotifierStatus(void)
 {
   char		*ptr,			/* Pointer to end of line in buffer */
 		message[1024];		/* Pointer to message text */
@@ -1325,17 +1362,6 @@
                                    message, sizeof(message))) != NULL)
     if (!strchr(NotifierStatusBuffer->buffer, '\n'))
       break;
-
-  if (ptr == NULL)
-  {
-   /*
-    * Fatal error on pipe - should never happen!
-    */
-
-    cupsdLogMessage(CUPSD_LOG_CRIT,
-                    "cupsdUpdateNotifierStatus: error reading from notifier error pipe - %s",
-                    strerror(errno));
-  }
 }
 
 
@@ -1397,5 +1423,132 @@
 
 
 /*
- * End of "$Id: subscriptions.c 4719 2005-09-28 21:12:44Z mike $".
+ * 'cupsd_start_notifier()' - Start a notifier subprocess...
+ */
+
+static void
+cupsd_start_notifier(
+    cupsd_subscription_t *sub)		/* I - Subscription object */
+{
+  int	pid;				/* Notifier process ID */
+  int	fds[2];				/* Pipe file descriptors */
+  int	envc;				/* Number of environment variables */
+  char	*argv[4],			/* Command-line arguments */
+	*envp[100],			/* Environment variables */
+	user_data[128],			/* Base-64 encoded user data */
+	scheme[256],			/* notify-recipient-uri scheme */
+	*ptr,				/* Pointer into scheme */
+	command[1024];			/* Notifier command */
+
+
+ /*
+  * Extract the scheme name from the recipient URI and point to the
+  * notifier program...
+  */
+
+  strlcpy(scheme, sub->recipient, sizeof(scheme));
+  if ((ptr = strchr(scheme, ':')) != NULL)
+    *ptr = '\0';
+
+  snprintf(command, sizeof(command), "%s/notifier/%s", ServerBin, scheme);
+
+ /*
+  * Base-64 encode the user data...
+  */
+
+  httpEncode64_2(user_data, sizeof(user_data), (char *)sub->user_data,
+                 sub->user_data_len);
+
+ /*
+  * Setup the argument array...
+  */
+
+  argv[0] = command;
+  argv[1] = sub->recipient;
+  argv[2] = user_data;
+  argv[3] = NULL;
+
+ /*
+  * Setup the environment...
+  */
+
+  envc = cupsdLoadEnv(envp, (int)(sizeof(envp) / sizeof(envp[0])));
+
+ /*
+  * Create pipes as needed...
+  */
+
+  if (!NotifierStatusBuffer)
+  {
+   /*
+    * Create the status pipe...
+    */
+
+    if (cupsdOpenPipe(NotifierPipes))
+    {
+      cupsdLogMessage(CUPSD_LOG_ERROR,
+                      "Unable to create pipes for notifier status - %s",
+		      strerror(errno));
+      return;
+    }
+
+    NotifierStatusBuffer = cupsdStatBufNew(NotifierPipes[0], "[Notifier]");
+
+    cupsdLogMessage(CUPSD_LOG_DEBUG2,
+                    "start_notifier: Adding fd %d to InputSet...",
+		    NotifierPipes[0]);
+
+    FD_SET(NotifierPipes[0], InputSet);
+  }
+
+  if (cupsdOpenPipe(fds))
+  {
+    cupsdLogMessage(CUPSD_LOG_ERROR,
+                    "Unable to create pipes for notifier %s - %s",
+		    scheme, strerror(errno));
+    return;
+  }
+
+ /*
+  * Make sure the delivery pipe is non-blocking...
+  */
+
+  fcntl(fds[1], F_SETFL, fcntl(fds[1], F_GETFL) | O_NONBLOCK);
+
+ /*
+  * Create the notifier process...
+  */
+
+  if (cupsdStartProcess(command, argv, envp, fds[0], -1, NotifierPipes[1],
+			-1, 0, &pid) < 0)
+  {
+   /*
+    * Error - can't fork!
+    */
+
+    cupsdLogMessage(CUPSD_LOG_ERROR, "Unable to fork for notifier %s - %s",
+                    scheme, strerror(errno));
+
+    cupsdClosePipe(fds);
+  }
+  else
+  {
+   /*
+    * Fork successful - return the PID...
+    */
+
+    cupsdLogMessage(CUPSD_LOG_DEBUG, "Notifier %s started - PID = %d",
+                    scheme, pid);
+
+    sub->pid    = pid;
+    sub->pipe   = fds[1];
+    sub->status = 0;
+
+    close(fds[0]);
+  }
+}
+
+
+/*
+ * End of "$Id: subscriptions.c 4830 2005-11-12 03:27:16Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/subscriptions.h cupsys-1.1.99.b1.r4748/scheduler/subscriptions.h
--- cupsys-1.1.99.b1.r4748~/scheduler/subscriptions.h	2005-09-29 06:12:44.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/subscriptions.h	2005-11-12 12:15:10.305626000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: subscriptions.h 4719 2005-09-28 21:12:44Z mike $"
+ * "$Id: subscriptions.h 4829 2005-11-12 03:15:10Z mike $"
  *
  *   Subscription definitions for the Common UNIX Printing System (CUPS) scheduler.
  *
@@ -168,9 +168,9 @@
 extern void	cupsdSendNotification(cupsd_subscription_t *sub,
 		                      cupsd_event_t *event);
 extern void	cupsdStopAllNotifiers(void);
-extern void	cupsdUpdateNotiferStatus(void);
+extern void	cupsdUpdateNotifierStatus(void);
 
 
 /*
- * End of "$Id: subscriptions.h 4719 2005-09-28 21:12:44Z mike $".
+ * End of "$Id: subscriptions.h 4829 2005-11-12 03:15:10Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/testdirsvc.c cupsys-1.1.99.b1.r4748/scheduler/testdirsvc.c
--- cupsys-1.1.99.b1.r4748~/scheduler/testdirsvc.c	1970-01-01 09:00:00.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/testdirsvc.c	2005-11-05 04:36:39.870260000 +0900
@@ -0,0 +1,275 @@
+/*
+ * "$Id: testdirsvc.c 4821 2005-11-04 19:36:39Z mike $"
+ *
+ *   Browsing test program for the Common UNIX Printing System (CUPS).
+ *
+ *   Copyright 1997-2005 by Easy Software Products, all rights reserved.
+ *
+ *   These coded instructions, statements, and computer programs are the
+ *   property of Easy Software Products and are protected by Federal
+ *   copyright law.  Distribution and use rights are outlined in the file
+ *   "LICENSE.txt" which should have been included with this file.  If this
+ *   file is missing or damaged please contact Easy Software Products
+ *   at:
+ *
+ *       Attn: CUPS Licensing Information
+ *       Easy Software Products
+ *       44141 Airport View Drive, Suite 204
+ *       Hollywood, Maryland 20636 USA
+ *
+ *       Voice: (301) 373-9600
+ *       EMail: cups-info@cups.org
+ *         WWW: http://www.cups.org
+ *
+ * Contents:
+ *
+ *   main()  - Simulate one or more remote printers.
+ *   usage() - Show program usage...
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include <cups/cups.h>
+#include <cups/string.h>
+#include <stdlib.h>
+#include <errno.h>
+
+
+/*
+ * Local functions...
+ */
+
+void	usage(void);
+
+
+/*
+ * 'main()' - Simulate one or more remote printers.
+ */
+
+int					/* O - Exit status */
+main(int  argc,				/* I - Number of command-line arguments */
+     char *argv[])			/* I - Command-line arguments */
+{
+  int		i,			/* Looping var */
+		printer,		/* Current printer */
+		num_printers,		/* Number of printers */
+		server,			/* Current server */
+		num_servers,		/* Number of servers */
+		count,			/* Number of printers sent this cycle */
+		interval,		/* Browse Interval */
+		continuous,		/* Run continuously? */
+		port,			/* Browse port */
+		sock,			/* Browse socket */
+		val,			/* Socket option value */
+		seconds,		/* Seconds until next cycle */
+		verbose;		/* Verbose output? */
+  const char	*options;		/* Options for URIs */
+  time_t	curtime;		/* Current UNIX time */
+  struct tm	*curdate;		/* Current date and time */
+  struct sockaddr_in addr;		/* Broadcast address */
+  char		packet[1540];		/* Data packet */
+  static const char * const names[26] =	/* Printer names */
+		{
+		  "alpha",
+		  "bravo",
+		  "charlie",
+		  "delta",
+		  "echo",
+		  "foxtrot",
+		  "golf",
+		  "hotel",
+		  "india",
+		  "juliet",
+		  "kilo",
+		  "lima",
+		  "mike",
+		  "november",
+		  "oscar",
+		  "papa",
+		  "quebec",
+		  "romeo",
+		  "sierra",
+		  "tango",
+		  "uniform",
+		  "victor",
+		  "wiskey",
+		  "x-ray",
+		  "yankee",
+		  "zulu"
+		};
+
+
+ /*
+  * Process command-line arguments...
+  */
+
+  num_printers = 10;
+  num_servers  = 1;
+  interval     = 30;
+  port         = 0;
+  verbose      = 0;
+  continuous   = 0;
+  options      = NULL;
+
+  for (i = 1; i < argc; i ++)
+  {
+    if (!strcmp(argv[i], "-c"))
+      continuous = 1;
+    if (!strcmp(argv[i], "-v"))
+      verbose = 1;
+    else if (!strcmp(argv[i], "-i"))
+    {
+      i ++;
+      if (i < argc)
+        interval = atoi(argv[i]);
+      else
+        usage();
+    }
+    else if (!strcmp(argv[i], "-o"))
+    {
+      i ++;
+      if (i < argc)
+        options = argv[i];
+      else
+        usage();
+    }
+    else if (!strcmp(argv[i], "-p"))
+    {
+      i ++;
+      if (i < argc)
+        num_printers = atoi(argv[i]);
+      else
+        usage();
+    }
+    else if (!strcmp(argv[i], "-s"))
+    {
+      i ++;
+      if (i < argc)
+        num_servers = atoi(argv[i]);
+      else
+        usage();
+    }
+    else if (isdigit(argv[i][0] & 255))
+    {
+      port = atoi(argv[i]);
+    }
+    else
+      usage();
+  }
+
+  if (num_printers <= 0 || num_servers <= 0 || interval <= 0 || port <= 0)
+    usage();
+
+ /*
+  * Open a broadcast socket...
+  */
+
+  if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
+  {
+    perror("Unable to open broadcast socket");
+    return (1);
+  }
+
+ /*
+  * Set the "broadcast" flag...
+  */
+
+  val = 1;
+  if (setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &val, sizeof(val)))
+  {
+    perror("Unable to put socket in broadcast mode");
+
+    close(sock);
+    return (1);
+  }
+
+ /*
+  * Broadcast to 127.0.0.1 (localhost)
+  */
+
+  memset(&addr, 0, sizeof(addr));
+  addr.sin_addr.s_addr = htonl(0x7f000001);
+  addr.sin_family      = AF_INET;
+  addr.sin_port        = htons(port);
+
+ /*
+  * Send virtual printers continuously until we are stopped.
+  */
+
+  for (;;)
+  {
+   /*
+    * Start a new cycle of N printers...
+    */
+
+    printf("Sending %d printers from %d servers...\n", num_printers,
+           num_servers);
+
+    count   = num_servers * num_printers / interval + 1;
+    curtime = time(NULL);
+    curdate = localtime(&curtime);
+    seconds = interval;
+
+    for (i = 0, printer = 0; printer < num_printers; printer ++)
+    {
+      for (server = 0; server < num_servers; server ++, i ++)
+      {
+        if (i == count)
+	{
+	  seconds --;
+	  i = 0;
+	  sleep(1);
+	  curtime = time(NULL);
+	  curdate = localtime(&curtime);
+	}
+
+        snprintf(packet, sizeof(packet),
+	         "%x %x ipp://testserver-%d/printers/%s-%d \"Server Room %d\" "
+		 "\"Test Printer %d\" \"Acme Blazer 2000\"%s%s\n",
+                 CUPS_PRINTER_REMOTE, IPP_PRINTER_IDLE, server + 1,
+		 names[printer % 26], printer / 26 + 1, server + 1,
+		 printer + 1, options ? " ipp-options=" : "",
+		 options ? options : "");
+
+        if (verbose)
+	  printf("[%02d:%02d:%02d] %s", curdate->tm_hour, curdate->tm_min,
+	         curdate->tm_sec, packet);
+
+        if (sendto(sock, packet, strlen(packet), 0,
+	           (struct sockaddr *)&addr, sizeof(addr)) < 0)
+	  perror("Unabled to send packet");
+      }
+    }
+
+    if (!continuous)
+      break;
+
+   /*
+    * Sleep for any remaining time...
+    */
+
+    if (seconds > 0) 
+      sleep(seconds);
+  }
+
+  return (0);
+}
+
+
+/*
+ * 'usage()' - Show program usage...
+ */
+
+void
+usage(void)
+{
+  puts("Usage: testdirsvc [-i interval] [-o ipp-options] [-p printers] [-s servers] [-v] port");
+  exit(0);
+}
+
+
+/*
+ * End of "$Id: testdirsvc.c 4821 2005-11-04 19:36:39Z mike $".
+ */
diff -urNad cupsys-1.1.99.b1.r4748~/scheduler/testspeed.c cupsys-1.1.99.b1.r4748/scheduler/testspeed.c
--- cupsys-1.1.99.b1.r4748~/scheduler/testspeed.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/scheduler/testspeed.c	2005-10-19 03:06:20.449904000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: testspeed.c 4724 2005-09-29 20:00:39Z mike $"
+ * "$Id: testspeed.c 4800 2005-10-18 18:06:20Z mike $"
  *
  *   Scheduler speed test for the Common UNIX Printing System (CUPS).
  *
@@ -225,7 +225,8 @@
   for (elapsed = 0.0, i = 0; i < requests; i ++)
   {
     if (verbose && (i % 10) == 0)
-      printf("testspeed(%d): %d%% complete...\n", getpid(), i * 100 / requests);
+      printf("testspeed(%d): %d%% complete...\n", (int)getpid(),
+             i * 100 / requests);
 
    /*
     * Build a request which requires the following attributes:
@@ -280,7 +281,7 @@
   httpClose(http);
 
   printf("testspeed(%d): %d requests in %.1fs (%.3fs/r, %.1fr/s)\n",
-         getpid(), i, elapsed, elapsed / i, i / elapsed);
+         (int)getpid(), i, elapsed, elapsed / i, i / elapsed);
 
   return (0);
 }
@@ -300,5 +301,5 @@
 
 
 /*
- * End of "$Id: testspeed.c 4724 2005-09-29 20:00:39Z mike $".
+ * End of "$Id: testspeed.c 4800 2005-10-18 18:06:20Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/standards/rfc2396.txt cupsys-1.1.99.b1.r4748/standards/rfc2396.txt
--- cupsys-1.1.99.b1.r4748~/standards/rfc2396.txt	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/standards/rfc2396.txt	1970-01-01 09:00:00.000000000 +0900
@@ -1,2243 +0,0 @@
-
-
-
-
-
-
-Network Working Group                                     T. Berners-Lee
-Request for Comments: 2396                                       MIT/LCS
-Updates: 1808, 1738                                          R. Fielding
-Category: Standards Track                                    U.C. Irvine
-                                                             L. Masinter
-                                                       Xerox Corporation
-                                                             August 1998
-
-
-           Uniform Resource Identifiers (URI): Generic Syntax
-
-Status of this Memo
-
-   This document specifies an Internet standards track protocol for the
-   Internet community, and requests discussion and suggestions for
-   improvements.  Please refer to the current edition of the "Internet
-   Official Protocol Standards" (STD 1) for the standardization state
-   and status of this protocol.  Distribution of this memo is unlimited.
-
-Copyright Notice
-
-   Copyright (C) The Internet Society (1998).  All Rights Reserved.
-
-IESG Note
-
-   This paper describes a "superset" of operations that can be applied
-   to URI.  It consists of both a grammar and a description of basic
-   functionality for URI.  To understand what is a valid URI, both the
-   grammar and the associated description have to be studied.  Some of
-   the functionality described is not applicable to all URI schemes, and
-   some operations are only possible when certain media types are
-   retrieved using the URI, regardless of the scheme used.
-
-Abstract
-
-   A Uniform Resource Identifier (URI) is a compact string of characters
-   for identifying an abstract or physical resource.  This document
-   defines the generic syntax of URI, including both absolute and
-   relative forms, and guidelines for their use; it revises and replaces
-   the generic definitions in RFC 1738 and RFC 1808.
-
-   This document defines a grammar that is a superset of all valid URI,
-   such that an implementation can parse the common components of a URI
-   reference without knowing the scheme-specific requirements of every
-   possible identifier type.  This document does not define a generative
-   grammar for URI; that task will be performed by the individual
-   specifications of each URI scheme.
-
-
-
-
-Berners-Lee, et. al.        Standards Track                     [Page 1]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-1. Introduction
-
-   Uniform Resource Identifiers (URI) provide a simple and extensible
-   means for identifying a resource.  This specification of URI syntax
-   and semantics is derived from concepts introduced by the World Wide
-   Web global information initiative, whose use of such objects dates
-   from 1990 and is described in "Universal Resource Identifiers in WWW"
-   [RFC1630].  The specification of URI is designed to meet the
-   recommendations laid out in "Functional Recommendations for Internet
-   Resource Locators" [RFC1736] and "Functional Requirements for Uniform
-   Resource Names" [RFC1737].
-
-   This document updates and merges "Uniform Resource Locators"
-   [RFC1738] and "Relative Uniform Resource Locators" [RFC1808] in order
-   to define a single, generic syntax for all URI.  It excludes those
-   portions of RFC 1738 that defined the specific syntax of individual
-   URL schemes; those portions will be updated as separate documents, as
-   will the process for registration of new URI schemes.  This document
-   does not discuss the issues and recommendation for dealing with
-   characters outside of the US-ASCII character set [ASCII]; those
-   recommendations are discussed in a separate document.
-
-   All significant changes from the prior RFCs are noted in Appendix G.
-
-1.1 Overview of URI
-
-   URI are characterized by the following definitions:
-
-      Uniform
-         Uniformity provides several benefits: it allows different types
-         of resource identifiers to be used in the same context, even
-         when the mechanisms used to access those resources may differ;
-         it allows uniform semantic interpretation of common syntactic
-         conventions across different types of resource identifiers; it
-         allows introduction of new types of resource identifiers
-         without interfering with the way that existing identifiers are
-         used; and, it allows the identifiers to be reused in many
-         different contexts, thus permitting new applications or
-         protocols to leverage a pre-existing, large, and widely-used
-         set of resource identifiers.
-
-      Resource
-         A resource can be anything that has identity.  Familiar
-         examples include an electronic document, an image, a service
-         (e.g., "today's weather report for Los Angeles"), and a
-         collection of other resources.  Not all resources are network
-         "retrievable"; e.g., human beings, corporations, and bound
-         books in a library can also be considered resources.
-
-
-
-Berners-Lee, et. al.        Standards Track                     [Page 2]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-         The resource is the conceptual mapping to an entity or set of
-         entities, not necessarily the entity which corresponds to that
-         mapping at any particular instance in time.  Thus, a resource
-         can remain constant even when its content---the entities to
-         which it currently corresponds---changes over time, provided
-         that the conceptual mapping is not changed in the process.
-
-      Identifier
-         An identifier is an object that can act as a reference to
-         something that has identity.  In the case of URI, the object is
-         a sequence of characters with a restricted syntax.
-
-   Having identified a resource, a system may perform a variety of
-   operations on the resource, as might be characterized by such words
-   as `access', `update', `replace', or `find attributes'.
-
-1.2. URI, URL, and URN
-
-   A URI can be further classified as a locator, a name, or both.  The
-   term "Uniform Resource Locator" (URL) refers to the subset of URI
-   that identify resources via a representation of their primary access
-   mechanism (e.g., their network "location"), rather than identifying
-   the resource by name or by some other attribute(s) of that resource.
-   The term "Uniform Resource Name" (URN) refers to the subset of URI
-   that are required to remain globally unique and persistent even when
-   the resource ceases to exist or becomes unavailable.
-
-   The URI scheme (Section 3.1) defines the namespace of the URI, and
-   thus may further restrict the syntax and semantics of identifiers
-   using that scheme.  This specification defines those elements of the
-   URI syntax that are either required of all URI schemes or are common
-   to many URI schemes.  It thus defines the syntax and semantics that
-   are needed to implement a scheme-independent parsing mechanism for
-   URI references, such that the scheme-dependent handling of a URI can
-   be postponed until the scheme-dependent semantics are needed.  We use
-   the term URL below when describing syntax or semantics that only
-   apply to locators.
-
-   Although many URL schemes are named after protocols, this does not
-   imply that the only way to access the URL's resource is via the named
-   protocol.  Gateways, proxies, caches, and name resolution services
-   might be used to access some resources, independent of the protocol
-   of their origin, and the resolution of some URL may require the use
-   of more than one protocol (e.g., both DNS and HTTP are typically used
-   to access an "http" URL's resource when it can't be found in a local
-   cache).
-
-
-
-
-
-Berners-Lee, et. al.        Standards Track                     [Page 3]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-   A URN differs from a URL in that it's primary purpose is persistent
-   labeling of a resource with an identifier.  That identifier is drawn
-   from one of a set of defined namespaces, each of which has its own
-   set name structure and assignment procedures.  The "urn" scheme has
-   been reserved to establish the requirements for a standardized URN
-   namespace, as defined in "URN Syntax" [RFC2141] and its related
-   specifications.
-
-   Most of the examples in this specification demonstrate URL, since
-   they allow the most varied use of the syntax and often have a
-   hierarchical namespace.  A parser of the URI syntax is capable of
-   parsing both URL and URN references as a generic URI; once the scheme
-   is determined, the scheme-specific parsing can be performed on the
-   generic URI components.  In other words, the URI syntax is a superset
-   of the syntax of all URI schemes.
-
-1.3. Example URI
-
-   The following examples illustrate URI that are in common use.
-
-   ftp://ftp.is.co.za/rfc/rfc1808.txt
-      -- ftp scheme for File Transfer Protocol services
-
-   gopher://spinaltap.micro.umn.edu/00/Weather/California/Los%20Angeles
-      -- gopher scheme for Gopher and Gopher+ Protocol services
-
-   http://www.math.uio.no/faq/compression-faq/part1.html
-      -- http scheme for Hypertext Transfer Protocol services
-
-   mailto:mduerst@ifi.unizh.ch
-      -- mailto scheme for electronic mail addresses
-
-   news:comp.infosystems.www.servers.unix
-      -- news scheme for USENET news groups and articles
-
-   telnet://melvyl.ucop.edu/
-      -- telnet scheme for interactive services via the TELNET Protocol
-
-1.4. Hierarchical URI and Relative Forms
-
-   An absolute identifier refers to a resource independent of the
-   context in which the identifier is used.  In contrast, a relative
-   identifier refers to a resource by describing the difference within a
-   hierarchical namespace between the current context and an absolute
-   identifier of the resource.
-
-
-
-
-
-
-Berners-Lee, et. al.        Standards Track                     [Page 4]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-   Some URI schemes support a hierarchical naming system, where the
-   hierarchy of the name is denoted by a "/" delimiter separating the
-   components in the scheme. This document defines a scheme-independent
-   `relative' form of URI reference that can be used in conjunction with
-   a `base' URI (of a hierarchical scheme) to produce another URI. The
-   syntax of hierarchical URI is described in Section 3; the relative
-   URI calculation is described in Section 5.
-
-1.5. URI Transcribability
-
-   The URI syntax was designed with global transcribability as one of
-   its main concerns. A URI is a sequence of characters from a very
-   limited set, i.e. the letters of the basic Latin alphabet, digits,
-   and a few special characters.  A URI may be represented in a variety
-   of ways: e.g., ink on paper, pixels on a screen, or a sequence of
-   octets in a coded character set.  The interpretation of a URI depends
-   only on the characters used and not how those characters are
-   represented in a network protocol.
-
-   The goal of transcribability can be described by a simple scenario.
-   Imagine two colleagues, Sam and Kim, sitting in a pub at an
-   international conference and exchanging research ideas.  Sam asks Kim
-   for a location to get more information, so Kim writes the URI for the
-   research site on a napkin.  Upon returning home, Sam takes out the
-   napkin and types the URI into a computer, which then retrieves the
-   information to which Kim referred.
-
-   There are several design concerns revealed by the scenario:
-
-      o  A URI is a sequence of characters, which is not always
-         represented as a sequence of octets.
-
-      o  A URI may be transcribed from a non-network source, and thus
-         should consist of characters that are most likely to be able to
-         be typed into a computer, within the constraints imposed by
-         keyboards (and related input devices) across languages and
-         locales.
-
-      o  A URI often needs to be remembered by people, and it is easier
-         for people to remember a URI when it consists of meaningful
-         components.
-
-   These design concerns are not always in alignment.  For example, it
-   is often the case that the most meaningful name for a URI component
-   would require characters that cannot be typed into some systems.  The
-   ability to transcribe the resource identifier from one medium to
-   another was considered more important than having its URI consist of
-   the most meaningful of components.  In local and regional contexts
-
-
-
-Berners-Lee, et. al.        Standards Track                     [Page 5]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-   and with improving technology, users might benefit from being able to
-   use a wider range of characters; such use is not defined in this
-   document.
-
-1.6. Syntax Notation and Common Elements
-
-   This document uses two conventions to describe and define the syntax
-   for URI.  The first, called the layout form, is a general description
-   of the order of components and component separators, as in
-
-      <first>/<second>;<third>?<fourth>
-
-   The component names are enclosed in angle-brackets and any characters
-   outside angle-brackets are literal separators.  Whitespace should be
-   ignored.  These descriptions are used informally and do not define
-   the syntax requirements.
-
-   The second convention is a BNF-like grammar, used to define the
-   formal URI syntax.  The grammar is that of [RFC822], except that "|"
-   is used to designate alternatives.  Briefly, rules are separated from
-   definitions by an equal "=", indentation is used to continue a rule
-   definition over more than one line, literals are quoted with "",
-   parentheses "(" and ")" are used to group elements, optional elements
-   are enclosed in "[" and "]" brackets, and elements may be preceded
-   with <n>* to designate n or more repetitions of the following
-   element; n defaults to 0.
-
-   Unlike many specifications that use a BNF-like grammar to define the
-   bytes (octets) allowed by a protocol, the URI grammar is defined in
-   terms of characters.  Each literal in the grammar corresponds to the
-   character it represents, rather than to the octet encoding of that
-   character in any particular coded character set.  How a URI is
-   represented in terms of bits and bytes on the wire is dependent upon
-   the character encoding of the protocol used to transport it, or the
-   charset of the document which contains it.
-
-   The following definitions are common to many elements:
-
-      alpha    = lowalpha | upalpha
-
-      lowalpha = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" |
-                 "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" |
-                 "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
-
-      upalpha  = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" |
-                 "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" |
-                 "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z"
-
-
-
-
-Berners-Lee, et. al.        Standards Track                     [Page 6]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-      digit    = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" |
-                 "8" | "9"
-
-      alphanum = alpha | digit
-
-   The complete URI syntax is collected in Appendix A.
-
-2. URI Characters and Escape Sequences
-
-   URI consist of a restricted set of characters, primarily chosen to
-   aid transcribability and usability both in computer systems and in
-   non-computer communications. Characters used conventionally as
-   delimiters around URI were excluded.  The restricted set of
-   characters consists of digits, letters, and a few graphic symbols
-   were chosen from those common to most of the character encodings and
-   input facilities available to Internet users.
-
-      uric          = reserved | unreserved | escaped
-
-   Within a URI, characters are either used as delimiters, or to
-   represent strings of data (octets) within the delimited portions.
-   Octets are either represented directly by a character (using the US-
-   ASCII character for that octet [ASCII]) or by an escape encoding.
-   This representation is elaborated below.
-
-2.1 URI and non-ASCII characters
-
-   The relationship between URI and characters has been a source of
-   confusion for characters that are not part of US-ASCII. To describe
-   the relationship, it is useful to distinguish between a "character"
-   (as a distinguishable semantic entity) and an "octet" (an 8-bit
-   byte). There are two mappings, one from URI characters to octets, and
-   a second from octets to original characters:
-
-   URI character sequence->octet sequence->original character sequence
-
-   A URI is represented as a sequence of characters, not as a sequence
-   of octets. That is because URI might be "transported" by means that
-   are not through a computer network, e.g., printed on paper, read over
-   the radio, etc.
-
-   A URI scheme may define a mapping from URI characters to octets;
-   whether this is done depends on the scheme. Commonly, within a
-   delimited component of a URI, a sequence of characters may be used to
-   represent a sequence of octets. For example, the character "a"
-   represents the octet 97 (decimal), while the character sequence "%",
-   "0", "a" represents the octet 10 (decimal).
-
-
-
-
-Berners-Lee, et. al.        Standards Track                     [Page 7]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-   There is a second translation for some resources: the sequence of
-   octets defined by a component of the URI is subsequently used to
-   represent a sequence of characters. A 'charset' defines this mapping.
-   There are many charsets in use in Internet protocols. For example,
-   UTF-8 [UTF-8] defines a mapping from sequences of octets to sequences
-   of characters in the repertoire of ISO 10646.
-
-   In the simplest case, the original character sequence contains only
-   characters that are defined in US-ASCII, and the two levels of
-   mapping are simple and easily invertible: each 'original character'
-   is represented as the octet for the US-ASCII code for it, which is,
-   in turn, represented as either the US-ASCII character, or else the
-   "%" escape sequence for that octet.
-
-   For original character sequences that contain non-ASCII characters,
-   however, the situation is more difficult. Internet protocols that
-   transmit octet sequences intended to represent character sequences
-   are expected to provide some way of identifying the charset used, if
-   there might be more than one [RFC2277].  However, there is currently
-   no provision within the generic URI syntax to accomplish this
-   identification. An individual URI scheme may require a single
-   charset, define a default charset, or provide a way to indicate the
-   charset used.
-
-   It is expected that a systematic treatment of character encoding
-   within URI will be developed as a future modification of this
-   specification.
-
-2.2. Reserved Characters
-
-   Many URI include components consisting of or delimited by, certain
-   special characters.  These characters are called "reserved", since
-   their usage within the URI component is limited to their reserved
-   purpose.  If the data for a URI component would conflict with the
-   reserved purpose, then the conflicting data must be escaped before
-   forming the URI.
-
-      reserved    = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" |
-                    "$" | ","
-
-   The "reserved" syntax class above refers to those characters that are
-   allowed within a URI, but which may not be allowed within a
-   particular component of the generic URI syntax; they are used as
-   delimiters of the components described in Section 3.
-
-
-
-
-
-
-
-Berners-Lee, et. al.        Standards Track                     [Page 8]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-   Characters in the "reserved" set are not reserved in all contexts.
-   The set of characters actually reserved within any given URI
-   component is defined by that component. In general, a character is
-   reserved if the semantics of the URI changes if the character is
-   replaced with its escaped US-ASCII encoding.
-
-2.3. Unreserved Characters
-
-   Data characters that are allowed in a URI but do not have a reserved
-   purpose are called unreserved.  These include upper and lower case
-   letters, decimal digits, and a limited set of punctuation marks and
-   symbols.
-
-      unreserved  = alphanum | mark
-
-      mark        = "-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")"
-
-   Unreserved characters can be escaped without changing the semantics
-   of the URI, but this should not be done unless the URI is being used
-   in a context that does not allow the unescaped character to appear.
-
-2.4. Escape Sequences
-
-   Data must be escaped if it does not have a representation using an
-   unreserved character; this includes data that does not correspond to
-   a printable character of the US-ASCII coded character set, or that
-   corresponds to any US-ASCII character that is disallowed, as
-   explained below.
-
-2.4.1. Escaped Encoding
-
-   An escaped octet is encoded as a character triplet, consisting of the
-   percent character "%" followed by the two hexadecimal digits
-   representing the octet code. For example, "%20" is the escaped
-   encoding for the US-ASCII space character.
-
-      escaped     = "%" hex hex
-      hex         = digit | "A" | "B" | "C" | "D" | "E" | "F" |
-                            "a" | "b" | "c" | "d" | "e" | "f"
-
-2.4.2. When to Escape and Unescape
-
-   A URI is always in an "escaped" form, since escaping or unescaping a
-   completed URI might change its semantics.  Normally, the only time
-   escape encodings can safely be made is when the URI is being created
-   from its component parts; each component may have its own set of
-   characters that are reserved, so only the mechanism responsible for
-   generating or interpreting that component can determine whether or
-
-
-
-Berners-Lee, et. al.        Standards Track                     [Page 9]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-   not escaping a character will change its semantics. Likewise, a URI
-   must be separated into its components before the escaped characters
-   within those components can be safely decoded.
-
-   In some cases, data that could be represented by an unreserved
-   character may appear escaped; for example, some of the unreserved
-   "mark" characters are automatically escaped by some systems.  If the
-   given URI scheme defines a canonicalization algorithm, then
-   unreserved characters may be unescaped according to that algorithm.
-   For example, "%7e" is sometimes used instead of "~" in an http URL
-   path, but the two are equivalent for an http URL.
-
-   Because the percent "%" character always has the reserved purpose of
-   being the escape indicator, it must be escaped as "%25" in order to
-   be used as data within a URI.  Implementers should be careful not to
-   escape or unescape the same string more than once, since unescaping
-   an already unescaped string might lead to misinterpreting a percent
-   data character as another escaped character, or vice versa in the
-   case of escaping an already escaped string.
-
-2.4.3. Excluded US-ASCII Characters
-
-   Although they are disallowed within the URI syntax, we include here a
-   description of those US-ASCII characters that have been excluded and
-   the reasons for their exclusion.
-
-   The control characters in the US-ASCII coded character set are not
-   used within a URI, both because they are non-printable and because
-   they are likely to be misinterpreted by some control mechanisms.
-
-   control     = <US-ASCII coded characters 00-1F and 7F hexadecimal>
-
-   The space character is excluded because significant spaces may
-   disappear and insignificant spaces may be introduced when URI are
-   transcribed or typeset or subjected to the treatment of word-
-   processing programs.  Whitespace is also used to delimit URI in many
-   contexts.
-
-   space       = <US-ASCII coded character 20 hexadecimal>
-
-   The angle-bracket "<" and ">" and double-quote (") characters are
-   excluded because they are often used as the delimiters around URI in
-   text documents and protocol fields.  The character "#" is excluded
-   because it is used to delimit a URI from a fragment identifier in URI
-   references (Section 4). The percent character "%" is excluded because
-   it is used for the encoding of escaped characters.
-
-   delims      = "<" | ">" | "#" | "%" | <">
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 10]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-   Other characters are excluded because gateways and other transport
-   agents are known to sometimes modify such characters, or they are
-   used as delimiters.
-
-   unwise      = "{" | "}" | "|" | "\" | "^" | "[" | "]" | "`"
-
-   Data corresponding to excluded characters must be escaped in order to
-   be properly represented within a URI.
-
-3. URI Syntactic Components
-
-   The URI syntax is dependent upon the scheme.  In general, absolute
-   URI are written as follows:
-
-      <scheme>:<scheme-specific-part>
-
-   An absolute URI contains the name of the scheme being used (<scheme>)
-   followed by a colon (":") and then a string (the <scheme-specific-
-   part>) whose interpretation depends on the scheme.
-
-   The URI syntax does not require that the scheme-specific-part have
-   any general structure or set of semantics which is common among all
-   URI.  However, a subset of URI do share a common syntax for
-   representing hierarchical relationships within the namespace.  This
-   "generic URI" syntax consists of a sequence of four main components:
-
-      <scheme>://<authority><path>?<query>
-
-   each of which, except <scheme>, may be absent from a particular URI.
-   For example, some URI schemes do not allow an <authority> component,
-   and others do not use a <query> component.
-
-      absoluteURI   = scheme ":" ( hier_part | opaque_part )
-
-   URI that are hierarchical in nature use the slash "/" character for
-   separating hierarchical components.  For some file systems, a "/"
-   character (used to denote the hierarchical structure of a URI) is the
-   delimiter used to construct a file name hierarchy, and thus the URI
-   path will look similar to a file pathname.  This does NOT imply that
-   the resource is a file or that the URI maps to an actual filesystem
-   pathname.
-
-      hier_part     = ( net_path | abs_path ) [ "?" query ]
-
-      net_path      = "//" authority [ abs_path ]
-
-      abs_path      = "/"  path_segments
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 11]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-   URI that do not make use of the slash "/" character for separating
-   hierarchical components are considered opaque by the generic URI
-   parser.
-
-      opaque_part   = uric_no_slash *uric
-
-      uric_no_slash = unreserved | escaped | ";" | "?" | ":" | "@" |
-                      "&" | "=" | "+" | "$" | ","
-
-   We use the term <path> to refer to both the <abs_path> and
-   <opaque_part> constructs, since they are mutually exclusive for any
-   given URI and can be parsed as a single component.
-
-3.1. Scheme Component
-
-   Just as there are many different methods of access to resources,
-   there are a variety of schemes for identifying such resources.  The
-   URI syntax consists of a sequence of components separated by reserved
-   characters, with the first component defining the semantics for the
-   remainder of the URI string.
-
-   Scheme names consist of a sequence of characters beginning with a
-   lower case letter and followed by any combination of lower case
-   letters, digits, plus ("+"), period ("."), or hyphen ("-").  For
-   resiliency, programs interpreting URI should treat upper case letters
-   as equivalent to lower case in scheme names (e.g., allow "HTTP" as
-   well as "http").
-
-      scheme        = alpha *( alpha | digit | "+" | "-" | "." )
-
-   Relative URI references are distinguished from absolute URI in that
-   they do not begin with a scheme name.  Instead, the scheme is
-   inherited from the base URI, as described in Section 5.2.
-
-3.2. Authority Component
-
-   Many URI schemes include a top hierarchical element for a naming
-   authority, such that the namespace defined by the remainder of the
-   URI is governed by that authority.  This authority component is
-   typically defined by an Internet-based server or a scheme-specific
-   registry of naming authorities.
-
-      authority     = server | reg_name
-
-   The authority component is preceded by a double slash "//" and is
-   terminated by the next slash "/", question-mark "?", or by the end of
-   the URI.  Within the authority component, the characters ";", ":",
-   "@", "?", and "/" are reserved.
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 12]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-   An authority component is not required for a URI scheme to make use
-   of relative references.  A base URI without an authority component
-   implies that any relative reference will also be without an authority
-   component.
-
-3.2.1. Registry-based Naming Authority
-
-   The structure of a registry-based naming authority is specific to the
-   URI scheme, but constrained to the allowed characters for an
-   authority component.
-
-      reg_name      = 1*( unreserved | escaped | "$" | "," |
-                          ";" | ":" | "@" | "&" | "=" | "+" )
-
-3.2.2. Server-based Naming Authority
-
-   URL schemes that involve the direct use of an IP-based protocol to a
-   specified server on the Internet use a common syntax for the server
-   component of the URI's scheme-specific data:
-
-      <userinfo>@<host>:<port>
-
-   where <userinfo> may consist of a user name and, optionally, scheme-
-   specific information about how to gain authorization to access the
-   server.  The parts "<userinfo>@" and ":<port>" may be omitted.
-
-      server        = [ [ userinfo "@" ] hostport ]
-
-   The user information, if present, is followed by a commercial at-sign
-   "@".
-
-      userinfo      = *( unreserved | escaped |
-                         ";" | ":" | "&" | "=" | "+" | "$" | "," )
-
-   Some URL schemes use the format "user:password" in the userinfo
-   field. This practice is NOT RECOMMENDED, because the passing of
-   authentication information in clear text (such as URI) has proven to
-   be a security risk in almost every case where it has been used.
-
-   The host is a domain name of a network host, or its IPv4 address as a
-   set of four decimal digit groups separated by ".".  Literal IPv6
-   addresses are not supported.
-
-      hostport      = host [ ":" port ]
-      host          = hostname | IPv4address
-      hostname      = *( domainlabel "." ) toplabel [ "." ]
-      domainlabel   = alphanum | alphanum *( alphanum | "-" ) alphanum
-      toplabel      = alpha | alpha *( alphanum | "-" ) alphanum
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 13]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-      IPv4address   = 1*digit "." 1*digit "." 1*digit "." 1*digit
-      port          = *digit
-
-   Hostnames take the form described in Section 3 of [RFC1034] and
-   Section 2.1 of [RFC1123]: a sequence of domain labels separated by
-   ".", each domain label starting and ending with an alphanumeric
-   character and possibly also containing "-" characters.  The rightmost
-   domain label of a fully qualified domain name will never start with a
-   digit, thus syntactically distinguishing domain names from IPv4
-   addresses, and may be followed by a single "." if it is necessary to
-   distinguish between the complete domain name and any local domain.
-   To actually be "Uniform" as a resource locator, a URL hostname should
-   be a fully qualified domain name.  In practice, however, the host
-   component may be a local domain literal.
-
-      Note: A suitable representation for including a literal IPv6
-      address as the host part of a URL is desired, but has not yet been
-      determined or implemented in practice.
-
-   The port is the network port number for the server.  Most schemes
-   designate protocols that have a default port number.  Another port
-   number may optionally be supplied, in decimal, separated from the
-   host by a colon.  If the port is omitted, the default port number is
-   assumed.
-
-3.3. Path Component
-
-   The path component contains data, specific to the authority (or the
-   scheme if there is no authority component), identifying the resource
-   within the scope of that scheme and authority.
-
-      path          = [ abs_path | opaque_part ]
-
-      path_segments = segment *( "/" segment )
-      segment       = *pchar *( ";" param )
-      param         = *pchar
-
-      pchar         = unreserved | escaped |
-                      ":" | "@" | "&" | "=" | "+" | "$" | ","
-
-   The path may consist of a sequence of path segments separated by a
-   single slash "/" character.  Within a path segment, the characters
-   "/", ";", "=", and "?" are reserved.  Each path segment may include a
-   sequence of parameters, indicated by the semicolon ";" character.
-   The parameters are not significant to the parsing of relative
-   references.
-
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 14]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-3.4. Query Component
-
-   The query component is a string of information to be interpreted by
-   the resource.
-
-      query         = *uric
-
-   Within a query component, the characters ";", "/", "?", ":", "@",
-   "&", "=", "+", ",", and "$" are reserved.
-
-4. URI References
-
-   The term "URI-reference" is used here to denote the common usage of a
-   resource identifier.  A URI reference may be absolute or relative,
-   and may have additional information attached in the form of a
-   fragment identifier.  However, "the URI" that results from such a
-   reference includes only the absolute URI after the fragment
-   identifier (if any) is removed and after any relative URI is resolved
-   to its absolute form.  Although it is possible to limit the
-   discussion of URI syntax and semantics to that of the absolute
-   result, most usage of URI is within general URI references, and it is
-   impossible to obtain the URI from such a reference without also
-   parsing the fragment and resolving the relative form.
-
-      URI-reference = [ absoluteURI | relativeURI ] [ "#" fragment ]
-
-   The syntax for relative URI is a shortened form of that for absolute
-   URI, where some prefix of the URI is missing and certain path
-   components ("." and "..") have a special meaning when, and only when,
-   interpreting a relative path.  The relative URI syntax is defined in
-   Section 5.
-
-4.1. Fragment Identifier
-
-   When a URI reference is used to perform a retrieval action on the
-   identified resource, the optional fragment identifier, separated from
-   the URI by a crosshatch ("#") character, consists of additional
-   reference information to be interpreted by the user agent after the
-   retrieval action has been successfully completed.  As such, it is not
-   part of a URI, but is often used in conjunction with a URI.
-
-      fragment      = *uric
-
-   The semantics of a fragment identifier is a property of the data
-   resulting from a retrieval action, regardless of the type of URI used
-   in the reference.  Therefore, the format and interpretation of
-   fragment identifiers is dependent on the media type [RFC2046] of the
-   retrieval result.  The character restrictions described in Section 2
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 15]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-   for URI also apply to the fragment in a URI-reference.  Individual
-   media types may define additional restrictions or structure within
-   the fragment for specifying different types of "partial views" that
-   can be identified within that media type.
-
-   A fragment identifier is only meaningful when a URI reference is
-   intended for retrieval and the result of that retrieval is a document
-   for which the identified fragment is consistently defined.
-
-4.2. Same-document References
-
-   A URI reference that does not contain a URI is a reference to the
-   current document.  In other words, an empty URI reference within a
-   document is interpreted as a reference to the start of that document,
-   and a reference containing only a fragment identifier is a reference
-   to the identified fragment of that document.  Traversal of such a
-   reference should not result in an additional retrieval action.
-   However, if the URI reference occurs in a context that is always
-   intended to result in a new request, as in the case of HTML's FORM
-   element, then an empty URI reference represents the base URI of the
-   current document and should be replaced by that URI when transformed
-   into a request.
-
-4.3. Parsing a URI Reference
-
-   A URI reference is typically parsed according to the four main
-   components and fragment identifier in order to determine what
-   components are present and whether the reference is relative or
-   absolute.  The individual components are then parsed for their
-   subparts and, if not opaque, to verify their validity.
-
-   Although the BNF defines what is allowed in each component, it is
-   ambiguous in terms of differentiating between an authority component
-   and a path component that begins with two slash characters.  The
-   greedy algorithm is used for disambiguation: the left-most matching
-   rule soaks up as much of the URI reference string as it is capable of
-   matching.  In other words, the authority component wins.
-
-   Readers familiar with regular expressions should see Appendix B for a
-   concrete parsing example and test oracle.
-
-5. Relative URI References
-
-   It is often the case that a group or "tree" of documents has been
-   constructed to serve a common purpose; the vast majority of URI in
-   these documents point to resources within the tree rather than
-
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 16]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-   outside of it.  Similarly, documents located at a particular site are
-   much more likely to refer to other resources at that site than to
-   resources at remote sites.
-
-   Relative addressing of URI allows document trees to be partially
-   independent of their location and access scheme.  For instance, it is
-   possible for a single set of hypertext documents to be simultaneously
-   accessible and traversable via each of the "file", "http", and "ftp"
-   schemes if the documents refer to each other using relative URI.
-   Furthermore, such document trees can be moved, as a whole, without
-   changing any of the relative references.  Experience within the WWW
-   has demonstrated that the ability to perform relative referencing is
-   necessary for the long-term usability of embedded URI.
-
-   The syntax for relative URI takes advantage of the <hier_part> syntax
-   of <absoluteURI> (Section 3) in order to express a reference that is
-   relative to the namespace of another hierarchical URI.
-
-      relativeURI   = ( net_path | abs_path | rel_path ) [ "?" query ]
-
-   A relative reference beginning with two slash characters is termed a
-   network-path reference, as defined by <net_path> in Section 3.  Such
-   references are rarely used.
-
-   A relative reference beginning with a single slash character is
-   termed an absolute-path reference, as defined by <abs_path> in
-   Section 3.
-
-   A relative reference that does not begin with a scheme name or a
-   slash character is termed a relative-path reference.
-
-      rel_path      = rel_segment [ abs_path ]
-
-      rel_segment   = 1*( unreserved | escaped |
-                          ";" | "@" | "&" | "=" | "+" | "$" | "," )
-
-   Within a relative-path reference, the complete path segments "." and
-   ".." have special meanings: "the current hierarchy level" and "the
-   level above this hierarchy level", respectively.  Although this is
-   very similar to their use within Unix-based filesystems to indicate
-   directory levels, these path components are only considered special
-   when resolving a relative-path reference to its absolute form
-   (Section 5.2).
-
-   Authors should be aware that a path segment which contains a colon
-   character cannot be used as the first segment of a relative URI path
-   (e.g., "this:that"), because it would be mistaken for a scheme name.
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 17]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-   It is therefore necessary to precede such segments with other
-   segments (e.g., "./this:that") in order for them to be referenced as
-   a relative path.
-
-   It is not necessary for all URI within a given scheme to be
-   restricted to the <hier_part> syntax, since the hierarchical
-   properties of that syntax are only necessary when relative URI are
-   used within a particular document.  Documents can only make use of
-   relative URI when their base URI fits within the <hier_part> syntax.
-   It is assumed that any document which contains a relative reference
-   will also have a base URI that obeys the syntax.  In other words,
-   relative URI cannot be used within a document that has an unsuitable
-   base URI.
-
-   Some URI schemes do not allow a hierarchical syntax matching the
-   <hier_part> syntax, and thus cannot use relative references.
-
-5.1. Establishing a Base URI
-
-   The term "relative URI" implies that there exists some absolute "base
-   URI" against which the relative reference is applied.  Indeed, the
-   base URI is necessary to define the semantics of any relative URI
-   reference; without it, a relative reference is meaningless.  In order
-   for relative URI to be usable within a document, the base URI of that
-   document must be known to the parser.
-
-   The base URI of a document can be established in one of four ways,
-   listed below in order of precedence.  The order of precedence can be
-   thought of in terms of layers, where the innermost defined base URI
-   has the highest precedence.  This can be visualized graphically as:
-
-      .----------------------------------------------------------.
-      |  .----------------------------------------------------.  |
-      |  |  .----------------------------------------------.  |  |
-      |  |  |  .----------------------------------------.  |  |  |
-      |  |  |  |  .----------------------------------.  |  |  |  |
-      |  |  |  |  |       <relative_reference>       |  |  |  |  |
-      |  |  |  |  `----------------------------------'  |  |  |  |
-      |  |  |  | (5.1.1) Base URI embedded in the       |  |  |  |
-      |  |  |  |         document's content             |  |  |  |
-      |  |  |  `----------------------------------------'  |  |  |
-      |  |  | (5.1.2) Base URI of the encapsulating entity |  |  |
-      |  |  |         (message, document, or none).        |  |  |
-      |  |  `----------------------------------------------'  |  |
-      |  | (5.1.3) URI used to retrieve the entity            |  |
-      |  `----------------------------------------------------'  |
-      | (5.1.4) Default Base URI is application-dependent        |
-      `----------------------------------------------------------'
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 18]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-5.1.1. Base URI within Document Content
-
-   Within certain document media types, the base URI of the document can
-   be embedded within the content itself such that it can be readily
-   obtained by a parser.  This can be useful for descriptive documents,
-   such as tables of content, which may be transmitted to others through
-   protocols other than their usual retrieval context (e.g., E-Mail or
-   USENET news).
-
-   It is beyond the scope of this document to specify how, for each
-   media type, the base URI can be embedded.  It is assumed that user
-   agents manipulating such media types will be able to obtain the
-   appropriate syntax from that media type's specification.  An example
-   of how the base URI can be embedded in the Hypertext Markup Language
-   (HTML) [RFC1866] is provided in Appendix D.
-
-   A mechanism for embedding the base URI within MIME container types
-   (e.g., the message and multipart types) is defined by MHTML
-   [RFC2110].  Protocols that do not use the MIME message header syntax,
-   but which do allow some form of tagged metainformation to be included
-   within messages, may define their own syntax for defining the base
-   URI as part of a message.
-
-5.1.2. Base URI from the Encapsulating Entity
-
-   If no base URI is embedded, the base URI of a document is defined by
-   the document's retrieval context.  For a document that is enclosed
-   within another entity (such as a message or another document), the
-   retrieval context is that entity; thus, the default base URI of the
-   document is the base URI of the entity in which the document is
-   encapsulated.
-
-5.1.3. Base URI from the Retrieval URI
-
-   If no base URI is embedded and the document is not encapsulated
-   within some other entity (e.g., the top level of a composite entity),
-   then, if a URI was used to retrieve the base document, that URI shall
-   be considered the base URI.  Note that if the retrieval was the
-   result of a redirected request, the last URI used (i.e., that which
-   resulted in the actual retrieval of the document) is the base URI.
-
-5.1.4. Default Base URI
-
-   If none of the conditions described in Sections 5.1.1--5.1.3 apply,
-   then the base URI is defined by the context of the application.
-   Since this definition is necessarily application-dependent, failing
-
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 19]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-   to define the base URI using one of the other methods may result in
-   the same content being interpreted differently by different types of
-   application.
-
-   It is the responsibility of the distributor(s) of a document
-   containing relative URI to ensure that the base URI for that document
-   can be established.  It must be emphasized that relative URI cannot
-   be used reliably in situations where the document's base URI is not
-   well-defined.
-
-5.2. Resolving Relative References to Absolute Form
-
-   This section describes an example algorithm for resolving URI
-   references that might be relative to a given base URI.
-
-   The base URI is established according to the rules of Section 5.1 and
-   parsed into the four main components as described in Section 3.  Note
-   that only the scheme component is required to be present in the base
-   URI; the other components may be empty or undefined.  A component is
-   undefined if its preceding separator does not appear in the URI
-   reference; the path component is never undefined, though it may be
-   empty.  The base URI's query component is not used by the resolution
-   algorithm and may be discarded.
-
-   For each URI reference, the following steps are performed in order:
-
-   1) The URI reference is parsed into the potential four components and
-      fragment identifier, as described in Section 4.3.
-
-   2) If the path component is empty and the scheme, authority, and
-      query components are undefined, then it is a reference to the
-      current document and we are done.  Otherwise, the reference URI's
-      query and fragment components are defined as found (or not found)
-      within the URI reference and not inherited from the base URI.
-
-   3) If the scheme component is defined, indicating that the reference
-      starts with a scheme name, then the reference is interpreted as an
-      absolute URI and we are done.  Otherwise, the reference URI's
-      scheme is inherited from the base URI's scheme component.
-
-      Due to a loophole in prior specifications [RFC1630], some parsers
-      allow the scheme name to be present in a relative URI if it is the
-      same as the base URI scheme.  Unfortunately, this can conflict
-      with the correct parsing of non-hierarchical URI.  For backwards
-      compatibility, an implementation may work around such references
-      by removing the scheme if it matches that of the base URI and the
-      scheme is known to always use the <hier_part> syntax.  The parser
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 20]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-      can then continue with the steps below for the remainder of the
-      reference components.  Validating parsers should mark such a
-      misformed relative reference as an error.
-
-   4) If the authority component is defined, then the reference is a
-      network-path and we skip to step 7.  Otherwise, the reference
-      URI's authority is inherited from the base URI's authority
-      component, which will also be undefined if the URI scheme does not
-      use an authority component.
-
-   5) If the path component begins with a slash character ("/"), then
-      the reference is an absolute-path and we skip to step 7.
-
-   6) If this step is reached, then we are resolving a relative-path
-      reference.  The relative path needs to be merged with the base
-      URI's path.  Although there are many ways to do this, we will
-      describe a simple method using a separate string buffer.
-
-      a) All but the last segment of the base URI's path component is
-         copied to the buffer.  In other words, any characters after the
-         last (right-most) slash character, if any, are excluded.
-
-      b) The reference's path component is appended to the buffer
-         string.
-
-      c) All occurrences of "./", where "." is a complete path segment,
-         are removed from the buffer string.
-
-      d) If the buffer string ends with "." as a complete path segment,
-         that "." is removed.
-
-      e) All occurrences of "<segment>/../", where <segment> is a
-         complete path segment not equal to "..", are removed from the
-         buffer string.  Removal of these path segments is performed
-         iteratively, removing the leftmost matching pattern on each
-         iteration, until no matching pattern remains.
-
-      f) If the buffer string ends with "<segment>/..", where <segment>
-         is a complete path segment not equal to "..", that
-         "<segment>/.." is removed.
-
-      g) If the resulting buffer string still begins with one or more
-         complete path segments of "..", then the reference is
-         considered to be in error.  Implementations may handle this
-         error by retaining these components in the resolved path (i.e.,
-         treating them as part of the final URI), by removing them from
-         the resolved path (i.e., discarding relative levels above the
-         root), or by avoiding traversal of the reference.
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 21]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-      h) The remaining buffer string is the reference URI's new path
-         component.
-
-   7) The resulting URI components, including any inherited from the
-      base URI, are recombined to give the absolute form of the URI
-      reference.  Using pseudocode, this would be
-
-         result = ""
-
-         if scheme is defined then
-             append scheme to result
-             append ":" to result
-
-         if authority is defined then
-             append "//" to result
-             append authority to result
-
-         append path to result
-
-         if query is defined then
-             append "?" to result
-             append query to result
-
-         if fragment is defined then
-             append "#" to result
-             append fragment to result
-
-         return result
-
-      Note that we must be careful to preserve the distinction between a
-      component that is undefined, meaning that its separator was not
-      present in the reference, and a component that is empty, meaning
-      that the separator was present and was immediately followed by the
-      next component separator or the end of the reference.
-
-   The above algorithm is intended to provide an example by which the
-   output of implementations can be tested -- implementation of the
-   algorithm itself is not required.  For example, some systems may find
-   it more efficient to implement step 6 as a pair of segment stacks
-   being merged, rather than as a series of string pattern replacements.
-
-      Note: Some WWW client applications will fail to separate the
-      reference's query component from its path component before merging
-      the base and reference paths in step 6 above.  This may result in
-      a loss of information if the query component contains the strings
-      "/../" or "/./".
-
-   Resolution examples are provided in Appendix C.
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 22]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-6. URI Normalization and Equivalence
-
-   In many cases, different URI strings may actually identify the
-   identical resource. For example, the host names used in URL are
-   actually case insensitive, and the URL <http://www.XEROX.com> is
-   equivalent to <http://www.xerox.com>. In general, the rules for
-   equivalence and definition of a normal form, if any, are scheme
-   dependent. When a scheme uses elements of the common syntax, it will
-   also use the common syntax equivalence rules, namely that the scheme
-   and hostname are case insensitive and a URL with an explicit ":port",
-   where the port is the default for the scheme, is equivalent to one
-   where the port is elided.
-
-7. Security Considerations
-
-   A URI does not in itself pose a security threat.  Users should beware
-   that there is no general guarantee that a URL, which at one time
-   located a given resource, will continue to do so.  Nor is there any
-   guarantee that a URL will not locate a different resource at some
-   later point in time, due to the lack of any constraint on how a given
-   authority apportions its namespace.  Such a guarantee can only be
-   obtained from the person(s) controlling that namespace and the
-   resource in question.  A specific URI scheme may include additional
-   semantics, such as name persistence, if those semantics are required
-   of all naming authorities for that scheme.
-
-   It is sometimes possible to construct a URL such that an attempt to
-   perform a seemingly harmless, idempotent operation, such as the
-   retrieval of an entity associated with the resource, will in fact
-   cause a possibly damaging remote operation to occur.  The unsafe URL
-   is typically constructed by specifying a port number other than that
-   reserved for the network protocol in question.  The client
-   unwittingly contacts a site that is in fact running a different
-   protocol.  The content of the URL contains instructions that, when
-   interpreted according to this other protocol, cause an unexpected
-   operation.  An example has been the use of a gopher URL to cause an
-   unintended or impersonating message to be sent via a SMTP server.
-
-   Caution should be used when using any URL that specifies a port
-   number other than the default for the protocol, especially when it is
-   a number within the reserved space.
-
-   Care should be taken when a URL contains escaped delimiters for a
-   given protocol (for example, CR and LF characters for telnet
-   protocols) that these are not unescaped before transmission.  This
-   might violate the protocol, but avoids the potential for such
-
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 23]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-   characters to be used to simulate an extra operation or parameter in
-   that protocol, which might lead to an unexpected and possibly harmful
-   remote operation to be performed.
-
-   It is clearly unwise to use a URL that contains a password which is
-   intended to be secret. In particular, the use of a password within
-   the 'userinfo' component of a URL is strongly disrecommended except
-   in those rare cases where the 'password' parameter is intended to be
-   public.
-
-8. Acknowledgements
-
-   This document was derived from RFC 1738 [RFC1738] and RFC 1808
-   [RFC1808]; the acknowledgements in those specifications still apply.
-   In addition, contributions by Gisle Aas, Martin Beet, Martin Duerst,
-   Jim Gettys, Martijn Koster, Dave Kristol, Daniel LaLiberte, Foteos
-   Macrides, James Marshall, Ryan Moats, Keith Moore, and Lauren Wood
-   are gratefully acknowledged.
-
-9. References
-
-   [RFC2277] Alvestrand, H., "IETF Policy on Character Sets and
-             Languages", BCP 18, RFC 2277, January 1998.
-
-   [RFC1630] Berners-Lee, T., "Universal Resource Identifiers in WWW: A
-             Unifying Syntax for the Expression of Names and Addresses
-             of Objects on the Network as used in the World-Wide Web",
-             RFC 1630, June 1994.
-
-   [RFC1738] Berners-Lee, T., Masinter, L., and M. McCahill, Editors,
-             "Uniform Resource Locators (URL)", RFC 1738, December 1994.
-
-   [RFC1866] Berners-Lee T., and D. Connolly, "HyperText Markup Language
-             Specification -- 2.0", RFC 1866, November 1995.
-
-   [RFC1123] Braden, R., Editor, "Requirements for Internet Hosts --
-             Application and Support", STD 3, RFC 1123, October 1989.
-
-   [RFC822]  Crocker, D., "Standard for the Format of ARPA Internet Text
-             Messages", STD 11, RFC 822, August 1982.
-
-   [RFC1808] Fielding, R., "Relative Uniform Resource Locators", RFC
-             1808, June 1995.
-
-   [RFC2046] Freed, N., and N. Borenstein, "Multipurpose Internet Mail
-             Extensions (MIME) Part Two: Media Types", RFC 2046,
-             November 1996.
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 24]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-   [RFC1736] Kunze, J., "Functional Recommendations for Internet
-             Resource Locators", RFC 1736, February 1995.
-
-   [RFC2141] Moats, R., "URN Syntax", RFC 2141, May 1997.
-
-   [RFC1034] Mockapetris, P., "Domain Names - Concepts and Facilities",
-             STD 13, RFC 1034, November 1987.
-
-   [RFC2110] Palme, J., and A. Hopmann, "MIME E-mail Encapsulation of
-             Aggregate Documents, such as HTML (MHTML)", RFC 2110, March
-             1997.
-
-   [RFC1737] Sollins, K., and L. Masinter, "Functional Requirements for
-             Uniform Resource Names", RFC 1737, December 1994.
-
-   [ASCII]   US-ASCII. "Coded Character Set -- 7-bit American Standard
-             Code for Information Interchange", ANSI X3.4-1986.
-
-   [UTF-8]   Yergeau, F., "UTF-8, a transformation format of ISO 10646",
-             RFC 2279, January 1998.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 25]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-10. Authors' Addresses
-
-   Tim Berners-Lee
-   World Wide Web Consortium
-   MIT Laboratory for Computer Science, NE43-356
-   545 Technology Square
-   Cambridge, MA 02139
-
-   Fax: +1(617)258-8682
-   EMail: timbl@w3.org
-
-
-   Roy T. Fielding
-   Department of Information and Computer Science
-   University of California, Irvine
-   Irvine, CA  92697-3425
-
-   Fax: +1(949)824-1715
-   EMail: fielding@ics.uci.edu
-
-
-   Larry Masinter
-   Xerox PARC
-   3333 Coyote Hill Road
-   Palo Alto, CA 94034
-
-   Fax: +1(415)812-4333
-   EMail: masinter@parc.xerox.com
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 26]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-A. Collected BNF for URI
-
-      URI-reference = [ absoluteURI | relativeURI ] [ "#" fragment ]
-      absoluteURI   = scheme ":" ( hier_part | opaque_part )
-      relativeURI   = ( net_path | abs_path | rel_path ) [ "?" query ]
-
-      hier_part     = ( net_path | abs_path ) [ "?" query ]
-      opaque_part   = uric_no_slash *uric
-
-      uric_no_slash = unreserved | escaped | ";" | "?" | ":" | "@" |
-                      "&" | "=" | "+" | "$" | ","
-
-      net_path      = "//" authority [ abs_path ]
-      abs_path      = "/"  path_segments
-      rel_path      = rel_segment [ abs_path ]
-
-      rel_segment   = 1*( unreserved | escaped |
-                          ";" | "@" | "&" | "=" | "+" | "$" | "," )
-
-      scheme        = alpha *( alpha | digit | "+" | "-" | "." )
-
-      authority     = server | reg_name
-
-      reg_name      = 1*( unreserved | escaped | "$" | "," |
-                          ";" | ":" | "@" | "&" | "=" | "+" )
-
-      server        = [ [ userinfo "@" ] hostport ]
-      userinfo      = *( unreserved | escaped |
-                         ";" | ":" | "&" | "=" | "+" | "$" | "," )
-
-      hostport      = host [ ":" port ]
-      host          = hostname | IPv4address
-      hostname      = *( domainlabel "." ) toplabel [ "." ]
-      domainlabel   = alphanum | alphanum *( alphanum | "-" ) alphanum
-      toplabel      = alpha | alpha *( alphanum | "-" ) alphanum
-      IPv4address   = 1*digit "." 1*digit "." 1*digit "." 1*digit
-      port          = *digit
-
-      path          = [ abs_path | opaque_part ]
-      path_segments = segment *( "/" segment )
-      segment       = *pchar *( ";" param )
-      param         = *pchar
-      pchar         = unreserved | escaped |
-                      ":" | "@" | "&" | "=" | "+" | "$" | ","
-
-      query         = *uric
-
-      fragment      = *uric
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 27]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-      uric          = reserved | unreserved | escaped
-      reserved      = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" |
-                      "$" | ","
-      unreserved    = alphanum | mark
-      mark          = "-" | "_" | "." | "!" | "~" | "*" | "'" |
-                      "(" | ")"
-
-      escaped       = "%" hex hex
-      hex           = digit | "A" | "B" | "C" | "D" | "E" | "F" |
-                              "a" | "b" | "c" | "d" | "e" | "f"
-
-      alphanum      = alpha | digit
-      alpha         = lowalpha | upalpha
-
-      lowalpha = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" |
-                 "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" |
-                 "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
-      upalpha  = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" |
-                 "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" |
-                 "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z"
-      digit    = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" |
-                 "8" | "9"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 28]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-B. Parsing a URI Reference with a Regular Expression
-
-   As described in Section 4.3, the generic URI syntax is not sufficient
-   to disambiguate the components of some forms of URI.  Since the
-   "greedy algorithm" described in that section is identical to the
-   disambiguation method used by POSIX regular expressions, it is
-   natural and commonplace to use a regular expression for parsing the
-   potential four components and fragment identifier of a URI reference.
-
-   The following line is the regular expression for breaking-down a URI
-   reference into its components.
-
-      ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
-       12            3  4          5       6  7        8 9
-
-   The numbers in the second line above are only to assist readability;
-   they indicate the reference points for each subexpression (i.e., each
-   paired parenthesis).  We refer to the value matched for subexpression
-   <n> as $<n>.  For example, matching the above expression to
-
-      http://www.ics.uci.edu/pub/ietf/uri/#Related
-
-   results in the following subexpression matches:
-
-      $1 = http:
-      $2 = http
-      $3 = //www.ics.uci.edu
-      $4 = www.ics.uci.edu
-      $5 = /pub/ietf/uri/
-      $6 = <undefined>
-      $7 = <undefined>
-      $8 = #Related
-      $9 = Related
-
-   where <undefined> indicates that the component is not present, as is
-   the case for the query component in the above example.  Therefore, we
-   can determine the value of the four components and fragment as
-
-      scheme    = $2
-      authority = $4
-      path      = $5
-      query     = $7
-      fragment  = $9
-
-   and, going in the opposite direction, we can recreate a URI reference
-   from its components using the algorithm in step 7 of Section 5.2.
-
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 29]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-C. Examples of Resolving Relative URI References
-
-   Within an object with a well-defined base URI of
-
-      http://a/b/c/d;p?q
-
-   the relative URI would be resolved as follows:
-
-C.1.  Normal Examples
-
-      g:h           =  g:h
-      g             =  http://a/b/c/g
-      ./g           =  http://a/b/c/g
-      g/            =  http://a/b/c/g/
-      /g            =  http://a/g
-      //g           =  http://g
-      ?y            =  http://a/b/c/?y
-      g?y           =  http://a/b/c/g?y
-      #s            =  (current document)#s
-      g#s           =  http://a/b/c/g#s
-      g?y#s         =  http://a/b/c/g?y#s
-      ;x            =  http://a/b/c/;x
-      g;x           =  http://a/b/c/g;x
-      g;x?y#s       =  http://a/b/c/g;x?y#s
-      .             =  http://a/b/c/
-      ./            =  http://a/b/c/
-      ..            =  http://a/b/
-      ../           =  http://a/b/
-      ../g          =  http://a/b/g
-      ../..         =  http://a/
-      ../../        =  http://a/
-      ../../g       =  http://a/g
-
-C.2.  Abnormal Examples
-
-   Although the following abnormal examples are unlikely to occur in
-   normal practice, all URI parsers should be capable of resolving them
-   consistently.  Each example uses the same base as above.
-
-   An empty reference refers to the start of the current document.
-
-      <>            =  (current document)
-
-   Parsers must be careful in handling the case where there are more
-   relative path ".." segments than there are hierarchical levels in the
-   base URI's path.  Note that the ".." syntax cannot be used to change
-   the authority component of a URI.
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 30]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-      ../../../g    =  http://a/../g
-      ../../../../g =  http://a/../../g
-
-   In practice, some implementations strip leading relative symbolic
-   elements (".", "..") after applying a relative URI calculation, based
-   on the theory that compensating for obvious author errors is better
-   than allowing the request to fail.  Thus, the above two references
-   will be interpreted as "http://a/g" by some implementations.
-
-   Similarly, parsers must avoid treating "." and ".." as special when
-   they are not complete components of a relative path.
-
-      /./g          =  http://a/./g
-      /../g         =  http://a/../g
-      g.            =  http://a/b/c/g.
-      .g            =  http://a/b/c/.g
-      g..           =  http://a/b/c/g..
-      ..g           =  http://a/b/c/..g
-
-   Less likely are cases where the relative URI uses unnecessary or
-   nonsensical forms of the "." and ".." complete path segments.
-
-      ./../g        =  http://a/b/g
-      ./g/.         =  http://a/b/c/g/
-      g/./h         =  http://a/b/c/g/h
-      g/../h        =  http://a/b/c/h
-      g;x=1/./y     =  http://a/b/c/g;x=1/y
-      g;x=1/../y    =  http://a/b/c/y
-
-   All client applications remove the query component from the base URI
-   before resolving relative URI.  However, some applications fail to
-   separate the reference's query and/or fragment components from a
-   relative path before merging it with the base path.  This error is
-   rarely noticed, since typical usage of a fragment never includes the
-   hierarchy ("/") character, and the query component is not normally
-   used within relative references.
-
-      g?y/./x       =  http://a/b/c/g?y/./x
-      g?y/../x      =  http://a/b/c/g?y/../x
-      g#s/./x       =  http://a/b/c/g#s/./x
-      g#s/../x      =  http://a/b/c/g#s/../x
-
-
-
-
-
-
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 31]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-   Some parsers allow the scheme name to be present in a relative URI if
-   it is the same as the base URI scheme.  This is considered to be a
-   loophole in prior specifications of partial URI [RFC1630]. Its use
-   should be avoided.
-
-      http:g        =  http:g           ; for validating parsers
-                    |  http://a/b/c/g   ; for backwards compatibility
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 32]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-D. Embedding the Base URI in HTML documents
-
-   It is useful to consider an example of how the base URI of a document
-   can be embedded within the document's content.  In this appendix, we
-   describe how documents written in the Hypertext Markup Language
-   (HTML) [RFC1866] can include an embedded base URI.  This appendix
-   does not form a part of the URI specification and should not be
-   considered as anything more than a descriptive example.
-
-   HTML defines a special element "BASE" which, when present in the
-   "HEAD" portion of a document, signals that the parser should use the
-   BASE element's "HREF" attribute as the base URI for resolving any
-   relative URI.  The "HREF" attribute must be an absolute URI.  Note
-   that, in HTML, element and attribute names are case-insensitive.  For
-   example:
-
-      <!doctype html public "-//IETF//DTD HTML//EN">
-      <HTML><HEAD>
-      <TITLE>An example HTML document</TITLE>
-      <BASE href="http://www.ics.uci.edu/Test/a/b/c">
-      </HEAD><BODY>
-      ... <A href="../x">a hypertext anchor</A> ...
-      </BODY></HTML>
-
-   A parser reading the example document should interpret the given
-   relative URI "../x" as representing the absolute URI
-
-      <http://www.ics.uci.edu/Test/a/x>
-
-   regardless of the context in which the example document was obtained.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 33]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-E. Recommendations for Delimiting URI in Context
-
-   URI are often transmitted through formats that do not provide a clear
-   context for their interpretation.  For example, there are many
-   occasions when URI are included in plain text; examples include text
-   sent in electronic mail, USENET news messages, and, most importantly,
-   printed on paper.  In such cases, it is important to be able to
-   delimit the URI from the rest of the text, and in particular from
-   punctuation marks that might be mistaken for part of the URI.
-
-   In practice, URI are delimited in a variety of ways, but usually
-   within double-quotes "http://test.com/", angle brackets
-   <http://test.com/>, or just using whitespace
-
-                             http://test.com/
-
-   These wrappers do not form part of the URI.
-
-   In the case where a fragment identifier is associated with a URI
-   reference, the fragment would be placed within the brackets as well
-   (separated from the URI with a "#" character).
-
-   In some cases, extra whitespace (spaces, linebreaks, tabs, etc.) may
-   need to be added to break long URI across lines. The whitespace
-   should be ignored when extracting the URI.
-
-   No whitespace should be introduced after a hyphen ("-") character.
-   Because some typesetters and printers may (erroneously) introduce a
-   hyphen at the end of line when breaking a line, the interpreter of a
-   URI containing a line break immediately after a hyphen should ignore
-   all unescaped whitespace around the line break, and should be aware
-   that the hyphen may or may not actually be part of the URI.
-
-   Using <> angle brackets around each URI is especially recommended as
-   a delimiting style for URI that contain whitespace.
-
-   The prefix "URL:" (with or without a trailing space) was recommended
-   as a way to used to help distinguish a URL from other bracketed
-   designators, although this is not common in practice.
-
-   For robustness, software that accepts user-typed URI should attempt
-   to recognize and strip both delimiters and embedded whitespace.
-
-   For example, the text:
-
-
-
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 34]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-      Yes, Jim, I found it under "http://www.w3.org/Addressing/",
-      but you can probably pick it up from <ftp://ds.internic.
-      net/rfc/>.  Note the warning in <http://www.ics.uci.edu/pub/
-      ietf/uri/historical.html#WARNING>.
-
-   contains the URI references
-
-      http://www.w3.org/Addressing/
-      ftp://ds.internic.net/rfc/
-      http://www.ics.uci.edu/pub/ietf/uri/historical.html#WARNING
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 35]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-F. Abbreviated URLs
-
-   The URL syntax was designed for unambiguous reference to network
-   resources and extensibility via the URL scheme.  However, as URL
-   identification and usage have become commonplace, traditional media
-   (television, radio, newspapers, billboards, etc.) have increasingly
-   used abbreviated URL references.  That is, a reference consisting of
-   only the authority and path portions of the identified resource, such
-   as
-
-      www.w3.org/Addressing/
-
-   or simply the DNS hostname on its own.  Such references are primarily
-   intended for human interpretation rather than machine, with the
-   assumption that context-based heuristics are sufficient to complete
-   the URL (e.g., most hostnames beginning with "www" are likely to have
-   a URL prefix of "http://").  Although there is no standard set of
-   heuristics for disambiguating abbreviated URL references, many client
-   implementations allow them to be entered by the user and
-   heuristically resolved.  It should be noted that such heuristics may
-   change over time, particularly when new URL schemes are introduced.
-
-   Since an abbreviated URL has the same syntax as a relative URL path,
-   abbreviated URL references cannot be used in contexts where relative
-   URLs are expected.  This limits the use of abbreviated URLs to places
-   where there is no defined base URL, such as dialog boxes and off-line
-   advertisements.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 36]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-G. Summary of Non-editorial Changes
-
-G.1. Additions
-
-   Section 4 (URI References) was added to stem the confusion regarding
-   "what is a URI" and how to describe fragment identifiers given that
-   they are not part of the URI, but are part of the URI syntax and
-   parsing concerns.  In addition, it provides a reference definition
-   for use by other IETF specifications (HTML, HTTP, etc.) that have
-   previously attempted to redefine the URI syntax in order to account
-   for the presence of fragment identifiers in URI references.
-
-   Section 2.4 was rewritten to clarify a number of misinterpretations
-   and to leave room for fully internationalized URI.
-
-   Appendix F on abbreviated URLs was added to describe the shortened
-   references often seen on television and magazine advertisements and
-   explain why they are not used in other contexts.
-
-G.2. Modifications from both RFC 1738 and RFC 1808
-
-   Changed to URI syntax instead of just URL.
-
-   Confusion regarding the terms "character encoding", the URI
-   "character set", and the escaping of characters with %<hex><hex>
-   equivalents has (hopefully) been reduced.  Many of the BNF rule names
-   regarding the character sets have been changed to more accurately
-   describe their purpose and to encompass all "characters" rather than
-   just US-ASCII octets.  Unless otherwise noted here, these
-   modifications do not affect the URI syntax.
-
-   Both RFC 1738 and RFC 1808 refer to the "reserved" set of characters
-   as if URI-interpreting software were limited to a single set of
-   characters with a reserved purpose (i.e., as meaning something other
-   than the data to which the characters correspond), and that this set
-   was fixed by the URI scheme.  However, this has not been true in
-   practice; any character that is interpreted differently when it is
-   escaped is, in effect, reserved.  Furthermore, the interpreting
-   engine on a HTTP server is often dependent on the resource, not just
-   the URI scheme.  The description of reserved characters has been
-   changed accordingly.
-
-   The plus "+", dollar "$", and comma "," characters have been added to
-   those in the "reserved" set, since they are treated as reserved
-   within the query component.
-
-
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 37]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-   The tilde "~" character was added to those in the "unreserved" set,
-   since it is extensively used on the Internet in spite of the
-   difficulty to transcribe it with some keyboards.
-
-   The syntax for URI scheme has been changed to require that all
-   schemes begin with an alpha character.
-
-   The "user:password" form in the previous BNF was changed to a
-   "userinfo" token, and the possibility that it might be
-   "user:password" made scheme specific. In particular, the use of
-   passwords in the clear is not even suggested by the syntax.
-
-   The question-mark "?" character was removed from the set of allowed
-   characters for the userinfo in the authority component, since testing
-   showed that many applications treat it as reserved for separating the
-   query component from the rest of the URI.
-
-   The semicolon ";" character was added to those stated as being
-   reserved within the authority component, since several new schemes
-   are using it as a separator within userinfo to indicate the type of
-   user authentication.
-
-   RFC 1738 specified that the path was separated from the authority
-   portion of a URI by a slash.  RFC 1808 followed suit, but with a
-   fudge of carrying around the separator as a "prefix" in order to
-   describe the parsing algorithm.  RFC 1630 never had this problem,
-   since it considered the slash to be part of the path.  In writing
-   this specification, it was found to be impossible to accurately
-   describe and retain the difference between the two URI
-      <foo:/bar>   and   <foo:bar>
-   without either considering the slash to be part of the path (as
-   corresponds to actual practice) or creating a separate component just
-   to hold that slash.  We chose the former.
-
-G.3. Modifications from RFC 1738
-
-   The definition of specific URL schemes and their scheme-specific
-   syntax and semantics has been moved to separate documents.
-
-   The URL host was defined as a fully-qualified domain name.  However,
-   many URLs are used without fully-qualified domain names (in contexts
-   for which the full qualification is not necessary), without any host
-   (as in some file URLs), or with a host of "localhost".
-
-   The URL port is now *digit instead of 1*digit, since systems are
-   expected to handle the case where the ":" separator between host and
-   port is supplied without a port.
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 38]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-   The recommendations for delimiting URI in context (Appendix E) have
-   been adjusted to reflect current practice.
-
-G.4. Modifications from RFC 1808
-
-   RFC 1808 (Section 4) defined an empty URL reference (a reference
-   containing nothing aside from the fragment identifier) as being a
-   reference to the base URL.  Unfortunately, that definition could be
-   interpreted, upon selection of such a reference, as a new retrieval
-   action on that resource.  Since the normal intent of such references
-   is for the user agent to change its view of the current document to
-   the beginning of the specified fragment within that document, not to
-   make an additional request of the resource, a description of how to
-   correctly interpret an empty reference has been added in Section 4.
-
-   The description of the mythical Base header field has been replaced
-   with a reference to the Content-Location header field defined by
-   MHTML [RFC2110].
-
-   RFC 1808 described various schemes as either having or not having the
-   properties of the generic URI syntax.  However, the only requirement
-   is that the particular document containing the relative references
-   have a base URI that abides by the generic URI syntax, regardless of
-   the URI scheme, so the associated description has been updated to
-   reflect that.
-
-   The BNF term <net_loc> has been replaced with <authority>, since the
-   latter more accurately describes its use and purpose.  Likewise, the
-   authority is no longer restricted to the IP server syntax.
-
-   Extensive testing of current client applications demonstrated that
-   the majority of deployed systems do not use the ";" character to
-   indicate trailing parameter information, and that the presence of a
-   semicolon in a path segment does not affect the relative parsing of
-   that segment.  Therefore, parameters have been removed as a separate
-   component and may now appear in any path segment.  Their influence
-   has been removed from the algorithm for resolving a relative URI
-   reference.  The resolution examples in Appendix C have been modified
-   to reflect this change.
-
-   Implementations are now allowed to work around misformed relative
-   references that are prefixed by the same scheme as the base URI, but
-   only for schemes known to use the <hier_part> syntax.
-
-
-
-
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 39]
-
-RFC 2396                   URI Generic Syntax                August 1998
-
-
-H.  Full Copyright Statement
-
-   Copyright (C) The Internet Society (1998).  All Rights Reserved.
-
-   This document and translations of it may be copied and furnished to
-   others, and derivative works that comment on or otherwise explain it
-   or assist in its implementation may be prepared, copied, published
-   and distributed, in whole or in part, without restriction of any
-   kind, provided that the above copyright notice and this paragraph are
-   included on all such copies and derivative works.  However, this
-   document itself may not be modified in any way, such as by removing
-   the copyright notice or references to the Internet Society or other
-   Internet organizations, except as needed for the purpose of
-   developing Internet standards in which case the procedures for
-   copyrights defined in the Internet Standards process must be
-   followed, or as required to translate it into languages other than
-   English.
-
-   The limited permissions granted above are perpetual and will not be
-   revoked by the Internet Society or its successors or assigns.
-
-   This document and the information contained herein is provided on an
-   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
-   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
-   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
-   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
-   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-Berners-Lee, et. al.        Standards Track                    [Page 40]
-
diff -urNad cupsys-1.1.99.b1.r4748~/standards/rfc3986.txt cupsys-1.1.99.b1.r4748/standards/rfc3986.txt
--- cupsys-1.1.99.b1.r4748~/standards/rfc3986.txt	1970-01-01 09:00:00.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/standards/rfc3986.txt	2005-10-08 13:13:06.355829000 +0900
@@ -0,0 +1,3419 @@
+
+
+
+
+
+
+Network Working Group                                     T. Berners-Lee
+Request for Comments: 3986                                       W3C/MIT
+STD: 66                                                      R. Fielding
+Updates: 1738                                               Day Software
+Obsoletes: 2732, 2396, 1808                                  L. Masinter
+Category: Standards Track                                  Adobe Systems
+                                                            January 2005
+
+
+           Uniform Resource Identifier (URI): Generic Syntax
+
+Status of This Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+Copyright Notice
+
+   Copyright (C) The Internet Society (2005).
+
+Abstract
+
+   A Uniform Resource Identifier (URI) is a compact sequence of
+   characters that identifies an abstract or physical resource.  This
+   specification defines the generic URI syntax and a process for
+   resolving URI references that might be in relative form, along with
+   guidelines and security considerations for the use of URIs on the
+   Internet.  The URI syntax defines a grammar that is a superset of all
+   valid URIs, allowing an implementation to parse the common components
+   of a URI reference without knowing the scheme-specific requirements
+   of every possible identifier.  This specification does not define a
+   generative grammar for URIs; that task is performed by the individual
+   specifications of each URI scheme.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                     [Page 1]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+Table of Contents
+
+   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4
+       1.1.  Overview of URIs . . . . . . . . . . . . . . . . . . . .  4
+             1.1.1.  Generic Syntax . . . . . . . . . . . . . . . . .  6
+             1.1.2.  Examples . . . . . . . . . . . . . . . . . . . .  7
+             1.1.3.  URI, URL, and URN  . . . . . . . . . . . . . . .  7
+       1.2.  Design Considerations  . . . . . . . . . . . . . . . . .  8
+             1.2.1.  Transcription  . . . . . . . . . . . . . . . . .  8
+             1.2.2.  Separating Identification from Interaction . . .  9
+             1.2.3.  Hierarchical Identifiers . . . . . . . . . . . . 10
+       1.3.  Syntax Notation  . . . . . . . . . . . . . . . . . . . . 11
+   2.  Characters . . . . . . . . . . . . . . . . . . . . . . . . . . 11
+       2.1.  Percent-Encoding . . . . . . . . . . . . . . . . . . . . 12
+       2.2.  Reserved Characters  . . . . . . . . . . . . . . . . . . 12
+       2.3.  Unreserved Characters  . . . . . . . . . . . . . . . . . 13
+       2.4.  When to Encode or Decode . . . . . . . . . . . . . . . . 14
+       2.5.  Identifying Data . . . . . . . . . . . . . . . . . . . . 14
+   3.  Syntax Components  . . . . . . . . . . . . . . . . . . . . . . 16
+       3.1.  Scheme . . . . . . . . . . . . . . . . . . . . . . . . . 17
+       3.2.  Authority  . . . . . . . . . . . . . . . . . . . . . . . 17
+             3.2.1.  User Information . . . . . . . . . . . . . . . . 18
+             3.2.2.  Host . . . . . . . . . . . . . . . . . . . . . . 18
+             3.2.3.  Port . . . . . . . . . . . . . . . . . . . . . . 22
+       3.3.  Path . . . . . . . . . . . . . . . . . . . . . . . . . . 22
+       3.4.  Query  . . . . . . . . . . . . . . . . . . . . . . . . . 23
+       3.5.  Fragment . . . . . . . . . . . . . . . . . . . . . . . . 24
+   4.  Usage  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
+       4.1.  URI Reference  . . . . . . . . . . . . . . . . . . . . . 25
+       4.2.  Relative Reference . . . . . . . . . . . . . . . . . . . 26
+       4.3.  Absolute URI . . . . . . . . . . . . . . . . . . . . . . 27
+       4.4.  Same-Document Reference  . . . . . . . . . . . . . . . . 27
+       4.5.  Suffix Reference . . . . . . . . . . . . . . . . . . . . 27
+   5.  Reference Resolution . . . . . . . . . . . . . . . . . . . . . 28
+       5.1.  Establishing a Base URI  . . . . . . . . . . . . . . . . 28
+             5.1.1.  Base URI Embedded in Content . . . . . . . . . . 29
+             5.1.2.  Base URI from the Encapsulating Entity . . . . . 29
+             5.1.3.  Base URI from the Retrieval URI  . . . . . . . . 30
+             5.1.4.  Default Base URI . . . . . . . . . . . . . . . . 30
+       5.2.  Relative Resolution  . . . . . . . . . . . . . . . . . . 30
+             5.2.1.  Pre-parse the Base URI . . . . . . . . . . . . . 31
+             5.2.2.  Transform References . . . . . . . . . . . . . . 31
+             5.2.3.  Merge Paths  . . . . . . . . . . . . . . . . . . 32
+             5.2.4.  Remove Dot Segments  . . . . . . . . . . . . . . 33
+       5.3.  Component Recomposition  . . . . . . . . . . . . . . . . 35
+       5.4.  Reference Resolution Examples  . . . . . . . . . . . . . 35
+             5.4.1.  Normal Examples  . . . . . . . . . . . . . . . . 36
+             5.4.2.  Abnormal Examples  . . . . . . . . . . . . . . . 36
+
+
+
+Berners-Lee, et al.         Standards Track                     [Page 2]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   6.  Normalization and Comparison . . . . . . . . . . . . . . . . . 38
+       6.1.  Equivalence  . . . . . . . . . . . . . . . . . . . . . . 38
+       6.2.  Comparison Ladder  . . . . . . . . . . . . . . . . . . . 39
+             6.2.1.  Simple String Comparison . . . . . . . . . . . . 39
+             6.2.2.  Syntax-Based Normalization . . . . . . . . . . . 40
+             6.2.3.  Scheme-Based Normalization . . . . . . . . . . . 41
+             6.2.4.  Protocol-Based Normalization . . . . . . . . . . 42
+   7.  Security Considerations  . . . . . . . . . . . . . . . . . . . 43
+       7.1.  Reliability and Consistency  . . . . . . . . . . . . . . 43
+       7.2.  Malicious Construction . . . . . . . . . . . . . . . . . 43
+       7.3.  Back-End Transcoding . . . . . . . . . . . . . . . . . . 44
+       7.4.  Rare IP Address Formats  . . . . . . . . . . . . . . . . 45
+       7.5.  Sensitive Information  . . . . . . . . . . . . . . . . . 45
+       7.6.  Semantic Attacks . . . . . . . . . . . . . . . . . . . . 45
+   8.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 46
+   9.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 46
+   10. References . . . . . . . . . . . . . . . . . . . . . . . . . . 46
+       10.1. Normative References . . . . . . . . . . . . . . . . . . 46
+       10.2. Informative References . . . . . . . . . . . . . . . . . 47
+   A.  Collected ABNF for URI . . . . . . . . . . . . . . . . . . . . 49
+   B.  Parsing a URI Reference with a Regular Expression  . . . . . . 50
+   C.  Delimiting a URI in Context  . . . . . . . . . . . . . . . . . 51
+   D.  Changes from RFC 2396  . . . . . . . . . . . . . . . . . . . . 53
+       D.1.  Additions  . . . . . . . . . . . . . . . . . . . . . . . 53
+       D.2.  Modifications  . . . . . . . . . . . . . . . . . . . . . 53
+   Index  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
+   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 60
+   Full Copyright Statement . . . . . . . . . . . . . . . . . . . . . 61
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                     [Page 3]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+1.  Introduction
+
+   A Uniform Resource Identifier (URI) provides a simple and extensible
+   means for identifying a resource.  This specification of URI syntax
+   and semantics is derived from concepts introduced by the World Wide
+   Web global information initiative, whose use of these identifiers
+   dates from 1990 and is described in "Universal Resource Identifiers
+   in WWW" [RFC1630].  The syntax is designed to meet the
+   recommendations laid out in "Functional Recommendations for Internet
+   Resource Locators" [RFC1736] and "Functional Requirements for Uniform
+   Resource Names" [RFC1737].
+
+   This document obsoletes [RFC2396], which merged "Uniform Resource
+   Locators" [RFC1738] and "Relative Uniform Resource Locators"
+   [RFC1808] in order to define a single, generic syntax for all URIs.
+   It obsoletes [RFC2732], which introduced syntax for an IPv6 address.
+   It excludes portions of RFC 1738 that defined the specific syntax of
+   individual URI schemes; those portions will be updated as separate
+   documents.  The process for registration of new URI schemes is
+   defined separately by [BCP35].  Advice for designers of new URI
+   schemes can be found in [RFC2718].  All significant changes from RFC
+   2396 are noted in Appendix D.
+
+   This specification uses the terms "character" and "coded character
+   set" in accordance with the definitions provided in [BCP19], and
+   "character encoding" in place of what [BCP19] refers to as a
+   "charset".
+
+1.1.  Overview of URIs
+
+   URIs are characterized as follows:
+
+   Uniform
+
+      Uniformity provides several benefits.  It allows different types
+      of resource identifiers to be used in the same context, even when
+      the mechanisms used to access those resources may differ.  It
+      allows uniform semantic interpretation of common syntactic
+      conventions across different types of resource identifiers.  It
+      allows introduction of new types of resource identifiers without
+      interfering with the way that existing identifiers are used.  It
+      allows the identifiers to be reused in many different contexts,
+      thus permitting new applications or protocols to leverage a pre-
+      existing, large, and widely used set of resource identifiers.
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                     [Page 4]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   Resource
+
+      This specification does not limit the scope of what might be a
+      resource; rather, the term "resource" is used in a general sense
+      for whatever might be identified by a URI.  Familiar examples
+      include an electronic document, an image, a source of information
+      with a consistent purpose (e.g., "today's weather report for Los
+      Angeles"), a service (e.g., an HTTP-to-SMS gateway), and a
+      collection of other resources.  A resource is not necessarily
+      accessible via the Internet; e.g., human beings, corporations, and
+      bound books in a library can also be resources.  Likewise,
+      abstract concepts can be resources, such as the operators and
+      operands of a mathematical equation, the types of a relationship
+      (e.g., "parent" or "employee"), or numeric values (e.g., zero,
+      one, and infinity).
+
+   Identifier
+
+      An identifier embodies the information required to distinguish
+      what is being identified from all other things within its scope of
+      identification.  Our use of the terms "identify" and "identifying"
+      refer to this purpose of distinguishing one resource from all
+      other resources, regardless of how that purpose is accomplished
+      (e.g., by name, address, or context).  These terms should not be
+      mistaken as an assumption that an identifier defines or embodies
+      the identity of what is referenced, though that may be the case
+      for some identifiers.  Nor should it be assumed that a system
+      using URIs will access the resource identified: in many cases,
+      URIs are used to denote resources without any intention that they
+      be accessed.  Likewise, the "one" resource identified might not be
+      singular in nature (e.g., a resource might be a named set or a
+      mapping that varies over time).
+
+   A URI is an identifier consisting of a sequence of characters
+   matching the syntax rule named <URI> in Section 3.  It enables
+   uniform identification of resources via a separately defined
+   extensible set of naming schemes (Section 3.1).  How that
+   identification is accomplished, assigned, or enabled is delegated to
+   each scheme specification.
+
+   This specification does not place any limits on the nature of a
+   resource, the reasons why an application might seek to refer to a
+   resource, or the kinds of systems that might use URIs for the sake of
+   identifying resources.  This specification does not require that a
+   URI persists in identifying the same resource over time, though that
+   is a common goal of all URI schemes.  Nevertheless, nothing in this
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                     [Page 5]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   specification prevents an application from limiting itself to
+   particular types of resources, or to a subset of URIs that maintains
+   characteristics desired by that application.
+
+   URIs have a global scope and are interpreted consistently regardless
+   of context, though the result of that interpretation may be in
+   relation to the end-user's context.  For example, "http://localhost/"
+   has the same interpretation for every user of that reference, even
+   though the network interface corresponding to "localhost" may be
+   different for each end-user: interpretation is independent of access.
+   However, an action made on the basis of that reference will take
+   place in relation to the end-user's context, which implies that an
+   action intended to refer to a globally unique thing must use a URI
+   that distinguishes that resource from all other things.  URIs that
+   identify in relation to the end-user's local context should only be
+   used when the context itself is a defining aspect of the resource,
+   such as when an on-line help manual refers to a file on the end-
+   user's file system (e.g., "file:///etc/hosts").
+
+1.1.1.  Generic Syntax
+
+   Each URI begins with a scheme name, as defined in Section 3.1, that
+   refers to a specification for assigning identifiers within that
+   scheme.  As such, the URI syntax is a federated and extensible naming
+   system wherein each scheme's specification may further restrict the
+   syntax and semantics of identifiers using that scheme.
+
+   This specification defines those elements of the URI syntax that are
+   required of all URI schemes or are common to many URI schemes.  It
+   thus defines the syntax and semantics needed to implement a scheme-
+   independent parsing mechanism for URI references, by which the
+   scheme-dependent handling of a URI can be postponed until the
+   scheme-dependent semantics are needed.  Likewise, protocols and data
+   formats that make use of URI references can refer to this
+   specification as a definition for the range of syntax allowed for all
+   URIs, including those schemes that have yet to be defined.  This
+   decouples the evolution of identification schemes from the evolution
+   of protocols, data formats, and implementations that make use of
+   URIs.
+
+   A parser of the generic URI syntax can parse any URI reference into
+   its major components.  Once the scheme is determined, further
+   scheme-specific parsing can be performed on the components.  In other
+   words, the URI generic syntax is a superset of the syntax of all URI
+   schemes.
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                     [Page 6]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+1.1.2.  Examples
+
+   The following example URIs illustrate several URI schemes and
+   variations in their common syntax components:
+
+      ftp://ftp.is.co.za/rfc/rfc1808.txt
+
+      http://www.ietf.org/rfc/rfc2396.txt
+
+      ldap://[2001:db8::7]/c=GB?objectClass?one
+
+      mailto:John.Doe@example.com
+
+      news:comp.infosystems.www.servers.unix
+
+      tel:+1-816-555-1212
+
+      telnet://192.0.2.16:80/
+
+      urn:oasis:names:specification:docbook:dtd:xml:4.1.2
+
+
+1.1.3.  URI, URL, and URN
+
+   A URI can be further classified as a locator, a name, or both.  The
+   term "Uniform Resource Locator" (URL) refers to the subset of URIs
+   that, in addition to identifying a resource, provide a means of
+   locating the resource by describing its primary access mechanism
+   (e.g., its network "location").  The term "Uniform Resource Name"
+   (URN) has been used historically to refer to both URIs under the
+   "urn" scheme [RFC2141], which are required to remain globally unique
+   and persistent even when the resource ceases to exist or becomes
+   unavailable, and to any other URI with the properties of a name.
+
+   An individual scheme does not have to be classified as being just one
+   of "name" or "locator".  Instances of URIs from any given scheme may
+   have the characteristics of names or locators or both, often
+   depending on the persistence and care in the assignment of
+   identifiers by the naming authority, rather than on any quality of
+   the scheme.  Future specifications and related documentation should
+   use the general term "URI" rather than the more restrictive terms
+   "URL" and "URN" [RFC3305].
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                     [Page 7]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+1.2.  Design Considerations
+
+1.2.1.  Transcription
+
+   The URI syntax has been designed with global transcription as one of
+   its main considerations.  A URI is a sequence of characters from a
+   very limited set: the letters of the basic Latin alphabet, digits,
+   and a few special characters.  A URI may be represented in a variety
+   of ways; e.g., ink on paper, pixels on a screen, or a sequence of
+   character encoding octets.  The interpretation of a URI depends only
+   on the characters used and not on how those characters are
+   represented in a network protocol.
+
+   The goal of transcription can be described by a simple scenario.
+   Imagine two colleagues, Sam and Kim, sitting in a pub at an
+   international conference and exchanging research ideas.  Sam asks Kim
+   for a location to get more information, so Kim writes the URI for the
+   research site on a napkin.  Upon returning home, Sam takes out the
+   napkin and types the URI into a computer, which then retrieves the
+   information to which Kim referred.
+
+   There are several design considerations revealed by the scenario:
+
+   o  A URI is a sequence of characters that is not always represented
+      as a sequence of octets.
+
+   o  A URI might be transcribed from a non-network source and thus
+      should consist of characters that are most likely able to be
+      entered into a computer, within the constraints imposed by
+      keyboards (and related input devices) across languages and
+      locales.
+
+   o  A URI often has to be remembered by people, and it is easier for
+      people to remember a URI when it consists of meaningful or
+      familiar components.
+
+   These design considerations are not always in alignment.  For
+   example, it is often the case that the most meaningful name for a URI
+   component would require characters that cannot be typed into some
+   systems.  The ability to transcribe a resource identifier from one
+   medium to another has been considered more important than having a
+   URI consist of the most meaningful of components.
+
+   In local or regional contexts and with improving technology, users
+   might benefit from being able to use a wider range of characters;
+   such use is not defined by this specification.  Percent-encoded
+   octets (Section 2.1) may be used within a URI to represent characters
+   outside the range of the US-ASCII coded character set if this
+
+
+
+Berners-Lee, et al.         Standards Track                     [Page 8]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   representation is allowed by the scheme or by the protocol element in
+   which the URI is referenced.  Such a definition should specify the
+   character encoding used to map those characters to octets prior to
+   being percent-encoded for the URI.
+
+1.2.2.  Separating Identification from Interaction
+
+   A common misunderstanding of URIs is that they are only used to refer
+   to accessible resources.  The URI itself only provides
+   identification; access to the resource is neither guaranteed nor
+   implied by the presence of a URI.  Instead, any operation associated
+   with a URI reference is defined by the protocol element, data format
+   attribute, or natural language text in which it appears.
+
+   Given a URI, a system may attempt to perform a variety of operations
+   on the resource, as might be characterized by words such as "access",
+   "update", "replace", or "find attributes".  Such operations are
+   defined by the protocols that make use of URIs, not by this
+   specification.  However, we do use a few general terms for describing
+   common operations on URIs.  URI "resolution" is the process of
+   determining an access mechanism and the appropriate parameters
+   necessary to dereference a URI; this resolution may require several
+   iterations.  To use that access mechanism to perform an action on the
+   URI's resource is to "dereference" the URI.
+
+   When URIs are used within information retrieval systems to identify
+   sources of information, the most common form of URI dereference is
+   "retrieval": making use of a URI in order to retrieve a
+   representation of its associated resource.  A "representation" is a
+   sequence of octets, along with representation metadata describing
+   those octets, that constitutes a record of the state of the resource
+   at the time when the representation is generated.  Retrieval is
+   achieved by a process that might include using the URI as a cache key
+   to check for a locally cached representation, resolution of the URI
+   to determine an appropriate access mechanism (if any), and
+   dereference of the URI for the sake of applying a retrieval
+   operation.  Depending on the protocols used to perform the retrieval,
+   additional information might be supplied about the resource (resource
+   metadata) and its relation to other resources.
+
+   URI references in information retrieval systems are designed to be
+   late-binding: the result of an access is generally determined when it
+   is accessed and may vary over time or due to other aspects of the
+   interaction.  These references are created in order to be used in the
+   future: what is being identified is not some specific result that was
+   obtained in the past, but rather some characteristic that is expected
+   to be true for future results.  In such cases, the resource referred
+   to by the URI is actually a sameness of characteristics as observed
+
+
+
+Berners-Lee, et al.         Standards Track                     [Page 9]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   over time, perhaps elucidated by additional comments or assertions
+   made by the resource provider.
+
+   Although many URI schemes are named after protocols, this does not
+   imply that use of these URIs will result in access to the resource
+   via the named protocol.  URIs are often used simply for the sake of
+   identification.  Even when a URI is used to retrieve a representation
+   of a resource, that access might be through gateways, proxies,
+   caches, and name resolution services that are independent of the
+   protocol associated with the scheme name.  The resolution of some
+   URIs may require the use of more than one protocol (e.g., both DNS
+   and HTTP are typically used to access an "http" URI's origin server
+   when a representation isn't found in a local cache).
+
+1.2.3.  Hierarchical Identifiers
+
+   The URI syntax is organized hierarchically, with components listed in
+   order of decreasing significance from left to right.  For some URI
+   schemes, the visible hierarchy is limited to the scheme itself:
+   everything after the scheme component delimiter (":") is considered
+   opaque to URI processing.  Other URI schemes make the hierarchy
+   explicit and visible to generic parsing algorithms.
+
+   The generic syntax uses the slash ("/"), question mark ("?"), and
+   number sign ("#") characters to delimit components that are
+   significant to the generic parser's hierarchical interpretation of an
+   identifier.  In addition to aiding the readability of such
+   identifiers through the consistent use of familiar syntax, this
+   uniform representation of hierarchy across naming schemes allows
+   scheme-independent references to be made relative to that hierarchy.
+
+   It is often the case that a group or "tree" of documents has been
+   constructed to serve a common purpose, wherein the vast majority of
+   URI references in these documents point to resources within the tree
+   rather than outside it.  Similarly, documents located at a particular
+   site are much more likely to refer to other resources at that site
+   than to resources at remote sites.  Relative referencing of URIs
+   allows document trees to be partially independent of their location
+   and access scheme.  For instance, it is possible for a single set of
+   hypertext documents to be simultaneously accessible and traversable
+   via each of the "file", "http", and "ftp" schemes if the documents
+   refer to each other with relative references.  Furthermore, such
+   document trees can be moved, as a whole, without changing any of the
+   relative references.
+
+   A relative reference (Section 4.2) refers to a resource by describing
+   the difference within a hierarchical name space between the reference
+   context and the target URI.  The reference resolution algorithm,
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 10]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   presented in Section 5, defines how such a reference is transformed
+   to the target URI.  As relative references can only be used within
+   the context of a hierarchical URI, designers of new URI schemes
+   should use a syntax consistent with the generic syntax's hierarchical
+   components unless there are compelling reasons to forbid relative
+   referencing within that scheme.
+
+      NOTE: Previous specifications used the terms "partial URI" and
+      "relative URI" to denote a relative reference to a URI.  As some
+      readers misunderstood those terms to mean that relative URIs are a
+      subset of URIs rather than a method of referencing URIs, this
+      specification simply refers to them as relative references.
+
+   All URI references are parsed by generic syntax parsers when used.
+   However, because hierarchical processing has no effect on an absolute
+   URI used in a reference unless it contains one or more dot-segments
+   (complete path segments of "." or "..", as described in Section 3.3),
+   URI scheme specifications can define opaque identifiers by
+   disallowing use of slash characters, question mark characters, and
+   the URIs "scheme:." and "scheme:..".
+
+1.3.  Syntax Notation
+
+   This specification uses the Augmented Backus-Naur Form (ABNF)
+   notation of [RFC2234], including the following core ABNF syntax rules
+   defined by that specification: ALPHA (letters), CR (carriage return),
+   DIGIT (decimal digits), DQUOTE (double quote), HEXDIG (hexadecimal
+   digits), LF (line feed), and SP (space).  The complete URI syntax is
+   collected in Appendix A.
+
+2.  Characters
+
+   The URI syntax provides a method of encoding data, presumably for the
+   sake of identifying a resource, as a sequence of characters.  The URI
+   characters are, in turn, frequently encoded as octets for transport
+   or presentation.  This specification does not mandate any particular
+   character encoding for mapping between URI characters and the octets
+   used to store or transmit those characters.  When a URI appears in a
+   protocol element, the character encoding is defined by that protocol;
+   without such a definition, a URI is assumed to be in the same
+   character encoding as the surrounding text.
+
+   The ABNF notation defines its terminal values to be non-negative
+   integers (codepoints) based on the US-ASCII coded character set
+   [ASCII].  Because a URI is a sequence of characters, we must invert
+   that relation in order to understand the URI syntax.  Therefore, the
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 11]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   integer values used by the ABNF must be mapped back to their
+   corresponding characters via US-ASCII in order to complete the syntax
+   rules.
+
+   A URI is composed from a limited set of characters consisting of
+   digits, letters, and a few graphic symbols.  A reserved subset of
+   those characters may be used to delimit syntax components within a
+   URI while the remaining characters, including both the unreserved set
+   and those reserved characters not acting as delimiters, define each
+   component's identifying data.
+
+2.1.  Percent-Encoding
+
+   A percent-encoding mechanism is used to represent a data octet in a
+   component when that octet's corresponding character is outside the
+   allowed set or is being used as a delimiter of, or within, the
+   component.  A percent-encoded octet is encoded as a character
+   triplet, consisting of the percent character "%" followed by the two
+   hexadecimal digits representing that octet's numeric value.  For
+   example, "%20" is the percent-encoding for the binary octet
+   "00100000" (ABNF: %x20), which in US-ASCII corresponds to the space
+   character (SP).  Section 2.4 describes when percent-encoding and
+   decoding is applied.
+
+      pct-encoded = "%" HEXDIG HEXDIG
+
+   The uppercase hexadecimal digits 'A' through 'F' are equivalent to
+   the lowercase digits 'a' through 'f', respectively.  If two URIs
+   differ only in the case of hexadecimal digits used in percent-encoded
+   octets, they are equivalent.  For consistency, URI producers and
+   normalizers should use uppercase hexadecimal digits for all percent-
+   encodings.
+
+2.2.  Reserved Characters
+
+   URIs include components and subcomponents that are delimited by
+   characters in the "reserved" set.  These characters are called
+   "reserved" because they may (or may not) be defined as delimiters by
+   the generic syntax, by each scheme-specific syntax, or by the
+   implementation-specific syntax of a URI's dereferencing algorithm.
+   If data for a URI component would conflict with a reserved
+   character's purpose as a delimiter, then the conflicting data must be
+   percent-encoded before the URI is formed.
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 12]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+      reserved    = gen-delims / sub-delims
+
+      gen-delims  = ":" / "/" / "?" / "#" / "[" / "]" / "@"
+
+      sub-delims  = "!" / "$" / "&" / "'" / "(" / ")"
+                  / "*" / "+" / "," / ";" / "="
+
+   The purpose of reserved characters is to provide a set of delimiting
+   characters that are distinguishable from other data within a URI.
+   URIs that differ in the replacement of a reserved character with its
+   corresponding percent-encoded octet are not equivalent.  Percent-
+   encoding a reserved character, or decoding a percent-encoded octet
+   that corresponds to a reserved character, will change how the URI is
+   interpreted by most applications.  Thus, characters in the reserved
+   set are protected from normalization and are therefore safe to be
+   used by scheme-specific and producer-specific algorithms for
+   delimiting data subcomponents within a URI.
+
+   A subset of the reserved characters (gen-delims) is used as
+   delimiters of the generic URI components described in Section 3.  A
+   component's ABNF syntax rule will not use the reserved or gen-delims
+   rule names directly; instead, each syntax rule lists the characters
+   allowed within that component (i.e., not delimiting it), and any of
+   those characters that are also in the reserved set are "reserved" for
+   use as subcomponent delimiters within the component.  Only the most
+   common subcomponents are defined by this specification; other
+   subcomponents may be defined by a URI scheme's specification, or by
+   the implementation-specific syntax of a URI's dereferencing
+   algorithm, provided that such subcomponents are delimited by
+   characters in the reserved set allowed within that component.
+
+   URI producing applications should percent-encode data octets that
+   correspond to characters in the reserved set unless these characters
+   are specifically allowed by the URI scheme to represent data in that
+   component.  If a reserved character is found in a URI component and
+   no delimiting role is known for that character, then it must be
+   interpreted as representing the data octet corresponding to that
+   character's encoding in US-ASCII.
+
+2.3.  Unreserved Characters
+
+   Characters that are allowed in a URI but do not have a reserved
+   purpose are called unreserved.  These include uppercase and lowercase
+   letters, decimal digits, hyphen, period, underscore, and tilde.
+
+      unreserved  = ALPHA / DIGIT / "-" / "." / "_" / "~"
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 13]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   URIs that differ in the replacement of an unreserved character with
+   its corresponding percent-encoded US-ASCII octet are equivalent: they
+   identify the same resource.  However, URI comparison implementations
+   do not always perform normalization prior to comparison (see Section
+   6).  For consistency, percent-encoded octets in the ranges of ALPHA
+   (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E),
+   underscore (%5F), or tilde (%7E) should not be created by URI
+   producers and, when found in a URI, should be decoded to their
+   corresponding unreserved characters by URI normalizers.
+
+2.4.  When to Encode or Decode
+
+   Under normal circumstances, the only time when octets within a URI
+   are percent-encoded is during the process of producing the URI from
+   its component parts.  This is when an implementation determines which
+   of the reserved characters are to be used as subcomponent delimiters
+   and which can be safely used as data.  Once produced, a URI is always
+   in its percent-encoded form.
+
+   When a URI is dereferenced, the components and subcomponents
+   significant to the scheme-specific dereferencing process (if any)
+   must be parsed and separated before the percent-encoded octets within
+   those components can be safely decoded, as otherwise the data may be
+   mistaken for component delimiters.  The only exception is for
+   percent-encoded octets corresponding to characters in the unreserved
+   set, which can be decoded at any time.  For example, the octet
+   corresponding to the tilde ("~") character is often encoded as "%7E"
+   by older URI processing implementations; the "%7E" can be replaced by
+   "~" without changing its interpretation.
+
+   Because the percent ("%") character serves as the indicator for
+   percent-encoded octets, it must be percent-encoded as "%25" for that
+   octet to be used as data within a URI.  Implementations must not
+   percent-encode or decode the same string more than once, as decoding
+   an already decoded string might lead to misinterpreting a percent
+   data octet as the beginning of a percent-encoding, or vice versa in
+   the case of percent-encoding an already percent-encoded string.
+
+2.5.  Identifying Data
+
+   URI characters provide identifying data for each of the URI
+   components, serving as an external interface for identification
+   between systems.  Although the presence and nature of the URI
+   production interface is hidden from clients that use its URIs (and is
+   thus beyond the scope of the interoperability requirements defined by
+   this specification), it is a frequent source of confusion and errors
+   in the interpretation of URI character issues.  Implementers have to
+   be aware that there are multiple character encodings involved in the
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 14]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   production and transmission of URIs: local name and data encoding,
+   public interface encoding, URI character encoding, data format
+   encoding, and protocol encoding.
+
+   Local names, such as file system names, are stored with a local
+   character encoding.  URI producing applications (e.g., origin
+   servers) will typically use the local encoding as the basis for
+   producing meaningful names.  The URI producer will transform the
+   local encoding to one that is suitable for a public interface and
+   then transform the public interface encoding into the restricted set
+   of URI characters (reserved, unreserved, and percent-encodings).
+   Those characters are, in turn, encoded as octets to be used as a
+   reference within a data format (e.g., a document charset), and such
+   data formats are often subsequently encoded for transmission over
+   Internet protocols.
+
+   For most systems, an unreserved character appearing within a URI
+   component is interpreted as representing the data octet corresponding
+   to that character's encoding in US-ASCII.  Consumers of URIs assume
+   that the letter "X" corresponds to the octet "01011000", and even
+   when that assumption is incorrect, there is no harm in making it.  A
+   system that internally provides identifiers in the form of a
+   different character encoding, such as EBCDIC, will generally perform
+   character translation of textual identifiers to UTF-8 [STD63] (or
+   some other superset of the US-ASCII character encoding) at an
+   internal interface, thereby providing more meaningful identifiers
+   than those resulting from simply percent-encoding the original
+   octets.
+
+   For example, consider an information service that provides data,
+   stored locally using an EBCDIC-based file system, to clients on the
+   Internet through an HTTP server.  When an author creates a file with
+   the name "Laguna Beach" on that file system, the "http" URI
+   corresponding to that resource is expected to contain the meaningful
+   string "Laguna%20Beach".  If, however, that server produces URIs by
+   using an overly simplistic raw octet mapping, then the result would
+   be a URI containing "%D3%81%87%A4%95%81@%C2%85%81%83%88".  An
+   internal transcoding interface fixes this problem by transcoding the
+   local name to a superset of US-ASCII prior to producing the URI.
+   Naturally, proper interpretation of an incoming URI on such an
+   interface requires that percent-encoded octets be decoded (e.g.,
+   "%20" to SP) before the reverse transcoding is applied to obtain the
+   local name.
+
+   In some cases, the internal interface between a URI component and the
+   identifying data that it has been crafted to represent is much less
+   direct than a character encoding translation.  For example, portions
+   of a URI might reflect a query on non-ASCII data, or numeric
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 15]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   coordinates on a map.  Likewise, a URI scheme may define components
+   with additional encoding requirements that are applied prior to
+   forming the component and producing the URI.
+
+   When a new URI scheme defines a component that represents textual
+   data consisting of characters from the Universal Character Set [UCS],
+   the data should first be encoded as octets according to the UTF-8
+   character encoding [STD63]; then only those octets that do not
+   correspond to characters in the unreserved set should be percent-
+   encoded.  For example, the character A would be represented as "A",
+   the character LATIN CAPITAL LETTER A WITH GRAVE would be represented
+   as "%C3%80", and the character KATAKANA LETTER A would be represented
+   as "%E3%82%A2".
+
+3.  Syntax Components
+
+   The generic URI syntax consists of a hierarchical sequence of
+   components referred to as the scheme, authority, path, query, and
+   fragment.
+
+      URI         = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
+
+      hier-part   = "//" authority path-abempty
+                  / path-absolute
+                  / path-rootless
+                  / path-empty
+
+   The scheme and path components are required, though the path may be
+   empty (no characters).  When authority is present, the path must
+   either be empty or begin with a slash ("/") character.  When
+   authority is not present, the path cannot begin with two slash
+   characters ("//").  These restrictions result in five different ABNF
+   rules for a path (Section 3.3), only one of which will match any
+   given URI reference.
+
+   The following are two example URIs and their component parts:
+
+         foo://example.com:8042/over/there?name=ferret#nose
+         \_/   \______________/\_________/ \_________/ \__/
+          |           |            |            |        |
+       scheme     authority       path        query   fragment
+          |   _____________________|__
+         / \ /                        \
+         urn:example:animal:ferret:nose
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 16]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+3.1.  Scheme
+
+   Each URI begins with a scheme name that refers to a specification for
+   assigning identifiers within that scheme.  As such, the URI syntax is
+   a federated and extensible naming system wherein each scheme's
+   specification may further restrict the syntax and semantics of
+   identifiers using that scheme.
+
+   Scheme names consist of a sequence of characters beginning with a
+   letter and followed by any combination of letters, digits, plus
+   ("+"), period ("."), or hyphen ("-").  Although schemes are case-
+   insensitive, the canonical form is lowercase and documents that
+   specify schemes must do so with lowercase letters.  An implementation
+   should accept uppercase letters as equivalent to lowercase in scheme
+   names (e.g., allow "HTTP" as well as "http") for the sake of
+   robustness but should only produce lowercase scheme names for
+   consistency.
+
+      scheme      = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
+
+   Individual schemes are not specified by this document.  The process
+   for registration of new URI schemes is defined separately by [BCP35].
+   The scheme registry maintains the mapping between scheme names and
+   their specifications.  Advice for designers of new URI schemes can be
+   found in [RFC2718].  URI scheme specifications must define their own
+   syntax so that all strings matching their scheme-specific syntax will
+   also match the <absolute-URI> grammar, as described in Section 4.3.
+
+   When presented with a URI that violates one or more scheme-specific
+   restrictions, the scheme-specific resolution process should flag the
+   reference as an error rather than ignore the unused parts; doing so
+   reduces the number of equivalent URIs and helps detect abuses of the
+   generic syntax, which might indicate that the URI has been
+   constructed to mislead the user (Section 7.6).
+
+3.2.  Authority
+
+   Many URI schemes include a hierarchical element for a naming
+   authority so that governance of the name space defined by the
+   remainder of the URI is delegated to that authority (which may, in
+   turn, delegate it further).  The generic syntax provides a common
+   means for distinguishing an authority based on a registered name or
+   server address, along with optional port and user information.
+
+   The authority component is preceded by a double slash ("//") and is
+   terminated by the next slash ("/"), question mark ("?"), or number
+   sign ("#") character, or by the end of the URI.
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 17]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+      authority   = [ userinfo "@" ] host [ ":" port ]
+
+   URI producers and normalizers should omit the ":" delimiter that
+   separates host from port if the port component is empty.  Some
+   schemes do not allow the userinfo and/or port subcomponents.
+
+   If a URI contains an authority component, then the path component
+   must either be empty or begin with a slash ("/") character.  Non-
+   validating parsers (those that merely separate a URI reference into
+   its major components) will often ignore the subcomponent structure of
+   authority, treating it as an opaque string from the double-slash to
+   the first terminating delimiter, until such time as the URI is
+   dereferenced.
+
+3.2.1.  User Information
+
+   The userinfo subcomponent may consist of a user name and, optionally,
+   scheme-specific information about how to gain authorization to access
+   the resource.  The user information, if present, is followed by a
+   commercial at-sign ("@") that delimits it from the host.
+
+      userinfo    = *( unreserved / pct-encoded / sub-delims / ":" )
+
+   Use of the format "user:password" in the userinfo field is
+   deprecated.  Applications should not render as clear text any data
+   after the first colon (":") character found within a userinfo
+   subcomponent unless the data after the colon is the empty string
+   (indicating no password).  Applications may choose to ignore or
+   reject such data when it is received as part of a reference and
+   should reject the storage of such data in unencrypted form.  The
+   passing of authentication information in clear text has proven to be
+   a security risk in almost every case where it has been used.
+
+   Applications that render a URI for the sake of user feedback, such as
+   in graphical hypertext browsing, should render userinfo in a way that
+   is distinguished from the rest of a URI, when feasible.  Such
+   rendering will assist the user in cases where the userinfo has been
+   misleadingly crafted to look like a trusted domain name
+   (Section 7.6).
+
+3.2.2.  Host
+
+   The host subcomponent of authority is identified by an IP literal
+   encapsulated within square brackets, an IPv4 address in dotted-
+   decimal form, or a registered name.  The host subcomponent is case-
+   insensitive.  The presence of a host subcomponent within a URI does
+   not imply that the scheme requires access to the given host on the
+   Internet.  In many cases, the host syntax is used only for the sake
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 18]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   of reusing the existing registration process created and deployed for
+   DNS, thus obtaining a globally unique name without the cost of
+   deploying another registry.  However, such use comes with its own
+   costs: domain name ownership may change over time for reasons not
+   anticipated by the URI producer.  In other cases, the data within the
+   host component identifies a registered name that has nothing to do
+   with an Internet host.  We use the name "host" for the ABNF rule
+   because that is its most common purpose, not its only purpose.
+
+      host        = IP-literal / IPv4address / reg-name
+
+   The syntax rule for host is ambiguous because it does not completely
+   distinguish between an IPv4address and a reg-name.  In order to
+   disambiguate the syntax, we apply the "first-match-wins" algorithm:
+   If host matches the rule for IPv4address, then it should be
+   considered an IPv4 address literal and not a reg-name.  Although host
+   is case-insensitive, producers and normalizers should use lowercase
+   for registered names and hexadecimal addresses for the sake of
+   uniformity, while only using uppercase letters for percent-encodings.
+
+   A host identified by an Internet Protocol literal address, version 6
+   [RFC3513] or later, is distinguished by enclosing the IP literal
+   within square brackets ("[" and "]").  This is the only place where
+   square bracket characters are allowed in the URI syntax.  In
+   anticipation of future, as-yet-undefined IP literal address formats,
+   an implementation may use an optional version flag to indicate such a
+   format explicitly rather than rely on heuristic determination.
+
+      IP-literal = "[" ( IPv6address / IPvFuture  ) "]"
+
+      IPvFuture  = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
+
+   The version flag does not indicate the IP version; rather, it
+   indicates future versions of the literal format.  As such,
+   implementations must not provide the version flag for the existing
+   IPv4 and IPv6 literal address forms described below.  If a URI
+   containing an IP-literal that starts with "v" (case-insensitive),
+   indicating that the version flag is present, is dereferenced by an
+   application that does not know the meaning of that version flag, then
+   the application should return an appropriate error for "address
+   mechanism not supported".
+
+   A host identified by an IPv6 literal address is represented inside
+   the square brackets without a preceding version flag.  The ABNF
+   provided here is a translation of the text definition of an IPv6
+   literal address provided in [RFC3513].  This syntax does not support
+   IPv6 scoped addressing zone identifiers.
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 19]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   A 128-bit IPv6 address is divided into eight 16-bit pieces.  Each
+   piece is represented numerically in case-insensitive hexadecimal,
+   using one to four hexadecimal digits (leading zeroes are permitted).
+   The eight encoded pieces are given most-significant first, separated
+   by colon characters.  Optionally, the least-significant two pieces
+   may instead be represented in IPv4 address textual format.  A
+   sequence of one or more consecutive zero-valued 16-bit pieces within
+   the address may be elided, omitting all their digits and leaving
+   exactly two consecutive colons in their place to mark the elision.
+
+      IPv6address =                            6( h16 ":" ) ls32
+                  /                       "::" 5( h16 ":" ) ls32
+                  / [               h16 ] "::" 4( h16 ":" ) ls32
+                  / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
+                  / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
+                  / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
+                  / [ *4( h16 ":" ) h16 ] "::"              ls32
+                  / [ *5( h16 ":" ) h16 ] "::"              h16
+                  / [ *6( h16 ":" ) h16 ] "::"
+
+      ls32        = ( h16 ":" h16 ) / IPv4address
+                  ; least-significant 32 bits of address
+
+      h16         = 1*4HEXDIG
+                  ; 16 bits of address represented in hexadecimal
+
+   A host identified by an IPv4 literal address is represented in
+   dotted-decimal notation (a sequence of four decimal numbers in the
+   range 0 to 255, separated by "."), as described in [RFC1123] by
+   reference to [RFC0952].  Note that other forms of dotted notation may
+   be interpreted on some platforms, as described in Section 7.4, but
+   only the dotted-decimal form of four octets is allowed by this
+   grammar.
+
+      IPv4address = dec-octet "." dec-octet "." dec-octet "." dec-octet
+
+      dec-octet   = DIGIT                 ; 0-9
+                  / %x31-39 DIGIT         ; 10-99
+                  / "1" 2DIGIT            ; 100-199
+                  / "2" %x30-34 DIGIT     ; 200-249
+                  / "25" %x30-35          ; 250-255
+
+   A host identified by a registered name is a sequence of characters
+   usually intended for lookup within a locally defined host or service
+   name registry, though the URI's scheme-specific semantics may require
+   that a specific registry (or fixed name table) be used instead.  The
+   most common name registry mechanism is the Domain Name System (DNS).
+   A registered name intended for lookup in the DNS uses the syntax
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 20]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   defined in Section 3.5 of [RFC1034] and Section 2.1 of [RFC1123].
+   Such a name consists of a sequence of domain labels separated by ".",
+   each domain label starting and ending with an alphanumeric character
+   and possibly also containing "-" characters.  The rightmost domain
+   label of a fully qualified domain name in DNS may be followed by a
+   single "." and should be if it is necessary to distinguish between
+   the complete domain name and some local domain.
+
+      reg-name    = *( unreserved / pct-encoded / sub-delims )
+
+   If the URI scheme defines a default for host, then that default
+   applies when the host subcomponent is undefined or when the
+   registered name is empty (zero length).  For example, the "file" URI
+   scheme is defined so that no authority, an empty host, and
+   "localhost" all mean the end-user's machine, whereas the "http"
+   scheme considers a missing authority or empty host invalid.
+
+   This specification does not mandate a particular registered name
+   lookup technology and therefore does not restrict the syntax of reg-
+   name beyond what is necessary for interoperability.  Instead, it
+   delegates the issue of registered name syntax conformance to the
+   operating system of each application performing URI resolution, and
+   that operating system decides what it will allow for the purpose of
+   host identification.  A URI resolution implementation might use DNS,
+   host tables, yellow pages, NetInfo, WINS, or any other system for
+   lookup of registered names.  However, a globally scoped naming
+   system, such as DNS fully qualified domain names, is necessary for
+   URIs intended to have global scope.  URI producers should use names
+   that conform to the DNS syntax, even when use of DNS is not
+   immediately apparent, and should limit these names to no more than
+   255 characters in length.
+
+   The reg-name syntax allows percent-encoded octets in order to
+   represent non-ASCII registered names in a uniform way that is
+   independent of the underlying name resolution technology.  Non-ASCII
+   characters must first be encoded according to UTF-8 [STD63], and then
+   each octet of the corresponding UTF-8 sequence must be percent-
+   encoded to be represented as URI characters.  URI producing
+   applications must not use percent-encoding in host unless it is used
+   to represent a UTF-8 character sequence.  When a non-ASCII registered
+   name represents an internationalized domain name intended for
+   resolution via the DNS, the name must be transformed to the IDNA
+   encoding [RFC3490] prior to name lookup.  URI producers should
+   provide these registered names in the IDNA encoding, rather than a
+   percent-encoding, if they wish to maximize interoperability with
+   legacy URI resolvers.
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 21]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+3.2.3.  Port
+
+   The port subcomponent of authority is designated by an optional port
+   number in decimal following the host and delimited from it by a
+   single colon (":") character.
+
+      port        = *DIGIT
+
+   A scheme may define a default port.  For example, the "http" scheme
+   defines a default port of "80", corresponding to its reserved TCP
+   port number.  The type of port designated by the port number (e.g.,
+   TCP, UDP, SCTP) is defined by the URI scheme.  URI producers and
+   normalizers should omit the port component and its ":" delimiter if
+   port is empty or if its value would be the same as that of the
+   scheme's default.
+
+3.3.  Path
+
+   The path component contains data, usually organized in hierarchical
+   form, that, along with data in the non-hierarchical query component
+   (Section 3.4), serves to identify a resource within the scope of the
+   URI's scheme and naming authority (if any).  The path is terminated
+   by the first question mark ("?") or number sign ("#") character, or
+   by the end of the URI.
+
+   If a URI contains an authority component, then the path component
+   must either be empty or begin with a slash ("/") character.  If a URI
+   does not contain an authority component, then the path cannot begin
+   with two slash characters ("//").  In addition, a URI reference
+   (Section 4.1) may be a relative-path reference, in which case the
+   first path segment cannot contain a colon (":") character.  The ABNF
+   requires five separate rules to disambiguate these cases, only one of
+   which will match the path substring within a given URI reference.  We
+   use the generic term "path component" to describe the URI substring
+   matched by the parser to one of these rules.
+
+      path          = path-abempty    ; begins with "/" or is empty
+                    / path-absolute   ; begins with "/" but not "//"
+                    / path-noscheme   ; begins with a non-colon segment
+                    / path-rootless   ; begins with a segment
+                    / path-empty      ; zero characters
+
+      path-abempty  = *( "/" segment )
+      path-absolute = "/" [ segment-nz *( "/" segment ) ]
+      path-noscheme = segment-nz-nc *( "/" segment )
+      path-rootless = segment-nz *( "/" segment )
+      path-empty    = 0<pchar>
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 22]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+      segment       = *pchar
+      segment-nz    = 1*pchar
+      segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / "@" )
+                    ; non-zero-length segment without any colon ":"
+
+      pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
+
+   A path consists of a sequence of path segments separated by a slash
+   ("/") character.  A path is always defined for a URI, though the
+   defined path may be empty (zero length).  Use of the slash character
+   to indicate hierarchy is only required when a URI will be used as the
+   context for relative references.  For example, the URI
+   <mailto:fred@example.com> has a path of "fred@example.com", whereas
+   the URI <foo://info.example.com?fred> has an empty path.
+
+   The path segments "." and "..", also known as dot-segments, are
+   defined for relative reference within the path name hierarchy.  They
+   are intended for use at the beginning of a relative-path reference
+   (Section 4.2) to indicate relative position within the hierarchical
+   tree of names.  This is similar to their role within some operating
+   systems' file directory structures to indicate the current directory
+   and parent directory, respectively.  However, unlike in a file
+   system, these dot-segments are only interpreted within the URI path
+   hierarchy and are removed as part of the resolution process (Section
+   5.2).
+
+   Aside from dot-segments in hierarchical paths, a path segment is
+   considered opaque by the generic syntax.  URI producing applications
+   often use the reserved characters allowed in a segment to delimit
+   scheme-specific or dereference-handler-specific subcomponents.  For
+   example, the semicolon (";") and equals ("=") reserved characters are
+   often used to delimit parameters and parameter values applicable to
+   that segment.  The comma (",") reserved character is often used for
+   similar purposes.  For example, one URI producer might use a segment
+   such as "name;v=1.1" to indicate a reference to version 1.1 of
+   "name", whereas another might use a segment such as "name,1.1" to
+   indicate the same.  Parameter types may be defined by scheme-specific
+   semantics, but in most cases the syntax of a parameter is specific to
+   the implementation of the URI's dereferencing algorithm.
+
+3.4.  Query
+
+   The query component contains non-hierarchical data that, along with
+   data in the path component (Section 3.3), serves to identify a
+   resource within the scope of the URI's scheme and naming authority
+   (if any).  The query component is indicated by the first question
+   mark ("?") character and terminated by a number sign ("#") character
+   or by the end of the URI.
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 23]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+      query       = *( pchar / "/" / "?" )
+
+   The characters slash ("/") and question mark ("?") may represent data
+   within the query component.  Beware that some older, erroneous
+   implementations may not handle such data correctly when it is used as
+   the base URI for relative references (Section 5.1), apparently
+   because they fail to distinguish query data from path data when
+   looking for hierarchical separators.  However, as query components
+   are often used to carry identifying information in the form of
+   "key=value" pairs and one frequently used value is a reference to
+   another URI, it is sometimes better for usability to avoid percent-
+   encoding those characters.
+
+3.5.  Fragment
+
+   The fragment identifier component of a URI allows indirect
+   identification of a secondary resource by reference to a primary
+   resource and additional identifying information.  The identified
+   secondary resource may be some portion or subset of the primary
+   resource, some view on representations of the primary resource, or
+   some other resource defined or described by those representations.  A
+   fragment identifier component is indicated by the presence of a
+   number sign ("#") character and terminated by the end of the URI.
+
+      fragment    = *( pchar / "/" / "?" )
+
+   The semantics of a fragment identifier are defined by the set of
+   representations that might result from a retrieval action on the
+   primary resource.  The fragment's format and resolution is therefore
+   dependent on the media type [RFC2046] of a potentially retrieved
+   representation, even though such a retrieval is only performed if the
+   URI is dereferenced.  If no such representation exists, then the
+   semantics of the fragment are considered unknown and are effectively
+   unconstrained.  Fragment identifier semantics are independent of the
+   URI scheme and thus cannot be redefined by scheme specifications.
+
+   Individual media types may define their own restrictions on or
+   structures within the fragment identifier syntax for specifying
+   different types of subsets, views, or external references that are
+   identifiable as secondary resources by that media type.  If the
+   primary resource has multiple representations, as is often the case
+   for resources whose representation is selected based on attributes of
+   the retrieval request (a.k.a., content negotiation), then whatever is
+   identified by the fragment should be consistent across all of those
+   representations.  Each representation should either define the
+   fragment so that it corresponds to the same secondary resource,
+   regardless of how it is represented, or should leave the fragment
+   undefined (i.e., not found).
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 24]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   As with any URI, use of a fragment identifier component does not
+   imply that a retrieval action will take place.  A URI with a fragment
+   identifier may be used to refer to the secondary resource without any
+   implication that the primary resource is accessible or will ever be
+   accessed.
+
+   Fragment identifiers have a special role in information retrieval
+   systems as the primary form of client-side indirect referencing,
+   allowing an author to specifically identify aspects of an existing
+   resource that are only indirectly provided by the resource owner.  As
+   such, the fragment identifier is not used in the scheme-specific
+   processing of a URI; instead, the fragment identifier is separated
+   from the rest of the URI prior to a dereference, and thus the
+   identifying information within the fragment itself is dereferenced
+   solely by the user agent, regardless of the URI scheme.  Although
+   this separate handling is often perceived to be a loss of
+   information, particularly for accurate redirection of references as
+   resources move over time, it also serves to prevent information
+   providers from denying reference authors the right to refer to
+   information within a resource selectively.  Indirect referencing also
+   provides additional flexibility and extensibility to systems that use
+   URIs, as new media types are easier to define and deploy than new
+   schemes of identification.
+
+   The characters slash ("/") and question mark ("?") are allowed to
+   represent data within the fragment identifier.  Beware that some
+   older, erroneous implementations may not handle this data correctly
+   when it is used as the base URI for relative references (Section
+   5.1).
+
+4.  Usage
+
+   When applications make reference to a URI, they do not always use the
+   full form of reference defined by the "URI" syntax rule.  To save
+   space and take advantage of hierarchical locality, many Internet
+   protocol elements and media type formats allow an abbreviation of a
+   URI, whereas others restrict the syntax to a particular form of URI.
+   We define the most common forms of reference syntax in this
+   specification because they impact and depend upon the design of the
+   generic syntax, requiring a uniform parsing algorithm in order to be
+   interpreted consistently.
+
+4.1.  URI Reference
+
+   URI-reference is used to denote the most common usage of a resource
+   identifier.
+
+      URI-reference = URI / relative-ref
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 25]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   A URI-reference is either a URI or a relative reference.  If the
+   URI-reference's prefix does not match the syntax of a scheme followed
+   by its colon separator, then the URI-reference is a relative
+   reference.
+
+   A URI-reference is typically parsed first into the five URI
+   components, in order to determine what components are present and
+   whether the reference is relative.  Then, each component is parsed
+   for its subparts and their validation.  The ABNF of URI-reference,
+   along with the "first-match-wins" disambiguation rule, is sufficient
+   to define a validating parser for the generic syntax.  Readers
+   familiar with regular expressions should see Appendix B for an
+   example of a non-validating URI-reference parser that will take any
+   given string and extract the URI components.
+
+4.2.  Relative Reference
+
+   A relative reference takes advantage of the hierarchical syntax
+   (Section 1.2.3) to express a URI reference relative to the name space
+   of another hierarchical URI.
+
+      relative-ref  = relative-part [ "?" query ] [ "#" fragment ]
+
+      relative-part = "//" authority path-abempty
+                    / path-absolute
+                    / path-noscheme
+                    / path-empty
+
+   The URI referred to by a relative reference, also known as the target
+   URI, is obtained by applying the reference resolution algorithm of
+   Section 5.
+
+   A relative reference that begins with two slash characters is termed
+   a network-path reference; such references are rarely used.  A
+   relative reference that begins with a single slash character is
+   termed an absolute-path reference.  A relative reference that does
+   not begin with a slash character is termed a relative-path reference.
+
+   A path segment that contains a colon character (e.g., "this:that")
+   cannot be used as the first segment of a relative-path reference, as
+   it would be mistaken for a scheme name.  Such a segment must be
+   preceded by a dot-segment (e.g., "./this:that") to make a relative-
+   path reference.
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 26]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+4.3.  Absolute URI
+
+   Some protocol elements allow only the absolute form of a URI without
+   a fragment identifier.  For example, defining a base URI for later
+   use by relative references calls for an absolute-URI syntax rule that
+   does not allow a fragment.
+
+      absolute-URI  = scheme ":" hier-part [ "?" query ]
+
+   URI scheme specifications must define their own syntax so that all
+   strings matching their scheme-specific syntax will also match the
+   <absolute-URI> grammar.  Scheme specifications will not define
+   fragment identifier syntax or usage, regardless of its applicability
+   to resources identifiable via that scheme, as fragment identification
+   is orthogonal to scheme definition.  However, scheme specifications
+   are encouraged to include a wide range of examples, including
+   examples that show use of the scheme's URIs with fragment identifiers
+   when such usage is appropriate.
+
+4.4.  Same-Document Reference
+
+   When a URI reference refers to a URI that is, aside from its fragment
+   component (if any), identical to the base URI (Section 5.1), that
+   reference is called a "same-document" reference.  The most frequent
+   examples of same-document references are relative references that are
+   empty or include only the number sign ("#") separator followed by a
+   fragment identifier.
+
+   When a same-document reference is dereferenced for a retrieval
+   action, the target of that reference is defined to be within the same
+   entity (representation, document, or message) as the reference;
+   therefore, a dereference should not result in a new retrieval action.
+
+   Normalization of the base and target URIs prior to their comparison,
+   as described in Sections 6.2.2 and 6.2.3, is allowed but rarely
+   performed in practice.  Normalization may increase the set of same-
+   document references, which may be of benefit to some caching
+   applications.  As such, reference authors should not assume that a
+   slightly different, though equivalent, reference URI will (or will
+   not) be interpreted as a same-document reference by any given
+   application.
+
+4.5.  Suffix Reference
+
+   The URI syntax is designed for unambiguous reference to resources and
+   extensibility via the URI scheme.  However, as URI identification and
+   usage have become commonplace, traditional media (television, radio,
+   newspapers, billboards, etc.) have increasingly used a suffix of the
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 27]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   URI as a reference, consisting of only the authority and path
+   portions of the URI, such as
+
+      www.w3.org/Addressing/
+
+   or simply a DNS registered name on its own.  Such references are
+   primarily intended for human interpretation rather than for machines,
+   with the assumption that context-based heuristics are sufficient to
+   complete the URI (e.g., most registered names beginning with "www"
+   are likely to have a URI prefix of "http://").  Although there is no
+   standard set of heuristics for disambiguating a URI suffix, many
+   client implementations allow them to be entered by the user and
+   heuristically resolved.
+
+   Although this practice of using suffix references is common, it
+   should be avoided whenever possible and should never be used in
+   situations where long-term references are expected.  The heuristics
+   noted above will change over time, particularly when a new URI scheme
+   becomes popular, and are often incorrect when used out of context.
+   Furthermore, they can lead to security issues along the lines of
+   those described in [RFC1535].
+
+   As a URI suffix has the same syntax as a relative-path reference, a
+   suffix reference cannot be used in contexts where a relative
+   reference is expected.  As a result, suffix references are limited to
+   places where there is no defined base URI, such as dialog boxes and
+   off-line advertisements.
+
+5.  Reference Resolution
+
+   This section defines the process of resolving a URI reference within
+   a context that allows relative references so that the result is a
+   string matching the <URI> syntax rule of Section 3.
+
+5.1.  Establishing a Base URI
+
+   The term "relative" implies that a "base URI" exists against which
+   the relative reference is applied.  Aside from fragment-only
+   references (Section 4.4), relative references are only usable when a
+   base URI is known.  A base URI must be established by the parser
+   prior to parsing URI references that might be relative.  A base URI
+   must conform to the <absolute-URI> syntax rule (Section 4.3).  If the
+   base URI is obtained from a URI reference, then that reference must
+   be converted to absolute form and stripped of any fragment component
+   prior to its use as a base URI.
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 28]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   The base URI of a reference can be established in one of four ways,
+   discussed below in order of precedence.  The order of precedence can
+   be thought of in terms of layers, where the innermost defined base
+   URI has the highest precedence.  This can be visualized graphically
+   as follows:
+
+         .----------------------------------------------------------.
+         |  .----------------------------------------------------.  |
+         |  |  .----------------------------------------------.  |  |
+         |  |  |  .----------------------------------------.  |  |  |
+         |  |  |  |  .----------------------------------.  |  |  |  |
+         |  |  |  |  |       <relative-reference>       |  |  |  |  |
+         |  |  |  |  `----------------------------------'  |  |  |  |
+         |  |  |  | (5.1.1) Base URI embedded in content   |  |  |  |
+         |  |  |  `----------------------------------------'  |  |  |
+         |  |  | (5.1.2) Base URI of the encapsulating entity |  |  |
+         |  |  |         (message, representation, or none)   |  |  |
+         |  |  `----------------------------------------------'  |  |
+         |  | (5.1.3) URI used to retrieve the entity            |  |
+         |  `----------------------------------------------------'  |
+         | (5.1.4) Default Base URI (application-dependent)         |
+         `----------------------------------------------------------'
+
+5.1.1.  Base URI Embedded in Content
+
+   Within certain media types, a base URI for relative references can be
+   embedded within the content itself so that it can be readily obtained
+   by a parser.  This can be useful for descriptive documents, such as
+   tables of contents, which may be transmitted to others through
+   protocols other than their usual retrieval context (e.g., email or
+   USENET news).
+
+   It is beyond the scope of this specification to specify how, for each
+   media type, a base URI can be embedded.  The appropriate syntax, when
+   available, is described by the data format specification associated
+   with each media type.
+
+5.1.2.  Base URI from the Encapsulating Entity
+
+   If no base URI is embedded, the base URI is defined by the
+   representation's retrieval context.  For a document that is enclosed
+   within another entity, such as a message or archive, the retrieval
+   context is that entity.  Thus, the default base URI of a
+   representation is the base URI of the entity in which the
+   representation is encapsulated.
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 29]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   A mechanism for embedding a base URI within MIME container types
+   (e.g., the message and multipart types) is defined by MHTML
+   [RFC2557].  Protocols that do not use the MIME message header syntax,
+   but that do allow some form of tagged metadata to be included within
+   messages, may define their own syntax for defining a base URI as part
+   of a message.
+
+5.1.3.  Base URI from the Retrieval URI
+
+   If no base URI is embedded and the representation is not encapsulated
+   within some other entity, then, if a URI was used to retrieve the
+   representation, that URI shall be considered the base URI.  Note that
+   if the retrieval was the result of a redirected request, the last URI
+   used (i.e., the URI that resulted in the actual retrieval of the
+   representation) is the base URI.
+
+5.1.4.  Default Base URI
+
+   If none of the conditions described above apply, then the base URI is
+   defined by the context of the application.  As this definition is
+   necessarily application-dependent, failing to define a base URI by
+   using one of the other methods may result in the same content being
+   interpreted differently by different types of applications.
+
+   A sender of a representation containing relative references is
+   responsible for ensuring that a base URI for those references can be
+   established.  Aside from fragment-only references, relative
+   references can only be used reliably in situations where the base URI
+   is well defined.
+
+5.2.  Relative Resolution
+
+   This section describes an algorithm for converting a URI reference
+   that might be relative to a given base URI into the parsed components
+   of the reference's target.  The components can then be recomposed, as
+   described in Section 5.3, to form the target URI.  This algorithm
+   provides definitive results that can be used to test the output of
+   other implementations.  Applications may implement relative reference
+   resolution by using some other algorithm, provided that the results
+   match what would be given by this one.
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 30]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+5.2.1.  Pre-parse the Base URI
+
+   The base URI (Base) is established according to the procedure of
+   Section 5.1 and parsed into the five main components described in
+   Section 3.  Note that only the scheme component is required to be
+   present in a base URI; the other components may be empty or
+   undefined.  A component is undefined if its associated delimiter does
+   not appear in the URI reference; the path component is never
+   undefined, though it may be empty.
+
+   Normalization of the base URI, as described in Sections 6.2.2 and
+   6.2.3, is optional.  A URI reference must be transformed to its
+   target URI before it can be normalized.
+
+5.2.2.  Transform References
+
+   For each URI reference (R), the following pseudocode describes an
+   algorithm for transforming R into its target URI (T):
+
+      -- The URI reference is parsed into the five URI components
+      --
+      (R.scheme, R.authority, R.path, R.query, R.fragment) = parse(R);
+
+      -- A non-strict parser may ignore a scheme in the reference
+      -- if it is identical to the base URI's scheme.
+      --
+      if ((not strict) and (R.scheme == Base.scheme)) then
+         undefine(R.scheme);
+      endif;
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 31]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+      if defined(R.scheme) then
+         T.scheme    = R.scheme;
+         T.authority = R.authority;
+         T.path      = remove_dot_segments(R.path);
+         T.query     = R.query;
+      else
+         if defined(R.authority) then
+            T.authority = R.authority;
+            T.path      = remove_dot_segments(R.path);
+            T.query     = R.query;
+         else
+            if (R.path == "") then
+               T.path = Base.path;
+               if defined(R.query) then
+                  T.query = R.query;
+               else
+                  T.query = Base.query;
+               endif;
+            else
+               if (R.path starts-with "/") then
+                  T.path = remove_dot_segments(R.path);
+               else
+                  T.path = merge(Base.path, R.path);
+                  T.path = remove_dot_segments(T.path);
+               endif;
+               T.query = R.query;
+            endif;
+            T.authority = Base.authority;
+         endif;
+         T.scheme = Base.scheme;
+      endif;
+
+      T.fragment = R.fragment;
+
+5.2.3.  Merge Paths
+
+   The pseudocode above refers to a "merge" routine for merging a
+   relative-path reference with the path of the base URI.  This is
+   accomplished as follows:
+
+   o  If the base URI has a defined authority component and an empty
+      path, then return a string consisting of "/" concatenated with the
+      reference's path; otherwise,
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 32]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   o  return a string consisting of the reference's path component
+      appended to all but the last segment of the base URI's path (i.e.,
+      excluding any characters after the right-most "/" in the base URI
+      path, or excluding the entire base URI path if it does not contain
+      any "/" characters).
+
+5.2.4.  Remove Dot Segments
+
+   The pseudocode also refers to a "remove_dot_segments" routine for
+   interpreting and removing the special "." and ".." complete path
+   segments from a referenced path.  This is done after the path is
+   extracted from a reference, whether or not the path was relative, in
+   order to remove any invalid or extraneous dot-segments prior to
+   forming the target URI.  Although there are many ways to accomplish
+   this removal process, we describe a simple method using two string
+   buffers.
+
+   1.  The input buffer is initialized with the now-appended path
+       components and the output buffer is initialized to the empty
+       string.
+
+   2.  While the input buffer is not empty, loop as follows:
+
+       A.  If the input buffer begins with a prefix of "../" or "./",
+           then remove that prefix from the input buffer; otherwise,
+
+       B.  if the input buffer begins with a prefix of "/./" or "/.",
+           where "." is a complete path segment, then replace that
+           prefix with "/" in the input buffer; otherwise,
+
+       C.  if the input buffer begins with a prefix of "/../" or "/..",
+           where ".." is a complete path segment, then replace that
+           prefix with "/" in the input buffer and remove the last
+           segment and its preceding "/" (if any) from the output
+           buffer; otherwise,
+
+       D.  if the input buffer consists only of "." or "..", then remove
+           that from the input buffer; otherwise,
+
+       E.  move the first path segment in the input buffer to the end of
+           the output buffer, including the initial "/" character (if
+           any) and any subsequent characters up to, but not including,
+           the next "/" character or the end of the input buffer.
+
+   3.  Finally, the output buffer is returned as the result of
+       remove_dot_segments.
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 33]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   Note that dot-segments are intended for use in URI references to
+   express an identifier relative to the hierarchy of names in the base
+   URI.  The remove_dot_segments algorithm respects that hierarchy by
+   removing extra dot-segments rather than treat them as an error or
+   leaving them to be misinterpreted by dereference implementations.
+
+   The following illustrates how the above steps are applied for two
+   examples of merged paths, showing the state of the two buffers after
+   each step.
+
+      STEP   OUTPUT BUFFER         INPUT BUFFER
+
+       1 :                         /a/b/c/./../../g
+       2E:   /a                    /b/c/./../../g
+       2E:   /a/b                  /c/./../../g
+       2E:   /a/b/c                /./../../g
+       2B:   /a/b/c                /../../g
+       2C:   /a/b                  /../g
+       2C:   /a                    /g
+       2E:   /a/g
+
+      STEP   OUTPUT BUFFER         INPUT BUFFER
+
+       1 :                         mid/content=5/../6
+       2E:   mid                   /content=5/../6
+       2E:   mid/content=5         /../6
+       2C:   mid                   /6
+       2E:   mid/6
+
+   Some applications may find it more efficient to implement the
+   remove_dot_segments algorithm by using two segment stacks rather than
+   strings.
+
+      Note: Beware that some older, erroneous implementations will fail
+      to separate a reference's query component from its path component
+      prior to merging the base and reference paths, resulting in an
+      interoperability failure if the query component contains the
+      strings "/../" or "/./".
+
+
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 34]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+5.3.  Component Recomposition
+
+   Parsed URI components can be recomposed to obtain the corresponding
+   URI reference string.  Using pseudocode, this would be:
+
+      result = ""
+
+      if defined(scheme) then
+         append scheme to result;
+         append ":" to result;
+      endif;
+
+      if defined(authority) then
+         append "//" to result;
+         append authority to result;
+      endif;
+
+      append path to result;
+
+      if defined(query) then
+         append "?" to result;
+         append query to result;
+      endif;
+
+      if defined(fragment) then
+         append "#" to result;
+         append fragment to result;
+      endif;
+
+      return result;
+
+   Note that we are careful to preserve the distinction between a
+   component that is undefined, meaning that its separator was not
+   present in the reference, and a component that is empty, meaning that
+   the separator was present and was immediately followed by the next
+   component separator or the end of the reference.
+
+5.4.  Reference Resolution Examples
+
+   Within a representation with a well defined base URI of
+
+      http://a/b/c/d;p?q
+
+   a relative reference is transformed to its target URI as follows.
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 35]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+5.4.1.  Normal Examples
+
+      "g:h"           =  "g:h"
+      "g"             =  "http://a/b/c/g"
+      "./g"           =  "http://a/b/c/g"
+      "g/"            =  "http://a/b/c/g/"
+      "/g"            =  "http://a/g"
+      "//g"           =  "http://g"
+      "?y"            =  "http://a/b/c/d;p?y"
+      "g?y"           =  "http://a/b/c/g?y"
+      "#s"            =  "http://a/b/c/d;p?q#s"
+      "g#s"           =  "http://a/b/c/g#s"
+      "g?y#s"         =  "http://a/b/c/g?y#s"
+      ";x"            =  "http://a/b/c/;x"
+      "g;x"           =  "http://a/b/c/g;x"
+      "g;x?y#s"       =  "http://a/b/c/g;x?y#s"
+      ""              =  "http://a/b/c/d;p?q"
+      "."             =  "http://a/b/c/"
+      "./"            =  "http://a/b/c/"
+      ".."            =  "http://a/b/"
+      "../"           =  "http://a/b/"
+      "../g"          =  "http://a/b/g"
+      "../.."         =  "http://a/"
+      "../../"        =  "http://a/"
+      "../../g"       =  "http://a/g"
+
+5.4.2.  Abnormal Examples
+
+   Although the following abnormal examples are unlikely to occur in
+   normal practice, all URI parsers should be capable of resolving them
+   consistently.  Each example uses the same base as that above.
+
+   Parsers must be careful in handling cases where there are more ".."
+   segments in a relative-path reference than there are hierarchical
+   levels in the base URI's path.  Note that the ".." syntax cannot be
+   used to change the authority component of a URI.
+
+      "../../../g"    =  "http://a/g"
+      "../../../../g" =  "http://a/g"
+
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 36]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   Similarly, parsers must remove the dot-segments "." and ".." when
+   they are complete components of a path, but not when they are only
+   part of a segment.
+
+      "/./g"          =  "http://a/g"
+      "/../g"         =  "http://a/g"
+      "g."            =  "http://a/b/c/g."
+      ".g"            =  "http://a/b/c/.g"
+      "g.."           =  "http://a/b/c/g.."
+      "..g"           =  "http://a/b/c/..g"
+
+   Less likely are cases where the relative reference uses unnecessary
+   or nonsensical forms of the "." and ".." complete path segments.
+
+      "./../g"        =  "http://a/b/g"
+      "./g/."         =  "http://a/b/c/g/"
+      "g/./h"         =  "http://a/b/c/g/h"
+      "g/../h"        =  "http://a/b/c/h"
+      "g;x=1/./y"     =  "http://a/b/c/g;x=1/y"
+      "g;x=1/../y"    =  "http://a/b/c/y"
+
+   Some applications fail to separate the reference's query and/or
+   fragment components from the path component before merging it with
+   the base path and removing dot-segments.  This error is rarely
+   noticed, as typical usage of a fragment never includes the hierarchy
+   ("/") character and the query component is not normally used within
+   relative references.
+
+      "g?y/./x"       =  "http://a/b/c/g?y/./x"
+      "g?y/../x"      =  "http://a/b/c/g?y/../x"
+      "g#s/./x"       =  "http://a/b/c/g#s/./x"
+      "g#s/../x"      =  "http://a/b/c/g#s/../x"
+
+   Some parsers allow the scheme name to be present in a relative
+   reference if it is the same as the base URI scheme.  This is
+   considered to be a loophole in prior specifications of partial URI
+   [RFC1630].  Its use should be avoided but is allowed for backward
+   compatibility.
+
+      "http:g"        =  "http:g"         ; for strict parsers
+                      /  "http://a/b/c/g" ; for backward compatibility
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 37]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+6.  Normalization and Comparison
+
+   One of the most common operations on URIs is simple comparison:
+   determining whether two URIs are equivalent without using the URIs to
+   access their respective resource(s).  A comparison is performed every
+   time a response cache is accessed, a browser checks its history to
+   color a link, or an XML parser processes tags within a namespace.
+   Extensive normalization prior to comparison of URIs is often used by
+   spiders and indexing engines to prune a search space or to reduce
+   duplication of request actions and response storage.
+
+   URI comparison is performed for some particular purpose.  Protocols
+   or implementations that compare URIs for different purposes will
+   often be subject to differing design trade-offs in regards to how
+   much effort should be spent in reducing aliased identifiers.  This
+   section describes various methods that may be used to compare URIs,
+   the trade-offs between them, and the types of applications that might
+   use them.
+
+6.1.  Equivalence
+
+   Because URIs exist to identify resources, presumably they should be
+   considered equivalent when they identify the same resource.  However,
+   this definition of equivalence is not of much practical use, as there
+   is no way for an implementation to compare two resources unless it
+   has full knowledge or control of them.  For this reason,
+   determination of equivalence or difference of URIs is based on string
+   comparison, perhaps augmented by reference to additional rules
+   provided by URI scheme definitions.  We use the terms "different" and
+   "equivalent" to describe the possible outcomes of such comparisons,
+   but there are many application-dependent versions of equivalence.
+
+   Even though it is possible to determine that two URIs are equivalent,
+   URI comparison is not sufficient to determine whether two URIs
+   identify different resources.  For example, an owner of two different
+   domain names could decide to serve the same resource from both,
+   resulting in two different URIs.  Therefore, comparison methods are
+   designed to minimize false negatives while strictly avoiding false
+   positives.
+
+   In testing for equivalence, applications should not directly compare
+   relative references; the references should be converted to their
+   respective target URIs before comparison.  When URIs are compared to
+   select (or avoid) a network action, such as retrieval of a
+   representation, fragment components (if any) should be excluded from
+   the comparison.
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 38]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+6.2.  Comparison Ladder
+
+   A variety of methods are used in practice to test URI equivalence.
+   These methods fall into a range, distinguished by the amount of
+   processing required and the degree to which the probability of false
+   negatives is reduced.  As noted above, false negatives cannot be
+   eliminated.  In practice, their probability can be reduced, but this
+   reduction requires more processing and is not cost-effective for all
+   applications.
+
+   If this range of comparison practices is considered as a ladder, the
+   following discussion will climb the ladder, starting with practices
+   that are cheap but have a relatively higher chance of producing false
+   negatives, and proceeding to those that have higher computational
+   cost and lower risk of false negatives.
+
+6.2.1.  Simple String Comparison
+
+   If two URIs, when considered as character strings, are identical,
+   then it is safe to conclude that they are equivalent.  This type of
+   equivalence test has very low computational cost and is in wide use
+   in a variety of applications, particularly in the domain of parsing.
+
+   Testing strings for equivalence requires some basic precautions.
+   This procedure is often referred to as "bit-for-bit" or
+   "byte-for-byte" comparison, which is potentially misleading.  Testing
+   strings for equality is normally based on pair comparison of the
+   characters that make up the strings, starting from the first and
+   proceeding until both strings are exhausted and all characters are
+   found to be equal, until a pair of characters compares unequal, or
+   until one of the strings is exhausted before the other.
+
+   This character comparison requires that each pair of characters be
+   put in comparable form.  For example, should one URI be stored in a
+   byte array in EBCDIC encoding and the second in a Java String object
+   (UTF-16), bit-for-bit comparisons applied naively will produce
+   errors.  It is better to speak of equality on a character-for-
+   character basis rather than on a byte-for-byte or bit-for-bit basis.
+   In practical terms, character-by-character comparisons should be done
+   codepoint-by-codepoint after conversion to a common character
+   encoding.
+
+   False negatives are caused by the production and use of URI aliases.
+   Unnecessary aliases can be reduced, regardless of the comparison
+   method, by consistently providing URI references in an already-
+   normalized form (i.e., a form identical to what would be produced
+   after normalization is applied, as described below).
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 39]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   Protocols and data formats often limit some URI comparisons to simple
+   string comparison, based on the theory that people and
+   implementations will, in their own best interest, be consistent in
+   providing URI references, or at least consistent enough to negate any
+   efficiency that might be obtained from further normalization.
+
+6.2.2.  Syntax-Based Normalization
+
+   Implementations may use logic based on the definitions provided by
+   this specification to reduce the probability of false negatives.
+   This processing is moderately higher in cost than character-for-
+   character string comparison.  For example, an application using this
+   approach could reasonably consider the following two URIs equivalent:
+
+      example://a/b/c/%7Bfoo%7D
+      eXAMPLE://a/./b/../b/%63/%7bfoo%7d
+
+   Web user agents, such as browsers, typically apply this type of URI
+   normalization when determining whether a cached response is
+   available.  Syntax-based normalization includes such techniques as
+   case normalization, percent-encoding normalization, and removal of
+   dot-segments.
+
+6.2.2.1.  Case Normalization
+
+   For all URIs, the hexadecimal digits within a percent-encoding
+   triplet (e.g., "%3a" versus "%3A") are case-insensitive and therefore
+   should be normalized to use uppercase letters for the digits A-F.
+
+   When a URI uses components of the generic syntax, the component
+   syntax equivalence rules always apply; namely, that the scheme and
+   host are case-insensitive and therefore should be normalized to
+   lowercase.  For example, the URI <HTTP://www.EXAMPLE.com/> is
+   equivalent to <http://www.example.com/>.  The other generic syntax
+   components are assumed to be case-sensitive unless specifically
+   defined otherwise by the scheme (see Section 6.2.3).
+
+6.2.2.2.  Percent-Encoding Normalization
+
+   The percent-encoding mechanism (Section 2.1) is a frequent source of
+   variance among otherwise identical URIs.  In addition to the case
+   normalization issue noted above, some URI producers percent-encode
+   octets that do not require percent-encoding, resulting in URIs that
+   are equivalent to their non-encoded counterparts.  These URIs should
+   be normalized by decoding any percent-encoded octet that corresponds
+   to an unreserved character, as described in Section 2.3.
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 40]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+6.2.2.3.  Path Segment Normalization
+
+   The complete path segments "." and ".." are intended only for use
+   within relative references (Section 4.1) and are removed as part of
+   the reference resolution process (Section 5.2).  However, some
+   deployed implementations incorrectly assume that reference resolution
+   is not necessary when the reference is already a URI and thus fail to
+   remove dot-segments when they occur in non-relative paths.  URI
+   normalizers should remove dot-segments by applying the
+   remove_dot_segments algorithm to the path, as described in
+   Section 5.2.4.
+
+6.2.3.  Scheme-Based Normalization
+
+   The syntax and semantics of URIs vary from scheme to scheme, as
+   described by the defining specification for each scheme.
+   Implementations may use scheme-specific rules, at further processing
+   cost, to reduce the probability of false negatives.  For example,
+   because the "http" scheme makes use of an authority component, has a
+   default port of "80", and defines an empty path to be equivalent to
+   "/", the following four URIs are equivalent:
+
+      http://example.com
+      http://example.com/
+      http://example.com:/
+      http://example.com:80/
+
+   In general, a URI that uses the generic syntax for authority with an
+   empty path should be normalized to a path of "/".  Likewise, an
+   explicit ":port", for which the port is empty or the default for the
+   scheme, is equivalent to one where the port and its ":" delimiter are
+   elided and thus should be removed by scheme-based normalization.  For
+   example, the second URI above is the normal form for the "http"
+   scheme.
+
+   Another case where normalization varies by scheme is in the handling
+   of an empty authority component or empty host subcomponent.  For many
+   scheme specifications, an empty authority or host is considered an
+   error; for others, it is considered equivalent to "localhost" or the
+   end-user's host.  When a scheme defines a default for authority and a
+   URI reference to that default is desired, the reference should be
+   normalized to an empty authority for the sake of uniformity, brevity,
+   and internationalization.  If, however, either the userinfo or port
+   subcomponents are non-empty, then the host should be given explicitly
+   even if it matches the default.
+
+   Normalization should not remove delimiters when their associated
+   component is empty unless licensed to do so by the scheme
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 41]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   specification.  For example, the URI "http://example.com/?" cannot be
+   assumed to be equivalent to any of the examples above.  Likewise, the
+   presence or absence of delimiters within a userinfo subcomponent is
+   usually significant to its interpretation.  The fragment component is
+   not subject to any scheme-based normalization; thus, two URIs that
+   differ only by the suffix "#" are considered different regardless of
+   the scheme.
+
+   Some schemes define additional subcomponents that consist of case-
+   insensitive data, giving an implicit license to normalizers to
+   convert this data to a common case (e.g., all lowercase).  For
+   example, URI schemes that define a subcomponent of path to contain an
+   Internet hostname, such as the "mailto" URI scheme, cause that
+   subcomponent to be case-insensitive and thus subject to case
+   normalization (e.g., "mailto:Joe@Example.COM" is equivalent to
+   "mailto:Joe@example.com", even though the generic syntax considers
+   the path component to be case-sensitive).
+
+   Other scheme-specific normalizations are possible.
+
+6.2.4.  Protocol-Based Normalization
+
+   Substantial effort to reduce the incidence of false negatives is
+   often cost-effective for web spiders.  Therefore, they implement even
+   more aggressive techniques in URI comparison.  For example, if they
+   observe that a URI such as
+
+      http://example.com/data
+
+   redirects to a URI differing only in the trailing slash
+
+      http://example.com/data/
+
+   they will likely regard the two as equivalent in the future.  This
+   kind of technique is only appropriate when equivalence is clearly
+   indicated by both the result of accessing the resources and the
+   common conventions of their scheme's dereference algorithm (in this
+   case, use of redirection by HTTP origin servers to avoid problems
+   with relative references).
+
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 42]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+7.  Security Considerations
+
+   A URI does not in itself pose a security threat.  However, as URIs
+   are often used to provide a compact set of instructions for access to
+   network resources, care must be taken to properly interpret the data
+   within a URI, to prevent that data from causing unintended access,
+   and to avoid including data that should not be revealed in plain
+   text.
+
+7.1.  Reliability and Consistency
+
+   There is no guarantee that once a URI has been used to retrieve
+   information, the same information will be retrievable by that URI in
+   the future.  Nor is there any guarantee that the information
+   retrievable via that URI in the future will be observably similar to
+   that retrieved in the past.  The URI syntax does not constrain how a
+   given scheme or authority apportions its namespace or maintains it
+   over time.  Such guarantees can only be obtained from the person(s)
+   controlling that namespace and the resource in question.  A specific
+   URI scheme may define additional semantics, such as name persistence,
+   if those semantics are required of all naming authorities for that
+   scheme.
+
+7.2.  Malicious Construction
+
+   It is sometimes possible to construct a URI so that an attempt to
+   perform a seemingly harmless, idempotent operation, such as the
+   retrieval of a representation, will in fact cause a possibly damaging
+   remote operation.  The unsafe URI is typically constructed by
+   specifying a port number other than that reserved for the network
+   protocol in question.  The client unwittingly contacts a site running
+   a different protocol service, and data within the URI contains
+   instructions that, when interpreted according to this other protocol,
+   cause an unexpected operation.  A frequent example of such abuse has
+   been the use of a protocol-based scheme with a port component of
+   "25", thereby fooling user agent software into sending an unintended
+   or impersonating message via an SMTP server.
+
+   Applications should prevent dereference of a URI that specifies a TCP
+   port number within the "well-known port" range (0 - 1023) unless the
+   protocol being used to dereference that URI is compatible with the
+   protocol expected on that well-known port.  Although IANA maintains a
+   registry of well-known ports, applications should make such
+   restrictions user-configurable to avoid preventing the deployment of
+   new services.
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 43]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   When a URI contains percent-encoded octets that match the delimiters
+   for a given resolution or dereference protocol (for example, CR and
+   LF characters for the TELNET protocol), these percent-encodings must
+   not be decoded before transmission across that protocol.  Transfer of
+   the percent-encoding, which might violate the protocol, is less
+   harmful than allowing decoded octets to be interpreted as additional
+   operations or parameters, perhaps triggering an unexpected and
+   possibly harmful remote operation.
+
+7.3.  Back-End Transcoding
+
+   When a URI is dereferenced, the data within it is often parsed by
+   both the user agent and one or more servers.  In HTTP, for example, a
+   typical user agent will parse a URI into its five major components,
+   access the authority's server, and send it the data within the
+   authority, path, and query components.  A typical server will take
+   that information, parse the path into segments and the query into
+   key/value pairs, and then invoke implementation-specific handlers to
+   respond to the request.  As a result, a common security concern for
+   server implementations that handle a URI, either as a whole or split
+   into separate components, is proper interpretation of the octet data
+   represented by the characters and percent-encodings within that URI.
+
+   Percent-encoded octets must be decoded at some point during the
+   dereference process.  Applications must split the URI into its
+   components and subcomponents prior to decoding the octets, as
+   otherwise the decoded octets might be mistaken for delimiters.
+   Security checks of the data within a URI should be applied after
+   decoding the octets.  Note, however, that the "%00" percent-encoding
+   (NUL) may require special handling and should be rejected if the
+   application is not expecting to receive raw data within a component.
+
+   Special care should be taken when the URI path interpretation process
+   involves the use of a back-end file system or related system
+   functions.  File systems typically assign an operational meaning to
+   special characters, such as the "/", "\", ":", "[", and "]"
+   characters, and to special device names like ".", "..", "...", "aux",
+   "lpt", etc.  In some cases, merely testing for the existence of such
+   a name will cause the operating system to pause or invoke unrelated
+   system calls, leading to significant security concerns regarding
+   denial of service and unintended data transfer.  It would be
+   impossible for this specification to list all such significant
+   characters and device names.  Implementers should research the
+   reserved names and characters for the types of storage device that
+   may be attached to their applications and restrict the use of data
+   obtained from URI components accordingly.
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 44]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+7.4.  Rare IP Address Formats
+
+   Although the URI syntax for IPv4address only allows the common
+   dotted-decimal form of IPv4 address literal, many implementations
+   that process URIs make use of platform-dependent system routines,
+   such as gethostbyname() and inet_aton(), to translate the string
+   literal to an actual IP address.  Unfortunately, such system routines
+   often allow and process a much larger set of formats than those
+   described in Section 3.2.2.
+
+   For example, many implementations allow dotted forms of three
+   numbers, wherein the last part is interpreted as a 16-bit quantity
+   and placed in the right-most two bytes of the network address (e.g.,
+   a Class B network).  Likewise, a dotted form of two numbers means
+   that the last part is interpreted as a 24-bit quantity and placed in
+   the right-most three bytes of the network address (Class A), and a
+   single number (without dots) is interpreted as a 32-bit quantity and
+   stored directly in the network address.  Adding further to the
+   confusion, some implementations allow each dotted part to be
+   interpreted as decimal, octal, or hexadecimal, as specified in the C
+   language (i.e., a leading 0x or 0X implies hexadecimal; a leading 0
+   implies octal; otherwise, the number is interpreted as decimal).
+
+   These additional IP address formats are not allowed in the URI syntax
+   due to differences between platform implementations.  However, they
+   can become a security concern if an application attempts to filter
+   access to resources based on the IP address in string literal format.
+   If this filtering is performed, literals should be converted to
+   numeric form and filtered based on the numeric value, and not on a
+   prefix or suffix of the string form.
+
+7.5.  Sensitive Information
+
+   URI producers should not provide a URI that contains a username or
+   password that is intended to be secret.  URIs are frequently
+   displayed by browsers, stored in clear text bookmarks, and logged by
+   user agent history and intermediary applications (proxies).  A
+   password appearing within the userinfo component is deprecated and
+   should be considered an error (or simply ignored) except in those
+   rare cases where the 'password' parameter is intended to be public.
+
+7.6.  Semantic Attacks
+
+   Because the userinfo subcomponent is rarely used and appears before
+   the host in the authority component, it can be used to construct a
+   URI intended to mislead a human user by appearing to identify one
+   (trusted) naming authority while actually identifying a different
+   authority hidden behind the noise.  For example
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 45]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+      ftp://cnn.example.com&story=breaking_news@10.0.0.1/top_story.htm
+
+   might lead a human user to assume that the host is 'cnn.example.com',
+   whereas it is actually '10.0.0.1'.  Note that a misleading userinfo
+   subcomponent could be much longer than the example above.
+
+   A misleading URI, such as that above, is an attack on the user's
+   preconceived notions about the meaning of a URI rather than an attack
+   on the software itself.  User agents may be able to reduce the impact
+   of such attacks by distinguishing the various components of the URI
+   when they are rendered, such as by using a different color or tone to
+   render userinfo if any is present, though there is no panacea.  More
+   information on URI-based semantic attacks can be found in [Siedzik].
+
+8.  IANA Considerations
+
+   URI scheme names, as defined by <scheme> in Section 3.1, form a
+   registered namespace that is managed by IANA according to the
+   procedures defined in [BCP35].  No IANA actions are required by this
+   document.
+
+9.  Acknowledgements
+
+   This specification is derived from RFC 2396 [RFC2396], RFC 1808
+   [RFC1808], and RFC 1738 [RFC1738]; the acknowledgements in those
+   documents still apply.  It also incorporates the update (with
+   corrections) for IPv6 literals in the host syntax, as defined by
+   Robert M. Hinden, Brian E. Carpenter, and Larry Masinter in
+   [RFC2732].  In addition, contributions by Gisle Aas, Reese Anschultz,
+   Daniel Barclay, Tim Bray, Mike Brown, Rob Cameron, Jeremy Carroll,
+   Dan Connolly, Adam M. Costello, John Cowan, Jason Diamond, Martin
+   Duerst, Stefan Eissing, Clive D.W. Feather, Al Gilman, Tony Hammond,
+   Elliotte Harold, Pat Hayes, Henry Holtzman, Ian B. Jacobs, Michael
+   Kay, John C. Klensin, Graham Klyne, Dan Kohn, Bruce Lilly, Andrew
+   Main, Dave McAlpin, Ira McDonald, Michael Mealling, Ray Merkert,
+   Stephen Pollei, Julian Reschke, Tomas Rokicki, Miles Sabin, Kai
+   Schaetzl, Mark Thomson, Ronald Tschalaer, Norm Walsh, Marc Warne,
+   Stuart Williams, and Henry Zongaro are gratefully acknowledged.
+
+10.  References
+
+10.1.  Normative References
+
+   [ASCII]    American National Standards Institute, "Coded Character
+              Set -- 7-bit American Standard Code for Information
+              Interchange", ANSI X3.4, 1986.
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 46]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   [RFC2234]  Crocker, D. and P. Overell, "Augmented BNF for Syntax
+              Specifications: ABNF", RFC 2234, November 1997.
+
+   [STD63]    Yergeau, F., "UTF-8, a transformation format of
+              ISO 10646", STD 63, RFC 3629, November 2003.
+
+   [UCS]      International Organization for Standardization,
+              "Information Technology - Universal Multiple-Octet Coded
+              Character Set (UCS)", ISO/IEC 10646:2003, December 2003.
+
+10.2.  Informative References
+
+   [BCP19]    Freed, N. and J. Postel, "IANA Charset Registration
+              Procedures", BCP 19, RFC 2978, October 2000.
+
+   [BCP35]    Petke, R. and I. King, "Registration Procedures for URL
+              Scheme Names", BCP 35, RFC 2717, November 1999.
+
+   [RFC0952]  Harrenstien, K., Stahl, M., and E. Feinler, "DoD Internet
+              host table specification", RFC 952, October 1985.
+
+   [RFC1034]  Mockapetris, P., "Domain names - concepts and facilities",
+              STD 13, RFC 1034, November 1987.
+
+   [RFC1123]  Braden, R., "Requirements for Internet Hosts - Application
+              and Support", STD 3, RFC 1123, October 1989.
+
+   [RFC1535]  Gavron, E., "A Security Problem and Proposed Correction
+              With Widely Deployed DNS Software", RFC 1535,
+              October 1993.
+
+   [RFC1630]  Berners-Lee, T., "Universal Resource Identifiers in WWW: A
+              Unifying Syntax for the Expression of Names and Addresses
+              of Objects on the Network as used in the World-Wide Web",
+              RFC 1630, June 1994.
+
+   [RFC1736]  Kunze, J., "Functional Recommendations for Internet
+              Resource Locators", RFC 1736, February 1995.
+
+   [RFC1737]  Sollins, K. and L. Masinter, "Functional Requirements for
+              Uniform Resource Names", RFC 1737, December 1994.
+
+   [RFC1738]  Berners-Lee, T., Masinter, L., and M. McCahill, "Uniform
+              Resource Locators (URL)", RFC 1738, December 1994.
+
+   [RFC1808]  Fielding, R., "Relative Uniform Resource Locators",
+              RFC 1808, June 1995.
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 47]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   [RFC2046]  Freed, N. and N. Borenstein, "Multipurpose Internet Mail
+              Extensions (MIME) Part Two: Media Types", RFC 2046,
+              November 1996.
+
+   [RFC2141]  Moats, R., "URN Syntax", RFC 2141, May 1997.
+
+   [RFC2396]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
+              Resource Identifiers (URI): Generic Syntax", RFC 2396,
+              August 1998.
+
+   [RFC2518]  Goland, Y., Whitehead, E., Faizi, A., Carter, S., and D.
+              Jensen, "HTTP Extensions for Distributed Authoring --
+              WEBDAV", RFC 2518, February 1999.
+
+   [RFC2557]  Palme, J., Hopmann, A., and N. Shelness, "MIME
+              Encapsulation of Aggregate Documents, such as HTML
+              (MHTML)", RFC 2557, March 1999.
+
+   [RFC2718]  Masinter, L., Alvestrand, H., Zigmond, D., and R. Petke,
+              "Guidelines for new URL Schemes", RFC 2718, November 1999.
+
+   [RFC2732]  Hinden, R., Carpenter, B., and L. Masinter, "Format for
+              Literal IPv6 Addresses in URL's", RFC 2732, December 1999.
+
+   [RFC3305]  Mealling, M. and R. Denenberg, "Report from the Joint
+              W3C/IETF URI Planning Interest Group: Uniform Resource
+              Identifiers (URIs), URLs, and Uniform Resource Names
+              (URNs): Clarifications and Recommendations", RFC 3305,
+              August 2002.
+
+   [RFC3490]  Faltstrom, P., Hoffman, P., and A. Costello,
+              "Internationalizing Domain Names in Applications (IDNA)",
+              RFC 3490, March 2003.
+
+   [RFC3513]  Hinden, R. and S. Deering, "Internet Protocol Version 6
+              (IPv6) Addressing Architecture", RFC 3513, April 2003.
+
+   [Siedzik]  Siedzik, R., "Semantic Attacks: What's in a URL?",
+              April 2001, <http://www.giac.org/practical/gsec/
+              Richard_Siedzik_GSEC.pdf>.
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 48]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+Appendix A.  Collected ABNF for URI
+
+   URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
+
+   hier-part     = "//" authority path-abempty
+                 / path-absolute
+                 / path-rootless
+                 / path-empty
+
+   URI-reference = URI / relative-ref
+
+   absolute-URI  = scheme ":" hier-part [ "?" query ]
+
+   relative-ref  = relative-part [ "?" query ] [ "#" fragment ]
+
+   relative-part = "//" authority path-abempty
+                 / path-absolute
+                 / path-noscheme
+                 / path-empty
+
+   scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
+
+   authority     = [ userinfo "@" ] host [ ":" port ]
+   userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
+   host          = IP-literal / IPv4address / reg-name
+   port          = *DIGIT
+
+   IP-literal    = "[" ( IPv6address / IPvFuture  ) "]"
+
+   IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
+
+   IPv6address   =                            6( h16 ":" ) ls32
+                 /                       "::" 5( h16 ":" ) ls32
+                 / [               h16 ] "::" 4( h16 ":" ) ls32
+                 / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
+                 / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
+                 / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
+                 / [ *4( h16 ":" ) h16 ] "::"              ls32
+                 / [ *5( h16 ":" ) h16 ] "::"              h16
+                 / [ *6( h16 ":" ) h16 ] "::"
+
+   h16           = 1*4HEXDIG
+   ls32          = ( h16 ":" h16 ) / IPv4address
+   IPv4address   = dec-octet "." dec-octet "." dec-octet "." dec-octet
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 49]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   dec-octet     = DIGIT                 ; 0-9
+                 / %x31-39 DIGIT         ; 10-99
+                 / "1" 2DIGIT            ; 100-199
+                 / "2" %x30-34 DIGIT     ; 200-249
+                 / "25" %x30-35          ; 250-255
+
+   reg-name      = *( unreserved / pct-encoded / sub-delims )
+
+   path          = path-abempty    ; begins with "/" or is empty
+                 / path-absolute   ; begins with "/" but not "//"
+                 / path-noscheme   ; begins with a non-colon segment
+                 / path-rootless   ; begins with a segment
+                 / path-empty      ; zero characters
+
+   path-abempty  = *( "/" segment )
+   path-absolute = "/" [ segment-nz *( "/" segment ) ]
+   path-noscheme = segment-nz-nc *( "/" segment )
+   path-rootless = segment-nz *( "/" segment )
+   path-empty    = 0<pchar>
+
+   segment       = *pchar
+   segment-nz    = 1*pchar
+   segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / "@" )
+                 ; non-zero-length segment without any colon ":"
+
+   pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
+
+   query         = *( pchar / "/" / "?" )
+
+   fragment      = *( pchar / "/" / "?" )
+
+   pct-encoded   = "%" HEXDIG HEXDIG
+
+   unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
+   reserved      = gen-delims / sub-delims
+   gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
+   sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
+                 / "*" / "+" / "," / ";" / "="
+
+Appendix B.  Parsing a URI Reference with a Regular Expression
+
+   As the "first-match-wins" algorithm is identical to the "greedy"
+   disambiguation method used by POSIX regular expressions, it is
+   natural and commonplace to use a regular expression for parsing the
+   potential five components of a URI reference.
+
+   The following line is the regular expression for breaking-down a
+   well-formed URI reference into its components.
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 50]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+      ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
+       12            3  4          5       6  7        8 9
+
+   The numbers in the second line above are only to assist readability;
+   they indicate the reference points for each subexpression (i.e., each
+   paired parenthesis).  We refer to the value matched for subexpression
+   <n> as $<n>.  For example, matching the above expression to
+
+      http://www.ics.uci.edu/pub/ietf/uri/#Related
+
+   results in the following subexpression matches:
+
+      $1 = http:
+      $2 = http
+      $3 = //www.ics.uci.edu
+      $4 = www.ics.uci.edu
+      $5 = /pub/ietf/uri/
+      $6 = <undefined>
+      $7 = <undefined>
+      $8 = #Related
+      $9 = Related
+
+   where <undefined> indicates that the component is not present, as is
+   the case for the query component in the above example.  Therefore, we
+   can determine the value of the five components as
+
+      scheme    = $2
+      authority = $4
+      path      = $5
+      query     = $7
+      fragment  = $9
+
+   Going in the opposite direction, we can recreate a URI reference from
+   its components by using the algorithm of Section 5.3.
+
+Appendix C.  Delimiting a URI in Context
+
+   URIs are often transmitted through formats that do not provide a
+   clear context for their interpretation.  For example, there are many
+   occasions when a URI is included in plain text; examples include text
+   sent in email, USENET news, and on printed paper.  In such cases, it
+   is important to be able to delimit the URI from the rest of the text,
+   and in particular from punctuation marks that might be mistaken for
+   part of the URI.
+
+   In practice, URIs are delimited in a variety of ways, but usually
+   within double-quotes "http://example.com/", angle brackets
+   <http://example.com/>, or just by using whitespace:
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 51]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+      http://example.com/
+
+   These wrappers do not form part of the URI.
+
+   In some cases, extra whitespace (spaces, line-breaks, tabs, etc.) may
+   have to be added to break a long URI across lines.  The whitespace
+   should be ignored when the URI is extracted.
+
+   No whitespace should be introduced after a hyphen ("-") character.
+   Because some typesetters and printers may (erroneously) introduce a
+   hyphen at the end of line when breaking it, the interpreter of a URI
+   containing a line break immediately after a hyphen should ignore all
+   whitespace around the line break and should be aware that the hyphen
+   may or may not actually be part of the URI.
+
+   Using <> angle brackets around each URI is especially recommended as
+   a delimiting style for a reference that contains embedded whitespace.
+
+   The prefix "URL:" (with or without a trailing space) was formerly
+   recommended as a way to help distinguish a URI from other bracketed
+   designators, though it is not commonly used in practice and is no
+   longer recommended.
+
+   For robustness, software that accepts user-typed URI should attempt
+   to recognize and strip both delimiters and embedded whitespace.
+
+   For example, the text
+
+      Yes, Jim, I found it under "http://www.w3.org/Addressing/",
+      but you can probably pick it up from <ftp://foo.example.
+      com/rfc/>.  Note the warning in <http://www.ics.uci.edu/pub/
+      ietf/uri/historical.html#WARNING>.
+
+   contains the URI references
+
+      http://www.w3.org/Addressing/
+      ftp://foo.example.com/rfc/
+      http://www.ics.uci.edu/pub/ietf/uri/historical.html#WARNING
+
+
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 52]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+Appendix D.  Changes from RFC 2396
+
+D.1.  Additions
+
+   An ABNF rule for URI has been introduced to correspond to one common
+   usage of the term: an absolute URI with optional fragment.
+
+   IPv6 (and later) literals have been added to the list of possible
+   identifiers for the host portion of an authority component, as
+   described by [RFC2732], with the addition of "[" and "]" to the
+   reserved set and a version flag to anticipate future versions of IP
+   literals.  Square brackets are now specified as reserved within the
+   authority component and are not allowed outside their use as
+   delimiters for an IP literal within host.  In order to make this
+   change without changing the technical definition of the path, query,
+   and fragment components, those rules were redefined to directly
+   specify the characters allowed.
+
+   As [RFC2732] defers to [RFC3513] for definition of an IPv6 literal
+   address, which, unfortunately, lacks an ABNF description of
+   IPv6address, we created a new ABNF rule for IPv6address that matches
+   the text representations defined by Section 2.2 of [RFC3513].
+   Likewise, the definition of IPv4address has been improved in order to
+   limit each decimal octet to the range 0-255.
+
+   Section 6, on URI normalization and comparison, has been completely
+   rewritten and extended by using input from Tim Bray and discussion
+   within the W3C Technical Architecture Group.
+
+D.2.  Modifications
+
+   The ad-hoc BNF syntax of RFC 2396 has been replaced with the ABNF of
+   [RFC2234].  This change required all rule names that formerly
+   included underscore characters to be renamed with a dash instead.  In
+   addition, a number of syntax rules have been eliminated or simplified
+   to make the overall grammar more comprehensible.  Specifications that
+   refer to the obsolete grammar rules may be understood by replacing
+   those rules according to the following table:
+
+
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 53]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   +----------------+--------------------------------------------------+
+   | obsolete rule  | translation                                      |
+   +----------------+--------------------------------------------------+
+   | absoluteURI    | absolute-URI                                     |
+   | relativeURI    | relative-part [ "?" query ]                      |
+   | hier_part      | ( "//" authority path-abempty /                  |
+   |                | path-absolute ) [ "?" query ]                    |
+   |                |                                                  |
+   | opaque_part    | path-rootless [ "?" query ]                      |
+   | net_path       | "//" authority path-abempty                      |
+   | abs_path       | path-absolute                                    |
+   | rel_path       | path-rootless                                    |
+   | rel_segment    | segment-nz-nc                                    |
+   | reg_name       | reg-name                                         |
+   | server         | authority                                        |
+   | hostport       | host [ ":" port ]                                |
+   | hostname       | reg-name                                         |
+   | path_segments  | path-abempty                                     |
+   | param          | *<pchar excluding ";">                           |
+   |                |                                                  |
+   | uric           | unreserved / pct-encoded / ";" / "?" / ":"       |
+   |                |  / "@" / "&" / "=" / "+" / "$" / "," / "/"       |
+   |                |                                                  |
+   | uric_no_slash  | unreserved / pct-encoded / ";" / "?" / ":"       |
+   |                |  / "@" / "&" / "=" / "+" / "$" / ","             |
+   |                |                                                  |
+   | mark           | "-" / "_" / "." / "!" / "~" / "*" / "'"          |
+   |                |  / "(" / ")"                                     |
+   |                |                                                  |
+   | escaped        | pct-encoded                                      |
+   | hex            | HEXDIG                                           |
+   | alphanum       | ALPHA / DIGIT                                    |
+   +----------------+--------------------------------------------------+
+
+   Use of the above obsolete rules for the definition of scheme-specific
+   syntax is deprecated.
+
+   Section 2, on characters, has been rewritten to explain what
+   characters are reserved, when they are reserved, and why they are
+   reserved, even when they are not used as delimiters by the generic
+   syntax.  The mark characters that are typically unsafe to decode,
+   including the exclamation mark ("!"), asterisk ("*"), single-quote
+   ("'"), and open and close parentheses ("(" and ")"), have been moved
+   to the reserved set in order to clarify the distinction between
+   reserved and unreserved and, hopefully, to answer the most common
+   question of scheme designers.  Likewise, the section on
+   percent-encoded characters has been rewritten, and URI normalizers
+   are now given license to decode any percent-encoded octets
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 54]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   corresponding to unreserved characters.  In general, the terms
+   "escaped" and "unescaped" have been replaced with "percent-encoded"
+   and "decoded", respectively, to reduce confusion with other forms of
+   escape mechanisms.
+
+   The ABNF for URI and URI-reference has been redesigned to make them
+   more friendly to LALR parsers and to reduce complexity.  As a result,
+   the layout form of syntax description has been removed, along with
+   the uric, uric_no_slash, opaque_part, net_path, abs_path, rel_path,
+   path_segments, rel_segment, and mark rules.  All references to
+   "opaque" URIs have been replaced with a better description of how the
+   path component may be opaque to hierarchy.  The relativeURI rule has
+   been replaced with relative-ref to avoid unnecessary confusion over
+   whether they are a subset of URI.  The ambiguity regarding the
+   parsing of URI-reference as a URI or a relative-ref with a colon in
+   the first segment has been eliminated through the use of five
+   separate path matching rules.
+
+   The fragment identifier has been moved back into the section on
+   generic syntax components and within the URI and relative-ref rules,
+   though it remains excluded from absolute-URI.  The number sign ("#")
+   character has been moved back to the reserved set as a result of
+   reintegrating the fragment syntax.
+
+   The ABNF has been corrected to allow the path component to be empty.
+   This also allows an absolute-URI to consist of nothing after the
+   "scheme:", as is present in practice with the "dav:" namespace
+   [RFC2518] and with the "about:" scheme used internally by many WWW
+   browser implementations.  The ambiguity regarding the boundary
+   between authority and path has been eliminated through the use of
+   five separate path matching rules.
+
+   Registry-based naming authorities that use the generic syntax are now
+   defined within the host rule.  This change allows current
+   implementations, where whatever name provided is simply fed to the
+   local name resolution mechanism, to be consistent with the
+   specification.  It also removes the need to re-specify DNS name
+   formats here.  Furthermore, it allows the host component to contain
+   percent-encoded octets, which is necessary to enable
+   internationalized domain names to be provided in URIs, processed in
+   their native character encodings at the application layers above URI
+   processing, and passed to an IDNA library as a registered name in the
+   UTF-8 character encoding.  The server, hostport, hostname,
+   domainlabel, toplabel, and alphanum rules have been removed.
+
+   The resolving relative references algorithm of [RFC2396] has been
+   rewritten with pseudocode for this revision to improve clarity and
+   fix the following issues:
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 55]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   o  [RFC2396] section 5.2, step 6a, failed to account for a base URI
+      with no path.
+
+   o  Restored the behavior of [RFC1808] where, if the reference
+      contains an empty path and a defined query component, the target
+      URI inherits the base URI's path component.
+
+   o  The determination of whether a URI reference is a same-document
+      reference has been decoupled from the URI parser, simplifying the
+      URI processing interface within applications in a way consistent
+      with the internal architecture of deployed URI processing
+      implementations.  The determination is now based on comparison to
+      the base URI after transforming a reference to absolute form,
+      rather than on the format of the reference itself.  This change
+      may result in more references being considered "same-document"
+      under this specification than there would be under the rules given
+      in RFC 2396, especially when normalization is used to reduce
+      aliases.  However, it does not change the status of existing
+      same-document references.
+
+   o  Separated the path merge routine into two routines: merge, for
+      describing combination of the base URI path with a relative-path
+      reference, and remove_dot_segments, for describing how to remove
+      the special "." and ".." segments from a composed path.  The
+      remove_dot_segments algorithm is now applied to all URI reference
+      paths in order to match common implementations and to improve the
+      normalization of URIs in practice.  This change only impacts the
+      parsing of abnormal references and same-scheme references wherein
+      the base URI has a non-hierarchical path.
+
+Index
+
+   A
+      ABNF  11
+      absolute  27
+      absolute-path  26
+      absolute-URI  27
+      access  9
+      authority  17, 18
+
+   B
+      base URI  28
+
+   C
+      character encoding  4
+      character  4
+      characters  8, 11
+      coded character set  4
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 56]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+   D
+      dec-octet  20
+      dereference  9
+      dot-segments  23
+
+   F
+      fragment  16, 24
+
+   G
+      gen-delims  13
+      generic syntax  6
+
+   H
+      h16  20
+      hier-part  16
+      hierarchical  10
+      host  18
+
+   I
+      identifier  5
+      IP-literal  19
+      IPv4  20
+      IPv4address  19, 20
+      IPv6  19
+      IPv6address  19, 20
+      IPvFuture  19
+
+   L
+      locator  7
+      ls32  20
+
+   M
+      merge  32
+
+   N
+      name  7
+      network-path  26
+
+   P
+      path  16, 22, 26
+         path-abempty  22
+         path-absolute  22
+         path-empty  22
+         path-noscheme  22
+         path-rootless  22
+      path-abempty  16, 22, 26
+      path-absolute  16, 22, 26
+      path-empty  16, 22, 26
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 57]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+      path-rootless  16, 22
+      pchar  23
+      pct-encoded  12
+      percent-encoding  12
+      port  22
+
+   Q
+      query  16, 23
+
+   R
+      reg-name  21
+      registered name  20
+      relative  10, 28
+      relative-path  26
+      relative-ref  26
+      remove_dot_segments  33
+      representation  9
+      reserved  12
+      resolution  9, 28
+      resource  5
+      retrieval  9
+
+   S
+      same-document  27
+      sameness  9
+      scheme  16, 17
+      segment  22, 23
+         segment-nz  23
+         segment-nz-nc  23
+      sub-delims  13
+      suffix  27
+
+   T
+      transcription  8
+
+   U
+      uniform  4
+      unreserved  13
+      URI grammar
+         absolute-URI  27
+         ALPHA  11
+         authority  18
+         CR  11
+         dec-octet  20
+         DIGIT  11
+         DQUOTE  11
+         fragment  24
+         gen-delims  13
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 58]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+         h16  20
+         HEXDIG  11
+         hier-part  16
+         host  19
+         IP-literal  19
+         IPv4address  20
+         IPv6address  20
+         IPvFuture  19
+         LF  11
+         ls32  20
+         OCTET  11
+         path  22
+         path-abempty  22
+         path-absolute  22
+         path-empty  22
+         path-noscheme  22
+         path-rootless  22
+         pchar  23
+         pct-encoded  12
+         port  22
+         query  24
+         reg-name  21
+         relative-ref  26
+         reserved  13
+         scheme  17
+         segment  23
+         segment-nz  23
+         segment-nz-nc  23
+         SP  11
+         sub-delims  13
+         unreserved  13
+         URI  16
+         URI-reference  25
+         userinfo  18
+      URI  16
+      URI-reference  25
+      URL  7
+      URN  7
+      userinfo  18
+
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 59]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+Authors' Addresses
+
+   Tim Berners-Lee
+   World Wide Web Consortium
+   Massachusetts Institute of Technology
+   77 Massachusetts Avenue
+   Cambridge, MA  02139
+   USA
+
+   Phone: +1-617-253-5702
+   Fax:   +1-617-258-5999
+   EMail: timbl@w3.org
+   URI:   http://www.w3.org/People/Berners-Lee/
+
+
+   Roy T. Fielding
+   Day Software
+   5251 California Ave., Suite 110
+   Irvine, CA  92617
+   USA
+
+   Phone: +1-949-679-2960
+   Fax:   +1-949-679-2972
+   EMail: fielding@gbiv.com
+   URI:   http://roy.gbiv.com/
+
+
+   Larry Masinter
+   Adobe Systems Incorporated
+   345 Park Ave
+   San Jose, CA  95110
+   USA
+
+   Phone: +1-408-536-3024
+   EMail: LMM@acm.org
+   URI:   http://larry.masinter.net/
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 60]
+
+RFC 3986                   URI Generic Syntax               January 2005
+
+
+Full Copyright Statement
+
+   Copyright (C) The Internet Society (2005).
+
+   This document is subject to the rights, licenses and restrictions
+   contained in BCP 78, and except as set forth therein, the authors
+   retain all their rights.
+
+   This document and the information contained herein are provided on an
+   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
+   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
+   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
+   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
+   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
+
+Intellectual Property
+
+   The IETF takes no position regarding the validity or scope of any
+   Intellectual Property Rights or other rights that might be claimed to
+   pertain to the implementation or use of the technology described in
+   this document or the extent to which any license under such rights
+   might or might not be available; nor does it represent that it has
+   made any independent effort to identify any such rights.  Information
+   on the IETF's procedures with respect to rights in IETF Documents can
+   be found in BCP 78 and BCP 79.
+
+   Copies of IPR disclosures made to the IETF Secretariat and any
+   assurances of licenses to be made available, or the result of an
+   attempt made to obtain a general license or permission for the use of
+   such proprietary rights by implementers or users of this
+   specification can be obtained from the IETF on-line IPR repository at
+   http://www.ietf.org/ipr.
+
+   The IETF invites any interested party to bring to its attention any
+   copyrights, patents or patent applications, or other proprietary
+   rights that may cover technology that may be required to implement
+   this standard.  Please address the information to the IETF at ietf-
+   ipr@ietf.org.
+
+
+Acknowledgement
+
+   Funding for the RFC Editor function is currently provided by the
+   Internet Society.
+
+
+
+
+
+
+Berners-Lee, et al.         Standards Track                    [Page 61]
+
diff -urNad cupsys-1.1.99.b1.r4748~/systemv/Makefile cupsys-1.1.99.b1.r4748/systemv/Makefile
--- cupsys-1.1.99.b1.r4748~/systemv/Makefile	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/systemv/Makefile	2005-10-14 10:39:44.868294000 +0900
@@ -1,5 +1,5 @@
 #
-# "$Id: Makefile 4494 2005-02-18 02:18:11Z mike $"
+# "$Id: Makefile 4791 2005-10-14 01:39:44Z mike $"
 #
 #   System V commands makefile for the Common UNIX Printing System (CUPS).
 #
@@ -77,10 +77,7 @@
 	$(INSTALL_BIN) lp $(BINDIR)
 	$(INSTALL_BIN) lpoptions $(BINDIR)
 	$(INSTALL_BIN) lpstat $(BINDIR)
-	-$(INSTALL_BIN) -m 4755 -o $(CUPS_USER) -g $(CUPS_GROUP) lppasswd $(BINDIR)
-	if test ! -x $(BINDIR)/lppasswd; then \
-		chmod 755 $(BINDIR)/lppasswd; \
-	fi
+	$(INSTALL_BIN) -m 4755 -o $(CUPS_USER) -g $(CUPS_GROUP) lppasswd $(BINDIR) || $(INSTALL_BIN) lppasswd $(BINDIR)
 
 
 #
@@ -194,5 +191,5 @@
 
 
 #
-# End of "$Id: Makefile 4494 2005-02-18 02:18:11Z mike $".
+# End of "$Id: Makefile 4791 2005-10-14 01:39:44Z mike $".
 #
diff -urNad cupsys-1.1.99.b1.r4748~/systemv/accept.c cupsys-1.1.99.b1.r4748/systemv/accept.c
--- cupsys-1.1.99.b1.r4748~/systemv/accept.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/systemv/accept.c	2005-10-22 03:49:24.065412000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: accept.c 4494 2005-02-18 02:18:11Z mike $"
+ * "$Id: accept.c 4806 2005-10-21 18:49:24Z mike $"
  *
  *   "accept", "disable", "enable", and "reject" commands for the Common
  *   UNIX Printing System (CUPS).
@@ -190,7 +190,8 @@
       ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
                    "attributes-natural-language", NULL, language->language);
 
-      snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", argv[i]);
+      httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                       "/printers/%s", argv[i]);
       ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI,
                    "printer-uri", NULL, uri);
 
@@ -279,5 +280,5 @@
 
 
 /*
- * End of "$Id: accept.c 4494 2005-02-18 02:18:11Z mike $".
+ * End of "$Id: accept.c 4806 2005-10-21 18:49:24Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/systemv/cancel.c cupsys-1.1.99.b1.r4748/systemv/cancel.c
--- cupsys-1.1.99.b1.r4748~/systemv/cancel.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/systemv/cancel.c	2005-10-22 03:49:24.065412000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: cancel.c 4494 2005-02-18 02:18:11Z mike $"
+ * "$Id: cancel.c 4806 2005-10-21 18:49:24Z mike $"
  *
  *   "cancel" command for the Common UNIX Printing System (CUPS).
  *
@@ -245,7 +245,8 @@
 
       if (dest)
       {
-        snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", dest);
+	httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                	 "/printers/%s", dest);
 	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI,
 	             "printer-uri", NULL, uri);
 	ippAddInteger(request, IPP_TAG_OPERATION, IPP_TAG_INTEGER, "job-id",
@@ -377,5 +378,5 @@
 
 
 /*
- * End of "$Id: cancel.c 4494 2005-02-18 02:18:11Z mike $".
+ * End of "$Id: cancel.c 4806 2005-10-21 18:49:24Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/systemv/cupsaddsmb.c cupsys-1.1.99.b1.r4748/systemv/cupsaddsmb.c
--- cupsys-1.1.99.b1.r4748~/systemv/cupsaddsmb.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/systemv/cupsaddsmb.c	2005-10-22 03:49:24.065412000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: cupsaddsmb.c 4718 2005-09-28 16:35:47Z mike $"
+ * "$Id: cupsaddsmb.c 4806 2005-10-21 18:49:24Z mike $"
  *
  *   "cupsaddsmb" command for the Common UNIX Printing System (CUPS).
  *
@@ -520,7 +520,8 @@
   ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_LANGUAGE,
                "attributes-natural-language", NULL, language->language);
 
-  snprintf(command, sizeof(command), "ipp://localhost/printers/%s", dest);
+  httpAssembleURIf(command, sizeof(command), "ipp", NULL, "localhost", 0,
+                   "/printers/%s", dest);
   ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI,
                "printer-uri", NULL, command);
 
@@ -949,5 +950,5 @@
 
 
 /*
- * End of "$Id: cupsaddsmb.c 4718 2005-09-28 16:35:47Z mike $".
+ * End of "$Id: cupsaddsmb.c 4806 2005-10-21 18:49:24Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/systemv/cupstestppd.c cupsys-1.1.99.b1.r4748/systemv/cupstestppd.c
--- cupsys-1.1.99.b1.r4748~/systemv/cupstestppd.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/systemv/cupstestppd.c	2005-10-11 04:23:23.958633000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: cupstestppd.c 4648 2005-09-15 19:31:32Z mike $"
+ * "$Id: cupstestppd.c 4767 2005-10-10 19:23:23Z mike $"
  *
  *   PPD test program for the Common UNIX Printing System (CUPS).
  *
@@ -851,6 +851,8 @@
 	    else
 	      ydpi = xdpi;
 	  }
+	  else
+	    ydpi = xdpi;
 
 	  if (xdpi <= 0 || ydpi <= 0 || strcmp(ptr, "dpi"))
 	  {
@@ -1281,5 +1283,5 @@
 
 
 /*
- * End of "$Id: cupstestppd.c 4648 2005-09-15 19:31:32Z mike $".
+ * End of "$Id: cupstestppd.c 4767 2005-10-10 19:23:23Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/systemv/lpadmin.c cupsys-1.1.99.b1.r4748/systemv/lpadmin.c
--- cupsys-1.1.99.b1.r4748~/systemv/lpadmin.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/systemv/lpadmin.c	2005-10-22 03:49:24.065412000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: lpadmin.c 4560 2005-08-04 18:49:00Z mike $"
+ * "$Id: lpadmin.c 4806 2005-10-21 18:49:24Z mike $"
  *
  *   "lpadmin" command for the Common UNIX Printing System (CUPS).
  *
@@ -748,7 +748,8 @@
   *    printer-uri
   */
 
-  snprintf(uri, sizeof(uri), "ipp://localhost/classes/%s", pclass);
+  httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                   "/classes/%s", pclass);
 
   request = ippNew();
 
@@ -818,7 +819,8 @@
   * OK, the printer isn't part of the class, so add it...
   */
 
-  snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", printer);
+  httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                   "/printers/%s", printer);
 
   if (response != NULL &&
       (members = ippFindAttribute(response, "member-uris", IPP_TAG_URI)) != NULL)
@@ -893,7 +895,8 @@
   *    printer-uri
   */
 
-  snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", printer);
+  httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                   "/printers/%s", printer);
 
   request = ippNew();
 
@@ -965,7 +968,8 @@
   *    printer-uri
   */
 
-  snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", printer);
+  httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                   "/printers/%s", printer);
 
   request = ippNew();
 
@@ -1044,7 +1048,8 @@
   *    printer-uri
   */
 
-  snprintf(uri, sizeof(uri), "ipp://localhost/classes/%s", pclass);
+  httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                   "/classes/%s", pclass);
 
   request = ippNew();
 
@@ -1222,7 +1227,8 @@
   *    printer-is-accepting-jobs
   */
 
-  snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", printer);
+  httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                   "/printers/%s", printer);
 
   request = ippNew();
 
@@ -1348,7 +1354,8 @@
   *    printer-uri
   */
 
-  snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", printer);
+  httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                   "/printers/%s", printer);
 
   request = ippNew();
 
@@ -1481,7 +1488,8 @@
   *    printer-uri
   */
 
-  snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", printer);
+  httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                   "/printers/%s", printer);
 
   request = ippNew();
 
@@ -1559,7 +1567,8 @@
   *    printer-uri
   */
 
-  snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", printer);
+  httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                   "/printers/%s", printer);
 
   request = ippNew();
 
@@ -1639,7 +1648,8 @@
   *    printer-uri
   */
 
-  snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", printer);
+  httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                   "/printers/%s", printer);
 
   request = ippNew();
 
@@ -1718,7 +1728,8 @@
   *    ppd-name
   */
 
-  snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", printer);
+  httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                   "/printers/%s", printer);
 
   request = ippNew();
 
@@ -1804,7 +1815,8 @@
 
   language = cupsLangDefault();
 
-  snprintf(uri, sizeof(uri), "ipp://localhost/printers/%s", printer);
+  httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                   "/printers/%s", printer);
 
  /*
   * Build a GET_PRINTER_ATTRIBUTES request, which requires the following
@@ -1850,7 +1862,8 @@
       if (attr->values[0].integer & (CUPS_PRINTER_CLASS | CUPS_PRINTER_IMPLICIT))
       {
         op = CUPS_ADD_CLASS;
-        snprintf(uri, sizeof(uri), "ipp://localhost/classes/%s", printer);
+	httpAssembleURIf(uri, sizeof(uri), "ipp", NULL, "localhost", 0,
+                	 "/classes/%s", printer);
       }
     }
 
@@ -2050,5 +2063,5 @@
 
 
 /*
- * End of "$Id: lpadmin.c 4560 2005-08-04 18:49:00Z mike $".
+ * End of "$Id: lpadmin.c 4806 2005-10-21 18:49:24Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/systemv/lpmove.c cupsys-1.1.99.b1.r4748/systemv/lpmove.c
--- cupsys-1.1.99.b1.r4748~/systemv/lpmove.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/systemv/lpmove.c	2005-10-22 04:18:46.452317000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: lpmove.c 4494 2005-02-18 02:18:11Z mike $"
+ * "$Id: lpmove.c 4808 2005-10-21 19:18:46Z mike $"
  *
  *   "lpmove" command for the Common UNIX Printing System (CUPS).
  *
@@ -204,7 +204,8 @@
   ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_NAME, "requesting-user-name",
                NULL, cupsUser());
 
-  snprintf(printer_uri, sizeof(printer_uri), "ipp://localhost/printers/%s", dest);
+  httpAssembleURIf(printer_uri, sizeof(printer_uri), "ipp", NULL, "localhost", 0,
+                   "/printers/%s", dest);
   ippAddString(request, IPP_TAG_JOB, IPP_TAG_URI, "job-printer-uri",
                NULL, printer_uri);
 
@@ -231,5 +232,5 @@
 
 
 /*
- * End of "$Id: lpmove.c 4494 2005-02-18 02:18:11Z mike $".
+ * End of "$Id: lpmove.c 4808 2005-10-21 19:18:46Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/systemv/lppasswd.c cupsys-1.1.99.b1.r4748/systemv/lppasswd.c
--- cupsys-1.1.99.b1.r4748~/systemv/lppasswd.c	2005-11-13 13:59:11.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/systemv/lppasswd.c	2005-11-13 06:46:52.687523000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: lppasswd.c 4740 2005-10-01 04:21:20Z mike $"
+ * "$Id: lppasswd.c 4833 2005-11-12 21:46:52Z mike $"
  *
  *   MD5 password program for the Common UNIX Printing System (CUPS).
  *
@@ -133,15 +133,11 @@
   snprintf(passwdnew, sizeof(passwdnew), "%s/passwd.new", root);
 
  /*
-  * Find the default system group: "sys", "system", or "root"...
+  * Find the default system group...
   */
 
-  if (getgrnam("sys"))
-    groupname = "sys";
-  else if (getgrnam("system"))
-    groupname = "system";
-  else if (getgrnam("root"))
-    groupname = "root";
+  if (getgrnam(CUPS_DEFAULT_GROUP))
+    groupname = CUPS_DEFAULT_GROUP;
   else
     groupname = "unknown";
 
@@ -489,5 +485,5 @@
 
 
 /*
- * End of "$Id: lppasswd.c 4740 2005-10-01 04:21:20Z mike $".
+ * End of "$Id: lppasswd.c 4833 2005-11-12 21:46:52Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/systemv/lpstat.c cupsys-1.1.99.b1.r4748/systemv/lpstat.c
--- cupsys-1.1.99.b1.r4748~/systemv/lpstat.c	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/systemv/lpstat.c	2005-10-22 03:49:24.065412000 +0900
@@ -1,5 +1,5 @@
 /*
- * "$Id: lpstat.c 4730 2005-09-30 21:45:34Z mike $"
+ * "$Id: lpstat.c 4806 2005-10-21 18:49:24Z mike $"
  *
  *   "lpstat" command for the Common UNIX Printing System (CUPS).
  *
@@ -1937,18 +1937,32 @@
                 	"requested-attributes",
 		        sizeof(jattrs) / sizeof(jattrs[0]), NULL, jattrs);
 
-          snprintf(printer_uri, sizeof(printer_uri), "ipp://%s/printers/%s",
-	           http->hostname, printer);
+	  httpAssembleURIf(printer_uri, sizeof(printer_uri), "ipp", NULL,
+	                   "localhost", 0, "/printers/%s", printer);
 	  ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI,
 	               "printer-uri", NULL, printer_uri);
 
-	  ippAddInteger(request, IPP_TAG_OPERATION, IPP_TAG_INTEGER,
-	        	"limit", 1);
-
           if ((jobs = cupsDoRequest(http, request, "/")) != NULL)
 	  {
-	    if ((jobattr = ippFindAttribute(jobs, "job-id", IPP_TAG_INTEGER)) != NULL)
-              jobid = jobattr->values[0].integer;
+	   /*
+	    * Get the current active job on this queue...
+	    */
+
+	    jobid = 0;
+
+	    for (jobattr = jobs->attrs; jobattr; jobattr = jobattr->next)
+	    {
+	      if (!jobattr->name)
+	        continue;
+
+	      if (!strcmp(jobattr->name, "job-id") &&
+	          jobattr->value_tag == IPP_TAG_INTEGER)
+		jobid = jobattr->values[0].integer;
+              else if (!strcmp(jobattr->name, "job-state") &&
+	               jobattr->value_tag == IPP_TAG_ENUM &&
+		       jobattr->values[0].integer == IPP_JOB_PROCESSING)
+		break;
+	    }
 
             ippDelete(jobs);
 	  }
@@ -2136,5 +2150,5 @@
 
 
 /*
- * End of "$Id: lpstat.c 4730 2005-09-30 21:45:34Z mike $".
+ * End of "$Id: lpstat.c 4806 2005-10-21 18:49:24Z mike $".
  */
diff -urNad cupsys-1.1.99.b1.r4748~/templates/edit-config.tmpl cupsys-1.1.99.b1.r4748/templates/edit-config.tmpl
--- cupsys-1.1.99.b1.r4748~/templates/edit-config.tmpl	2005-11-13 13:02:24.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/templates/edit-config.tmpl	1970-01-01 09:00:00.000000000 +0900
@@ -1,115 +0,0 @@
-<SCRIPT TYPE="text/javascript">
-function reset_config()
-{
-  document.cups.CUPSDCONF.value =
-"# Log general information in error_log - change \\"info\\" to \\"debug\\" for\\n" +
-"# troubleshooting...\\n" +
-"LogLevel info\\n" +
-"\\n" +
-"\\n" +
-"# Administrator user group...\\n" +
-"SystemGroup lpadmin\\n" +
-"\\n" +
-"\\n" +
-"# Only listen for connections from the local machine.\\n" +
-"Listen 127.0.0.1:631\\n" +
-"Listen /var/run/cups/cups.sock\\n" +
-"\\n" +
-"\\n" +
-"# Show shared printers on the local network.\\n" +
-"Browsing On\\n" +
-"BrowseOrder allow,deny\\n" +
-"BrowseAllow @LOCAL\\n" +
-"\\n" +
-"\\n" +
-"# Restrict access to the server...\\n" +
-"<Location />\\n" +
-"  Order allow,deny\\n" +
-"  Allow localhost\\n" +
-"</Location>\\n" +
-"\\n" +
-"# Restrict access to the admin pages...\\n" +
-"<Location /admin>\\n" +
-"  Order allow,deny\\n" +
-"  Allow localhost\\n" +
-"</Location>\\n" +
-"\\n" +
-"# Restrict access to configuration files...\\n" +
-"<Location /admin/conf>\\n" +
-"  AuthType Basic\\n" +
-"  Require user @SYSTEM\\n" +
-"  Order allow,deny\\n" +
-"  Allow localhost\\n" +
-"</Location>\\n" +
-"\\n" +
-"# Authenticate against system accounts by default...\\n" +
-"DefaultAuthType Basic\\n" +
-"\\n" +
-"# Set the default printer/job policies...\\n" +
-"<Policy default>\\n" +
-"  # Job-related operations must be done by the owner or an adminstrator...\\n" +
-"  <Limit Send-Document Send-URI Hold-Job Release-Job Restart-Job Purge-Jobs Set-Job-Attributes Create-Job-Subscription Renew-Subscription Cancel-Subscription Get-Notifications Reprocess-Job Cancel-Current-Job Suspend-Current-Job Resume-Job CUPS-Move-Job>\\n" +
-"    Require user @OWNER @SYSTEM\\n" +
-"    Order deny,allow\\n" +
-"  </Limit>\\n" +
-"\\n" +
-"  # All administration operations require an adminstrator to authenticate...\\n" +
-"  <Limit Pause-Printer Resume-Printer Set-Printer-Attributes Enable-Printer Disable-Printer Pause-Printer-After-Current-Job Hold-New-Jobs Release-Held-New-Jobs Deactivate-Printer Activate-Printer Restart-Printer Shutdown-Printer Startup-Printer Promote-Job Schedule-Job-After CUPS-Add-Printer CUPS-Delete-Printer CUPS-Add-Class CUPS-Delete-Class CUPS-Accept-Jobs CUPS-Reject-Jobs CUPS-Set-Default>\\n" +
-"    AuthType Basic\\n" +
-"    Require user @SYSTEM\\n" +
-"    Order deny,allow\\n" +
-"  </Limit>\\n" +
-"\\n" +
-"  # Only the owner or an administrator can cancel or authenticate a job...\\n" +
-"  <Limit Cancel-Job CUPS-Authenticate-Job>\\n" +
-"    Require user @OWNER @SYSTEM\\n" +
-"    Order deny,allow\\n" +
-"  </Limit>\\n" +
-"\\n" +
-"  <Limit All>\\n" +
-"    Order deny,allow\\n" +
-"  </Limit>\\n" +
-"</Policy>\\n";
-}
-</SCRIPT>
-
-<P><TABLE CELLPADDING="0" CELLSPACING="0" BORDER="0" WIDTH="100%">
-<TR CLASS="header">
-<TH ALIGN="LEFT" VALIGN="TOP"><IMG SRC="/images/hdr-top-left.gif"
-WIDTH="16" HEIGHT="16" ALT=""></TH>
-<TH>Server Configuration File</TH>
-<TH ALIGN="RIGHT" VALIGN="TOP"><IMG
-SRC="/images/hdr-top-right.gif" WIDTH="16" HEIGHT="16"
-ALT=""></TH>
-</TR>
-<TR CLASS="data">
-<TD></TD>
-<TD WIDTH="100%">
-
-<FORM NAME="cups" METHOD="POST" ACTION="/admin/">
-
-<INPUT TYPE="HIDDEN" NAME="OP" VALUE="config-server">
-
-<P><TEXTAREA NAME="CUPSDCONF" COLS="80"
-ROWS="25">{CUPSDCONF}</TEXTAREA></P>
-
-<P><INPUT TYPE="IMAGE" SRC="/images/save-changes.gif"
-ALIGN="MIDDLE" BORDER="0" ALT="Save Changes"> <A
-HREF="javascript:reset_config();"><IMG
-SRC="/images/use-default-config.gif" ALIGN="MIDDLE" BORDER="0"
-ALT="Use Default Configuration File"></A></P>
-
-</FORM>
-
-</TD>
-<TD></TD>
-</TR>
-<TR CLASS="header">
-<TH ALIGN="LEFT" VALIGN="BOTTOM"><IMG SRC="/images/hdr-bottom-left.gif"
-WIDTH="16" HEIGHT="16" ALT=""></TH>
-<TH></TH>
-<TH ALIGN="RIGHT" VALIGN="BOTTOM"><IMG
-SRC="/images/hdr-bottom-right.gif" WIDTH="16" HEIGHT="16"
-ALT=""></TH>
-</TR>
-</TABLE></P>
diff -urNad cupsys-1.1.99.b1.r4748~/test/run-stp-tests.sh cupsys-1.1.99.b1.r4748/test/run-stp-tests.sh
--- cupsys-1.1.99.b1.r4748~/test/run-stp-tests.sh	2005-09-22 20:52:38.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/test/run-stp-tests.sh	2005-11-12 12:15:10.305626000 +0900
@@ -1,6 +1,6 @@
 #!/bin/sh
 #
-# "$Id: run-stp-tests.sh 4685 2005-09-22 11:52:38Z mike $"
+# "$Id: run-stp-tests.sh 4829 2005-11-12 03:15:10Z mike $"
 #
 #   Perform the complete set of IPP compliance tests specified in the
 #   CUPS Software Test Plan.
@@ -200,6 +200,7 @@
 ln -s $root/backend/socket /tmp/cups-$user/bin/backend
 ln -s $root/backend/usb /tmp/cups-$user/bin/backend
 ln -s $root/cgi-bin /tmp/cups-$user/bin
+ln -s $root/notifier /tmp/cups-$user/bin
 ln -s $root/scheduler /tmp/cups-$user/bin/daemon
 ln -s $root/filter/hpgltops /tmp/cups-$user/bin/filter
 ln -s $root/filter/imagetops /tmp/cups-$user/bin/filter
@@ -547,5 +548,5 @@
 echo ""
 
 #
-# End of "$Id: run-stp-tests.sh 4685 2005-09-22 11:52:38Z mike $"
+# End of "$Id: run-stp-tests.sh 4829 2005-11-12 03:15:10Z mike $"
 #
diff -urNad cupsys-1.1.99.b1.r4748~/tools/testosx cupsys-1.1.99.b1.r4748/tools/testosx
--- cupsys-1.1.99.b1.r4748~/tools/testosx	1970-01-01 09:00:00.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/tools/testosx	2005-11-13 03:48:19.114041000 +0900
@@ -0,0 +1,87 @@
+#!/bin/sh
+# Make sure we are running in the right directory...
+if test ! -f tools/testosx; then
+	echo "Run this script from the top-level CUPS source directory, e.g.:"
+	echo ""
+	echo "    tools/testosx"
+	echo ""
+	exit 1
+fi
+
+# Update the current working copy...
+svn up
+rev=`svnversion . | sed -e '1,$s/[a-zA-Z]//g'`
+
+# Make everything...
+make all
+
+# Setup an install directory...
+user=`whoami`
+topdir=`pwd`
+pkgdir="/tmp/cups.pkg-$user"
+
+echo Building package using temp directory $pkgdir...
+rm -rf $pkgdir
+mkdir -p $pkgdir/Package
+mkdir -p $pkgdir/Resources
+
+# Install CUPS into the Package directory...
+#make INSTALL=$topdir/install-sh BUILDROOT=$pkgdir/Package install
+make BUILDROOT=$pkgdir/Package install
+
+# Install resource files into the Resources directory...
+echo Installing resource files...
+cp packaging/LICENSE.rtf $pkgdir/Resources/ReadMe.rtf
+cp packaging/WELCOME.rtf $pkgdir/Resources/Welcome.rtf
+cp packaging/installer.tif $pkgdir/Resources/background.tif
+
+cat >$pkgdir/Resources/preflight <<EOF
+#!/bin/sh
+killall cupsd
+EOF
+chmod 755 $pkgdir/Resources/preflight
+
+cat >$pkgdir/Resources/postflight <<EOF
+#!/bin/sh
+/usr/sbin/cupsd
+EOF
+chmod 755 $pkgdir/Resources/postflight
+
+# Tag the current revision in the plist and web interface files...
+sed -e '1,$s/@CUPS_VERSION@/1.2svn-r'$rev'/g' \
+	-e '1,$s/@CUPS_RELEASE@/1.2.'$rev'/g' \
+	<packaging/cups-desc.plist.in >packaging/cups-desc.plist
+sed -e '1,$s/@CUPS_VERSION@/1.2svn-r'$rev'/g' \
+	-e '1,$s/@CUPS_RELEASE@/1.2.'$rev'/g' \
+	<packaging/cups-info.plist.in >packaging/cups-info.plist
+sed -e '1,$s/@CUPS_VERSION@/1.2svn-r'$rev'/g' \
+	<doc/index.html.in >doc/index.html
+
+# Figure out where PackageMaker is installled...
+if test -d /Developer/Applications/Utilities/PackageMaker.app; then
+	PackageMaker=/Developer/Applications/Utilities/PackageMaker.app/Contents/MacOS/PackageMaker
+else
+	PackageMaker=/Developer/Applications/PackageMaker.app/Contents/MacOS/PackageMaker
+fi
+
+# Create the package...
+echo Creating MacOS X package...
+rm -rf cups.pkg
+echo $PackageMaker -build -v -p cups.pkg \
+	-f $pkgdir/Package \
+	-r $pkgdir/Resources \
+	-d packaging/cups-desc.plist \
+	-i packaging/cups-info.plist
+$PackageMaker -build -v -p cups.pkg \
+	-f $pkgdir/Package \
+	-r $pkgdir/Resources \
+	-d packaging/cups-desc.plist \
+	-i packaging/cups-info.plist
+
+# Create a disk image...
+echo Creating MacOS X disk image...
+hdiutil create -ov -srcfolder cups.pkg cups-1.2svn-r$rev.dmg
+
+# Cleanup temp files...
+echo Removing temporary files...
+rm -rf $pkgdir
diff -urNad cupsys-1.1.99.b1.r4748~/tools/testrpm cupsys-1.1.99.b1.r4748/tools/testrpm
--- cupsys-1.1.99.b1.r4748~/tools/testrpm	2005-11-13 13:59:12.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/tools/testrpm	2005-11-13 03:48:19.114041000 +0900
@@ -3,9 +3,18 @@
 # Test script for making RPMs...
 #
 
+# Make sure we are running in the right directory...
+if test ! -f tools/testrpm; then
+        echo "Run this script from the top-level CUPS source directory, e.g.:"
+        echo ""
+        echo "    tools/testrpm"
+        echo ""
+        exit 1
+fi
+
 echo Updating...
 svn up
-rev=`svnversion .`
+rev=`svnversion . | sed -e '1,$s/[a-zA-Z]//g'`
 version="1.2svn"
 
 echo Exporting $version...
@@ -15,10 +24,14 @@
 echo Configuring...
 cd /tmp/cups-$version/config-scripts
 
-sed -e '1,$s/^CUPS_VERSION=.*/CUPS_VERSION='$version'/' <cups-common.m4 >cups-common.m4.new
+sed -e '1,$s/^CUPS_VERSION=.*/CUPS_VERSION='$version'/' \
+	<cups-common.m4 >cups-common.m4.new
 mv cups-common.m4.new cups-common.m4
 cd ..
-sed -e '1,$s/@CUPS_VERSION@/'$version'/' -e '1,$s/^Release:.*/Release: '$rev'/' -e '1,$s/-source/-r'$rev'-source/' <cups.spec.in >cups.spec
+sed -e '1,$s/@CUPS_VERSION@/'$version'/' \
+	-e '1,$s/^Release:.*/Release: '$rev'/' \
+	-e '1,$s/-source/-r'$rev'-source/' \
+	<packaging/cups.spec.in >packaging/cups.spec
 autoconf -f
 rm -rf autom4te*.cache
 rm -rf standards
diff -urNad cupsys-1.1.99.b1.r4748~/vcnet/config.h cupsys-1.1.99.b1.r4748/vcnet/config.h
--- cupsys-1.1.99.b1.r4748~/vcnet/config.h	1970-01-01 09:00:00.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/vcnet/config.h	2005-11-11 21:53:38.810647000 +0900
@@ -0,0 +1,352 @@
+/*
+ * "$Id: config.h 4828 2005-11-11 12:53:38Z mike $"
+ *
+ *   Configuration file for the Common UNIX Printing System (CUPS).
+ *
+ *   Copyright 1997-2005 by Easy Software Products.
+ *
+ *   These coded instructions, statements, and computer programs are the
+ *   property of Easy Software Products and are protected by Federal
+ *   copyright law.  Distribution and use rights are outlined in the file
+ *   "LICENSE.txt" which should have been included with this file.  If this
+ *   file is missing or damaged please contact Easy Software Products
+ *   at:
+ *
+ *       Attn: CUPS Licensing Information
+ *       Easy Software Products
+ *       44141 Airport View Drive, Suite 204
+ *       Hollywood, Maryland 20636 USA
+ *
+ *       Voice: (301) 373-9600
+ *       EMail: cups-info@cups.org
+ *         WWW: http://www.cups.org
+ */
+
+#ifndef _CUPS_CONFIG_H_
+#define _CUPS_CONFIG_H_
+
+/*
+ * Compiler stuff...
+ */
+
+#undef const
+#undef __CHAR_UNSIGNED__
+
+
+/*
+ * Version of software...
+ */
+
+#define CUPS_SVERSION		"CUPS v1.2svn"
+#define CUPS_MINIMAL		"CUPS/1.2svn"
+
+
+/*
+ * Default user and group...
+ */
+
+#define CUPS_DEFAULT_USER	"lp"
+#define CUPS_DEFAULT_GROUP	"sys"
+
+
+/*
+ * Default IPP port...
+ */
+
+#define CUPS_DEFAULT_IPP_PORT	631
+
+
+/*
+ * Maximum number of file descriptors to support.
+ */
+
+#define CUPS_MAX_FDS		4096
+
+
+/*
+ * Do we have domain socket support?
+ */
+
+#undef CUPS_DEFAULT_DOMAINSOCKET
+
+
+/*
+ * Where are files stored?
+ *
+ * Note: These are defaults, which can be overridden by environment
+ *       variables at run-time...
+ */
+
+#define CUPS_CACHEDIR	"C:/CUPS/cache"
+#define CUPS_DATADIR    "C:/CUPS/share"
+#define CUPS_DOCROOT	"C:/CUPS/share/doc"
+#define CUPS_FONTPATH	"C:/CUPS/share/fonts"
+#define CUPS_LOCALEDIR	"C:/CUPS/locale"
+#define CUPS_LOGDIR	"C:/CUPS/logs"
+#define CUPS_REQUESTS	"C:/CUPS/spool"
+#define CUPS_SERVERBIN	"C:/CUPS/lib"
+#define CUPS_SERVERROOT	"C:/CUPS/etc"
+#define CUPS_STATEDIR	"C:/CUPS/run"
+
+
+/*
+ * Do we have various image libraries?
+ */
+
+#undef HAVE_LIBPNG
+#undef HAVE_LIBZ
+#undef HAVE_LIBJPEG
+#undef HAVE_LIBTIFF
+
+
+/*
+ * Do we have PAM stuff?
+ */
+
+#ifndef HAVE_LIBPAM
+#define HAVE_LIBPAM 0
+#endif /* !HAVE_LIBPAM */
+
+#undef HAVE_PAM_PAM_APPL_H
+
+
+/*
+ * Do we have <shadow.h>?
+ */
+
+#undef HAVE_SHADOW_H
+
+
+/*
+ * Do we have <crypt.h>?
+ */
+
+#undef HAVE_CRYPT_H
+
+
+/*
+ * Use <string.h>, <strings.h>, and/or <bstring.h>?
+ */
+
+#define HAVE_STRING_H
+#undef HAVE_STRINGS_H
+#undef HAVE_BSTRING_H
+
+
+/*
+ * Do we have the long long type?
+ */
+
+#undef HAVE_LONG_LONG
+
+#ifdef HAVE_LONG_LONG
+#  define CUPS_LLFMT	"%lld"
+#  define CUPS_LLCAST	(long long)
+#else
+#  define CUPS_LLFMT	"%ld"
+#  define CUPS_LLCAST	(long)
+#endif /* HAVE_LONG_LONG */
+
+
+/*
+ * Do we have the strtoll() function?
+ */
+
+#undef HAVE_STRTOLL
+
+#ifndef HAVE_STRTOLL
+#  define strtoll(nptr,endptr,base) strtol((nptr), (endptr), (base))
+#endif /* !HAVE_STRTOLL */
+
+
+/*
+ * Do we have the strXXX() functions?
+ */
+
+#define HAVE_STRDUP
+#define HAVE_STRCASECMP
+#define HAVE_STRNCASECMP
+#undef HAVE_STRLCAT
+#undef HAVE_STRLCPY
+
+
+/*
+ * Do we have the geteuid() function?
+ */
+
+#undef HAVE_GETEUID
+
+
+/*
+ * Do we have the vsyslog() function?
+ */
+
+#undef HAVE_VSYSLOG
+
+
+/*
+ * Do we have the (v)snprintf() functions?
+ */
+
+#undef HAVE_SNPRINTF
+#undef HAVE_VSNPRINTF
+
+
+/*
+ * What signal functions to use?
+ */
+
+#undef HAVE_SIGSET
+#undef HAVE_SIGACTION
+
+
+/*
+ * What wait functions to use?
+ */
+
+#undef HAVE_WAITPID
+#undef HAVE_WAIT3
+
+
+/*
+ * Do we have the mallinfo function and malloc.h?
+ */
+
+#undef HAVE_MALLINFO
+#undef HAVE_MALLOC_H
+
+
+/*
+ * Do we have the langinfo.h header file?
+ */
+
+#undef HAVE_LANGINFO_H
+
+
+/*
+ * Which encryption libraries do we have?
+ */
+
+#undef HAVE_CDSASSL
+#undef HAVE_GNUTLS
+#undef HAVE_LIBSSL
+#undef HAVE_SSL
+
+
+/*
+ * Do we have the OpenSLP library?
+ */
+
+#undef HAVE_LIBSLP
+
+
+/*
+ * Do we have libpaper?
+ */
+
+#undef HAVE_LIBPAPER
+
+
+/*
+ * Do we have <sys/ioctl.h>?
+ */
+
+#undef HAVE_SYS_IOCTL_H
+
+
+/*
+ * Do we have mkstemp() and/or mkstemps()?
+ */
+
+#undef HAVE_MKSTEMP
+#undef HAVE_MKSTEMPS
+
+
+/*
+ * Does the "tm" structure contain the "tm_gmtoff" member?
+ */
+
+#undef HAVE_TM_GMTOFF
+
+
+/*
+ * Do we have rresvport_af()?
+ */
+
+#undef HAVE_RRESVPORT_AF
+
+
+/*
+ * Do we have getaddrinfo()?
+ */
+
+#define HAVE_GETADDRINFO
+
+
+/*
+ * Do we have getnameinfo()?
+ */
+
+#define HAVE_GETNAMEINFO
+
+
+/*
+ * Do we have getifaddrs()?
+ */
+
+#undef HAVE_GETIFADDRS
+
+
+/*
+ * Do we have hstrerror()?
+ */
+
+#undef HAVE_HSTRERROR
+
+
+/*
+ * Do we have the <sys/sockio.h> header file?
+ */
+
+#undef HAVE_SYS_SOCKIO_H
+
+
+/*
+ * Does the sockaddr structure contain an sa_len parameter?
+ */
+
+#undef HAVE_STRUCT_SOCKADDR_SA_LEN
+
+
+/*
+ * Do we have the AIX usersec.h header file?
+ */
+
+#undef HAVE_USERSEC_H
+
+/*
+ * Do we have pthread support?
+ */
+
+#undef HAVE_PTHREAD_H
+
+
+/*
+ * Various scripting languages...
+ */
+
+#undef HAVE_JAVA
+#define CUPS_JAVA	"/usr/bin/java"
+#undef HAVE_PERL
+#define CUPS_PERL	"/usr/bin/perl"
+#undef HAVE_PHP
+#define CUPS_PHP	"/usr/bin/php"
+#undef HAVE_PYTHON
+#define CUPS_PYTHON	"/usr/bin/python"
+
+
+#endif /* !_CUPS_CONFIG_H_ */
+
+/*
+ * End of "$Id: config.h 4828 2005-11-11 12:53:38Z mike $".
+ */
diff -urNad cupsys-1.1.99.b1.r4748~/vcnet/cups.sln cupsys-1.1.99.b1.r4748/vcnet/cups.sln
--- cupsys-1.1.99.b1.r4748~/vcnet/cups.sln	1970-01-01 09:00:00.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/vcnet/cups.sln	2005-11-11 21:53:38.810647000 +0900
@@ -0,0 +1,21 @@
+Microsoft Visual Studio Solution File, Format Version 8.00
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libcups2", "libcups2.vcproj", "{CB4AA6F2-3E84-45BE-B505-95CD375E8BE3}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfiguration) = preSolution
+		Debug = Debug
+		Release = Release
+	EndGlobalSection
+	GlobalSection(ProjectConfiguration) = postSolution
+		{CB4AA6F2-3E84-45BE-B505-95CD375E8BE3}.Debug.ActiveCfg = Debug|Win32
+		{CB4AA6F2-3E84-45BE-B505-95CD375E8BE3}.Debug.Build.0 = Debug|Win32
+		{CB4AA6F2-3E84-45BE-B505-95CD375E8BE3}.Release.ActiveCfg = Release|Win32
+		{CB4AA6F2-3E84-45BE-B505-95CD375E8BE3}.Release.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+	EndGlobalSection
+	GlobalSection(ExtensibilityAddIns) = postSolution
+	EndGlobalSection
+EndGlobal
diff -urNad cupsys-1.1.99.b1.r4748~/vcnet/libcups2.def cupsys-1.1.99.b1.r4748/vcnet/libcups2.def
--- cupsys-1.1.99.b1.r4748~/vcnet/libcups2.def	1970-01-01 09:00:00.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/vcnet/libcups2.def	2005-11-11 21:53:38.810647000 +0900
@@ -0,0 +1,247 @@
+LIBRARY libcups2
+VERSION 2.6
+EXPORTS
+cupsAddDest
+cupsAddOption
+cupsArrayAdd
+cupsArrayClear
+cupsArrayCount
+cupsArrayCurrent
+cupsArrayDelete
+cupsArrayDup
+cupsArrayFind
+cupsArrayFirst
+cupsArrayLast
+cupsArrayNew
+cupsArrayNext
+cupsArrayPrev
+cupsArrayRemove
+cupsArrayRestore
+cupsArraySave
+cupsBackchannelRead
+cupsBackchannelWrite
+cupsCancelJob
+cupsCharmapFlush
+cupsCharmapFree
+cupsCharmapGet
+cupsCharsetToUTF8
+cupsDirClose
+cupsDirOpen
+cupsDirRead
+cupsDirRewind
+cupsDoAuthentication
+cupsDoFileRequest
+cupsEncodeOptions
+cupsEncodeOptions2
+cupsEncodingName
+cupsEncryption
+cupsFileClose
+cupsFileCompression
+cupsFileEOF
+cupsFileFlush
+cupsFileGetChar
+cupsFileGetConf
+cupsFileGets
+cupsFileLock
+cupsFileNumber
+cupsFileOpen
+cupsFileOpenFd
+cupsFilePeekChar
+cupsFilePrintf
+cupsFilePutChar
+cupsFilePuts
+cupsFileRead
+cupsFileRewind
+cupsFileSeek
+cupsFileTell
+cupsFileUnlock
+cupsFileWrite
+cupsFreeDests
+cupsFreeJobs
+cupsFreeOptions
+cupsGetClasses
+cupsGetDefault
+cupsGetDefault2
+cupsGetDest
+cupsGetDests
+cupsGetDests2
+cupsGetFd
+cupsGetFile
+cupsGetJobs
+cupsGetJobs2
+cupsGetOption
+cupsGetPassword
+cupsGetPPD
+cupsGetPPD2
+cupsGetPrinters
+cupsLangEncoding
+cupsLangFlush
+cupsLangFree
+cupsLangGet
+cupsLangPrintf
+cupsLangPuts
+cupsLastError
+cupsMarkOptions
+_cups_md5_append
+_cups_md5_finish
+_cups_md5_init
+cupsNormalizeMapsFlush
+cupsNormalizeMapsFree
+cupsNormalizeMapsGet
+cupsParseOptions
+cupsPrintFile
+cupsPrintFile2
+cupsPrintFiles
+cupsPrintFiles2
+cupsPutFd
+cupsPutFile
+_cupsRestoreLocale
+_cupsSaveLocale
+cupsServer
+cupsSetDests
+cupsSetDests2
+cupsSetEncryption
+cupsSetPasswordCB
+cupsSetServer
+cupsSetUser
+_cups_strcpy
+_cups_strlcat
+_cups_strlcpy
+cupsTempFd
+cupsTempFile
+cupsTempFile2
+cupsUser
+cupsUTF16ToUTF32
+cupsUTF16ToUTF8
+cupsUTF32CaseFold
+cupsUTF32CharacterProperty
+cupsUTF32CompareCaseless
+cupsUTF32CompareIdentifier
+cupsUTF32Normalize
+cupsUTF32ToUTF16
+cupsUTF32ToUTF8
+cupsUTF8CaseFold
+cupsUTF8CompareCaseless
+cupsUTF8CompareIdentifier
+cupsUTF8Normalize
+cupsUTF8ToCharset
+cupsUTF8ToUTF16
+cupsUTF8ToUTF32
+httpAddrAny
+httpAddrConnect
+httpAddrEqual
+httpAddrFreeList
+httpAddrGetList
+httpAddrLength
+httpAddrLocalhost
+httpAddrLookup
+httpAddrString
+httpAssembleURI
+httpAssembleURIf
+httpCheck
+httpClearCookie
+httpClose
+httpConnect
+httpConnectEncrypt
+httpDecode64
+httpDecode64_2
+httpDelete
+httpEncode64
+httpEncode64_2
+httpEncryption
+httpFlush
+httpFlushWrite
+httpGet
+httpGetDateString
+httpGetDateString2
+httpGetDateTime
+httpGetHostByName
+httpGetHostname
+httpGetLength
+httpGetLength2
+httpGets
+httpGetSubField
+httpGetSubField2
+httpHead
+httpInitialize
+httpMD5
+httpMD5Final
+httpMD5String
+httpOptions
+httpPost
+httpPrintf
+httpPut
+httpRead
+httpReconnect
+httpSeparate
+httpSeparate2
+httpSeparateURI
+httpSetCookie
+httpSetField
+httpSetLength
+httpStatus
+httpTrace
+httpUpdate
+httpWait
+httpWrite
+_ipp_add_attr
+ippAddBoolean
+ippAddBooleans
+ippAddCollection
+ippAddCollections
+ippAddDate
+ippAddInteger
+ippAddIntegers
+ippAddRange
+ippAddRanges
+ippAddResolution
+ippAddResolutions
+ippAddSeparator
+ippAddString
+ippAddStrings
+ippDateToTime
+ippDelete
+ippDeleteAttribute
+ippErrorString
+ippErrorValue
+ippFindAttribute
+ippFindNextAttribute
+_ipp_free_attr
+ippLength
+ippNew
+ippOpString
+ippOpValue
+ippPort
+ippRead
+ippReadFile
+ippReadIO
+ippSetPort
+ippTimeToDate
+ippWrite
+ippWriteFile
+ippWriteIO
+ppdClose
+ppdCollect
+ppdConflicts
+ppdEmit
+ppdEmitFd
+ppdEmitJCL
+ppdEmitJCLEnd
+ppdErrorString
+ppdFindAttr
+ppdFindChoice
+ppdFindMarkedChoice
+ppdFindNextAttr
+ppdFindOption
+ppdIsMarked
+ppdLastError
+ppdMarkDefaults
+ppdMarkOption
+ppdOpen
+ppdOpen2
+ppdOpenFd
+ppdOpenFile
+ppdPageLength
+ppdPageSize
+ppdPageWidth
+ppdSetConformance
diff -urNad cupsys-1.1.99.b1.r4748~/vcnet/libcups2.vcproj cupsys-1.1.99.b1.r4748/vcnet/libcups2.vcproj
--- cupsys-1.1.99.b1.r4748~/vcnet/libcups2.vcproj	1970-01-01 09:00:00.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/vcnet/libcups2.vcproj	2005-11-11 21:53:38.810647000 +0900
@@ -0,0 +1,286 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="libcups2"
+	ProjectGUID="{CB4AA6F2-3E84-45BE-B505-95CD375E8BE3}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..\vcnet,.."
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;LIBCUPS2_EXPORTS"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				BufferSecurityCheck="TRUE"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib"
+				OutputFile="$(OutDir)/libcups2.dll"
+				LinkIncremental="2"
+				ModuleDefinitionFile="..\vcnet\libcups2.def"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/libcups2.pdb"
+				SubSystem="2"
+				ImportLibrary="$(OutDir)/libcups2.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="1"
+				AdditionalIncludeDirectories="..\vcnet,.."
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;LIBCUPS2_EXPORTS"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="ws2_32.lib"
+				OutputFile="$(OutDir)/libcups2.dll"
+				LinkIncremental="1"
+				ModuleDefinitionFile="..\vcnet\libcups2.def"
+				GenerateDebugInformation="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				ImportLibrary="$(OutDir)/libcups2.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}">
+			<File
+				RelativePath="..\cups\array.c">
+			</File>
+			<File
+				RelativePath="..\cups\attr.c">
+			</File>
+			<File
+				RelativePath="..\cups\auth.c">
+			</File>
+			<File
+				RelativePath="..\cups\backchannel.c">
+			</File>
+			<File
+				RelativePath="..\cups\dest.c">
+			</File>
+			<File
+				RelativePath="..\cups\dir.c">
+			</File>
+			<File
+				RelativePath="..\cups\emit.c">
+			</File>
+			<File
+				RelativePath="..\cups\encode.c">
+			</File>
+			<File
+				RelativePath="..\cups\file.c">
+			</File>
+			<File
+				RelativePath="..\cups\getputfile.c">
+			</File>
+			<File
+				RelativePath="..\cups\globals.c">
+			</File>
+			<File
+				RelativePath="..\cups\http-addr.c">
+			</File>
+			<File
+				RelativePath="..\cups\http-addrlist.c">
+			</File>
+			<File
+				RelativePath="..\cups\http-support.c">
+			</File>
+			<File
+				RelativePath="..\cups\http.c">
+			</File>
+			<File
+				RelativePath="..\cups\ipp-support.c">
+			</File>
+			<File
+				RelativePath="..\cups\ipp.c">
+			</File>
+			<File
+				RelativePath="..\cups\langprintf.c">
+			</File>
+			<File
+				RelativePath="..\cups\language.c">
+			</File>
+			<File
+				RelativePath="..\cups\mark.c">
+			</File>
+			<File
+				RelativePath="..\cups\md5.c">
+			</File>
+			<File
+				RelativePath="..\cups\md5passwd.c">
+			</File>
+			<File
+				RelativePath="..\cups\normalize.c">
+			</File>
+			<File
+				RelativePath="..\cups\options.c">
+			</File>
+			<File
+				RelativePath="..\cups\page.c">
+			</File>
+			<File
+				RelativePath="..\cups\ppd.c">
+			</File>
+			<File
+				RelativePath="..\cups\snprintf.c">
+			</File>
+			<File
+				RelativePath="..\cups\string.c">
+			</File>
+			<File
+				RelativePath="..\cups\tempfile.c">
+			</File>
+			<File
+				RelativePath="..\cups\transcode.c">
+			</File>
+			<File
+				RelativePath="..\cups\usersys.c">
+			</File>
+			<File
+				RelativePath="..\cups\util.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}">
+			<File
+				RelativePath="..\cups\array.h">
+			</File>
+			<File
+				RelativePath="..\cups\backend.h">
+			</File>
+			<File
+				RelativePath="..\cups\cups.h">
+			</File>
+			<File
+				RelativePath="..\cups\debug.h">
+			</File>
+			<File
+				RelativePath="..\cups\dir.h">
+			</File>
+			<File
+				RelativePath="..\cups\file.h">
+			</File>
+			<File
+				RelativePath="..\cups\globals.h">
+			</File>
+			<File
+				RelativePath="..\cups\http-private.h">
+			</File>
+			<File
+				RelativePath="..\cups\http.h">
+			</File>
+			<File
+				RelativePath="..\cups\ipp.h">
+			</File>
+			<File
+				RelativePath="..\cups\language.h">
+			</File>
+			<File
+				RelativePath="..\cups\md5-apple.h">
+			</File>
+			<File
+				RelativePath="..\cups\md5.h">
+			</File>
+			<File
+				RelativePath="..\cups\normalize.h">
+			</File>
+			<File
+				RelativePath="..\cups\ppd.h">
+			</File>
+			<File
+				RelativePath="..\cups\string.h">
+			</File>
+			<File
+				RelativePath="..\cups\transcode.h">
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urNad cupsys-1.1.99.b1.r4748~/visualc/config.h cupsys-1.1.99.b1.r4748/visualc/config.h
--- cupsys-1.1.99.b1.r4748~/visualc/config.h	2005-02-18 11:18:11.000000000 +0900
+++ cupsys-1.1.99.b1.r4748/visualc/config.h	1970-01-01 09:00:00.000000000 +0900
@@ -1,297 +0,0 @@
-/*
- * "$Id: config.h 4494 2005-02-18 02:18:11Z mike $"
- *
- *   Configuration file for the Common UNIX Printing System (CUPS).
- *
- *   Copyright 1997-2005 by Easy Software Products.
- *
- *   These coded instructions, statements, and computer programs are the
- *   property of Easy Software Products and are protected by Federal
- *   copyright law.  Distribution and use rights are outlined in the file
- *   "LICENSE.txt" which should have been included with this file.  If this
- *   file is missing or damaged please contact Easy Software Products
- *   at:
- *
- *       Attn: CUPS Licensing Information
- *       Easy Software Products
- *       44141 Airport View Drive, Suite 204
- *       Hollywood, Maryland 20636 USA
- *
- *       Voice: (301) 373-9600
- *       EMail: cups-info@cups.org
- *         WWW: http://www.cups.org
- */
-
-/*
- * Compiler stuff...
- */
-
-#undef const
-#undef __CHAR_UNSIGNED__
-
-
-/*
- * Version of software...
- */
-
-#define CUPS_SVERSION	"CUPS v1.2.0b1"
-
-
-/*
- * Default user and group...
- */
-
-#define CUPS_DEFAULT_USER	"lp"
-#define CUPS_DEFAULT_GROUP	"sys"
-
-
-/*
- * Default IPP port...
- */
-
-#define CUPS_DEFAULT_IPP_PORT 631
-
-
-/*
- * Maximum number of file descriptors to support.
- */
-
-#define CUPS_MAX_FDS		4096
-
-
-/*
- * Where are files stored?
- */
-
-#define CUPS_LOCALEDIR	"C:/CUPS/locale"
-#define CUPS_SERVERROOT	"C:/CUPS/etc"
-#define CUPS_SERVERBIN	"C:/CUPS"
-#define CUPS_DOCROOT	"C:/CUPS/share/doc"
-#define CUPS_REQUESTS	"C:/CUPS/spool"
-#define CUPS_LOGDIR	"C:/CUPS/logs"
-#define CUPS_DATADIR    "C:/CUPS/share"
-#define CUPS_FONTPATH	"C:/CUPS/share/fonts"
-
-
-/*
- * What is the format string for strftime?
- */
-
-#define CUPS_STRFTIME_FORMAT	"%c"
-
-
-/*
- * Do we have various image libraries?
- */
-
-#undef HAVE_LIBPNG
-#undef HAVE_LIBZ
-#undef HAVE_LIBJPEG
-#undef HAVE_LIBTIFF
-
-
-/*
- * Does this machine store words in big-endian (MSB-first) order?
- */
-
-#undef WORDS_BIGENDIAN
-
-
-/*
- * Which directory functions and headers do we use?
- */
-
-#undef HAVE_DIRENT_H
-#undef HAVE_SYS_DIR_H
-#undef HAVE_SYS_NDIR_H
-#undef HAVE_NDIR_H
-
-/*
- * Do we have PAM stuff?
- */
-
-#ifndef HAVE_LIBPAM
-#define HAVE_LIBPAM 0
-#endif /* !HAVE_LIBPAM */
-
-#undef HAVE_PAM_PAM_APPL_H
-
-
-/*
- * Do we have <shadow.h>?
- */
-
-#undef HAVE_SHADOW_H
-
-
-/*
- * Do we have <crypt.h>?
- */
-
-#undef HAVE_CRYPT_H
-
-
-/*
- * How about standard C header files?
- */
-
-#undef HAVE_STDDEF_H
-#define HAVE_STDLIB_H
-
-
-/*
- * Use <string.h>, <strings.h>, and/or <bstring.h>?
- */
-
-#define HAVE_STRING_H
-#undef HAVE_STRINGS_H
-#undef HAVE_BSTRING_H
-
-
-/*
- * Do we have the strXXX() functions?
- */
-
-#define HAVE_STRDUP
-#define HAVE_STRCASECMP
-#define HAVE_STRNCASECMP
-#undef HAVE_STRLCAT
-#undef HAVE_STRLCPY
-
-
-/*
- * Do we have the vsyslog() function?
- */
-
-#undef HAVE_VSYSLOG
-
-
-/*
- * Do we have the (v)snprintf() functions?
- */
-
-#undef HAVE_SNPRINTF
-#undef HAVE_VSNPRINTF
-
-
-/*
- * What signal functions to use?
- */
-
-#undef HAVE_SIGSET
-#undef HAVE_SIGACTION
-
-/*
- * What wait functions to use?
- */
-
-#undef HAVE_WAITPID
-#undef HAVE_WAIT3
-
-
-/*
- * Do we have the mallinfo function and malloc.h?
- */
-
-#undef HAVE_MALLINFO
-#undef HAVE_MALLOC_H
-
-
-/*
- * Which encryption libraries do we have?
- */
-
-#undef HAVE_CDSASSL
-#undef HAVE_GNUTLS
-#undef HAVE_LIBSSL
-#undef HAVE_SSL
-
-
-/*
- * Do we have the OpenSLP library?
- */
-
-#undef HAVE_LIBSLP
-
-
-/*
- * Do we have libpaper?
- */
-
-#undef HAVE_LIBPAPER
-
-
-/*
- * Do we have <sys/ioctl.h>?
- */
-
-#undef HAVE_SYS_IOCTL_H
-
-
-/*
- * Do we have mkstemp() and/or mkstemps()?
- */
-
-#undef HAVE_MKSTEMP
-#undef HAVE_MKSTEMPS
-
-
-/*
- * Does the "tm" structure contain the "tm_gmtoff" member?
- */
-
-#undef HAVE_TM_GMTOFF
-
-
-/*
- * Do we have rresvport()?
- */
-
-#undef HAVE_RRESVPORT
-
-
-/*
- * Do we have getifaddrs()?
- */
-
-#undef HAVE_GETIFADDRS
-
-
-/*
- * Do we have hstrerror()?
- */
-
-#undef HAVE_HSTRERROR
-
-
-/*
- * Do we have the <sys/sockio.h> header file?
- */
-
-#undef HAVE_SYS_SOCKIO_H
-
-
-/*
- * Does the sockaddr structure contain an sa_len parameter?
- */
-
-#undef HAVE_STRUCT_SOCKADDR_SA_LEN
-
-
-/*
- * Various scripting languages...
- */
-
-#undef HAVE_JAVA
-#define CUPS_JAVA	"/usr/bin/java"
-#undef HAVE_PERL
-#define CUPS_PERL	"/usr/bin/perl"
-#undef HAVE_PHP
-#define CUPS_PHP	"/usr/bin/php"
-#undef HAVE_PYTHON
-#define CUPS_PYTHON	"/usr/bin/python"
-
-
-/*
- * End of "$Id: config.h 4494 2005-02-18 02:18:11Z mike $".
- */
