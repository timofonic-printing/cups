--- a/backend/ipp.c
+++ b/backend/ipp.c
@@ -3,7 +3,7 @@
  *
  *   IPP backend for CUPS.
  *
- *   Copyright 2007-2011 by Apple Inc.
+ *   Copyright 2007-2012 by Apple Inc.
  *   Copyright 1997-2007 by Easy Software Products, all rights reserved.
  *
  *   These coded instructions, statements, and computer programs are the
@@ -63,6 +63,7 @@
   int			port,		/* Port number */
 			version,	/* IPP version */
 			job_id;		/* Job ID for submitted job */
+  const char		*job_name;	/* Job name for submitted job */
   http_encryption_t	encryption;	/* Use encryption? */
   ipp_jstate_t		job_state;	/* Current job state */
   ipp_pstate_t		printer_state;	/* Current printer state */
@@ -82,12 +83,16 @@
 {
   "job-impressions-completed",
   "job-media-sheets-completed",
+  "job-name",
+  "job-originating-user-name",
   "job-state",
   "job-state-reasons"
 };
 static int		job_canceled = 0;
 					/* Job cancelled? */
-static char		*password = NULL;
+static char		username[256] = "",
+					/* Username for device URI */
+			*password = NULL;
 					/* Password for device URI */
 static int		password_tries = 0;
 					/* Password tries */
@@ -186,7 +191,6 @@
   const char	*device_uri;		/* Device URI */
   char		scheme[255],		/* Scheme in URI */
 		hostname[1024],		/* Hostname */
-		username[255],		/* Username info */
 		resource[1024],		/* Resource info (printer name) */
 		addrname[256],		/* Address name */
 		*optptr,		/* Pointer to URI options */
@@ -205,6 +209,7 @@
   int		port;			/* Port number (not used) */
   char		portname[255];		/* Port name */
   char		uri[HTTP_MAX_URI];	/* Updated URI without user/pass */
+  char		print_job_name[1024];	/* Update job-name for Print-Job */
   http_status_t	http_status;		/* Status of HTTP request */
   ipp_status_t	ipp_status;		/* Status of IPP request */
   http_t	*http;			/* HTTP connection */
@@ -231,7 +236,9 @@
   ipp_attribute_t *doc_handling_sup;	/* multiple-document-handling-supported */
   ipp_attribute_t *printer_state;	/* printer-state attribute */
   ipp_attribute_t *printer_accepting;	/* printer-is-accepting-jobs */
-  int		validate_job;		/* Does printer support Validate-Job? */
+  int		create_job = 0,		/* Does printer support Create-Job? */
+		send_document = 0,	/* Does printer support Send-Document? */
+		validate_job = 0;	/* Does printer support Validate-Job? */
   int		copies,			/* Number of copies for job */
 		copies_remaining;	/* Number of copies remaining */
   const char	*content_type,		/* CONTENT_TYPE environment variable */
@@ -604,7 +611,10 @@
     const char *ptr = getenv("AUTH_USERNAME");
 
     if (ptr)
+    {
+      strlcpy(username, ptr, sizeof(username));
       cupsSetUser(ptr);
+    }
 
     password = getenv("AUTH_PASSWORD");
   }
@@ -789,7 +799,6 @@
   supported        = NULL;
   operations_sup   = NULL;
   doc_handling_sup = NULL;
-  validate_job     = 0;
 
   do
   {
@@ -834,7 +843,9 @@
     fprintf(stderr, "DEBUG: Get-Printer-Attributes: %s (%s)\n",
             ippErrorString(ipp_status), cupsLastErrorString());
 
-    if (ipp_status > IPP_OK_CONFLICT)
+    if (ipp_status <= IPP_OK_CONFLICT)
+      password_tries = 0;
+    else
     {
       fprintf(stderr, "DEBUG: Get-Printer-Attributes returned %s.\n",
               ippErrorString(ipp_status));
@@ -891,16 +902,21 @@
 
 	return (CUPS_BACKEND_STOP);
       }
-      else if (ipp_status == IPP_NOT_AUTHORIZED || ipp_status == IPP_FORBIDDEN)
+      else if (ipp_status == IPP_FORBIDDEN ||
+               ipp_status == IPP_AUTHENTICATION_CANCELED)
       {
-	if (!strncmp(httpGetField(http, HTTP_FIELD_WWW_AUTHENTICATE),
-		     "Negotiate", 9))
+        const char *www_auth = httpGetField(http, HTTP_FIELD_WWW_AUTHENTICATE);
+        				/* WWW-Authenticate field value */
+
+	if (!strncmp(www_auth, "Negotiate", 9))
 	  auth_info_required = "negotiate";
+        else if (www_auth[0])
+          auth_info_required = "username,password";
 
 	fprintf(stderr, "ATTR: auth-info-required=%s\n", auth_info_required);
 	return (CUPS_BACKEND_AUTH_REQUIRED);
       }
-      else
+      else if (ipp_status != IPP_NOT_AUTHORIZED)
       {
 	_cupsLangPrintFilter(stderr, "ERROR",
 	                     _("Unable to get printer status."));
@@ -1042,11 +1058,21 @@
 			     "cups-ipp-missing-get-printer-attributes");
 
       for (i = 0; i < operations_sup->num_values; i ++)
+      {
         if (operations_sup->values[i].integer == IPP_VALIDATE_JOB)
-	{
 	  validate_job = 1;
-	  break;
-	}
+        else if (operations_sup->values[i].integer == IPP_CREATE_JOB)
+	  create_job = 1;
+        else if (operations_sup->values[i].integer == IPP_SEND_DOCUMENT)
+	  send_document = 1;
+      }
+
+      if (!send_document)
+      {
+        fputs("DEBUG: Printer supports Create-Job but not Send-Document.\n",
+              stderr);
+        create_job = 0;
+      }
 
       if (!validate_job)
 	update_reasons(NULL, "+cups-ipp-conformance-failure-report,"
@@ -1116,7 +1142,7 @@
   {
     copies_remaining = 1;
 
-    if (argc < 7 && !send_options)
+    if (argc < 7 && !_cups_strncasecmp(final_content_type, "image/", 6))
       copies = 1;
   }
   else
@@ -1153,7 +1179,8 @@
   if (format_sup != NULL)
   {
     for (i = 0; i < format_sup->num_values; i ++)
-      if (!_cups_strcasecmp(final_content_type, format_sup->values[i].string.text))
+      if (!_cups_strcasecmp(final_content_type,
+                            format_sup->values[i].string.text))
       {
         document_format = final_content_type;
 	break;
@@ -1163,7 +1190,7 @@
     {
       for (i = 0; i < format_sup->num_values; i ++)
 	if (!_cups_strcasecmp("application/octet-stream",
-	                format_sup->values[i].string.text))
+	                      format_sup->values[i].string.text))
 	{
 	  document_format = "application/octet-stream";
 	  break;
@@ -1171,6 +1198,9 @@
     }
   }
 
+  fprintf(stderr, "DEBUG: final_content_type=\"%s\", document_format=\"%s\"\n",
+          final_content_type, document_format ? document_format : "(null)");
+
  /*
   * If the printer does not support HTTP/1.1 (which IPP requires), copy stdin
   * to a temporary file so that we can do a HTTP/1.0 submission...
@@ -1188,8 +1218,17 @@
 
     _cupsLangPrintFilter(stderr, "INFO", _("Copying print data."));
 
-    compatsize = backendRunLoop(-1, fd, snmp_fd, &(addrlist->addr), 0, 0,
-		                backendNetworkSideCB);
+    if ((compatsize = write(fd, buffer, bytes)) < 0)
+    {
+      perror("DEBUG: Unable to write temporary file");
+      return (CUPS_BACKEND_FAILED);
+    }
+
+    if ((bytes = backendRunLoop(-1, fd, snmp_fd, &(addrlist->addr), 0, 0,
+		                backendNetworkSideCB)) < 0)
+      return (CUPS_BACKEND_FAILED);
+
+    compatsize += bytes;
 
     close(fd);
 
@@ -1220,6 +1259,17 @@
   monitor.job_state     = IPP_JOB_PENDING;
   monitor.printer_state = IPP_PRINTER_IDLE;
 
+  if (create_job)
+  {
+    monitor.job_name = argv[3];
+  }
+  else
+  {
+    snprintf(print_job_name, sizeof(print_job_name), "%s - %s", argv[1],
+             argv[3]);
+    monitor.job_name = print_job_name;
+  }
+
   _cupsThreadCreate((_cups_thread_func_t)monitor_printer, &monitor);
 
  /*
@@ -1228,8 +1278,8 @@
 
   while (!job_canceled && validate_job)
   {
-    request = new_request(IPP_VALIDATE_JOB, version, uri, argv[2], argv[3],
-                          num_options, options, compression,
+    request = new_request(IPP_VALIDATE_JOB, version, uri, argv[2],
+                          monitor.job_name, num_options, options, compression,
 			  copies_sup ? copies : 1, document_format, pc,
 			  media_col_sup, doc_handling_sup);
 
@@ -1248,26 +1298,16 @@
       _cupsLangPrintFilter(stderr, "INFO", _("The printer is busy."));
       sleep(10);
     }
-    else if (ipp_status == IPP_NOT_AUTHORIZED || ipp_status == IPP_FORBIDDEN ||
+    else if (ipp_status == IPP_FORBIDDEN ||
 	     ipp_status == IPP_AUTHENTICATION_CANCELED)
     {
-     /*
-      * Update auth-info-required as needed...
-      */
-
-      fprintf(stderr, "DEBUG: WWW-Authenticate=\"%s\"\n",
-	      httpGetField(http, HTTP_FIELD_WWW_AUTHENTICATE));
-
-     /*
-      * Normal authentication goes through the password callback, which sets
-      * auth_info_required to "username,password".  Kerberos goes directly
-      * through GSSAPI, so look for Negotiate in the WWW-Authenticate header
-      * here and set auth_info_required as needed...
-      */
+      const char *www_auth = httpGetField(http, HTTP_FIELD_WWW_AUTHENTICATE);
+					/* WWW-Authenticate field value */
 
-      if (!strncmp(httpGetField(http, HTTP_FIELD_WWW_AUTHENTICATE),
-		   "Negotiate", 9))
+      if (!strncmp(www_auth, "Negotiate", 9))
 	auth_info_required = "negotiate";
+      else if (www_auth[0])
+	auth_info_required = "username,password";
 
       goto cleanup;
     }
@@ -1306,16 +1346,17 @@
     if (job_canceled)
       break;
 
-    request = new_request(num_files > 1 ? IPP_CREATE_JOB : IPP_PRINT_JOB,
-			  version, uri, argv[2], argv[3], num_options, options,
-			  compression, copies_sup ? copies : 1, document_format,
-			  pc, media_col_sup, doc_handling_sup);
+    request = new_request((num_files > 1 || create_job) ? IPP_CREATE_JOB :
+                                                          IPP_PRINT_JOB,
+			  version, uri, argv[2], monitor.job_name, num_options,
+			  options, compression, copies_sup ? copies : 1,
+			  document_format, pc, media_col_sup, doc_handling_sup);
 
    /*
     * Do the request...
     */
 
-    if (num_files > 1)
+    if (num_files > 1 || create_job)
       response = cupsDoRequest(http, request, resource);
     else
     {
@@ -1333,7 +1374,13 @@
       if (http_status == HTTP_CONTINUE && request->state == IPP_DATA)
       {
         if (num_files == 1)
-	  fd = open(files[0], O_RDONLY);
+        {
+	  if ((fd = open(files[0], O_RDONLY)) < 0)
+	  {
+	    _cupsLangPrintError("ERROR", _("Unable to open print file"));
+	    return (CUPS_BACKEND_FAILED);
+	  }
+	}
 	else
 	{
 	  fd          = 0;
@@ -1382,7 +1429,7 @@
     ipp_status = cupsLastError();
 
     fprintf(stderr, "DEBUG: %s: %s (%s)\n",
-            num_files > 1 ? "Create-Job" : "Print-Job",
+            (num_files > 1 || create_job) ? "Create-Job" : "Print-Job",
             ippErrorString(ipp_status), cupsLastErrorString());
 
     if (ipp_status > IPP_OK_CONFLICT)
@@ -1411,6 +1458,8 @@
       }
       else if (ipp_status == IPP_ERROR_JOB_CANCELED)
         goto cleanup;
+      else if (ipp_status == IPP_NOT_AUTHORIZED)
+        continue;
       else
       {
        /*
@@ -1420,21 +1469,24 @@
         _cupsLangPrintFilter(stderr, "ERROR",
 	                     _("Print file was not accepted."));
 
-	if (ipp_status == IPP_NOT_AUTHORIZED || ipp_status == IPP_FORBIDDEN)
+        if (ipp_status == IPP_FORBIDDEN ||
+            ipp_status == IPP_AUTHENTICATION_CANCELED)
 	{
-	  fprintf(stderr, "DEBUG: WWW-Authenticate=\"%s\"\n",
-		  httpGetField(http, HTTP_FIELD_WWW_AUTHENTICATE));
+	  const char *www_auth = httpGetField(http, HTTP_FIELD_WWW_AUTHENTICATE);
+					/* WWW-Authenticate field value */
 
-         /*
-	  * Normal authentication goes through the password callback, which sets
-	  * auth_info_required to "username,password".  Kerberos goes directly
-	  * through GSSAPI, so look for Negotiate in the WWW-Authenticate header
-	  * here and set auth_info_required as needed...
+	  if (!strncmp(www_auth, "Negotiate", 9))
+	    auth_info_required = "negotiate";
+	  else if (www_auth[0])
+	    auth_info_required = "username,password";
+	}
+	else if (ipp_status == IPP_REQUEST_VALUE)
+	{
+	 /*
+	  * Print file is too large, abort this job...
 	  */
 
-	  if (!strncmp(httpGetField(http, HTTP_FIELD_WWW_AUTHENTICATE),
-		       "Negotiate", 9))
-	    auth_info_required = "negotiate";
+	  goto cleanup;
 	}
 	else
 	  sleep(10);
@@ -1461,19 +1513,21 @@
     }
     else
     {
+      password_tries = 0;
       monitor.job_id = job_id = job_id_attr->values[0].integer;
       _cupsLangPrintFilter(stderr, "INFO",
                            _("Print file accepted - job ID %d."), job_id);
     }
 
+    fprintf(stderr, "DEBUG: job-id=%d\n", job_id);
     ippDelete(response);
 
     if (job_canceled)
       break;
 
-    if (job_id && num_files > 1)
+    if (job_id && (num_files > 1 || create_job))
     {
-      for (i = 0; i < num_files; i ++)
+      for (i = 0; num_files == 0 || i < num_files; i ++)
       {
        /*
 	* Check for side-channel requests...
@@ -1499,16 +1553,35 @@
 	  ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_NAME,
                        "requesting-user-name", NULL, argv[2]);
 
-        if ((i + 1) == num_files)
+        if ((i + 1) >= num_files)
 	  ippAddBoolean(request, IPP_TAG_OPERATION, "last-document", 1);
 
-        ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_MIMETYPE,
-	             "document-format", NULL, content_type);
+	if (document_format)
+	  ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_MIMETYPE,
+		       "document-format", NULL, document_format);
 
 	fprintf(stderr, "DEBUG: Sending file %d using chunking...\n", i + 1);
 	http_status = cupsSendRequest(http, request, resource, 0);
-	if (http_status == HTTP_CONTINUE && request->state == IPP_DATA &&
-	    (fd = open(files[i], O_RDONLY)) >= 0)
+	if (http_status == HTTP_CONTINUE && request->state == IPP_DATA)
+	{
+	  if (num_files == 0)
+	  {
+	    fd          = 0;
+	    http_status = cupsWriteRequestData(http, buffer, bytes);
+	  }
+	  else
+	  {
+	    if ((fd = open(files[i], O_RDONLY)) < 0)
+	    {
+	      _cupsLangPrintError("ERROR", _("Unable to open print file"));
+	      return (CUPS_BACKEND_FAILED);
+	    }
+	  }
+	}
+	else
+	  fd = -1;
+
+	if (fd >= 0)
 	{
 	  while (!job_canceled &&
 	         (bytes = read(fd, buffer, sizeof(buffer))) > 0)
@@ -1525,7 +1598,8 @@
 	    }
 	  }
 
-	  close(fd);
+          if (fd > 0)
+	    close(fd);
 	}
 
 	ippDelete(cupsGetResponse(http, resource));
@@ -1542,6 +1616,13 @@
 			       _("Unable to add document to print job."));
 	  break;
 	}
+	else
+	{
+	  password_tries = 0;
+
+	  if (num_files == 0 || fd < 0)
+	    break;
+	}
       }
     }
 
@@ -1554,6 +1635,14 @@
              ipp_status == IPP_NOT_POSSIBLE ||
 	     ipp_status == IPP_PRINTER_BUSY)
       continue;
+    else if (ipp_status == IPP_REQUEST_VALUE)
+    {
+     /*
+      * Print file is too large, abort this job...
+      */
+
+      goto cleanup;
+    }
     else
       copies_remaining --;
 
@@ -1621,16 +1710,16 @@
       fprintf(stderr, "DEBUG: Get-Job-Attributes: %s (%s)\n",
 	      ippErrorString(ipp_status), cupsLastErrorString());
 
-      if (ipp_status > IPP_OK_CONFLICT)
+      if (ipp_status <= IPP_OK_CONFLICT)
+	password_tries = 0;
+      else
       {
 	if (ipp_status != IPP_SERVICE_UNAVAILABLE &&
 	    ipp_status != IPP_NOT_POSSIBLE &&
 	    ipp_status != IPP_PRINTER_BUSY)
 	{
 	  ippDelete(response);
-
-          _cupsLangPrintFilter(stderr, "ERROR",
-			       _("Unable to get print job status."));
+          ipp_status = IPP_OK;
           break;
 	}
       }
@@ -1777,6 +1866,11 @@
   else if (ipp_status == IPP_DOCUMENT_FORMAT ||
            ipp_status == IPP_CONFLICT)
     return (CUPS_BACKEND_FAILED);
+  else if (ipp_status == IPP_REQUEST_VALUE)
+  {
+    _cupsLangPrintFilter(stderr, "ERROR", _("Print job too large."));
+    return (CUPS_BACKEND_CANCEL);
+  }
   else if (ipp_status > IPP_OK_CONFLICT && ipp_status != IPP_ERROR_JOB_CANCELED)
     return (CUPS_BACKEND_RETRY_CURRENT);
   else
@@ -1879,6 +1973,9 @@
   fprintf(stderr, "DEBUG: Get-Printer-Attributes: %s (%s)\n",
 	  ippErrorString(cupsLastError()), cupsLastErrorString());
 
+  if (cupsLastError() <= IPP_OK_CONFLICT)
+    password_tries = 0;
+
  /*
   * Return the printer-state value...
   */
@@ -1972,6 +2069,11 @@
   ipp_attribute_t *attr;		/* Attribute in response */
   int		delay,			/* Current delay */
 		prev_delay;		/* Previous delay */
+  ipp_op_t	job_op;			/* Operation to use */
+  int		job_id;			/* Job ID */
+  const char	*job_name;		/* Job name */
+  ipp_jstate_t	job_state;		/* Job state */
+  const char	*job_user;		/* Job originating user name */
 
 
  /*
@@ -1981,6 +2083,8 @@
   http = _httpCreate(monitor->hostname, monitor->port, NULL, monitor->encryption,
                      AF_UNSPEC);
   httpSetTimeout(http, 30.0, timeout_cb, NULL);
+  if (username[0])
+    cupsSetUser(username);
   cupsSetPasswordCB(password_cb);
 
  /*
@@ -2006,47 +2110,99 @@
 						   monitor->user,
 						   monitor->version);
 
-      if (monitor->job_id > 0)
-      {
-       /*
-        * Check the status of the job itself...
-	*/
+     /*
+      * Check the status of the job itself...
+      */
 
-	request = ippNewRequest(IPP_GET_JOB_ATTRIBUTES);
-	request->request.op.version[0] = monitor->version / 10;
-	request->request.op.version[1] = monitor->version % 10;
+      job_op  = monitor->job_id > 0 ? IPP_GET_JOB_ATTRIBUTES : IPP_GET_JOBS;
+      request = ippNewRequest(job_op);
+      request->request.op.version[0] = monitor->version / 10;
+      request->request.op.version[1] = monitor->version % 10;
 
-	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri",
-		     NULL, monitor->uri);
+      ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_URI, "printer-uri",
+		   NULL, monitor->uri);
+      if (job_op == IPP_GET_JOB_ATTRIBUTES)
 	ippAddInteger(request, IPP_TAG_OPERATION, IPP_TAG_INTEGER, "job-id",
-	              monitor->job_id);
+		      monitor->job_id);
 
-	if (monitor->user && monitor->user[0])
-	  ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_NAME,
-		       "requesting-user-name", NULL, monitor->user);
+      if (monitor->user && monitor->user[0])
+	ippAddString(request, IPP_TAG_OPERATION, IPP_TAG_NAME,
+		     "requesting-user-name", NULL, monitor->user);
 
-	ippAddStrings(request, IPP_TAG_OPERATION, IPP_TAG_KEYWORD,
-		      "requested-attributes",
-		      (int)(sizeof(jattrs) / sizeof(jattrs[0])), NULL, jattrs);
+      ippAddStrings(request, IPP_TAG_OPERATION, IPP_TAG_KEYWORD,
+		    "requested-attributes",
+		    (int)(sizeof(jattrs) / sizeof(jattrs[0])), NULL, jattrs);
 
-       /*
-	* Do the request...
-	*/
+     /*
+      * Do the request...
+      */
 
-	response = cupsDoRequest(http, request, monitor->resource);
+      response = cupsDoRequest(http, request, monitor->resource);
 
-	fprintf(stderr, "DEBUG: Get-Job-Attributes: %s (%s)\n",
-		ippErrorString(cupsLastError()), cupsLastErrorString());
+      fprintf(stderr, "DEBUG: %s: %s (%s)\n", ippOpString(job_op),
+	      ippErrorString(cupsLastError()), cupsLastErrorString());
 
+      if (cupsLastError() <= IPP_OK_CONFLICT)
+        password_tries = 0;
+
+      if (job_op == IPP_GET_JOB_ATTRIBUTES)
+      {
 	if ((attr = ippFindAttribute(response, "job-state",
 				     IPP_TAG_ENUM)) != NULL)
 	  monitor->job_state = (ipp_jstate_t)attr->values[0].integer;
 	else
 	  monitor->job_state = IPP_JOB_COMPLETED;
+      }
+      else if (response)
+      {
+        for (attr = response->attrs; attr; attr = attr->next)
+        {
+          job_id    = 0;
+          job_name  = NULL;
+          job_state = IPP_JOB_PENDING;
+          job_user  = NULL;
+
+          while (attr && attr->group_tag != IPP_TAG_JOB)
+            attr = attr->next;
+
+          if (!attr)
+            break;
+
+          while (attr && attr->group_tag == IPP_TAG_JOB)
+          {
+            if (!strcmp(attr->name, "job-id") &&
+                attr->value_tag == IPP_TAG_INTEGER)
+              job_id = attr->values[0].integer;
+            else if (!strcmp(attr->name, "job-name") &&
+		     (attr->value_tag == IPP_TAG_NAME ||
+		      attr->value_tag == IPP_TAG_NAMELANG))
+              job_name = attr->values[0].string.text;
+            else if (!strcmp(attr->name, "job-state") &&
+		     attr->value_tag == IPP_TAG_ENUM)
+              job_state = attr->values[0].integer;
+            else if (!strcmp(attr->name, "job-originating-user-name") &&
+		     (attr->value_tag == IPP_TAG_NAME ||
+		      attr->value_tag == IPP_TAG_NAMELANG))
+              job_user = attr->values[0].string.text;
 
-	ippDelete(response);
+            attr = attr->next;
+          }
+
+          if (job_id > 0 && job_name && !strcmp(job_name, monitor->job_name) &&
+              job_user && monitor->user && !strcmp(job_user, monitor->user))
+          {
+            monitor->job_id    = job_id;
+            monitor->job_state = job_state;
+            break;
+          }
+
+          if (!attr)
+            break;
+        }
       }
 
+      ippDelete(response);
+
      /*
       * Disconnect from the printer - we'll reconnect on the next poll...
       */
@@ -2064,6 +2220,15 @@
   }
 
  /*
+  * Cancel the job if necessary...
+  */
+
+  if (job_canceled && monitor->job_id > 0)
+    if (!httpReconnect(http))
+      cancel_job(http, monitor->uri, monitor->job_id, monitor->resource,
+                 monitor->user, monitor->version);
+
+ /*
   * Cleanup and return...
   */
 
@@ -2088,7 +2253,7 @@
     cups_option_t   *options,		/* I - Options to send */
     const char      *compression,	/* I - compression value or NULL */
     int             copies,		/* I - copies value or 0 */
-    const char      *format,		/* I - documet-format value or NULL */
+    const char      *format,		/* I - document-format value or NULL */
     _ppd_cache_t    *pc,		/* I - PPD cache and mapping data */
     ipp_attribute_t *media_col_sup,	/* I - media-col-supported values */
     ipp_attribute_t *doc_handling_sup)  /* I - multiple-document-handling-supported values */
@@ -2163,6 +2328,9 @@
   {
     if (pc)
     {
+      int	num_finishings = 0,	/* Number of finishing values */
+		finishings[10];		/* Finishing enum values */
+
      /*
       * Send standard IPP attributes...
       */
@@ -2284,6 +2452,7 @@
       }
 
       if (doc_handling_sup &&
+          (!format || _cups_strncasecmp(format, "image/", 6)) &&
  	  (keyword = cupsGetOption("collate", num_options, options)) != NULL)
       {
         if (!_cups_strcasecmp(keyword, "true"))
@@ -2299,6 +2468,43 @@
 	    break;
           }
       }
+
+     /*
+      * Map finishing options...
+      */
+
+      num_finishings = _ppdCacheGetFinishingValues(pc, num_options, options,
+                                                   (int)(sizeof(finishings) /
+                                                         sizeof(finishings[0])),
+                                                   finishings);
+      if (num_finishings > 0)
+	ippAddIntegers(request, IPP_TAG_JOB, IPP_TAG_ENUM, "finishings",
+		       num_finishings, finishings);
+
+     /*
+      * Map FaxOut options...
+      */
+
+      if ((keyword = cupsGetOption("phone", num_options, options)) != NULL)
+      {
+	ipp_t	*destination;		/* destination collection */
+	char	tel_uri[1024];		/* tel: URI */
+
+        destination = ippNew();
+
+        httpAssembleURI(HTTP_URI_CODING_ALL, tel_uri, sizeof(tel_uri), "tel",
+                        NULL, NULL, 0, keyword);
+        ippAddString(destination, IPP_TAG_JOB, IPP_TAG_URI, "destination-uri",
+                     NULL, tel_uri);
+
+	if ((keyword = cupsGetOption("faxPrefix", num_options,
+	                             options)) != NULL && *keyword)
+	  ippAddString(destination, IPP_TAG_JOB, IPP_TAG_TEXT,
+	               "pre-dial-string", NULL, keyword);
+
+        ippAddCollection(request, IPP_TAG_JOB, "destination-uris", destination);
+        ippDelete(destination);
+      }
     }
     else
     {
@@ -2324,6 +2530,9 @@
 static const char *			/* O - Password  */
 password_cb(const char *prompt)		/* I - Prompt (not used) */
 {
+  fprintf(stderr, "DEBUG: password_cb(prompt=\"%s\"), password=%p, "
+          "password_tries=%d\n", prompt, password, password_tries);
+
   (void)prompt;
 
  /*
@@ -2386,17 +2595,23 @@
       case IPP_TAG_TEXT :
       case IPP_TAG_NAME :
       case IPP_TAG_KEYWORD :
+          *valptr++ = '\'';
           *valptr++ = '\"';
 	  for (attrptr = attr->values[i].string.text;
 	       *attrptr && valptr < (value + sizeof(value) - 10);
 	       attrptr ++)
 	  {
-	    if (*attrptr == '\\' || *attrptr == '\"')
+	    if (*attrptr == '\\' || *attrptr == '\"' || *attrptr == '\'')
+	    {
+	      *valptr++ = '\\';
 	      *valptr++ = '\\';
+	      *valptr++ = '\\';
+	    }
 
 	    *valptr++ = *attrptr;
 	  }
           *valptr++ = '\"';
+          *valptr++ = '\'';
           break;
 
       default :
--- a/cups/auth.c
+++ b/cups/auth.c
@@ -124,7 +124,8 @@
     const char *method,			/* I - Request method ("GET", "POST", "PUT") */
     const char *resource)		/* I - Resource path */
 {
-  const char	*password;		/* Password string */
+  const char	*password,		/* Password string */
+		*www_auth;		/* WWW-Authenticate header */
   char		prompt[1024],		/* Prompt for user */
 		realm[HTTP_MAX_VALUE],	/* realm="xyz" string */
 		nonce[HTTP_MAX_VALUE];	/* nonce="xyz" string */
@@ -179,9 +180,11 @@
   * Nope, see if we should retry the current username:password...
   */
 
+  www_auth = http->fields[HTTP_FIELD_WWW_AUTHENTICATE];
+
   if ((http->digest_tries > 1 || !http->userpass[0]) &&
-      (!strncmp(http->fields[HTTP_FIELD_WWW_AUTHENTICATE], "Basic", 5) ||
-       !strncmp(http->fields[HTTP_FIELD_WWW_AUTHENTICATE], "Digest", 6)))
+      (!_cups_strncasecmp(www_auth, "Basic", 5) ||
+       !_cups_strncasecmp(www_auth, "Digest", 6)))
   {
    /*
     * Nope - get a new password from the user...
@@ -197,8 +200,7 @@
 	     cupsUser(),
 	     http->hostname[0] == '/' ? "localhost" : http->hostname);
 
-    http->digest_tries  = _cups_strncasecmp(http->fields[HTTP_FIELD_WWW_AUTHENTICATE],
-                                      "Digest", 5) != 0;
+    http->digest_tries  = _cups_strncasecmp(www_auth, "Digest", 6) != 0;
     http->userpass[0]   = '\0';
 
     if ((password = cupsGetPassword2(prompt, http, method, resource)) == NULL)
@@ -227,7 +229,7 @@
   */
 
 #ifdef HAVE_GSSAPI
-  if (!strncmp(http->fields[HTTP_FIELD_WWW_AUTHENTICATE], "Negotiate", 9))
+  if (!_cups_strncasecmp(www_auth, "Negotiate", 9))
   {
    /*
     * Kerberos authentication...
@@ -241,7 +243,7 @@
   }
   else
 #endif /* HAVE_GSSAPI */
-  if (!strncmp(http->fields[HTTP_FIELD_WWW_AUTHENTICATE], "Basic", 5))
+  if (!_cups_strncasecmp(www_auth, "Basic", 5))
   {
    /*
     * Basic authentication...
@@ -254,7 +256,7 @@
                    (int)strlen(http->userpass));
     httpSetAuthString(http, "Basic", encode);
   }
-  else if (!strncmp(http->fields[HTTP_FIELD_WWW_AUTHENTICATE], "Digest", 6))
+  else if (!_cups_strncasecmp(www_auth, "Digest", 6))
   {
    /*
     * Digest authentication...
@@ -277,7 +279,7 @@
   else
   {
     DEBUG_printf(("1cupsDoAuthentication: Unknown auth type: \"%s\"",
-                  http->fields[HTTP_FIELD_WWW_AUTHENTICATE]));
+                  www_auth));
     http->status = HTTP_AUTHORIZATION_CANCELED;
     return (-1);
   }
--- a/cups/http-support.c
+++ b/cups/http-support.c
@@ -757,10 +757,13 @@
 
 
   tdate = gmtime(&t);
-  snprintf(s, slen, "%s, %02d %s %d %02d:%02d:%02d GMT",
-           http_days[tdate->tm_wday], tdate->tm_mday,
-	   http_months[tdate->tm_mon], tdate->tm_year + 1900,
-	   tdate->tm_hour, tdate->tm_min, tdate->tm_sec);
+  if (tdate)
+    snprintf(s, slen, "%s, %02d %s %d %02d:%02d:%02d GMT",
+	     http_days[tdate->tm_wday], tdate->tm_mday,
+	     http_months[tdate->tm_mon], tdate->tm_year + 1900,
+	     tdate->tm_hour, tdate->tm_min, tdate->tm_sec);
+  else
+    s[0] = '\0';
 
   return (s);
 }
--- a/cups/http.c
+++ b/cups/http.c
@@ -3833,7 +3833,8 @@
   _cups_globals_t	*cg = _cupsGlobals();
 					/* Pointer to library globals */
   int			any_root;	/* Allow any root */
-  char			*hostname;	/* Hostname */
+  char			hostname[256],	/* Hostname */
+			*hostptr;	/* Pointer into hostname */
 
 #  ifdef HAVE_LIBSSL
   SSL_CTX		*context;	/* Context for encryption */
@@ -3869,11 +3870,24 @@
   */
 
   if (httpAddrLocalhost(http->hostaddr))
+  {
     any_root = 1;
+    strlcpy(hostname, "localhost", sizeof(hostname));
+  }
   else
+  {
+   /*
+    * Otherwise use the system-wide setting and make sure the hostname we have
+    * does not end in a trailing dot.
+    */
+
     any_root = cg->any_root;
 
-  hostname = httpAddrLocalhost(http->hostaddr) ? "localhost" : http->hostname;
+    strlcpy(hostname, http->hostname, sizeof(hostname));
+    if ((hostptr = hostname + strlen(hostname) - 1) >= hostname &&
+        *hostptr == '.')
+      *hostptr = '\0';
+  }
 
 #  ifdef HAVE_LIBSSL
   (void)any_root;
@@ -4009,15 +4023,6 @@
                   cg->expired_root, (int)error));
   }
 
-#    ifdef HAVE_SSLSETPROTOCOLVERSIONMAX
-  if (!error)
-  {
-    error = SSLSetProtocolVersionMax(http->tls, kTLSProtocol1);
-    DEBUG_printf(("4http_setup_ssl: SSLSetProtocolVersionMax(kTLSProtocol1), "
-                  "error=%d", (int)error));
-  }
-#    endif /* HAVE_SSLSETPROTOCOLVERSIONMAX */
-
  /*
   * In general, don't verify certificates since things like the common name
   * often do not match...
--- a/cups/ppd-cache.c
+++ b/cups/ppd-cache.c
@@ -3,7 +3,7 @@
  *
  *   PPD cache implementation for CUPS.
  *
- *   Copyright 2010-2011 by Apple Inc.
+ *   Copyright 2010-2012 by Apple Inc.
  *
  *   These coded instructions, statements, and computer programs are the
  *   property of Apple Inc. and are protected by Federal copyright
@@ -65,6 +65,9 @@
  * Local functions...
  */
 
+static int	pwg_compare_finishings(_pwg_finishings_t *a,
+		                       _pwg_finishings_t *b);
+static void	pwg_free_finishings(_pwg_finishings_t *f);
 static void	pwg_ppdize_name(const char *ipp, char *name, size_t namesize);
 static void	pwg_unppdize_name(const char *ppd, char *name, size_t namesize);
 
@@ -86,6 +89,7 @@
   _ppd_cache_t	*pc;			/* PWG mapping data */
   _pwg_size_t	*size;			/* Current size */
   _pwg_map_t	*map;			/* Current map */
+  _pwg_finishings_t *finishings;	/* Current finishings option */
   int		linenum,		/* Current line number */
 		num_bins,		/* Number of bins in file */
 		num_sizes,		/* Number of sizes in file */
@@ -532,6 +536,23 @@
       pc->sides_2sided_long = _cupsStrAlloc(value);
     else if (!_cups_strcasecmp(line, "Sides2SidedShort"))
       pc->sides_2sided_short = _cupsStrAlloc(value);
+    else if (!_cups_strcasecmp(line, "Finishings"))
+    {
+      if (!pc->finishings)
+	pc->finishings =
+	    cupsArrayNew3((cups_array_func_t)pwg_compare_finishings,
+			  NULL, NULL, 0, NULL,
+			  (cups_afree_func_t)pwg_free_finishings);
+
+      if ((finishings = calloc(1, sizeof(_pwg_finishings_t))) == NULL)
+        goto create_error;
+
+      finishings->value       = strtol(value, &valueptr, 10);
+      finishings->num_options = cupsParseOptions(valueptr, 0,
+                                                 &(finishings->options));
+
+      cupsArrayAdd(pc->finishings, finishings);
+    }
     else
     {
       DEBUG_printf(("_ppdCacheCreateWithFile: Unknown %s on line %d.", line,
@@ -633,6 +654,7 @@
 			new_known_pwg;	/* New PWG name is well-known */
   _pwg_size_t           *new_size;	/* New size to add, if any */
   const char		*filter;	/* Current filter */
+  _pwg_finishings_t	*finishings;	/* Current finishings value */
 
 
   DEBUG_printf(("_ppdCacheCreateWithPPD(ppd=%p)", ppd));
@@ -731,8 +753,10 @@
     * want to keep it if it has a larger imageable area length.
     */
 
-    new_width      = _PWG_FROMPTS(ppd_size->width);
-    new_length     = _PWG_FROMPTS(ppd_size->length);
+    pwg_media      = _pwgMediaForSize(_PWG_FROMPTS(ppd_size->width),
+                                      _PWG_FROMPTS(ppd_size->length));
+    new_width      = pwg_media->width;
+    new_length     = pwg_media->length;
     new_left       = _PWG_FROMPTS(ppd_size->left);
     new_bottom     = _PWG_FROMPTS(ppd_size->bottom);
     new_right      = _PWG_FROMPTS(ppd_size->width - ppd_size->right);
@@ -862,7 +886,7 @@
       else if (!_cups_strncasecmp(choice->choice, "Multipurpose", 12) ||
                !_cups_strcasecmp(choice->choice, "MP") ||
                !_cups_strcasecmp(choice->choice, "MPTray"))
-        pwg_name = "alternate";
+        pwg_name = "by-pass-tray";
       else if (!_cups_strcasecmp(choice->choice, "LargeCapacity"))
         pwg_name = "large-capacity";
       else if (!_cups_strncasecmp(choice->choice, "Lower", 5))
@@ -1299,6 +1323,32 @@
     pc->product = _cupsStrAlloc(ppd->product);
 
  /*
+  * Copy finishings mapping data...
+  */
+
+  if ((ppd_attr = ppdFindAttr(ppd, "cupsIPPFinishings", NULL)) != NULL)
+  {
+    pc->finishings = cupsArrayNew3((cups_array_func_t)pwg_compare_finishings,
+                                   NULL, NULL, 0, NULL,
+                                   (cups_afree_func_t)pwg_free_finishings);
+
+    do
+    {
+      if ((finishings = calloc(1, sizeof(_pwg_finishings_t))) == NULL)
+        goto create_error;
+
+      finishings->value       = atoi(ppd_attr->spec);
+      finishings->num_options = _ppdParseOptions(ppd_attr->value, 0,
+                                                 &(finishings->options),
+                                                 _PPD_PARSE_OPTIONS);
+
+      cupsArrayAdd(pc->finishings, finishings);
+    }
+    while ((ppd_attr = ppdFindNextAttr(ppd, "cupsIPPFinishings",
+                                       NULL)) != NULL);
+  }
+
+ /*
   * Return the cache data...
   */
 
@@ -1396,6 +1446,7 @@
   _cupsStrFree(pc->product);
   cupsArrayDelete(pc->filters);
   cupsArrayDelete(pc->prefilters);
+  cupsArrayDelete(pc->finishings);
 
   free(pc);
 }
@@ -1435,6 +1486,125 @@
 
 
 /*
+ * '_ppdCacheGetFinishingOptions()' - Get PPD finishing options for the given
+ *                                    IPP finishings value(s).
+ */
+
+int					/* O  - New number of options */
+_ppdCacheGetFinishingOptions(
+    _ppd_cache_t  *pc,			/* I  - PPD cache and mapping data */
+    ipp_t         *job,			/* I  - Job attributes or NULL */
+    ipp_finish_t  value,		/* I  - IPP finishings value of IPP_FINISHINGS_NONE */
+    int           num_options,		/* I  - Number of options */
+    cups_option_t **options)		/* IO - Options */
+{
+  int			i;		/* Looping var */
+  _pwg_finishings_t	*f,		/* PWG finishings options */
+			key;		/* Search key */
+  ipp_attribute_t	*attr;		/* Finishings attribute */
+  cups_option_t		*option;	/* Current finishings option */
+
+
+ /*
+  * Range check input...
+  */
+
+  if (!pc || cupsArrayCount(pc->finishings) == 0 || !options ||
+      (!job && value == IPP_FINISHINGS_NONE))
+    return (num_options);
+
+ /*
+  * Apply finishing options...
+  */
+
+  if (job && (attr = ippFindAttribute(job, "finishings", IPP_TAG_ENUM)) != NULL)
+  {
+    for (i = 0; i < attr->num_values; i ++)
+    {
+      key.value = attr->values[i].integer;
+
+      if ((f = cupsArrayFind(pc->finishings, &key)) != NULL)
+      {
+        int	j;			/* Another looping var */
+
+        for (j = f->num_options, option = f->options; j > 0; j --, option ++)
+          num_options = cupsAddOption(option->name, option->value,
+                                      num_options, options);
+      }
+    }
+  }
+  else if (value != IPP_FINISHINGS_NONE)
+  {
+    key.value = value;
+
+    if ((f = cupsArrayFind(pc->finishings, &key)) != NULL)
+    {
+      int	j;			/* Another looping var */
+
+      for (j = f->num_options, option = f->options; j > 0; j --, option ++)
+	num_options = cupsAddOption(option->name, option->value,
+				    num_options, options);
+    }
+  }
+
+  return (num_options);
+}
+
+
+/*
+ * '_ppdCacheGetFinishingValues()' - Get IPP finishings value(s) from the given
+ *                                   PPD options.
+ */
+
+int					/* O - Number of finishings values */
+_ppdCacheGetFinishingValues(
+    _ppd_cache_t  *pc,			/* I - PPD cache and mapping data */
+    int           num_options,		/* I - Number of options */
+    cups_option_t *options,		/* I - Options */
+    int           max_values,		/* I - Maximum number of finishings values */
+    int           *values)		/* O - Finishings values */
+{
+  int			i,		/* Looping var */
+			num_values = 0;	/* Number of values */
+  _pwg_finishings_t	*f;		/* Current finishings option */
+  cups_option_t		*option;	/* Current option */
+  const char		*val;		/* Value for option */
+
+
+ /*
+  * Range check input...
+  */
+
+  if (!pc || !pc->finishings || num_options < 1 || max_values < 1 || !values)
+    return (0);
+
+ /*
+  * Go through the finishings options and see what is set...
+  */
+
+  for (f = (_pwg_finishings_t *)cupsArrayFirst(pc->finishings);
+       f;
+       f = (_pwg_finishings_t *)cupsArrayNext(pc->finishings))
+  {
+    for (i = f->num_options, option = f->options; i > 0; i --, option ++)
+      if ((val = cupsGetOption(option->name, num_options, options)) == NULL ||
+          _cups_strcasecmp(option->value, val))
+        break;
+
+    if (i == 0)
+    {
+      values[num_values ++] = f->value;
+
+      if (num_values >= max_values)
+        break;
+    }
+  }
+
+  return (num_values);
+}
+
+
+/*
  * '_ppdCacheGetInputSlot()' - Get the PPD InputSlot associated with the job
  *                        attributes or a keyword string.
  */
@@ -1835,7 +2005,8 @@
     _ppd_cache_t *pc,			/* I - PPD cache and mapping data */
     const char   *page_size)		/* I - PPD PageSize */
 {
-  int		i;
+  int		i;			/* Looping var */
+  _pwg_media_t	*media;			/* Media */
   _pwg_size_t	*size;			/* Current size */
 
 
@@ -1914,9 +2085,26 @@
   */
 
   for (i = pc->num_sizes, size = pc->sizes; i > 0; i --, size ++)
-    if (!_cups_strcasecmp(page_size, size->map.ppd))
+    if (!_cups_strcasecmp(page_size, size->map.ppd) ||
+        !_cups_strcasecmp(page_size, size->map.pwg))
       return (size);
 
+ /*
+  * Look up standard sizes...
+  */
+
+  if ((media = _pwgMediaForPPD(page_size)) == NULL)
+    if ((media = _pwgMediaForLegacy(page_size)) == NULL)
+      media = _pwgMediaForPWG(page_size);
+
+  if (media)
+  {
+    pc->custom_size.width  = media->width;
+    pc->custom_size.length = media->length;
+
+    return (&(pc->custom_size));
+  }
+
   return (NULL);
 }
 
@@ -1989,13 +2177,14 @@
     const char   *filename,		/* I - File to write */
     ipp_t        *attrs)		/* I - Attributes to write, if any */
 {
-  int		i, j, k;		/* Looping vars */
-  cups_file_t	*fp;			/* Output file */
-  _pwg_size_t	*size;			/* Current size */
-  _pwg_map_t	*map;			/* Current map */
-  cups_option_t	*option;		/* Current option */
-  const char	*value;			/* Filter/pre-filter value */
-  char		newfile[1024];		/* New filename */
+  int			i, j, k;	/* Looping vars */
+  cups_file_t		*fp;		/* Output file */
+  _pwg_size_t		*size;		/* Current size */
+  _pwg_map_t		*map;		/* Current map */
+  _pwg_finishings_t	*f;		/* Current finishing option */
+  cups_option_t		*option;	/* Current option */
+  const char		*value;		/* Filter/pre-filter value */
+  char			newfile[1024];	/* New filename */
 
 
  /*
@@ -2129,6 +2318,20 @@
   cupsFilePrintf(fp, "SingleFile %s\n", pc->single_file ? "true" : "false");
 
  /*
+  * Finishing options...
+  */
+
+  for (f = (_pwg_finishings_t *)cupsArrayFirst(pc->finishings);
+       f;
+       f = (_pwg_finishings_t *)cupsArrayNext(pc->finishings))
+  {
+    cupsFilePrintf(fp, "Finishings %d", f->value);
+    for (i = f->num_options, option = f->options; i > 0; i --, option ++)
+      cupsFilePrintf(fp, " %s=%s", option->name, option->value);
+    cupsFilePutChar(fp, '\n');
+  }
+
+ /*
   * IPP attributes, if any...
   */
 
@@ -2310,6 +2513,32 @@
 }
 
 
+/*
+ * 'pwg_compare_finishings()' - Compare two finishings values.
+ */
+
+static int				/* O- Result of comparison */
+pwg_compare_finishings(
+    _pwg_finishings_t *a,		/* I - First finishings value */
+    _pwg_finishings_t *b)		/* I - Second finishings value */
+{
+  return (b->value - a->value);
+}
+
+
+/*
+ * 'pwg_free_finishings()' - Free a finishings value.
+ */
+
+static void
+pwg_free_finishings(
+    _pwg_finishings_t *f)		/* I - Finishings value */
+{
+  cupsFreeOptions(f->num_options, f->options);
+  free(f);
+}
+
+
 /*
  * 'pwg_ppdize_name()' - Convert an IPP keyword to a PPD keyword.
  */
--- a/cups/ppd-private.h
+++ b/cups/ppd-private.h
@@ -49,7 +49,7 @@
  * Constants...
  */
 
-#  define _PPD_CACHE_VERSION	1	/* Version number in cache file */
+#  define _PPD_CACHE_VERSION	2	/* Version number in cache file */
 
 
 /*
@@ -86,7 +86,7 @@
   _PWG_PRINT_COLOR_MODE_MAX
 } _pwg_print_color_mode_t;
 
-typedef enum _pwg_print_quality_e	/**** PWG print-quality indices ****/
+typedef enum _pwg_print_quality_e	/**** PWG print-quality values ****/
 {
   _PWG_PRINT_QUALITY_DRAFT = 0,		/* print-quality=3 */
   _PWG_PRINT_QUALITY_NORMAL,		/* print-quality=4 */
@@ -94,6 +94,13 @@
   _PWG_PRINT_QUALITY_MAX
 } _pwg_print_quality_t;
 
+typedef struct _pwg_finishings_s	/**** PWG finishings mapping data ****/
+{
+  ipp_finish_t	value;			/* finishings value */
+  int		num_options;		/* Number of options to apply */
+  cups_option_t	*options;		/* Options to apply */
+} _pwg_finishings_t;
+
 struct _ppd_cache_s			/**** PPD cache and PWG conversion data ****/
 {
   int		num_bins;		/* Number of output bins */
@@ -125,6 +132,7 @@
   cups_array_t	*filters,		/* cupsFilter/cupsFilter2 values */
 		*prefilters;		/* cupsPreFilter values */
   int		single_file;		/* cupsSingleFile value */
+  cups_array_t	*finishings;		/* cupsIPPFinishings values */
 };
 
 
@@ -138,6 +146,12 @@
 extern void		_ppdCacheDestroy(_ppd_cache_t *pc);
 extern const char	*_ppdCacheGetBin(_ppd_cache_t *pc,
 			                 const char *output_bin);
+extern int		_ppdCacheGetFinishingOptions(_ppd_cache_t *pc, ipp_t *job,
+			                             ipp_finish_t value, int num_options,
+			                             cups_option_t **options);
+extern int		_ppdCacheGetFinishingValues(_ppd_cache_t *pc, int num_options,
+			                            cups_option_t *options,
+			                            int max_values, int *values);
 extern const char	*_ppdCacheGetInputSlot(_ppd_cache_t *pc, ipp_t *job,
 			                       const char *keyword);
 extern const char	*_ppdCacheGetMediaType(_ppd_cache_t *pc, ipp_t *job,
--- a/cups/pwg-media.c
+++ b/cups/pwg-media.c
@@ -117,7 +117,7 @@
 
   /* Chinese Standard Sheet Media Inch Sizes */
   _PWG_MEDIA_IN("roc_16k_7.75x10.75in", NULL, "roc16k", 7.75, 10.75),
-  _PWG_MEDIA_IN("roc_8k_10.75x15.5in", NULL, NULL, 10.75, 15.5),
+  _PWG_MEDIA_IN("roc_8k_10.75x15.5in", NULL, "roc8k", 10.75, 15.5),
 
   /* ISO Standard Sheet Media Sizes */
   _PWG_MEDIA_MM("iso_a10_26x37mm", "iso-a10", "A10", 26, 37),
@@ -128,7 +128,7 @@
   _PWG_MEDIA_MM("iso_a5_148x210mm", "iso-a5", "A5", 148, 210),
   _PWG_MEDIA_MM("iso_a5-extra_174x235mm", NULL, "A5Extra", 174, 235),
   _PWG_MEDIA_MM("iso_a4_210x297mm", "iso-a4", "A4", 210, 297),
-  _PWG_MEDIA_MM("iso_a4-tab_225x297mm", NULL, NULL, 225, 297),
+  _PWG_MEDIA_MM("iso_a4-tab_225x297mm", NULL, "A4Tab", 225, 297),
   _PWG_MEDIA_MM("iso_a4-extra_235.5x322.3mm", NULL, "A4Extra", 235.5, 322.3),
   _PWG_MEDIA_MM("iso_a3_297x420mm", "iso-a3", "A3", 297, 420),
   _PWG_MEDIA_MM("iso_a4x3_297x630mm", "iso-a4x3", NULL, 297, 630),
@@ -233,9 +233,9 @@
   _PWG_MEDIA_MM("om_small-photo_100x150mm", NULL, NULL, 100, 150),
   _PWG_MEDIA_MM("om_italian_110x230mm", NULL, "EnvItalian", 110, 230),
   _PWG_MEDIA_MM("om_postfix_114x229mm", NULL, NULL, 114, 229),
-  _PWG_MEDIA_MM("om_large-photo_200x300", NULL, NULL, 200, 300),
+  _PWG_MEDIA_MM("om_large-photo_200x300", NULL, "om_large-photo", 200, 300),
   _PWG_MEDIA_MM("om_folio_210x330mm", "folio", "Folio", 210, 330),
-  _PWG_MEDIA_MM("om_folio-sp_215x315mm", NULL, NULL, 215, 315),
+  _PWG_MEDIA_MM("om_folio-sp_215x315mm", NULL, "FolioSP", 215, 315),
   _PWG_MEDIA_MM("om_invite_220x220mm", NULL, "EnvInvite", 220, 220)
 };
 
--- a/cups/pwg-private.h
+++ b/cups/pwg-private.h
@@ -39,7 +39,7 @@
  */
 
 /* Convert from points to 2540ths */
-#  define _PWG_FROMPTS(n)	(int)((n) * 2540 / 72)
+#  define _PWG_FROMPTS(n)	(int)(((n) * 2540 + 36) / 72)
 /* Convert from 2540ths to points */
 #  define _PWG_TOPTS(n)		((n) * 72.0 / 2540.0)
 
