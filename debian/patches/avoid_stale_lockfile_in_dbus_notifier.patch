Description: Avoid stale lockfile in dbus notifier
Bug-Redhat: https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=1026949
Author: Tim Waugh <twaugh@redhat.com>
Last-Updated: 2014-01-02

--- a/notifier/dbus.c
+++ b/notifier/dbus.c
@@ -4,7 +4,7 @@
  *   D-Bus notifier for CUPS.
  *
  *   Copyright 2008-2012 by Apple Inc.
- *   Copyright (C) 2011 Red Hat, Inc.
+ *   Copyright (C) 2011, 2013 Red Hat, Inc.
  *   Copyright (C) 2007 Tim Waugh <twaugh@redhat.com>
  *   Copyright 1997-2005 by Easy Software Products.
  *
@@ -157,9 +157,16 @@
 
 
 /*
+ * Global variables...
+ */
+
+static char		lock_filename[1024];	/* Lock filename */
+
+/*
  * Local functions...
  */
 
+static void		release_lock(void);
 static int		acquire_lock(int *fd, char *lockfile, size_t locksize);
 static const char	*validate_utf8(const char *str);
 
@@ -253,8 +260,6 @@
   DBusMessage		*message;	/* Message to send */
   DBusMessageIter	iter;		/* Iterator for message data */
   int			lock_fd = -1;	/* Lock file descriptor */
-  char			lock_filename[1024];
-					/* Lock filename */
 
 
  /*
@@ -656,7 +661,7 @@
   if (lock_fd >= 0)
   {
     close(lock_fd);
-    unlink(lock_filename);
+    release_lock();
   }
 
   return (0);
@@ -664,6 +669,27 @@
 
 
 /*
+ * 'release_lock()' - Release the singleton lock.
+ */
+
+static void
+release_lock(void)
+{
+  unlink(lock_filename);
+}
+
+
+/*
+ * 'handle_sigterm()' - Handle SIGTERM signal.
+ */
+static void
+handle_sigterm(int signum)
+{
+  release_lock();
+  _exit (0);
+}
+
+/*
  * 'acquire_lock()' - Acquire a lock so we only have a single notifier running.
  */
 
@@ -672,7 +698,8 @@
              char   *lockfile,		/* I - Lock filename buffer */
 	     size_t locksize)		/* I - Size of filename buffer */
 {
-  const char	*tmpdir;		/* Temporary directory */
+  const char		*tmpdir;	/* Temporary directory */
+  struct sigaction	action;		/* POSIX sigaction data */
 
 
  /*
@@ -690,8 +717,16 @@
 
   if ((*fd = open(lockfile, O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR)) < 0)
     return (-1);
-  else
-    return (0);
+
+ /*
+  * Set a SIGTERM handler to make sure we release the lock if the
+  * scheduler decides to stop us.
+  */
+  memset(&action, 0, sizeof(action));
+  action.sa_handler = handle_sigterm;
+  sigaction(SIGTERM, &action, NULL);
+
+  return (0);
 }
 #else /* !HAVE_DBUS */
 int
