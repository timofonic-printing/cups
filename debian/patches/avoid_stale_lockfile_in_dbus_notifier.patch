Description: Avoid stale lockfile in dbus notifier
Bug-Redhat: https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=1026949
Bug-Upstream: https://www.cups.org/str.php?L4314
Author: Tim Waugh <twaugh@redhat.com>
Author: Michael Sweet <msweet@apple.com>
Last-Updated: 2014-01-09

--- a/notifier/dbus.c
+++ b/notifier/dbus.c
@@ -1,23 +1,18 @@
 /*
  * "$Id: dbus.c 3933 2012-10-01 03:01:10Z msweet $"
  *
- *   D-Bus notifier for CUPS.
+ * D-Bus notifier for CUPS.
  *
- *   Copyright 2008-2012 by Apple Inc.
- *   Copyright (C) 2011 Red Hat, Inc.
- *   Copyright (C) 2007 Tim Waugh <twaugh@redhat.com>
- *   Copyright 1997-2005 by Easy Software Products.
- *
- *   These coded instructions, statements, and computer programs are the
- *   property of Apple Inc. and are protected by Federal copyright
- *   law.  Distribution and use rights are outlined in the file "LICENSE.txt"
- *   which should have been included with this file.  If this file is
- *   file is missing or damaged, see the license at "http://www.cups.org/".
- *
- * Contents:
- *
- *   main()         - Read events and send DBUS notifications.
- *   acquire_lock() - Acquire a lock so we only have a single notifier running.
+ * Copyright 2008-2014 by Apple Inc.
+ * Copyright (C) 2011, 2013 Red Hat, Inc.
+ * Copyright (C) 2007 Tim Waugh <twaugh@redhat.com>
+ * Copyright 1997-2005 by Easy Software Products.
+ *
+ * These coded instructions, statements, and computer programs are the
+ * property of Apple Inc. and are protected by Federal copyright
+ * law.  Distribution and use rights are outlined in the file "LICENSE.txt"
+ * which should have been included with this file.  If this file is
+ * file is missing or damaged, see the license at "http://www.cups.org/".
  */
 
 /*
@@ -157,6 +152,13 @@
 
 
 /*
+ * Global variables...
+ */
+
+static char		lock_filename[1024];	/* Lock filename */
+
+
+/*
  * Local functions...
  */
 
@@ -253,8 +255,6 @@
   DBusMessage		*message;	/* Message to send */
   DBusMessageIter	iter;		/* Iterator for message data */
   int			lock_fd = -1;	/* Lock file descriptor */
-  char			lock_filename[1024];
-					/* Lock filename */
 
 
  /*
@@ -656,7 +656,7 @@
   if (lock_fd >= 0)
   {
     close(lock_fd);
-    unlink(lock_filename);
+    release_lock();
   }
 
   return (0);
@@ -664,6 +664,27 @@
 
 
 /*
+ * 'release_lock()' - Release the singleton lock.
+ */
+
+static void
+release_lock(void)
+{
+  unlink(lock_filename);
+}
+
+
+/*
+ * 'handle_sigterm()' - Handle SIGTERM signal.
+ */
+static void
+handle_sigterm(int signum)
+{
+  release_lock();
+  _exit(0);
+}
+
+/*
  * 'acquire_lock()' - Acquire a lock so we only have a single notifier running.
  */
 
@@ -672,7 +693,8 @@
              char   *lockfile,		/* I - Lock filename buffer */
 	     size_t locksize)		/* I - Size of filename buffer */
 {
-  const char	*tmpdir;		/* Temporary directory */
+  const char		*tmpdir;	/* Temporary directory */
+  struct sigaction	action;		/* POSIX sigaction data */
 
 
  /*
@@ -690,8 +712,16 @@
 
   if ((*fd = open(lockfile, O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR)) < 0)
     return (-1);
-  else
-    return (0);
+
+ /*
+  * Set a SIGTERM handler to make sure we release the lock if the
+  * scheduler decides to stop us.
+  */
+  memset(&action, 0, sizeof(action));
+  action.sa_handler = handle_sigterm;
+  sigaction(SIGTERM, &action, NULL);
+
+  return (0);
 }
 #else /* !HAVE_DBUS */
 int
